if (AjxPackage.define("NewWindow_2")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */
/*
 * NewWindow, part 2
 * 
 * Special package to support actions in a new window. So far, there is
 * just composing a message and displaying a RFC attachment in a new window.
 * Everything that might be needed for those is in here: HTML editor,
 * contact picker (search, timezone, list view), msg view, attachments, etc.
 * 
 * NOTE: This package is not optimized at all - it contains everythings that
 * might possibly be needed in a new window.
 */
if (AjxPackage.define("ajax.dwt.keyboard.DwtTabGroupEvent")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @constructor
 * @class
 * This class represents a the tab event. This event is used to indicate changes in
 * the state of {@link DwtTabGroup} objects (e.g. member addition and deletion). 
 * 
 * @author Ross Dargahi
 * 
 * @private
 */
DwtTabGroupEvent = function() {
	/**
	 * Tab group for which the event is being generated
	 * @type DwtTabGroup
	 */
	this.tabGroup = null;
	
	/**
	 * New focus member
	 * @type DwtControl|HTMLElement
	 */
	this.newFocusMember = null;
}

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtTabGroupEvent.prototype.toString = 
function() {
	return "DwtTabGroupEvent";
}

/**
 * Resets the members of the event.
 * 
 */
DwtTabGroupEvent.prototype.reset =
function() {
	this.tabGroup = null;
	this.newFocusMember = null;
}
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtKeyMapMgr")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates and initializes a manager for the given keymap.
 * @constructor
 * @class
 * A keymap manager parses the keymap into a form that is easily used for 
 * translating key codes into actions. It also provides some static methods
 * that map the available keyboard to key codes, and which qualify certain
 * keys as punctuation, etc.
 * 
 * @author Ross Dargahi
 *
 * @param {DwtKeyMap}	keyMap the keymap
 *
 * @private
 */
DwtKeyMapMgr = function(keyMap) {

	var map = this._map = keyMap.getMap();
	this._args = keyMap._args;
	
	// build FSA for each mapping
	this._fsas = {};
	for (var key in map) {
		DBG.println(AjxDebug.DBG3, "building FSA for key: " + key);
		this._fsas[key] = DwtKeyMapMgr.__buildFSA({}, map[key], key);
	}
	DBG.dumpObj(AjxDebug.DBG3, this._fsas);
};

DwtKeyMapMgr.prototype.toString = function() { return "DwtKeyMapMgr"; };
DwtKeyMapMgr.prototype.isDwtKeyMapMgr = true;

DwtKeyMapMgr.NOT_A_TERMINAL = -999;
DwtKeyMapMgr.TAB_KEYCODE = DwtKeyEvent.KEY_TAB;


/**
 * This method will attempt to look up the action code for a given key sequence in
 * a given key map. 
 * 
 * @param {string}		keySeq				key sequence to lookup
 * @param {string}		mappingName			keymap name in which to search
 * @param {boolean}		forceActionCode		if <code>true</code>, then if the key sequence contains both
 * 											a submap and an action code, then return the action code.
 * 											If this parameter is false or omitted, then
 * 											{@link DwtKeyMapMgr.NOT_A_TERMINAL} will be returned for
 * 											a key sequence that contains both a submap and an action code.
 * 
 * @return {string|number}	the action code for the provided key map name, null if there is no action code
 * 		or {@link DwtKeyMapMgr.NOT_A_TERMINAL} if the key sequence is an intermediate
 * 		node in the key map (i.e. has a submap)
 * 
 */
DwtKeyMapMgr.prototype.getActionCode =
function(keySeq, mappingName, forceActionCode) {
	//DBG.println(AjxDebug.DBG3, "Getting action code for: " + keySeq + " in map: " + mappingName);
	var mapping =  this._fsas[mappingName];

	if (!mapping) {
		DBG.println(AjxDebug.DBG3, "No keymap for: " + mappingName);
		return null;
	}

	var keySeqLen = keySeq.length;
	var tmpFsa = mapping;
	var key;
	for (var j = 0; j < keySeqLen && tmpFsa; j++) {
		key = keySeq[j];

		if (!tmpFsa || !tmpFsa[key]) break;

		if (j < keySeqLen - 1) {
			tmpFsa = tmpFsa[key].subMap;
		}
	}

	if (tmpFsa && tmpFsa[key]) {
		var binding = tmpFsa[key];
		/* If the binding does not have a submap, then it must have an action code
		 * so return it. Else if the binding does not have an action code (i.e. it
		 * has a submap only) or if forceActionCode is false, then return DwtKeyMapMgr.NOT_A_TERMINAL
		 * since we are to behave like an intermediate node. Else return the action code. */
		if (!binding.subMap || forceActionCode) {
			var inherited = this.__getInheritedActionCode(keySeq, mapping, forceActionCode);
            //if keyMap not available then return the inherited keyMap.
            return inherited == DwtKeyMapMgr.NOT_A_TERMINAL ? DwtKeyMapMgr.NOT_A_TERMINAL : ( binding.actionCode || inherited );
		} else {
			return DwtKeyMapMgr.NOT_A_TERMINAL;
		}
	} else {
		return this.__getInheritedActionCode(keySeq, mapping, forceActionCode);
	}
};

/**
 * Returns the action for the given map and key sequence.
 * 
 */
DwtKeyMapMgr.prototype.getAction =
function(mapName, keySeq) {
	return this._map[mapName][keySeq];
};

/**
 * Returns the key sequences associated with the given map and action.
 */
DwtKeyMapMgr.prototype.getKeySequences =
function(mapName, action) {
	var keySeqs = [];
	for (var ks in this._map[mapName]) {
		if (this._map[mapName][ks] == action) {
			keySeqs.push(ks);
		}
	}
	return keySeqs;
};

/**
 * Allow the programmatic setting of a key sequence mapping for a given map
 * 
 * @param {string} 			mapName map name to affect
 * @param {string} 			keySeq the key sequence to set
 * @param {string|number} action the action code for the key sequence
 */
DwtKeyMapMgr.prototype.setMapping =
function(mapName, keySeq, action) {
	this._map[mapName][keySeq] = action;
};

/**
 * Allow the programatting removal of a key sequence mapping for a given map
 * 
 * @param {string} mapName map name to affect
 * @param {string} keySeq the key sequence to remove
 */
DwtKeyMapMgr.prototype.removeMapping =
function(mapName, keySeq) {
	delete this._map[mapName][keySeq];
};

/**
 * Replace the key sequence for a given action in a keymap 
 * 
 * @param {string} mapName map name to affect
 * @param {string} oldKeySeq the key sequence to replace
 * @param {string} newKeySeq the new key sequence
 */
DwtKeyMapMgr.prototype.replaceMapping =
function(mapName, oldKeySeq, newKeySeq) {
	var action = this._map[mapName][oldKeySeq];
	if (!action) return;
	this.removeMapping(mapName, oldKeySeq);
	this.setMapping(mapName, newKeySeq, action);
};

DwtKeyMapMgr.prototype.setArg =
function(mapName, action, arg) {
	if (!this._args[mapName]) {
		this._args[mapName] = {};
	}
	this._args[mapName][action] = arg;
};

DwtKeyMapMgr.prototype.removeArg =
function(mapName, action) {
	delete this._args[mapName][action];
};

DwtKeyMapMgr.prototype.getArg =
function(mapName, action) {
	return this._args[mapName] ? this._args[mapName][action] : null;
};

/**
 * Reloads a given keymap
 * 
 * @param {string} mapName Name of the keymap to reload
 */
DwtKeyMapMgr.prototype.reloadMap =
function(mapName) {
	this._fsas[mapName] = DwtKeyMapMgr.__buildFSA({}, this._map[mapName], mapName);
};

/**
 * Returns a list of maps that the given map inherits from.
 *
 * @param {string} mapName Name of the keymap to reload
 */
DwtKeyMapMgr.prototype.getAncestors =
function(mapName, list) {
    list = list || [];
    var subMap = this._fsas[mapName];
    var parents = subMap && subMap.inherit;
    if (parents && parents.length) {
        for (var i = 0; i < parents.length; i++) {
            list.push(parents[i]);
            list = this.getAncestors(parents[i], list);
        }
    }
    return list;
};

/**
 * Returns true if the given element accepts text input.
 * 
 * @param element	[Element]		DOM element
 */
DwtKeyMapMgr.isInputElement =
function(element) {
	if (!element) { return false; }
	// Check designMode in case we're in an HTML editor iframe
	var dm = element.ownerDocument ? element.ownerDocument.designMode : null;
	if (dm && (dm.toLowerCase() == "on")) { return true; }

	var tag = element.tagName.toUpperCase();
	return (tag == "INPUT" || tag == "TEXTAREA");
};

DwtKeyMapMgr.__buildFSA =
function(fsa, mapping, mapName) {
	for (var i in mapping) {
		// check for inheritance from other maps (in CSV list)
		if (i == DwtKeyMap.INHERIT) {
			fsa.inherit = mapping[i].split(/\s*,\s*/);
			continue;
		}
		 
		var keySeq = i.split(DwtKeyMap.SEP);
		var keySeqLen = keySeq.length;
		var tmpFsa = fsa;
		for (var j = 0; j < keySeqLen; j++) {
			var key = keySeq[j];
			//DBG.println(AjxDebug.DBG3, "Processing: " + key);
			
			if (!tmpFsa[key]) {
				tmpFsa[key] = {};	// first time visiting this key
			}

			if (j == keySeqLen - 1) {
				/* We are at the last key in the sequence so we can bind the
				 * action code to it */
				//DBG.println(AjxDebug.DBG3, "BINDING: " + mapping[i]);
				tmpFsa[key].actionCode = mapping[i];
			} else {
				/* We have more keys in the sequence. If our subMap is null,
				 * then we need to create it to hold the new key sequences */
				if (!tmpFsa[key].subMap) {
					tmpFsa[key].subMap = {};
					//DBG.println(AjxDebug.DBG3, "NEW SUBMAP");
				}
					
				tmpFsa = tmpFsa[key].subMap;
			}			
		}
	}
	return fsa;
};

DwtKeyMapMgr.prototype.__getInheritedActionCode =
function(keySeq, mapping, forceActionCode) {
	if (mapping.inherit && mapping.inherit.length) {
		var actionCode = null;
		var len = mapping.inherit.length;
		for (var i = 0; i < len; i++) {
			DBG.println(AjxDebug.DBG3, "checking inherited map: " + mapping.inherit[i]);
			actionCode = this.getActionCode(keySeq, mapping.inherit[i], forceActionCode);
			if (actionCode != null) {
				return actionCode;
			}
		}
	}
	return null;
};

/**
 * Returns true if the given key event has a modifier which makes it nonprintable.
 * 
 * @param ev	[Event]		key event
 */
DwtKeyMapMgr.hasModifier =
function(ev) {
	return (ev.altKey || ev.ctrlKey || ev.metaKey);
};
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtKeyboardMgr")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an empty keyboard manager. Intended for use as a singleton.
 * @constructor
 * @class
 * This class is responsible for managing focus and shortcuts via the keyboard. That includes dispatching
 * keyboard events (shortcuts), as well as managing tab groups. It is at the heart of the
 * Dwt keyboard navigation framework.
 * <p>
 * {@link DwtKeyboardMgr} intercepts key strokes and translates
 * them into actions which it then dispatches to the component with focus. If the key
 * stroke is a TAB (or Shift-TAB), then focus is moved based on the current tab group.
 * </p><p>
 * A {@link DwtShell} instantiates its own <i>DwtKeyboardMgr</i> at construction.
 * The keyboard manager may then be retrieved via the shell's <code>getKeyboardMgr()</code>
 * function. Once a handle to the shell's keyboard manager is retrieved, then the user is free
 * to add tab groups, and to register keymaps and handlers with the keyboard manager.
 * </p><p>
 * Focus is managed among a stack of tab groups. The TAB button will move the focus within the
 * current tab group. When a non-TAB is received, we first check if the control can handle it.
 * In general, control key events simulate something the user could do with the mouse, and change
 * the state/appearance of the control. For example, ENTER on a DwtButton simulates a button
 * press. If the control does not handle the key event, the event is handed to the application,
 * which handles it based on its current state. The application key event handler is in a sense
 * global, since it does not matter which control received the event.
 * </p><p>
 * At any given time there is a default handler, which is responsible for determining what
 * action is associated with a particular key sequence, and then taking it. A handler should support
 * the following methods:
 * 
 * <ul>
 * <li><i>getKeyMapName()</i> -- returns the name of the map that defines shortcuts for this handler</li>
 * <li><i>handleKeyAction()</i> -- performs the action associated with a shortcut</li>
 * <li><i>handleKeyEvent()</i>	-- optional override; handler solely responsible for handling event</li>
 * </ul>
 * </p>
 *
 * @author Ross Dargahi
 *
 * @param	{DwtShell}	shell		the shell
 * @see DwtShell
 * @see DwtTabGroup
 * @see DwtKeyMap
 * @see DwtKeyMapMgr
 * 
 * @private
 */
DwtKeyboardMgr = function(shell) {

	DwtKeyboardMgr.__shell = shell;

    this.__kbEventStatus = DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
    this.__keyTimeout = DwtKeyboardMgr.SHORTCUT_TIMEOUT;

    // focus
    this.__tabGrpStack = [];
    this.__currTabGroup = null;
    this.__tabGroupChangeListenerObj = this.__tabGrpChangeListener.bind(this);

    // shortcuts
    this.__shortcutsEnabled = false;
	this.__defaultHandlerStack = [];
	this.__currDefaultHandler = null;
    this.__killKeySeqTimedAction = new AjxTimedAction(this, this.__killKeySequenceAction);
    this.__killKeySeqTimedActionId = -1;
    this.__keySequence = [];
    this._evtMgr = new AjxEventMgr();

    Dwt.setHandler(document, DwtEvent.ONKEYDOWN, DwtKeyboardMgr.__keyDownHdlr);
    Dwt.setHandler(document, DwtEvent.ONKEYUP, DwtKeyboardMgr.__keyUpHdlr);
    Dwt.setHandler(document, DwtEvent.ONKEYPRESS, DwtKeyboardMgr.__keyPressHdlr);
};

DwtKeyboardMgr.prototype.isDwtKeyboardMgr = true;
DwtKeyboardMgr.prototype.toString = function() { return "DwtKeyboardMgr"; };

DwtKeyboardMgr.SHORTCUT_TIMEOUT = 750;

DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED	= "NOT HANDLED";
DwtKeyboardMgr.__KEYSEQ_HANDLED		= "HANDLED";
DwtKeyboardMgr.__KEYSEQ_PENDING		= "PENDING";

/**
 * Checks if the event may be a shortcut from within an input (text input or
 * textarea). Since printable characters are echoed, the shortcut must be non-printable:
 * 
 * <ul>
 * <li>Alt or Ctrl or Meta plus another key</li>
 * <li>Esc</li>
 * </ul>
 * 
 * @param {DwtKeyEvent}	ev	the key event
 * @return	{boolean}	<code>true</code> if the event may be a shortcut
 */

// Enter and all four arrows can be used as shortcuts in an INPUT
DwtKeyboardMgr.IS_INPUT_SHORTCUT_KEY = AjxUtil.arrayAsHash([
    DwtKeyEvent.KEY_END_OF_TEXT,
    DwtKeyEvent.KEY_RETURN,
    DwtKeyEvent.KEY_ARROW_LEFT,
    DwtKeyEvent.KEY_ARROW_UP,
    DwtKeyEvent.KEY_ARROW_RIGHT,
    DwtKeyEvent.KEY_ARROW_DOWN
]);

// Returns true if the key event has a keycode that could be used in an input (INPUT or TEXTAREA) as a shortcut. That
// excludes printable characters.
DwtKeyboardMgr.isPossibleInputShortcut = function(ev) {

	var target = DwtUiEvent.getTarget(ev);
    return !DwtKeyMap.IS_MODIFIER[ev.keyCode] && (ev.keyCode === DwtKeyEvent.KEY_ESCAPE || DwtKeyMapMgr.hasModifier(ev) ||
			(target && target.nodeName.toLowerCase() == "input" && DwtKeyboardMgr.IS_INPUT_SHORTCUT_KEY[ev.keyCode]));
};

/**
 * Pushes the tab group onto the stack and makes it the active tab group.
 * 
 * @param 	{DwtTabGroup}	tabGroup	the tab group to push onto the stack
 * 
 * @see		#popTabGroup
 */
DwtKeyboardMgr.prototype.pushTabGroup = function(tabGroup, preventFocus) {

    if (!(tabGroup && tabGroup.isDwtTabGroup)) {
        DBG.println(AjxDebug.DBG1, "pushTabGroup() called without a tab group: " + tabGroup);
        return;
    }

	DBG.println(AjxDebug.FOCUS, "PUSH tab group " + tabGroup.getName());
	this.__tabGrpStack.push(tabGroup);
	this.__currTabGroup = tabGroup;
	var focusMember = tabGroup.getFocusMember();
	if (!focusMember) {
		focusMember = tabGroup.resetFocusMember(true);
	}
	if (!focusMember) {
		DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr.pushTabGroup: tab group " + tabGroup.__name + " has no members!");
		return;
	}
	tabGroup.addFocusChangeListener(this.__tabGroupChangeListenerObj);
	if (!preventFocus) {
		this.grabFocus(focusMember);
	}
};

/**
 * Pops the current tab group off the top of the tab group stack. The previous 
 * tab group (if there is one) then becomes the current tab group.
 * 
 * @param {DwtTabGroup} [tabGroup]		the tab group to pop. If supplied, then the tab group
 * 		stack is searched for the tab group and it is removed. If <code>null</code>, then the
 * 		top tab group is popped.
 * 
 * @return {DwtTabGroup}	the popped tab group or <code>null</code> if there is one or less tab groups
 */
DwtKeyboardMgr.prototype.popTabGroup = function(tabGroup) {

    if (!(tabGroup && tabGroup.isDwtTabGroup)) {
        DBG.println(AjxDebug.DBG1, "popTabGroup() called without a tab group: " + tabGroup);
        return null;
    }

    DBG.println(AjxDebug.FOCUS, "POP tab group " + tabGroup.getName());
	
	// we never want an empty stack
	if (this.__tabGrpStack.length <= 1) {
		return null;
	}
	
	// If we are popping a tab group that is not on the top of the stack then
	// we need to find it and remove it.
	if (tabGroup && this.__tabGrpStack[this.__tabGrpStack.length - 1] != tabGroup) {
		var a = this.__tabGrpStack;
		var len = a.length;
		for (var i = len - 1; i >= 0; i--) {
			if (tabGroup == a[i]) {
				a[i].dump(AjxDebug.DBG1);
				break;
			}
		}
		
		/* If there is no match in the stack for tabGroup, then simply return null,
		 * else if the match is not the top item on the stack, then remove it from 
		 * the stack. Else we are dealing with the topmost item on the stack so handle it 
		 * as a simple pop. */
		if (i < 0) { // No match
			return null;
		} else if (i != len - 1) { // item is not on top
			// Remove tabGroup
			a.splice(i, 1);
			return tabGroup;
		}
	} 

	var tabGroup = this.__tabGrpStack.pop();
	tabGroup.removeFocusChangeListener(this.__tabGroupChangeListenerObj);
	
	var currTg = null;
	if (this.__tabGrpStack.length > 0) {
		currTg = this.__tabGrpStack[this.__tabGrpStack.length - 1];
		var focusMember = currTg.getFocusMember();
		if (!focusMember) {
			focusMember = currTg.resetFocusMember(true);
		}
		if (focusMember) {
			this.grabFocus(focusMember);
		}
	}
	this.__currTabGroup = currTg;

	return tabGroup;
};

/**
 * Replaces the current tab group with the given tab group.
 * 
 * @param {DwtTabGroup} tabGroup 	the tab group to use
 * @return {DwtTabGroup}	the old tab group
 */
DwtKeyboardMgr.prototype.setTabGroup = function(tabGroup) {

	var otg = this.popTabGroup();
	this.pushTabGroup(tabGroup);

	return otg;
};

/**
 * Gets the current tab group
 *
 * @return {DwtTabGroup}	current tab group
 */
DwtKeyboardMgr.prototype.getCurrentTabGroup = function() {

    return this.__currTabGroup;
};

/**
 * Adds a default handler to the stack. A handler should define a 'handleKeyAction' method.
 *
 * @param {Object}  handler     default handler
 */
DwtKeyboardMgr.prototype.pushDefaultHandler = function(handler) {

	if (!this.isEnabled() || !handler) {
        return;
    }
	DBG.println(AjxDebug.FOCUS, "PUSH default handler: " + handler);
		
	this.__defaultHandlerStack.push(handler);
	this.__currDefaultHandler = handler;
};

/**
 * Removes a default handler from the stack.
 *
 * @return {Object}  handler     a default handler
 */
DwtKeyboardMgr.prototype.popDefaultHandler = function() {

	DBG.println(AjxDebug.FOCUS, "POP default handler");
	// we never want an empty stack
	if (this.__defaultHandlerStack.length <= 1) {
        return null;
    }

	DBG.println(AjxDebug.FOCUS, "Default handler stack length: " + this.__defaultHandlerStack.length);
	var handler = this.__defaultHandlerStack.pop();
	this.__currDefaultHandler = this.__defaultHandlerStack[this.__defaultHandlerStack.length - 1];
	DBG.println(AjxDebug.FOCUS, "Default handler is now: " + this.__currDefaultHandler);

	return handler;
};

/**
 * Sets the focus to the given object.
 * 
 * @param {HTMLInputElement|DwtControl|string} focusObj		the object to which to set focus, or its ID
 */ 
DwtKeyboardMgr.prototype.grabFocus = function(focusObj) {

	if (typeof focusObj === "string") {
		focusObj = document.getElementById(focusObj);
	}
    else if (focusObj && focusObj.isDwtTabGroup) {
        focusObj = focusObj.getFocusMember() || focusObj.getFirstMember();
    }

    if (!focusObj) {
        return;
    }

	// Make sure tab group knows what's currently focused
	if (this.__currTabGroup) {
		this.__currTabGroup.setFocusMember(focusObj, false, true);
	}
		
	this.__doGrabFocus(focusObj);
};

/**
 * Tells the keyboard manager that the given control now has focus. That control will handle shortcuts and become
 * the reference point for tabbing.
 *
 * @param {DwtControl|Element}  focusObj    control (or element) that has focus
 */
DwtKeyboardMgr.prototype.updateFocus = function(focusObj, ev) {

    if (!focusObj) {
        return;
    }

    var ctg = this.__currTabGroup;
    if (ctg) {
        this.__currTabGroup.__showFocusedItem(focusObj, "updateFocus");
    }
    var control = focusObj.isDwtControl ? focusObj : DwtControl.findControl(focusObj);

    // Set the keyboard mgr's focus obj, which will be handed shortcuts. It must be a DwtControl.
    if (control) {
        this.__focusObj = control;
        DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr UPDATEFOCUS kbMgr focus obj: " + control);
    }

    // Update the current (usually root) tab group's focus member to whichever of these it contains: the focus obj,
    // its tab group member, or its control.
    var tgm = this._findTabGroupMember(ev || focusObj);
    if (tgm && ctg) {
        ctg.setFocusMember(tgm, false, true);
    }
};

// Goes up the DOM looking for something (element or control) that is in the current tab group.
DwtKeyboardMgr.prototype._findTabGroupMember = function(obj) {

    var ctg = this.__currTabGroup;
    if (!obj || !ctg) {
        return;
    }

    var htmlEl = (obj.isDwtControl && obj.getHtmlElement()) || DwtUiEvent.getTarget(obj, false) || obj;

    try {
        while (htmlEl) {
            if (ctg.contains(htmlEl)) {
                return htmlEl;
            }
            else {
                var control = DwtControl.ALL_BY_ID[htmlEl.id];
                if (control && ctg.contains(control)) {
                    return control;
                }
                else {
                    var tgm = control && control.getTabGroupMember && control.getTabGroupMember();
                    if (tgm && ctg.contains(tgm)) {
                        return tgm;
                    }
                }
            }
            htmlEl = htmlEl.parentNode;
        }
    } catch(e) {
    }

    return null;
};

/**
 * Gets the object that has focus.
 *
 * @return {HTMLInputElement|DwtControl} focusObj		the object with focus
 */
DwtKeyboardMgr.prototype.getFocusObj = function(focusObj) {

	return this.__focusObj;
};

/**
 * This method is used to register an application key handler. If registered, this
 * handler must support the following methods:
 * <ul>
 * <li><i>getKeyMapName</i>: This method returns a string representing the key map 
 * to be used for looking up actions
 * <li><i>handleKeyAction</i>: This method should handle the key action and return
 * true if it handled it else false. <i>handleKeyAction</i> has two formal parameters
 *    <ul>
 *    <li><i>actionCode</i>: The action code to be handled</li>
 *    <li><i>ev</i>: the {@link DwtKeyEvent} corresponding to the last key event in the sequence</li>
 *    </ul>
 * </ul>
 * 
 * @param 	{function}	hdlr	the handler function. This method should have the following
 * 									signature <code>Boolean hdlr(Int actionCode DwtKeyEvent event);</code>
 * 
 * @see DwtKeyEvent
 */
DwtKeyboardMgr.prototype.registerDefaultKeyActionHandler = function(hdlr) {

	if (this.isEnabled()) {
        this.__defaultKeyActionHdlr = hdlr;
    }
};

/**
 * Registers a keymap with the shell. A keymap typically
 * is a subclass of {@link DwtKeyMap} and defines the mappings from key sequences to
 * actions.
 *
 * @param {DwtKeyMap} keyMap		the key map to register
 * 
 */
DwtKeyboardMgr.prototype.registerKeyMap = function(keyMap) {

	if (this.isEnabled()) {
	    this.__keyMapMgr = new DwtKeyMapMgr(keyMap);
    }
};

/**
 * Sets the timeout (in milliseconds) between key presses for handling multi-keypress sequences.
 * 
 * @param 	{number}	timeout		the timeout (in milliseconds)
 */
DwtKeyboardMgr.prototype.setKeyTimeout = function(timeout) {
	this.__keyTimeout = timeout;
};

/**
 * Clears the key sequence. The next key event will begin a new one.
 * 
 */
DwtKeyboardMgr.prototype.clearKeySeq = function() {

	this.__killKeySeqTimedActionId = -1;
	this.__keySequence = [];
};

/**
 * Enables/disables keyboard nav (shortcuts).
 * 
 * @param 	{boolean}	enabled		if <code>true</code>, enable keyboard nav
 */
DwtKeyboardMgr.prototype.enable = function(enabled) {

	DBG.println(AjxDebug.DBG2, "keyboard shortcuts enabled: " + enabled);
	this.__shortcutsEnabled = enabled;
};

DwtKeyboardMgr.prototype.isEnabled = function() {
	return this.__shortcutsEnabled;
};

/**
 * Adds a global key event listener.
 *
 * @param {constant}	ev			key event type
 * @param {AjxListener}	listener	listener to notify
 */
DwtKeyboardMgr.prototype.addListener = function(ev, listener) {
	this._evtMgr.addListener(ev, listener);
};

/**
 * Removes a global key event listener.
 *
 * @param {constant}	ev			key event type
 * @param {AjxListener}	listener	listener to remove
 */
DwtKeyboardMgr.prototype.removeListener = function(ev, listener) {
	this._evtMgr.removeListener(ev, listener);
};

DwtKeyboardMgr.prototype.__doGrabFocus = function(focusObj) {

	if (!focusObj) {
        return;
    }

    var curFocusObj = this.getFocusObj();
    if (curFocusObj && curFocusObj.blur) {
        DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr DOGRABFOCUS cur focus obj: " + [curFocusObj, curFocusObj._htmlElId || curFocusObj.id].join(' / '));
        curFocusObj.blur();
    }

    DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr DOGRABFOCUS new focus obj: " + [focusObj, focusObj._htmlElId || focusObj.id].join(' / '));
    if (focusObj.focus) {
        // focus handler should lead to focus update, but just in case ...
        this.updateFocus(focusObj.focus() || focusObj);
    }
};

/**
 * @private
 */
DwtKeyboardMgr.__keyUpHdlr = function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	DBG.println(AjxDebug.KEYBOARD, "keyup: " + ev.keyCode);

	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	if (kbMgr._evtMgr.notifyListeners(DwtEvent.ONKEYUP, ev) === false) {
		return false;
	}

	// clear saved Gecko key
	if (AjxEnv.isMac && AjxEnv.isGeckoBased && ev.keyCode === 0) {
		return DwtKeyboardMgr.__keyDownHdlr(ev);
	}
    else {
		return DwtKeyboardMgr.__handleKeyEvent(ev);
	}
};

/**
 * @private
 */
DwtKeyboardMgr.__keyPressHdlr = function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	DBG.println(AjxDebug.KEYBOARD, "keypress: " + (ev.keyCode || ev.charCode));

	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	if (kbMgr._evtMgr.notifyListeners(DwtEvent.ONKEYPRESS, ev) === false) {
		return false;
	}

	DwtKeyEvent.geckoCheck(ev);

	return DwtKeyboardMgr.__handleKeyEvent(ev);
};

/**
 * @private
 */
DwtKeyboardMgr.__handleKeyEvent =
function(ev) {

	if (DwtKeyboardMgr.__shell._blockInput) {
        return false;
    }

	ev = DwtUiEvent.getEvent(ev, this);
	DBG.println(AjxDebug.KEYBOARD, [ev.type, ev.keyCode, ev.charCode, ev.which].join(" / "));
	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	var kev = DwtShell.keyEvent;
	kev.setFromDhtmlEvent(ev);

	if (kbMgr.__kbEventStatus != DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED) {
		return kbMgr.__processKeyEvent(ev, kev, false);
	}
};

/**
 * @private
 */
DwtKeyboardMgr.__keyDownHdlr = function(ev) {

	try {

	ev = DwtUiEvent.getEvent(ev, this);
	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	ev.focusObj = null;
	if (kbMgr._evtMgr.notifyListeners(DwtEvent.ONKEYDOWN, ev) === false) {
		return false;
	}

	if (DwtKeyboardMgr.__shell._blockInput) {
        return false;
    }
	DBG.println(AjxDebug.KEYBOARD, [ev.type, ev.keyCode, ev.charCode, ev.which].join(" / "));

	var kev = DwtShell.keyEvent;
	kev.setFromDhtmlEvent(ev);
	var keyCode = DwtKeyEvent.getCharCode(ev);
	DBG.println(AjxDebug.KEYBOARD, "keydown: " + keyCode + " -------- " + ev.target);

	// Popdown any tooltip
	DwtKeyboardMgr.__shell.getToolTip().popdown();

    /********* FOCUS MANAGEMENT *********/

	/* The first thing we care about is the tab key since we want to manage
	 * focus based on the tab groups. 
	 * 
	 * If the tab hit happens in the currently
	 * focused obj, the go to the next/prev element in the tab group. 
	 * 
	 * If the tab happens in an element that is in the tab group hierarchy, but that 
	 * element is not the currently focus element in the tab hierarchy (e.g. the user
	 * clicked in it and we didnt detect it) then sync the tab group's current focus 
	 * element and handle the tab
	 * 
	 * If the tab happens in an object not under the tab group hierarchy, then set
	 * focus to the current focus object in the tab hierarchy i.e. grab back control
	 */
    var ctg = kbMgr.__currTabGroup,
        member;

	if (keyCode == DwtKeyEvent.KEY_TAB) {
	    if (ctg && !DwtKeyMapMgr.hasModifier(kev)) {
			DBG.println(AjxDebug.FOCUS, "Tab");
			// If the tab hit is in an element or if the current tab group has a focus member
			if (ctg.getFocusMember()) {
                member = kev.shiftKey ? ctg.getPrevFocusMember(true) : ctg.getNextFocusMember(true);
			}
            else {
			 	DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr.__keyDownHdlr: no current focus member, resetting to first in tab group");
			 	// If there is no current focus member, then reset
                member = ctg.resetFocusMember(true);
			}
	    }
        // If we did not handle the Tab, let the browser handle it
        return kbMgr.__processKeyEvent(ev, kev, !member, member ? DwtKeyboardMgr.__KEYSEQ_HANDLED : DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED);
	}
    else if (ctg && AjxEnv.isGecko && kev.target instanceof HTMLHtmlElement) {
	 	/* With FF we focus get set to the <html> element when tabbing in
	 	 * from the address or search fields. What we want to do is capture
	 	 * this here and reset the focus to the first element in the tabgroup
	 	 * 
	 	 * TODO Verify this trick is needed/works with IE/Safari
	 	 */
        member = ctg.resetFocusMember(true);
	}
	 
    // Allow key events to propagate when keyboard manager is disabled (to avoid taking over browser shortcuts). Bugzilla #45469.
    if (!kbMgr.isEnabled()) {
        return true;
    }


    /********* SHORTCUTS *********/

	// Filter out modifier keys. If we're in an input field, filter out legitimate input.
	// (A shortcut from an input field must use a modifier key.)
	if (DwtKeyMap.IS_MODIFIER[keyCode] || (kbMgr.__killKeySeqTimedActionId === -1 &&
		kev.target && DwtKeyMapMgr.isInputElement(kev.target) && !kev.target["data-hidden"] && !DwtKeyboardMgr.isPossibleInputShortcut(kev))) {

	 	return kbMgr.__processKeyEvent(ev, kev, true, DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED);
	}
	 
	/* Cancel any pending time action to kill the keysequence */
	if (kbMgr.__killKeySeqTimedActionId != -1) {
		AjxTimedAction.cancelAction(kbMgr.__killKeySeqTimedActionId);
		kbMgr.__killKeySeqTimedActionId = -1;
	}
		
 	var parts = [];
	if (kev.altKey) 	{ parts.push(DwtKeyMap.ALT); }
	if (kev.ctrlKey) 	{ parts.push(DwtKeyMap.CTRL); }
 	if (kev.metaKey) 	{ parts.push(DwtKeyMap.META); }
	if (kev.shiftKey) 	{ parts.push(DwtKeyMap.SHIFT); }
	parts.push(keyCode);
	kbMgr.__keySequence[kbMgr.__keySequence.length] = parts.join(DwtKeyMap.JOIN);

	DBG.println(AjxDebug.KEYBOARD, "KEYCODE: " + keyCode + " - KEY SEQ: " + kbMgr.__keySequence.join(""));
	
	var handled = DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;

	// First see if the control that currently has focus can handle the key event
	var obj = ev.focusObj || kbMgr.__focusObj;
    var hasFocus = obj && obj.hasFocus && obj.hasFocus();
    DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr::__keyDownHdlr - focus object " + obj + " has focus: " + hasFocus);
	if (hasFocus && obj.handleKeyAction) {
		handled = kbMgr.__dispatchKeyEvent(obj, kev);
		while ((handled === DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED) && obj.parent) {
			obj = obj.parent;
            if (obj.getKeyMapName) {
			    handled = kbMgr.__dispatchKeyEvent(obj, kev);
            }
		}
	}

	// If the currently focused control didn't handle the event, hand it to the default key event handler
	if (handled === DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED && kbMgr.__currDefaultHandler) {
		handled = kbMgr.__dispatchKeyEvent(kbMgr.__currDefaultHandler, kev);
	}

	// see if we should let browser handle the event as well; note that we need to set the 'handled' var rather than
	// just the 'propagate' one below, since the keyboard mgr isn't built for both it and the browser to handle the event.
	if (kev.forcePropagate) {
		handled = DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
		kev.forcePropagate = false;
	}
	
	kbMgr.__kbEventStatus = handled;
	var propagate = (handled == DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED);

	if (handled != DwtKeyboardMgr.__KEYSEQ_PENDING) {
		kbMgr.clearKeySeq();
	}

	return kbMgr.__processKeyEvent(ev, kev, propagate);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * Handles event dispatching
 * 
 * @private
 */
DwtKeyboardMgr.prototype.__dispatchKeyEvent = function(hdlr, ev, forceActionCode) {

	if (hdlr && hdlr.handleKeyEvent) {
		var handled = hdlr.handleKeyEvent(ev);
		return handled ? DwtKeyboardMgr.__KEYSEQ_HANDLED : DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}

	var mapName = (hdlr && hdlr.getKeyMapName) ? hdlr.getKeyMapName() : null;
	if (!mapName) {
		return DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}

	DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__dispatchKeyEvent: handler " + hdlr.toString() + " handling " + this.__keySequence + " for map: " + mapName);
	var actionCode = this.__keyMapMgr.getActionCode(this.__keySequence, mapName, forceActionCode);
	if (actionCode === DwtKeyMapMgr.NOT_A_TERMINAL) {
		DBG.println(AjxDebug.KEYBOARD, "scheduling action to kill key sequence");
		/* setup a timed action to redispatch/kill the key sequence in the event
		 * the user does not press another key in the allotted time */
		this.__hdlr = hdlr;
		this.__mapName = mapName;
		this.__ev = ev;
		this.__killKeySeqTimedActionId = AjxTimedAction.scheduleAction(this.__killKeySeqTimedAction, this.__keyTimeout);
		return DwtKeyboardMgr.__KEYSEQ_PENDING;	
	}
    else if (actionCode != null) {
		/* It is possible that the component may not handle a valid action
		 * particulary actions defined in the default map */
		DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__dispatchKeyEvent: handling action: " + actionCode);
		if (!hdlr.handleKeyAction) {
			return DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
		}
		var result = hdlr.handleKeyAction(actionCode, ev);
		return result ? DwtKeyboardMgr.__KEYSEQ_HANDLED : DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}
    else {
		DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__dispatchKeyEvent: no action code for " + this.__keySequence);
		return DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}
};

/**
 * This method will reattempt to handle the event in the case that the intermediate
 * node in the keymap may have an action code associated with it.
 * 
 * @private
 */
DwtKeyboardMgr.prototype.__killKeySequenceAction = function() {

	DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__killKeySequenceAction: " + this.__mapName);
	this.__dispatchKeyEvent(this.__hdlr, this.__ev, true);
	this.clearKeySeq();
};

/**
 * @private
 */
DwtKeyboardMgr.prototype.__tabGrpChangeListener = function(ev) {
	this.__doGrabFocus(ev.newFocusMember);
};

/**
 * @private
 */
DwtKeyboardMgr.prototype.__processKeyEvent = function(ev, kev, propagate, status) {

	if (status) {
		this.__kbEventStatus = status;
	}
	kev._stopPropagation = !propagate;
	kev._returnValue = propagate;
	kev.setToDhtmlEvent(ev);
	DBG.println(AjxDebug.KEYBOARD, "key event returning: " + propagate);
	return propagate;
};
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtTabGroup")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates an empty tab group.
 * @constructor
 * @class
 * A tab group is used to manage keyboard focus among a group of related visual 
 * elements. It is a tree structure consisting of elements and other tab groups.
 * <p>
 * The root tab group is the only one without a parent tab group, and is the one
 * that the application interacts with. Focus listeners register with the root
 * tab group. The root tab group tracks where focus is.
 * 
 * @param {string}	name					the name of this tab group
 *
 * @author Ross Dargahi
 */
DwtTabGroup = function(name) {

	this.__members = new AjxVector();
	this.__parent = null;
	this.__name = name;
	this.__currFocusMember = null;
	this.__evtMgr = new AjxEventMgr();

    DwtTabGroup.BY_NAME[name] = this;
};

DwtTabGroup.prototype.isDwtTabGroup = true;
DwtTabGroup.prototype.toString = function() { return "DwtTabGroup"; };



/** 
 * Exception string that is thrown when an operation is attempted
 * on a non-root tab group.
 */
DwtTabGroup.NOT_ROOT_TABGROUP = "NOT ROOT TAB GROUP";

DwtTabGroup.__changeEvt = new DwtTabGroupEvent();

// Allow static access to any tab group by its name
DwtTabGroup.getByName = function(name) {
    return DwtTabGroup.BY_NAME[name];
};
DwtTabGroup.BY_NAME = {};

/**
 * Gets the name of this tab group.
 * 
 * @return	{string}	the tab group name
 */
DwtTabGroup.prototype.getName = function() {
	return this.__name;
};

/**
 * Adds a focus change listener to the root tab group. The listener is called
 * when the focus member changes. Note that the focus member hasn't actually
 * been focused yet - only its status within the tab group has changed. It is
 * up to the listener to implement the appropriate focus action.
 * 
 * @param {AjxListener} listener	a listener
 * 
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.addFocusChangeListener = function(listener) {

	this.__checkRoot();		
	this.__evtMgr.addListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Removes a focus change listener from the root tab group.
 * 
 * @param {AjxListener} listener	a listener
 * 
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.removeFocusChangeListener = function(listener) {

	this.__checkRoot();		
	this.__evtMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Adds a member to the tab group.
 * 
 * @param {Array|DwtControl|DwtTabGroup|HTMLElement} member	the member(s) to be added
 * @param {number} [index] 		the index at which to add the member. If omitted, the member
 * 		will be added to the end of the tab group
 */
DwtTabGroup.prototype.addMember = function(member, index) {

    index = (index != null) ? index : this.__members.size();
    var members = AjxUtil.collapseList(AjxUtil.toArray(member));

	for (var i = 0, len = members.length; i < len; i++) {
        var member = members[i];
        this.__members.add(member, index + i);
        // If adding a tab group, register me as its parent
        if (member.isDwtTabGroup) {
            member.newParent(this);
        }
	}
};

/**
 * Resets all members of the tab group to the given arguments.
 * 
 * @param {Array|DwtControl|DwtTabGroup|HTMLElement} members	the member(s) for the tab group
 */
DwtTabGroup.prototype.setMembers = function(members) {
	this.removeAllMembers();
	this.addMember(members);
};

/**
 * Adds a member to the tab group, positioned after another member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member 		the member to be added
 * @param {DwtControl|DwtTabGroup|HTMLElement} afterMember 	the member after which to add <code>member</code>
 */
DwtTabGroup.prototype.addMemberAfter = function(newMember, afterMember) {

	this.addMember(newMember, this.__indexOfMember(afterMember) + 1);
};

/**
 * Adds a member to the tab group, positioned before another member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member 		the member to be added
 * @param {DwtControl|DwtTabGroup|HTMLElement} beforeMember 	the member before which to add <code>member</code>
 */
DwtTabGroup.prototype.addMemberBefore = function(newMember, beforeMember) {

	this.addMember(newMember, this.__indexOfMember(beforeMember));
};

/**
 * This method removes a member from the tab group. If the member being removed
 * is currently the focus member, then we will try to set focus to the
 * previous member. If that fails, we will try the next member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member 	the member to be removed
 * @param {boolean} [checkEnabled] 		if <code>true</code>, then make sure that if we have a newly focused member it is enabled
 * @param {boolean} [skipNotify] 		if <code>true</code>, notification is not fired. This flag typically set by Dwt tab management framework when it is calling into this method
 * @return {DwtControl|DwtTabGroup|HTMLElement}	the removed member or <code>null</code> if <code>oldMember</code> is not in the tab groups hierarchy
 */
DwtTabGroup.prototype.removeMember = function(member, checkEnabled, skipNotify) {

	return this.replaceMember(member, null, checkEnabled, skipNotify);
};

/**
 * Removes all members.
 * 
 */
DwtTabGroup.prototype.removeAllMembers = function() {

	this.__members.removeAll();
};

/**
 * This method replaces a member in the tab group with a new member. If the member being
 * replaced is currently the focus member, then we will try to set focus to the
 * previous member. If that fails, we will try the next member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} oldMember 	the member to be replaced
 * @param {DwtControl|DwtTabGroup|HTMLElement} newMember 	the replacing member
 * 		If this parameter is <code>null</code>, then this method effectively removes <code>oldMember</code>
 * @param {boolean} [checkEnabled] 	if <code>true</code>, then make sure that if we have a newly focused
 * 		member it is enabled
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag is
 * 		typically set by the tab management framework when it is calling into this method
 * @return {DwtControl|DwtTabGroup|HTMLElement}	replaced member or <code>null></code> if <code>oldMember</code> is not in the tab group
 */
DwtTabGroup.prototype.replaceMember = function(oldMember, newMember, checkEnabled, skipNotify, focusItem, noFocus) {

	var tg = this.__getTabGroupForMember(oldMember);
	if (!tg) {
		this.addMember(newMember);
		return null;
	}

	/* If we are removing the current focus member, then we need to adjust the focus
	 * member index. If the tab group is empty as a result of the removal
	 */
	var root = this.__getRootTabGroup();
	var newFocusMember;
	if (focusItem) {
		newFocusMember = focusItem;
	}
    else if (root.__currFocusMember === oldMember || (oldMember && oldMember.isDwtTabGroup && oldMember.contains(root.__currFocusMember))) {
		if (newMember) {
			newFocusMember = (newMember.isDwtTabGroup) ? newMember.getFirstMember() : newMember;
		}
        else {
			newFocusMember = this.__getPrevMember(oldMember, checkEnabled);
			if (!newFocusMember) {
				newFocusMember =  this.__getNextMember(oldMember, checkEnabled);
			}
		}
	}

	if (newFocusMember && !noFocus) {
		root.__currFocusMember = newFocusMember;
		this.__showFocusedItem(this.__currFocusMember, "replaceMember");
		if (!skipNotify) {
			this.__notifyListeners(newFocusMember);
		}
	}

	if (newMember && newMember.isDwtTabGroup) {
		newMember.newParent(this);
	}
		
	return newMember ? this.__members.replaceObject(oldMember, newMember) : this.__members.remove(oldMember);
};

/**
 * Returns true if this tab group contains <code>member</code>.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member	the member for which to search
 * 
 * @return {boolean}	<code>true</code> if the tab group contains member
 */
DwtTabGroup.prototype.contains = function(member) {

	return !!this.__getTabGroupForMember(member);
};

/**
 * Sets a new parent for this tab group.
 * 
 * @param {DwtTabGroup} newParent 	the new parent. If the parent is <code>null</code>, then this tabGroup is the root tab group.
 */
DwtTabGroup.prototype.newParent = function(newParent) {

	this.__parent = newParent;
};

/**
 * Gets the first member of the tab group.
 * 
 * @param {boolean} [checkEnabled]		if <code>true</code>, then return first enabled member
 *
 * @return {DwtControl|HTMLElement}	the first member of the tab group
 */
DwtTabGroup.prototype.getFirstMember = function(checkEnabled) {

	return this.__getLeftMostMember(checkEnabled);
};

/**
 * Gets the last member of the tab group.
 * 
 * @param {boolean} [checkEnabled]		if <code>true</code>, then return last enabled member
 *
 * @return {DwtControl|HTMLElement}	the last member of the tab group
 */
DwtTabGroup.prototype.getLastMember = function(checkEnabled) {

	return this.__getRightMostMember(checkEnabled);
};
 
/**
 * Returns the current focus member.
 * 
 * @return {DwtControl|HTMLElement}	current focus member
 * 
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.getFocusMember = function(){

	this.__checkRoot();
	return this.__currFocusMember;
};

/**
 * Sets the current focus member. 
 * 
 * @param {DwtControl|HTMLElement} member 		the member to which to set focus
 * @param {boolean} [checkEnabled] 	if <code>true</code>, then make sure the member is enabled
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by Dwt tab management framework when it is calling into this method
 * 
 * @return {boolean}	<code>true</code> if member was part of the tab group hierarchy, else false
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.setFocusMember = function(member, checkEnabled, skipNotify) {

    if (!member) {
        return false;
    }

    if (member.isDwtTabGroup) {
        DBG.println(AjxDebug.FOCUS, "DwtTabGroup SETFOCUSMEMBER to a DwtTabGroup: " + member + " / " + member.getName());
        member = member.getFocusMember() || member.getFirstMember();
    }
	this.__checkRoot();	
	if (!this.__checkEnabled(member, checkEnabled)) {
		return false;
	}

	if (this.contains(member)) {
		this.__currFocusMember = member;
		this.__showFocusedItem(this.__currFocusMember, "setFocusMember");
		if (!skipNotify) {
			this.__notifyListeners(this.__currFocusMember);
		}
		return true;	
	}

	return false;
};

/**
 * This method sets and returns the next focus member in this tab group. If there is no next
 * member, sets and returns the first member in the tab group.
 * 
 * @param {boolean} [checkEnabled] 	if <code>true</code>, get the next enabled member
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by {@link Dwt} tab management framework when it is calling into this method
 * 
 * @return {DwtControl|HTMLElement}	new focus member or <code>null</code> if there is no focus member or if the focus
 * 		member has not changed (i.e. only one member in the tabgroup)
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.getNextFocusMember = function(checkEnabled, skipNotify) {

	this.__checkRoot();		
	return this.__setFocusMember(true, checkEnabled, skipNotify);
};

/**
 * This method sets and returns the previous focus member in this tab group. If there is no
 * previous member, sets and returns the last member in the tab group.
 * 
 * @param {boolean} [checkEnabled] 	if <code>true</code>, get the previously enabled member
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by Dwt tab management framework when it is calling into this method
 * 
 * @return {DwtControl|HTMLElement}	new focus member or <code>null</code> if there is no focus member or if the focus
 * 		member has not changed (i.e. only one member in the tabgroup)
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.getPrevFocusMember = function(checkEnabled, skipNotify) {

	this.__checkRoot();		
	return this.__setFocusMember(false, checkEnabled, skipNotify);
};

/**
 * Resets the the focus member to the first element in the tab group.
 * 
 * @param {boolean} [checkEnabled] 	if <code>true</code>, then pick a enabled member to which to set focus
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by Dwt tab management framework when it is calling into this method
 * 
 * @return {DwtControl|HTMLElement}	the new focus member
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.resetFocusMember = function(checkEnabled, skipNotify) {

	this.__checkRoot();
	var focusMember = this.__getLeftMostMember(checkEnabled);
	if ((focusMember != this.__currFocusMember) && !skipNotify) {
		this.__notifyListeners(this.__currFocusMember);
	}
	this.__showFocusedItem(this.__currFocusMember, "resetFocusMember");
    DBG.println(AjxDebug.FOCUS, "DwtTabGroup RESETFOCUSMEMBER: " + focusMember);
	this.__currFocusMember = focusMember;
	
	return this.__currFocusMember;
};

/**
 * Pretty-prints the contents of the tab group to the browser console or the
 * debug window.
 *
 * @param {number} [debugLevel]     if specified, dump to the debug window
 *                                  at the given level.
 */
DwtTabGroup.prototype.dump = function(debugLevel) {

	if (debugLevel) {
		if (!window.AjxDebug || !window.DBG) {
			return;
		}

		var logger = function(s) {
			var s = AjxStringUtil.convertToHtml(s);
			DBG.println(debugLevel, s);
		}

		DwtTabGroup.__dump(this, logger, 0);
	} else if (window.console && window.console.log) {
		var r = [];
		DwtTabGroup.__dump(this, r.push.bind(r), 0);
		console.log(r.join('\n'));
	}
};

/**
 * Gets the size of the group.
 * 
 * @return	{number}	the size
 */
DwtTabGroup.prototype.size = function() {

	return this.__members.size();
};

/**
 * Returns the previous member in the tag group.
 * 
 * @private
 */
DwtTabGroup.prototype.__getPrevMember = function(member, checkEnabled) {

	var a = this.__members.getArray();

	// Start working from the member to the immediate left, then keep going left
	for (var i = this.__lastIndexOfMember(member) - 1; i > -1; i--) {
		var prevMember = a[i];
		/* if sibling is not a tab group, then it is the previous child. If the
		 * sibling is a tab group, get its rightmost member.*/
		if (!prevMember.isDwtTabGroup) {
			if (this.__checkEnabled(prevMember, checkEnabled)) {
				return prevMember;
			}
		} else {
			prevMember = prevMember.__getRightMostMember(checkEnabled);
			if (this.__checkEnabled(prevMember, checkEnabled)) {
				return prevMember;
			}
		}
	}

	/* If we have fallen through to here it is because the tab group only has 
	 * one member. So we roll up to the parent, unless we are at the root in 
	 * which case we return null. */
	return this.__parent ? this.__parent.__getPrevMember(this, checkEnabled) : null;
};

/**
 * Returns true if the given member can accept focus, or if there is no need to check.
 * If we are checking, the member must be enabled and visible if it is a control, and
 * enabled otherwise. A member may also set the "noTab" flag to take itself out of the
 * tab hierarchy.
 * 
 * @private
 */
DwtTabGroup.prototype.__checkEnabled = function(member, checkEnabled) {

	if (!checkEnabled) {
		return true;
	}

	if (!member || member.noTab) {
		return false;
	}

	if (member.isDwtControl ? !member.getEnabled() : member.disabled) {
		return false;
	}

	if (member.isDwtControl) {
		member = member.getHtmlElement();
	}

	var loc = Dwt.getLocation(member);
	if (loc.x === null || loc.y === null || loc.x === Dwt.LOC_NOWHERE || loc.y === Dwt.LOC_NOWHERE) {
		return false;
	}

	var size = Dwt.getSize(member);
	if (!size || size.x === 0 || size.y === 0) {
		return false;
	}

	if (member.nodeName && member.nodeName.toLowerCase() === "body") {
		return true;
	}
	return (Dwt.getZIndex(member, true) > Dwt.Z_HIDDEN &&
	        Dwt.getVisible(member) && Dwt.getVisibility(member));
};

DwtTabGroup.prototype.__indexOfMember = function(member) {

    return this.__members.indexOf(member);
};

DwtTabGroup.prototype.__lastIndexOfMember = function(member) {

    return this.__members.lastIndexOf(member);
};

/**
 * Sets and returns the next member in the tag group.
 * 
 * @private
 */
DwtTabGroup.prototype.__getNextMember = function(member, checkEnabled) {

	var a = this.__members.getArray();
	var sz = this.__members.size();

	// Start working from the member rightwards
	for (var i = this.__indexOfMember(member) + 1; i < sz; i++) {
		var nextMember = a[i];
		/* if sibling is not a tab group, then it is the next child. If the
		 * sibling is a tab group, get its leftmost member.*/
		if (!nextMember.isDwtTabGroup) {
			if (this.__checkEnabled(nextMember, checkEnabled)) {
				return nextMember;
			}
		}
        else {
			nextMember = nextMember.__getLeftMostMember(checkEnabled);
			if (this.__checkEnabled(nextMember, checkEnabled)) {
				return nextMember;
			}
		}
	}

	/* If we have fallen through to here it is because the tab group only has 
	 * one member or we are at the end of the list. So we roll up to the parent, 
	 * unless we are at the root in which case we return null. */
	return this.__parent ? this.__parent.__getNextMember(this, checkEnabled) : null;
};

/**
 * Finds the rightmost member of the tab group. Will recurse down
 * into contained tab groups if necessary.
 * @private
 */
DwtTabGroup.prototype.__getRightMostMember = function(checkEnabled) {

	var a = this.__members.getArray();
	var member = null;
	
	/* Work backwards from the rightmost member. If the member is a tab group, then
	 * recurse into it. If member is not a tab group, return it as it is the 
	 * rightmost element. */
	for (var i = this.__members.size() - 1; i >= 0; i--) {
		member = a[i]
		if (!member.isDwtTabGroup) {
			if (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
        else {
			member = member.__getRightMostMember(checkEnabled);
			if (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
	}

	return this.__checkEnabled(member, checkEnabled) ? member : null;
};

/**
 *  Finds the leftmost member of the tab group. Will recurse down
 * into contained tab groups if necessary.
 * @private
 */
DwtTabGroup.prototype.__getLeftMostMember = function(checkEnabled) {

	var sz = this.__members.size();
	var a = this.__members.getArray();
	var member = null;

	/* Work forwards from the leftmost member. If the member is a tabgroup, then
	 * recurse into it. If member is not a tabgroup, return it as it is the 
	 * rightmost element */
	for (var i = 0; i < sz; i++) {
		member = a[i]
		if (!member.isDwtTabGroup) {
			if  (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
        else {
			member = member.__getLeftMostMember(checkEnabled);
			if (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
	}

	return this.__checkEnabled(member, checkEnabled) ? member : null;
};

/**
 * Notifies focus change listeners.
 * @private
 */
DwtTabGroup.prototype.__notifyListeners = function(newFocusMember) {

	// Only the root tab group will issue notifications
	var rootTg = this.__getRootTabGroup();
	if (rootTg.__evtMgr) {
		var evt = DwtTabGroup.__changeEvt;
		evt.reset();
		evt.tabGroup = this;
		evt.newFocusMember = newFocusMember;
		rootTg.__evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, evt);
	}
};

/**
 * @private
 */
DwtTabGroup.prototype.__getRootTabGroup = function() {

	var root = this;
	while (root.__parent) {
		root = root.__parent;
	}
	
	return root;
}

DwtTabGroup.DUMP_INDENT = '|\t';

/**
 * @private
 */
DwtTabGroup.__dump = function(tg, logger, level) {

	var myIndent = AjxStringUtil.repeat(DwtTabGroup.DUMP_INDENT, level);

	logger(myIndent + "TABGROUP: " + tg.__name);

	myIndent += DwtTabGroup.DUMP_INDENT;

	var sz = tg.__members.size();
	var a = tg.__members.getArray();
	for (var i = 0; i < sz; i++) {
        var m = a[i];
		if (m.isDwtTabGroup) {
			DwtTabGroup.__dump(m, logger, level + 1);
		}
        else {
			var desc = m.nodeName ? [ m.nodeName, m.id, m.className ].join(' ') : [ String(m), m._htmlElId ].join(' ');
			if (m.noTab) {
				desc += ' - no tab!';
			}
			logger(myIndent + desc);
		}
	}
};

/**
 * Sets the next or previous focus member.
 * @private
 */
DwtTabGroup.prototype.__setFocusMember = function(next, checkEnabled, skipNotify) {

	// If there is currently no focus member, then reset to the first member and return
	if (!this.__currFocusMember) {
		return this.resetFocusMember(checkEnabled, skipNotify);
	}
	
	var tabGroup = this.__getTabGroupForMember(this.__currFocusMember);
	if (!tabGroup) {
		DBG.println(AjxDebug.DBG1, "tab group not found for focus member: " + this.__currFocusMember);
		return null;
	}
	var m = next ? tabGroup.__getNextMember(this.__currFocusMember, checkEnabled)
				 : tabGroup.__getPrevMember(this.__currFocusMember, checkEnabled);

	if (!m) {
        // wrap around
		m = next ? this.__getLeftMostMember(checkEnabled)
				 : this.__getRightMostMember(checkEnabled);

		// Test for the case where there is only one member in the tabgroup
		if (m == this.__currFocusMember) {
			return null;
		}
	}

	this.__currFocusMember = m;
	
	this.__showFocusedItem(this.__currFocusMember, "__setFocusMember");
	if (!skipNotify) {
		this.__notifyListeners(this.__currFocusMember);
	}
	
	return this.__currFocusMember;
};

/**
 * Returns the tab group from within this tab group's hierarchy that contains the given member. Traverses the tree top-down.
 *
 * @private
 */
DwtTabGroup.prototype.__getTabGroupForMember = function(member) {

	if (!member) {
        return null;
    }

    var a = this.__members.getArray(),
        ln = a.length, i, m;

	for (i = 0; i < ln; i++) {
		m = a[i];
		if (m === member) {
			return this;
		}
        else if (m.isDwtTabGroup && (m = m.__getTabGroupForMember(member))) {
			return m;
		}
	}
	return null;
};

/**
 * Throws an exception if this is not the root tab group.
 * 
 * @private
 */
DwtTabGroup.prototype.__checkRoot = function() {

	if (this.__parent) {
        DBG.println(AjxDebug.DBG1, "DwtTabGroup NOT_ROOT_TABGROUP: " + this.getName());
//		throw DwtTabGroup.NOT_ROOT_TABGROUP;
	}
};

// Prints out a debug line describing the currently focused member
DwtTabGroup.prototype.__showFocusedItem = function(item, caller) {

	if (item && window.AjxDebug && window.DBG) {
		var callerText = caller ? "DwtTabGroup." + caller + ": " : "",
			idText = " [" + (item.isDwtControl ? item._htmlElId : item.id) + "] ",
            itemText = (item.nodeName || item) + " " + idText,
			otherText = (item.getTitle && item.getTitle()) || (item.getText && item.getText()) || "",
			fullText = itemText + otherText;

		DBG.println(AjxDebug.FOCUS, callerText + "current focus member is now " + itemText);
		DBG.println(AjxDebug.FOCUS1, "Focus: " + fullText);
	}
};
}
if (AjxPackage.define("ajax.dwt.core.DwtId")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @class
 * This class is responsible for providing unique, predictable IDs for HTML elements.
 * That way, code outside the client can locate particular elements.
 * <p>
 * Not every element that has an associated JS object will have a known ID. Those are
 * allocated only for elements it would be useful to locate: major components of the UI,
 * toolbars, buttons, views, menus, some menu items, and some selects.
 * <p>
 * There is a simple naming scheme for the IDs themselves. Each ID starts with a "z" followed
 * by one to a few letters that indicate the type of object (widget) represented by the element.
 * 
 * @author Conrad Damon
 */
 
DwtId = function() {}

// separator for parts used in constructing IDs - need to pick one that
// doesn't show up in any of the parts
DwtId.SEP = "__";

// widget types (used to prefix IDs)
/**
 * Defines the widget "list view".
 */
DwtId.WIDGET_LIST_VIEW		= "zl";			// list view
/**
 * Defines the widget "list view header".
 */
DwtId.WIDGET_HDR			= "zlh";		// list view header
/**
 * Defines the widget "list view header table".
 */
DwtId.WIDGET_HDR_TABLE		= "zlht";		// list view header table
/**
 * Defines the widget "list view header icon image".
 */
DwtId.WIDGET_HDR_ICON		= "zlhi";		// list view header image
/**
 * Defines the widget "list view header text".
 */
DwtId.WIDGET_HDR_LABEL		= "zlhl";		// list view header text
/**
 * Defines the widget "list view header dropdown arrow".
 */
DwtId.WIDGET_HDR_ARROW		= "zlha";		// list view header dropdown arrow
/**
 * Defines the widget "sash between list view headers".
 */
DwtId.WIDGET_HDR_SASH		= "zlhs";		// sash between list view headers
/**
 * Defines the widget "list view item".
 */
DwtId.WIDGET_ITEM			= "zli";		// list view item
/**
 * Defines the widget "list view item row".
 */
DwtId.WIDGET_ITEM_ROW		= "zlir";		// list view item row
/**
 * Defines the widget "list view item cell".
 */
DwtId.WIDGET_ITEM_CELL		= "zlic";		// list view item cell
/**
 * Defines the widget "list view item field".
 */
DwtId.WIDGET_ITEM_FIELD		= "zlif";		// list view item field

// list view modifiers
/**
 * Defines the list view "headers" modifier.
 */
DwtId.LIST_VIEW_HEADERS	= "headers";
/**
 * Defines the list view "rows" modifier.
 */
DwtId.LIST_VIEW_ROWS	= "rows";

DwtId.IFRAME = "iframe";

DwtId.DND_PLUS_ID		= "z__roundPlus";

/**
 * Joins the given arguments into an ID, excluding empty ones.
 * 
 * @private
 */
DwtId.makeId =
function() {
	var list = [];
	for (var i = 0; i < arguments.length; i++) {
		var arg = arguments[i];
		if (arg != null && arg != "") {
			list.push(arg);
		}
	}
	return list.join(DwtId.SEP);
};
DwtId._makeId = DwtId.makeId;	// back-compatibility

/**
 * Gets an ID for a list view.
 * 
 * @param {constant}	context		the owning view identifier
 * @param {DwtId.LIST_VIEW_HEADERS|DwtId.LIST_VIEW_ROWS}	modifier	indicates element within list view (see <code>DwtId.LIST_VIEW*</code> constants)	
 * @return	{string}	the ID
 */
DwtId.getListViewId =
function(context, modifier) {
	return DwtId.makeId(DwtId.WIDGET_LIST_VIEW, context, modifier);
};

/**
 * Gets an ID for an element within a list view header.
 * 
 * @param {constant}	type		the type of hdr element (see <code>DwtId.WIDGET_HDR*</code> constants)
 * @param {constant}	context	the the ID of owning view
 * @param {constant}	hdr		the header ID
 * @return	{string}	the ID
 */
DwtId.getListViewHdrId =
function(type, context, hdr) {
	return DwtId.makeId(type, context, hdr);
};

/**
 * Gets an ID for an element associated with the display of an item in a list view.
 * 
 * @param {constant}	type		the type of item element (see <code>DwtId.WIDGET_ITEM*</code> constants)
 * @param {constant}	context		the ID of owning view
 * @param {string}	itemId	the item ID (typically numeric)
 * @param {constant}	field		the field identifier (for example, "su" for subject)
 * @return	{string}	the ID
 */
DwtId.getListViewItemId =
function(type, context, itemId, field) {
	return DwtId.makeId(type, context, itemId, field);
};

/**
 * Gets an ID for an IFRAME.
 * 
 * @param {constant}	context	the ID of owning {@link DwtIframe}
 * @return	{string}	the ID
 */
DwtId.getIframeId =
function(context) {
	return DwtId.makeId(context, DwtId.IFRAME);
};
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDragEvent")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @constructor
 * @class
 * DwtDragEvent is generated by the Drag and Drop framework when a drag operation is
 * in process. The drag event is dispatched to the registered {@link DwtDragSource} instance.
 * 
 * @author Ross Dargahi
 * 
 * @see DwtDragSource
 */
DwtDragEvent = function() {
	/**
	 * Type of drag operation. One of:
	 * <ul>
	 * <li>{@link DwtDragEvent.DRAG_START}</li>
	 * <li>{@link DwtDragEvent.SET_DATA}</li>
	 * <li>{@link DwtDragEvent.DRAG_END}</li>
	 * </ul>
	 */
	this.operation = null;
	
	/**
	 * Drag source control
	 * @type DwtControl
	 */
	this.srcControl = null;
	
	/**
	 * Action being performed. One of:
	 * <ul>
	 * <li>{@link Dwt.DND_DROP_NONE}</li>
	 * <li>{@link Dwt.DND_DROP_COPY}</li>
	 * <li>{@link Dwt.DND_DROP_MOVE}</li>
	 * </ul>
	 */
	this.action = null;
	
	/**
	 * Whether the DnD framework should perform the operation. The application is
	 * responsible for setting this value based on whatever business logic it is
	 * implementing
	 * @type boolean
	 */
	this.doIt = false;
	
	/**
	 * Drag source data. This is the application data associated with the item being dragged.
	 */
	this.srcData = null;
};

/**
 * Drag initialization.
 */
DwtDragEvent.DRAG_INIT = "INIT";

/**
 * Drag is starting.
 */
DwtDragEvent.DRAG_START = "START";

/**
 * Set the <code>srcData</code> field of the event.
 */
DwtDragEvent.SET_DATA = "SET_DATA";

/**
 * Drag movement has occurred.
 */
DwtDragEvent.DRAG_MOVE = "MOVE";

/**
 * Drag has ended.
 */
DwtDragEvent.DRAG_END = "END";

/**
 * Drag canceled (i.e. dropped on invalid target).
 */
DwtDragEvent.DRAG_CANCEL = "CANCEL";
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDragSource")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @constructor
 * @class
 * A drag source is registered with a control to indicate that the control is 
 * draggable. The drag source is the mechanism by which the DnD framework provides 
 * the binding between the UI components and the application.
 * <p>
 * Application developers instantiate {@link DwtDragSource} and register it with the control
 * which is to be draggable (via {@link DwtControl.setDragSource}). The
 * application should then register a listener with the {@link DwtDragSource}. This way
 * when drag events occur the application will be notified and may act on them 
 * accordingly
 * </p>
 * 
 * @author Ross Dargahi
 * 
 * @param {number} supportedOps 	the supported operations. This is an arithmetic OR'ing of
 * 		the operations supported by the drag source. Supported values are:
 * 		<ul>
 * 			<li>{@link Dwt.DND_DROP_NONE}</li>
 * 			<li>{@link Dwt.DND_DROP_COPY}</li>
 * 			<li>{@link Dwt.DND_DROP_MOVE}</li>
 * 		</ul> 
 * 
 * @see DwtDragEvent
 * @see DwtControl
 * @see DwtControl#setDragSource
 */
DwtDragSource = function(supportedOps) {
	this.__supportedOps = supportedOps
	this.__evtMgr = new AjxEventMgr();
};

/** @private */
DwtDragSource.__DRAG_LISTENER = "DwtDragSource.__DRAG_LISTENER";

/** @private */
DwtDragSource.__dragEvent = new DwtDragEvent();

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtDragSource.prototype.toString = 
function() {
	return "DwtDragSource";
};


/**
 * Registers a listener for <i>DwtDragEvent</i> events.
 *
 * @param {AjxListener} dragSourceListener Listener to be registered 
 * 
 * @see DwtDragEvent
 * @see AjxListener
 * @see #removeDragListener
 */
DwtDragSource.prototype.addDragListener =
function(dragSourceListener) {
	this.__evtMgr.addListener(DwtDragSource.__DRAG_LISTENER, dragSourceListener);
};

/**
 * Removes a registered event listener.
 * 
 * @param {AjxListener} dragSourceListener Listener to be removed
 * 
 * @see AjxListener
 * @see #addDragListener
 */
DwtDragSource.prototype.removeDragListener =
function(dragSourceListener) {
	this.__evtMgr.removeListener(DwtDragSource.__DRAG_LISTENER, dragSourceListener);
};

// The following methods are called by DwtControl during the drag lifecycle 

/** @private */
DwtDragSource.prototype._beginDrag =
function(operation, srcControl) {
	if (!(this.__supportedOps & operation))
		return Dwt.DND_DROP_NONE;
		
	DwtDragSource.__dragEvent.operation = operation;
	DwtDragSource.__dragEvent.srcControl = srcControl;
	DwtDragSource.__dragEvent.action = DwtDragEvent.DRAG_START;
	DwtDragSource.__dragEvent.srcData = null;
	DwtDragSource.__dragEvent.doit = true;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.operation;
};

/** @private */
DwtDragSource.prototype._getData =
function() {
	DwtDragSource.__dragEvent.action = DwtDragEvent.SET_DATA;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.srcData;
};

/** @private */
DwtDragSource.prototype._endDrag =
function() {
	DwtDragSource.__dragEvent.action = DwtDragEvent.DRAG_END;
	DwtDragSource.__dragEvent.doit = false;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.doit;
};

/** @private */
DwtDragSource.prototype._cancelDrag =
function() {
	DwtDragSource.__dragEvent.action = DwtDragEvent.DRAG_CANCEL;
	DwtDragSource.__dragEvent.doit = false;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.doit;
};
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDropEvent")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @constructor
 * @class
 * DwtDropEvent is generated by the Drag and Drop framework when a drag n drop operation is
 * in process. The drop event is dispatched to the registered {@link DwtDropTarget} instance.
 * 
 * @author Ross Dargahi
 * 
 * @see DwtDropTarget
 */
DwtDropEvent = function() {
	/**
	 * Type of drag operation. One of:
	 * <ul>
	 * <li>{@link DwtDragEvent.DRAG_START}</li>
	 * <li>{@link DwtDragEvent.SET_DATA}</li>
	 * <li>{@link DwtDragEvent.DRAG_END}</li>
	 * </ul>
	 */
	this.operation = null;
	
	/**
	 * Drop target control.
	 * @type DwtControl
	 * */	
	this.targetControl = null;
	
	/**
	 * Action being performed. One of:
	 * <ul>
	 * <li>{@link Dwt.DND_DROP_NONE}</li>
	 * <li>{@link Dwt.DND_DROP_COPY}</li>
	 * <li>{@link Dwt.DND_DROP_MOVE}</li>
	 * </ul>
	 */
	this.action = null;
	
	/**
	 * Drag source data. This is the application data associated with the item being dragged.
	 */
	this.srcData = null;

	/**
	 * Whether the DnD framework should perform the operation. The application is
	 * responsible for setting this value based on whatever business logic it is
	 * implementing.
	 * @type boolean
	 */
	this.doIt = false;
}

/**
 * A draggable object has entered the drop target.
 */
DwtDropEvent.DRAG_ENTER = 1;

/**
 * A draggable object has left the drop target.
 */
DwtDropEvent.DRAG_LEAVE = 2;

/**
 * Drag operation has changed e.g. from move to copy.
 */
DwtDropEvent.DRAG_OP_CHANGED = 3;

/**
 * A draggable object has been dropped on the drag target.
 */
DwtDropEvent.DRAG_DROP = 4;
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDropTarget")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @constructor
 * @class
 * A drop target is registered with a control to indicate that the control is 
 * a drop target. The drop target is the mechanism by which the DnD framework provides 
 * the binding between the UI components and the application.
 * <p>
 * Application developers instantiate {@link DwtDropTarget} and register it with the control
 * which is to be a drop target (via {@link DwtControl.setDropTarget}). The
 * application should then register a listener with the {@link DwtDropTarget}. This way
 * when drop events occur the application will be notified and may act on them 
 * accordingly
 * </p>
 * 
 * @author Ross Dargahi
 * 
 * @param {array} transferType	a list of supported object types that may be dropped onto
 * 		this drop target. Typically the items represent classes (i.e. functions) whose 
 * 		instances may be dropped on this drop target e.g. 
 * 		<code>new DwtDropTarget(MailItem, AppointmentItme)</code>
 * 
 * @see DwtDropEvent
 * @see DwtControl
 * @see DwtControl#setDropTarget
 */
DwtDropTarget = function(types) {
	/** @private */
	this._evtMgr = new AjxEventMgr();

	/** @private */
	this.__hasMultiple = false;
	
	this._types = {};
	if (typeof types == "string") {
		types = [types];
	}
	if (types && types.length) {
		for (var i = 0; i < types.length; i++) {
			this.addTransferType(types[i]);
		}
	}
}

/** @private */
DwtDropTarget.__DROP_LISTENER = "DwtDropTarget.__DROP_LISTENER";

/** @private */
DwtDropTarget.__dropEvent = new DwtDropEvent();

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtDropTarget.prototype.toString = 
function() {
	return "DwtDropTarget";
}

/**
 * Registers a listener for {@link DwtDragEvent} events.
 *
 * @param {AjxListener} dropTargetListener Listener to be registered 
 * 
 * @see DwtDropEvent
 * @see AjxListener
 * @see #removeDropListener
 */
DwtDropTarget.prototype.addDropListener =
function(dropTargetListener) {
	this._evtMgr.addListener(DwtDropTarget.__DROP_LISTENER, dropTargetListener);
}

/**
 * Removes a registered event listener.
 * 
 * @param {AjxListener} dropTargetListener Listener to be removed
 * 
 * @see AjxListener
 * @see #addDropListener
 */
DwtDropTarget.prototype.removeDropListener =
function(dropTargetListener) {
	this._evtMgr.removeListener(DwtDropTarget.__DROP_LISTENER, dropTargetListener);
}

/**
 *  Check to see if the types in <code>items</code> can be dropped on this drop target
 *
 * @param {object|array} items an array of objects or single object whose types are
 * 		to be checked against the set of transfer types supported by this drop target
 * 
 * @return true if all of the objects in <code>items</code> may legally be dropped on 
 * 		this drop target
 * @type boolean
 */
DwtDropTarget.prototype.isValidTarget =
function(items) {
	if (items instanceof Array) {
		var len = items.length;
		for (var i = 0; i < len; i++) {
			if (!this.__checkTarget(items[i])) {
				return false;
			}
		}
		return true;
	} else {
		return this.__checkTarget(items);
	}
}

/**
 * Calling this method indicates that the UI component backing this drop target has multiple 
 * sub-components
 */
DwtDropTarget.prototype.markAsMultiple = 
function() {
	this.__hasMultiple = true;
};

/**
 * Checks if the UI component backing this drop target has multiple sub-components.
 * 
 * @return	{boolean}		<code>true</code> if the UI component has multiple sub-components
 */
DwtDropTarget.prototype.hasMultipleTargets = 
function () {
	return this.__hasMultiple;
};

/**
 * Gets the transfer types.
 * 
 * @return {array}	the list of transfer types supported by this drop target
 * 
 * @see #setTransferTypes
 */
DwtDropTarget.prototype.getTransferTypes =
function() {
	return this._types;
}

/**
 * Declares a type of object as valid for being dropped onto this target. The type is provided
 * as a string, since the corresponding class may not yet be defined. The type is eval'ed before
 * it is used for any validation, since the check is done with <code>instanceof</code>.
 * 
 * @param {string}	type		the name of class
 */
DwtDropTarget.prototype.addTransferType =
function(type) {
	this._types[type] = null;
};

// The following methods are called by DwtControl during the Drag lifecycle 

/** @private */
DwtDropTarget.prototype._dragEnter =
function(operation, targetControl, srcData, ev, dndProxy) {
	DwtDropTarget.__dropEvent.operation = operation;
	DwtDropTarget.__dropEvent.targetControl = targetControl;
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_ENTER;
	DwtDropTarget.__dropEvent.srcData = srcData;
	DwtDropTarget.__dropEvent.uiEvent = ev;
	DwtDropTarget.__dropEvent.doIt = true;
	DwtDropTarget.__dropEvent.dndProxy = dndProxy;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
	return DwtDropTarget.__dropEvent.doIt;
}

/** @private */
DwtDropTarget.prototype._dragLeave =
function() {
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_LEAVE;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
}

/** @private */
DwtDropTarget.prototype._dragOpChanged =
function(newOperation) {
	DwtDropTarget.__dropEvent.operation = newOperation;
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_OP_CHANGED;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
	return DwtDropTarget.__dropEvent.doIt;
};

/** @private */
DwtDropTarget.prototype._drop =
function(srcData, ev) {
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_DROP;
	DwtDropTarget.__dropEvent.srcData = srcData;
	DwtDropTarget.__dropEvent.uiEvent = ev;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
	return DwtDropTarget.__dropEvent.doIt;
};


// Private methods

/**@private*/
DwtDropTarget.prototype.__checkTarget =
function(item) {
	if (this._types) {
		for (var i in this._types) {
			var ctor;
			if (this._types[i]) {
				ctor = this._types[i];
			} else {
				ctor = this._types[i] = eval(i);
			}
			if (ctor && (typeof ctor == "function") && (item instanceof ctor)) {
				return true;
			}
		}
		return false;
	}
};
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDragBox")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @constructor
 * @class
 * A drag box is registered with a control to indicate that the control supports the
 * presence of an elastic box created by clicking and dragging, and typically used to
 * select visual objects within a space.
 * <p>
 * Application developers instantiate {@link DwtDragBox} and register it with the control
 * which is to be draggable (via {@link DwtControl.setDragBox}). The
 * application should then register a listener with the {@link DwtDragBox}. This way
 * when drag events occur the application will be notified and may act on them 
 * accordingly.
 * </p>
 * 
 * @author Conrad Damon
 * 
 * @see DwtDragEvent
 * @see DwtControl
 * @see DwtControl#setDragBox
 */
DwtDragBox = function() {
	this.__evtMgr = new AjxEventMgr();
};

/** @private */
DwtDragBox.__DRAG_LISTENER = "DwtDragBox.__DRAG_LISTENER";

/** @private */
DwtDragBox.__dragEvent = new DwtDragEvent();

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtDragBox.prototype.toString = 
function() {
	return "DwtDragBox";
};


/**
 * Registers a listener for <i>DwtDragEvent</i> events.
 *
 * @param {AjxListener} dragBoxListener Listener to be registered
 * 
 * @see DwtDragEvent
 * @see AjxListener
 * @see #removeDragListener
 */
DwtDragBox.prototype.addDragListener =
function(dragBoxListener) {
	this.__evtMgr.addListener(DwtDragBox.__DRAG_LISTENER, dragBoxListener);
};

/**
 * Removes a registered event listener.
 * 
 * @param {AjxListener} dragBoxListener Listener to be removed
 * 
 * @see AjxListener
 * @see #addDragListener
 */
DwtDragBox.prototype.removeDragListener =
function(dragBoxListener) {
	this.__evtMgr.removeListener(DwtDragBox.__DRAG_LISTENER, dragBoxListener);
};

// The following methods are called by DwtControl during the drag lifecycle 

DwtDragBox.prototype._setStart =
function(mouseEv, srcControl) {

	this._startX = mouseEv.docX;
	this._startY = mouseEv.docY;
	this._dragObj = DwtDragBox.__dragEvent.srcControl = srcControl;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_INIT;
	DwtDragBox.__dragEvent.target = mouseEv.target;
	return (this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent) !== false);
};

DwtDragBox.prototype._beginDrag =
function(srcControl) {

	srcControl._dragging = DwtControl._DRAGGING;
	DwtDragBox.__dragEvent.srcControl = srcControl;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_START;
	this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent);
};

DwtDragBox.prototype._dragMove =
function(mouseEv, srcControl) {

	var deltaX = mouseEv.docX - this._startX;
	var deltaY = mouseEv.docY - this._startY;
	var locX = (deltaX > 0) ? this._startX : mouseEv.docX;
	var locY = (deltaY > 0) ? this._startY : mouseEv.docY;

	var box = srcControl.getDragSelectionBox();
	Dwt.setLocation(box, locX, locY);
	Dwt.setSize(box, Math.abs(deltaX), Math.abs(deltaY));

	DwtDragBox.__dragEvent.srcControl = srcControl;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_MOVE;
	this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent);
};

DwtDragBox.prototype._endDrag =
function(srcControl) {

	srcControl._dragging = DwtControl._NO_DRAG;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_END;
	if (!this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent)) {
		srcControl.destroyDragSelectionBox();
	}
	this._dragObj = null;
};

/*
 *  return starting X position
 *  @return {int} starting X position
 */
DwtDragBox.prototype.getStartX =
function() {
    return this._startX;
};

/*  return starting Y position
 *  @return {int} starting Y position
 */
DwtDragBox.prototype.getStartY =
function() {
    return this._startY;
};
}
if (AjxPackage.define("ajax.dwt.events.DwtDisposeEvent")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * 
 * @private
 */
DwtDisposeEvent = function(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
}

DwtDisposeEvent.prototype = new DwtEvent;
DwtDisposeEvent.prototype.constructor = DwtDisposeEvent;

DwtDisposeEvent.prototype.toString = 
function() {
	return "DwtDisposeEvent";
}
}

if (AjxPackage.define("ajax.dwt.widgets.DwtTreeItem")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates a Tree Item.
 * @constructor
 * @class
 * This class implements a tree item widget.
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params				a hash of parameters
 * @param {DwtComposite}      params.parent	the parent widget
 * @param {number}      params.index 			the index at which to add this control among parent's children
 * @param {string}      params.text 					the label text for the tree item
 * @param {string}      params.imageInfo			the icon for the left end of the tree item
 * @param {string}      params.extraInfo				the icon for the right end of the tree item
 * @param {string}      params.expandNodeImage		the icon to use for expanding tree item (instead of default)
 * @param {string}      params.collapseNodeImage     the icon to use for collapsing tree item (instead of default)
 * @param {string}      params.className				the CSS class
 * @param {constant}      params.posStyle				the positioning style (see {@link DwtControl})
 * @param {boolean}      params.deferred				if <code>true</code>, postpone initialization until needed.
 * @param {boolean}      params.selectable			if <code>true</code>, this item is selectable
 * @param {boolean}      params.forceNotifySelection	force notify selection even if checked style
 * @param {boolean}      params.forceNotifyAction		force notify action even if checked style
 * @param {boolean}      params.singleClickAction		if <code>true</code>, an action is performed in single click
 * @param {AjxCallback}      params.dndScrollCallback	the callback triggered when scrolling of a drop area for an object being dragged
 * @param {string}      params.dndScrollId			the id
 * @param {boolean}    params.arrowDisabled
 * @param {boolean}     params.dynamicWidth		if <code>true</code>, the table should be width auto instead of the default fixed
 *
 * @extends		DwtComposite		
 */
DwtTreeItem = function(params) {

    if (arguments.length == 0) { return; }    

    params = Dwt.getParams(arguments, DwtTreeItem.PARAMS);
	var parent = params.parent;
	if (parent instanceof DwtTree) {
		this._tree = parent;
	} else if (parent instanceof DwtTreeItem) {
		this._tree = parent._tree;
	} else {
		throw new DwtException("DwtTreeItem parent must be a DwtTree or DwtTreeItem", DwtException.INVALIDPARENT, "DwtTreeItem");
	}

	this._origClassName = params.className || "DwtTreeItem";
	this._textClassName = [this._origClassName, "Text"].join("-");
	this._selectedClassName = this._origClassName + ' ' + [this._origClassName, DwtCssStyle.SELECTED].join("-");
	this._selectedFocusedClassName = this._selectedClassName + ' ' + [this._origClassName, DwtCssStyle.SELECTED, DwtCssStyle.FOCUSED].join("-");
	this._actionedClassName = this._origClassName + ' ' + [this._origClassName, DwtCssStyle.ACTIONED].join("-");
	this._dragOverClassName = this._origClassName + ' ' + [this._origClassName, DwtCssStyle.DRAG_OVER].join("-");
    this._treeItemTextClass = "DwtTreeItem-Text";
    this._treeItemExtraImgClass = "DwtTreeItem-ExtraImg";

	this._dynamicWidth = params.dynamicWidth;

	params.deferred = (params.deferred !== false);
	params.className = 'DwtTreeItem-Control';
	DwtComposite.call(this, params);

	this._imageInfoParam = params.imageInfo;
	this._extraInfo = params.extraInfo;
	this._textParam = params.text;
	this._deferred = params.deferred;
	this._expandNodeImage = params.expandNodeImage || "NodeExpanded";
	this._collapseNodeImage = params.collapseNodeImage || "NodeCollapsed";
	this._itemChecked = false;
	this._initialized = false;
	this._selectionEnabled = Boolean(params.selectable !== false);
	this._forceNotifySelection = Boolean(params.forceNotifySelection);
	this._actionEnabled = true;
	this._forceNotifyAction = Boolean(params.forceNotifyAction);
	this._dndScrollCallback = params.dndScrollCallback;
	this._dndScrollId = params.dndScrollId;
	this._arrowDisabled = params.arrowDisabled;

	if (params.singleClickAction) {
		this._singleClickAction = true;
		this._selectedFocusedClassName = this._selectedClassName = this._textClassName;
		this._hoverClassName = [this._origClassName, DwtCssStyle.HOVER].join("-");
	} else {
		this._hoverClassName = this._textClassName;
	}

	// if our parent is DwtTree or our parent is initialized and is not deferred
	// type or is expanded, then initialize ourself, else wait
	if (parent instanceof DwtTree || (parent._initialized && (!parent._deferred || parent._expanded)) || !params.deferred) {
		this._initialize(params.index);
	} else {
		parent._addDeferredChild(this, params.index);
		this._index = params.index;
	}
};

DwtTreeItem.PARAMS = ["parent", "index", "text", "imageInfo", "deferred", "className", "posStyle",
					  "forceNotifySelection", "forceNotifyAction"];

DwtTreeItem.prototype = new DwtComposite;
DwtTreeItem.prototype.constructor = DwtTreeItem;

DwtTreeItem.prototype.isDwtTreeItem = true;
DwtTreeItem.prototype.toString = function() { return "DwtTreeItem"; };

DwtTreeItem.prototype.TEMPLATE = "dwt.Widgets#ZTreeItem";

DwtTreeItem.prototype.role = "treeitem";
DwtTreeItem.prototype.isFocusable = true;

DwtTreeItem.prototype._checkBoxVisible = true; // Assume it's shown, if check style

// Consts

DwtTreeItem._NODECELL_DIM = "16px";
DwtTreeItem._processedMouseDown = false;

// Public Methods

DwtTreeItem.prototype.dispose =
function() {
    DwtComposite.prototype.dispose.call(this);
	this._itemDiv = null;
	this._nodeCell = null;
	this._checkBoxCell = null;
	this._checkedImg = null;
	this._checkBox = null;
	this._imageCell = null;
	this._textCell = null;
	this._childDiv = null;
	this._initialized = false;
};

/**
 * override DwtControl.prototype.getData to take care of special case of KEY_OBJECT of type ZmOrganizer. See bug 82027
 * @param key
 * @return {*}
 */
DwtTreeItem.prototype.getData =
function(key) {
	var obj = this._data[key];
	if (key !== Dwt.KEY_OBJECT || !obj || !obj.isZmOrganizer) {
		return obj;
	}
	//special case for ZmOrganizer instance of the Dwt.KEY_OBJECT attribute.
	//bug 82027 - the folder attributes such as name could be wrong after refresh block+ rename when new instance was created but not set to the item Dwt.KEY_OBJECT attribute.
	var cachedOrganizer = obj && appCtxt.cacheGet(obj.id);
	return cachedOrganizer || obj; //just in case somehow it's no longer cached. No idea if could happen.
};

/**
 * Checks if the item is checked.
 * 
 * @return	{boolean}	<code>true</code> if the item is checked
 */
DwtTreeItem.prototype.getChecked =
function() {
	return this._itemChecked;
};

/**
 * Sets the checked flag.
 * 
 * @param	{boolean}	checked		if <code>true</code>, check the item
 * @param	{boolean}	force		if <code>true</code>, force the setting
 */
DwtTreeItem.prototype.setChecked =
function(checked, force) {
	if ((this._itemChecked != checked) || force) {
		this._itemChecked = checked;
		if (this._checkBox != null &&
			(this._checkBoxCell && Dwt.getVisible(this._checkBoxCell)))
		{
			Dwt.setVisible(this._checkedImg, checked);
		}
	}
};

DwtTreeItem.prototype._handleCheckboxOnclick =
function(ev) {
	this.setChecked(!Dwt.getVisible(this._checkedImg));

	ev = ev || window.event;
	ev.item = this;
	this._tree._itemChecked(this, ev);
};

DwtTreeItem.prototype.getExpanded =
function() {
	return this._expanded;
};

/**
 * Expands or collapses this tree item.
 *
 * @param {boolean}	expanded		if <code>true</code>, expands this node; otherwise collapses it
 * @param {boolean}	recurse		if <code>true</code>, expand children recursively (does not apply to collapsing)
 * @param	{boolean}	skipNotify		if <code>true</code>, do not notify the listeners
 */
DwtTreeItem.prototype.setExpanded =
function(expanded, recurse, skipNotify) {
	// Go up the chain, ensuring that parents are expanded/initialized
	if (expanded) {
		var p = this.parent;
		while (p instanceof DwtTreeItem && !p._expanded) {
			p.setExpanded(true);
			p = p.parent;
		}
		// Realize any deferred children
		this._realizeDeferredChildren();
	}
		
	// If we have children, then allow for expanding/collapsing
	if (this.getNumChildren()) {
		if (expanded && recurse) {
			if (!this._expanded) {
				this._expand(expanded, null, skipNotify);
			}
			var a = this.getChildren();
			for (var i = 0; i < a.length; i++) {
				if (a[i] instanceof DwtTreeItem) {
					a[i].setExpanded(expanded, recurse, skipNotify);
				}
			}
		} else if (this._expanded != expanded) {
			this._expand(expanded, null, skipNotify);
		}
	}
};

/**
 * Gets the child item count.
 * 
 * @return	{number}	the child item count
 */
DwtTreeItem.prototype.getItemCount =
function() {
	return this._children.size();
};

/**
 * Gets the items.
 * 
 * @return	{array}	an array of child {@link DwtTreeItem} objects
 */
DwtTreeItem.prototype.getItems =
function() {
	return this._children.getArray();
};

DwtTreeItem.prototype.getChildIndex =
function(item) {
	return this._children.indexOf(item);
};

/**
 * Get the nesting level; the toplevel tree is zero, and each lower layer
 * increases by one.
 * 
 * @return	{number}	the child item count
 */
DwtTreeItem.prototype.getNestingLevel =
function() {
	return this.parent.getNestingLevel() + 1;
};

/**
 * Gets the image.
 * 
 * @return	{string}	the image
 */
DwtTreeItem.prototype.getImage =
function() {
	return this._imageInfo;
};

/**
 * Sets the image.
 * 
 * @param	{string}	imageInfo		the image
 */
DwtTreeItem.prototype.setImage =
function(imageInfo) {
	if (this._initialized) {
		if (this._imageCell) {
			AjxImg.setImage(this._imageCell, imageInfo);
		}
		this._imageInfo = imageInfo;
	} else {
		this._imageInfoParam = imageInfo;
	}	
};

DwtTreeItem.prototype.setDndImage =
function(imageInfo) {
	this._dndImageInfo = imageInfo;
};

DwtTreeItem.prototype.getSelected =
function() {
	return this._selected;
};

DwtTreeItem.prototype.getActioned =
function() {
	return this._actioned;
};

/**
 * Gets the text.
 * 
 * @return	{string}	the text
 */
DwtTreeItem.prototype.getText =
function() {
	return this._text;
};

/**
 * Sets the text.
 * 
 * @param	{string}	text		the text
 */
DwtTreeItem.prototype.setText =
function(text) {
	if (this._initialized && this._textCell) {
		if (!text) text = "";
		this._text = this._textCell.innerHTML = text;
	} else {
		this._textParam = text;
	}
};

/**
 * Sets the drag-and-drop text.
 * 
 * @param	{string}	text		the text
 */
DwtTreeItem.prototype.setDndText =
function(text) {
	this._dndText = text;
};

/**
 * Shows (or hides) the check box.
 * 
 * @param	{boolean}	show		if <code>true</code>, show the check box
 */
DwtTreeItem.prototype.showCheckBox =
function(show) {
	this._checkBoxVisible = show;
	if (this._checkBoxCell) {
		Dwt.setVisible(this._checkBoxCell, show);
	}
};

/**
 * Shows (or hides) the expansion icon.
 * 
 * @param	{boolean}	show		if <code>true</code>, show the expansion icon
 */
DwtTreeItem.prototype.showExpansionIcon =
function(show) {
	if (this._nodeCell) {
		Dwt.setVisible(this._nodeCell, show);
	}
};

/**
 * Enables (or disables) the selection.
 * 
 * @param	{boolean}	enable		if <code>true</code>, enable selection
 */
DwtTreeItem.prototype.enableSelection =
function(enable) {
	this._selectionEnabled = enable;
	this._selectedClassName = enable
		? this._origClassName + "-" + DwtCssStyle.SELECTED
		: this._origClassName;

};

DwtTreeItem.prototype.isSelectionEnabled =
function() {
	return this._selectionEnabled;
};


DwtTreeItem.prototype.enableAction =
function(enable) {
	this._actionEnabled = enable;
};

/**
 * Adds a separator at the given index. If no index is provided, adds it at the
 * end. A separator cannot currently be added as the first item (the child DIV will
 * not have been created).
 *
 * @param {number}	index		the position at which to add the separator
 */
DwtTreeItem.prototype.addSeparator =
function(index) {
	this._children.add((new DwtTreeItemSeparator(this)), index);
};

/**
 * Makes this tree item, or just part of it, visible or hidden.
 *
 * @param {boolean}	visible		if <code>true</code>, item (or part of it) becomes visible
 * @param {boolean}	itemOnly		if <code>true</code>, apply to this item's DIV only; child items are unaffected
 * @param {boolean}	childOnly		if <code>true</code>, apply to this item's child items only
 */
DwtTreeItem.prototype.setVisible =
function(visible, itemOnly, childOnly) {
	if (itemOnly && !childOnly) {
		Dwt.setVisible(this._itemDiv, visible);
	} else if (childOnly && !itemOnly) {
		Dwt.setVisible(this._childDiv, visible);
	} else {
		DwtComposite.prototype.setVisible.call(this, visible);
	}
};

DwtTreeItem.prototype.removeChild =
function(child) {
	if (child._initialized) {
		this._tree._deselect(child);
		if (this._childDiv) {
			this._childDiv.removeChild(child.getHtmlElement());
		}
	}
	this._children.remove(child);

	// if we have no children and we are expanded, then mark us a collapsed.
	// Also if there are no deferred children, then make sure we remove the
	// expand/collapse icon and replace it with a blank16Icon.
	if (this._children.size() == 0) {
		if (this._expanded)
			this._expanded = false;

		this._expandable = false;
		this.removeAttribute('aria-expanded')
		
		if (this._initialized && this._nodeCell) {
			AjxImg.setImage(this._nodeCell, "Blank_16");
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl)
				Dwt.clearHandler(imgEl, DwtEvent.ONMOUSEDOWN);
		}
	}
};

DwtTreeItem.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_TREE;
};

DwtTreeItem.prototype.handleKeyAction =
function(actionCode, ev) {

	switch (actionCode) {
		
		case DwtKeyMap.ENTER:
			this._tree.setEnterSelection(this, true);
			break;


		case DwtKeyMap.NEXT: {
			var ti = this._tree._getNextTreeItem(true);
			if (ti) {
				ti._tree.setSelection(ti, false, true);
			}
			break;
		}

		case DwtKeyMap.PREV: {
			var ti = this._tree._getNextTreeItem(false);
			if (ti) {
				ti._tree.setSelection(ti, false, true);
			}
			break;
		}

		case DwtKeyMap.SELECT_FIRST:
		case DwtKeyMap.SELECT_LAST: {
			var ti = (actionCode === DwtKeyMap.SELECT_FIRST) ?
				this._tree._getFirstTreeItem() : this._tree._getLastTreeItem();
			if (ti) {
				ti._tree.setSelection(ti, false, true);
			}
			break;
		}

		case DwtKeyMap.EXPAND: {
			if (!this._expanded) {
				this.setExpanded(true, false, true);
			} else if (this._children.size() > 0) {
				// Select first child node
				var firstChild = this._children.get(0);
				this._tree.setSelection(firstChild, false, true);
			}
			break;
		}

		case DwtKeyMap.COLLAPSE: {
			if (this._expanded) {
				this.setExpanded(false, false, true);
			} else if (this.parent.isDwtTreeItem) {
				// select parent
				this._tree.setSelection(this.parent, false, true);
			}
			break;
		}

		case DwtKeyMap.SUBMENU: {
			var target = this.getHtmlElement();
			var p = Dwt.toWindow(target, 0, 0);
			var s = this.getSize();
			var docX = p.x + s.x / 4;
			var docY = p.y + s.y / 2;
			this._gotMouseDownRight = true;
			this._emulateSingleClick({dwtObj:this, target:target, button:DwtMouseEvent.RIGHT,
									  docX:docX, docY:docY, kbNavEvent:true});
			break;
		}

		default:
			return false;

	}

	return true;
};

DwtTreeItem.prototype.addNodeIconListeners =
function() {
	var imgEl = AjxImg.getImageElement(this._nodeCell);
	if (imgEl) {
		Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
		Dwt.setHandler(imgEl, DwtEvent.ONMOUSEUP, DwtTreeItem._nodeIconMouseUpHdlr);
	}
};

DwtTreeItem.prototype._initialize =
function(index, realizeDeferred, forceNode) {
	this._checkState();
	if (AjxEnv.isIE) {
		this._setEventHdlrs([DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE]);
	}
	if (AjxEnv.isSafari) {	// bug fix #25016
		this._setEventHdlrs([DwtEvent.ONCONTEXTMENU]);
	}
	var data = {
		id: this._htmlElId,
		divClassName: this._origClassName,
		isCheckedStyle: this._tree.isCheckedStyle,
		textClassName: this._textClassName
	};

	this._createHtmlFromTemplate(this.TEMPLATE, data);

	// add this object's HTML element to the DOM
	this.parent._addItem(this, index, realizeDeferred);

	// cache DOM objects here
	this._itemDiv = document.getElementById(data.id + "_div");
	this._nodeCell = document.getElementById(data.id + "_nodeCell");
	this._checkBoxCell = document.getElementById(data.id + "_checkboxCell");
	this._checkBox = document.getElementById(data.id + "_checkbox");
	this._checkedImg = document.getElementById(data.id + "_checkboxImg");
	this._imageCell = document.getElementById(data.id + "_imageCell");
	this._textCell = document.getElementById(data.id + "_textCell");
	this._extraCell = document.getElementById(data.id + "_extraCell");

	/* assign the ARIA level */
	this.setAttribute("aria-level", this.getNestingLevel());

	/* add a label for screenreaders, so that they don't read the entire
	   element */
	if (this._textCell) {
		this.setAttribute("aria-labelledby", this._textCell.id);
	}

	if (this._dynamicWidth){
		var tableNode = document.getElementById(data.id + "_table");
		if (tableNode) {
			tableNode.style.tableLayout = "auto";
		}
	}

	this._expandable = false;
	this.removeAttribute('aria-expanded');

	// If we have deferred children, then make sure we set up accordingly
	if (this._nodeCell) {
		this._nodeCell.style.minWidth = this._nodeCell.style.width = this._nodeCell.style.height = DwtTreeItem._NODECELL_DIM;
		if (this._children.size() > 0 || forceNode) {
			this._expandable = true;
			AjxImg.setImage(this._nodeCell, this._collapseNodeImage);
			this.addNodeIconListeners();
		}
	}

	if (this._extraCell) {
		AjxImg.setImage(this._extraCell, (this._extraInfo ||  "Blank_16"));
		this._extraCell.className = this._treeItemExtraImgClass;
	}

	// initialize checkbox
	if (this._tree.isCheckedStyle && this._checkBox) {
		this._checkBox.onclick = AjxCallback.simpleClosure(this._handleCheckboxOnclick, this);
		this.showCheckBox(this._checkBoxVisible);
		this.setChecked(this._tree.isCheckedByDefault, true);
	}

	// initialize icon
	if (this._imageCell && this._imageInfoParam) {
		AjxImg.setImage(this._imageCell, this._imageInfoParam);
		this._imageInfo = this._imageInfoParam;
	}

	// initialize text
	if (this._textCell && this._textParam) {
		this._textCell.innerHTML = this._text = this._textParam;
	}
	this._expanded = this._selected = this._actioned = false;
	this._gotMouseDownLeft = this._gotMouseDownRight = false;
	this._addMouseListeners();

	this._initialized = true;
};

/**
 * Sets the tree item color.
 * 
 * @param	{string}	className		the class name
 */
DwtTreeItem.prototype.setTreeItemColor = 
function(className) {
	var id = this._htmlElId +"_table";
	var treeItemTableEl = document.getElementById(id);
	var treeItemDivEl = document.getElementById(this._htmlElId + "_div");
	var treeItemEl = this.getHtmlElement();

	var newClassName = this._origClassName + " " + className;
	if (treeItemDivEl) {
		treeItemDivEl.className = newClassName;
	} else if (treeItemEl) {
		treeItemEl.className =  className;
	}
};

DwtTreeItem.prototype._addMouseListeners =
function() {
	var events = [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONDBLCLICK];
	if (AjxEnv.isIE) {
		events.push(DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE);
	} else {
		events.push(DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT);
	}
	if (AjxEnv.isSafari) {
		events.push(DwtEvent.ONCONTEXTMENU);
	}
	for (var i = 0; i < events.length; i++) {
		this.addListener(events[i], DwtTreeItem._listeners[events[i]]);
	}
};

DwtTreeItem.prototype._addDeferredChild =
function(child, index) {
	// If we are initialized, then we need to add a expansion node
	if (this._initialized && this._children.size() == 0) {
		if (this._nodeCell) {
			AjxImg.setImage(this._nodeCell, this._collapseNodeImage);
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl) {
				this._expandable = true;
				this.setAttribute('aria-expanded', this._expanded);
				Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
				Dwt.setHandler(imgEl, DwtEvent.ONMOUSEUP, DwtTreeItem._nodeIconMouseUpHdlr);
			}
		}
	}
	this._children.add(child, index);
};

DwtTreeItem.prototype.addChild =
function(child) { /* do nothing since we add to the DOM our own way */ };

DwtTreeItem.prototype._addItem =
function(item, index, realizeDeferred) {
	if (!this._children.contains(item)) {
		this._children.add(item, index);
	}
	this._expandable = true;

	if (this._childDiv == null) {
		this._childDiv = document.createElement("div");
		this._childDiv.className = (this.parent != this._tree)
			? "DwtTreeItemChildDiv" : "DwtTreeItemLevel1ChildDiv";
		this._childDiv.setAttribute('role', 'group');
		this._childDiv.setAttribute('aria-labelledby', this._itemDiv.id);
		this._childDiv.setAttribute('aria-expanded', this._expanded);
		this.getHtmlElement().appendChild(this._childDiv);
		if (!this._expanded) {
			this._childDiv.style.display = "none";
		}
	}

	if (realizeDeferred && this._nodeCell) {
		if (AjxImg.getImageClass(this._nodeCell) == AjxImg.getClassForImage("Blank_16")) {
			AjxImg.setImage(this._nodeCell, this._expanded ? this._expandNodeImage : this._collapseNodeImage);
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl) {
				Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
			}
		}
	}

	var childDiv = this._childDiv;
	var numChildren = childDiv.childNodes.length;
	if (index == null || index >= numChildren || numChildren == 0) {
		childDiv.appendChild(item.getHtmlElement());
	} else {
		childDiv.insertBefore(item.getHtmlElement(), childDiv.childNodes[index]);
	}
};

DwtTreeItem.prototype.sort =
function(cmp) {
	this._children.sort(cmp);
	if (this._childDiv) {
		this._setChildElOrder();
	} else {
		this._needsSort = true;
	}
};

DwtTreeItem.prototype._setChildElOrder =
function(cmp) {
	var df = document.createDocumentFragment();
	this._children.foreach(function(item, i) {
		df.appendChild(item.getHtmlElement());
		item._index = i;
	});
	this._childDiv.appendChild(df);
};

DwtTreeItem.prototype._getDragProxy =
function() {
	var icon = document.createElement("div");
	Dwt.setPosition(icon, Dwt.ABSOLUTE_STYLE); 
	var table = document.createElement("table");
	icon.appendChild(table);
	table.cellSpacing = table.cellPadding = 0;

	var row = table.insertRow(0);
	var i = 0;

	var c = row.insertCell(i++);
	c.noWrap = true;
	if (this._dndImageInfo) {
		AjxImg.setImage(c, this._dndImageInfo);
	} else if (this._imageInfo) {
		AjxImg.setImage(c, this._imageInfo);
	}

	c = row.insertCell(i);
	c.noWrap = true;
	c.className = this._origClassName;
	if (this._dndText) {
		c.innerHTML = this._dndText;
	} else if (this._text) {
		c.innerHTML = this._text;
	}

	this.shell.getHtmlElement().appendChild(icon);
	Dwt.setZIndex(icon, Dwt.Z_DND);
	return icon;
};

DwtTreeItem.prototype._dragEnter =
function() {
	this._preDragClassName = this._textCell.className;
	this._textCell.className = this._dragOverClassName;
	this._draghovering = true;
};

DwtTreeItem.prototype._dragHover =
function() {
	if (this.getNumChildren() > 0 && !this.getExpanded()) {
		this.setExpanded(true);
	}
};

DwtTreeItem.prototype._dragLeave =
function(ev) {
	if (this._preDragClassName) {
		this._textCell.className = this._preDragClassName;
	}
	this._draghovering = false;
};

DwtTreeItem.prototype._drop =
function() {
	if (this._preDragClassName) {
		this._textCell.className = this._preDragClassName;
	}
	this._draghovering = false;
};

/**
 *   This is for bug 45129.
 *   In the DwControl's focusByMouseDownEvent, it focuses the TreeItem 
 *   And change TreeItem's color. But sometimes when mousedown and mouseup
 *   haven't been matched on the one element. It will cause multiple selection. 
 *   For in the mouseup handle function, we has done focus if we find both mouse 
 *   down and up happened on the same element. So when the mouse is down, we just
 *   do nothing.
 */
DwtTreeItem.prototype._focusByMouseDownEvent =
function(ev) {
	
}

DwtTreeItem._nodeIconMouseDownHdlr =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, obj);
	if (mouseEv.button == DwtMouseEvent.LEFT) {
		obj._expand(!obj._expanded, mouseEv);
	} else if (mouseEv.button == DwtMouseEvent.RIGHT) {
		mouseEv.dwtObj._tree._itemActioned(mouseEv.dwtObj, mouseEv);
	}

	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

DwtTreeItem._nodeIconMouseUpHdlr = 
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

DwtTreeItem.prototype._expand =
function(expand, ev, skipNotify) {
	if (expand !== this._expanded) {
		if (!expand) {
			this._expanded = false;
			this._childDiv.style.display = "none";
			if (this._nodeCell) {
				AjxImg.setImage(this._nodeCell, this._collapseNodeImage);
			}
			this._tree._itemCollapsed(this, ev, skipNotify);
		} else {
			// The first thing we need to do is initialize any deferred children so that they
			// actually have content
			this._realizeDeferredChildren();
			this._expanded = true;
			if(this._childDiv && this._childDiv.style)
				this._childDiv.style.display = "block";
			if (this._nodeCell) {
				AjxImg.setImage(this._nodeCell, this._expandNodeImage);
			}
			this._tree._itemExpanded(this, ev, skipNotify);
		}	

		this.setAttribute('aria-expanded', expand);
		this._childDiv.setAttribute('aria-expanded', expand);
		this._childDiv.setAttribute('aria-hidden', !expand);
	}
};

DwtTreeItem.prototype._realizeDeferredChildren =
function() {
	var a = this._children.getArray();
	for (var i = 0; i < a.length; i++) {
		var treeItem = a[i];
		if (!treeItem._initialized) {
			treeItem._initialize(treeItem._index, true);
		} else if (treeItem._isSeparator && !treeItem.div && this._childDiv) {
			// Note: separators marked as initialized on construction
			var div = treeItem.div = document.createElement("div");
			div.className = "vSpace";
			this._childDiv.appendChild(div);
			treeItem._initialized = true;
		}
	}
	if (this._needsSort) {
		if (a.length) {
			this._setChildElOrder();
		}
		delete this.__needsSort;
	}
};

DwtTreeItem.prototype._isChildOf =
function(item) {
	var test = this.parent;
	while (test && test != this._tree) {
		if (test == item)
			return true;
		test = test.parent;
	}
	return false;
};

DwtTreeItem.prototype._setTreeElementStyles =
function(img, focused) {
   if (this._arrowDisabled || this._draghovering) {
        return;
   }
   var selected = focused ? "-focused" : "";
   if (this._extraCell) {
        AjxImg.setImage(this._extraCell, img);
        this._extraCell.className = this._treeItemExtraImgClass + selected;
   }
   if (this._textCell)
        this._textCell.className = this._treeItemTextClass + selected;
}

DwtTreeItem.prototype._setSelected =
function(selected, noFocus) {
	if (this._selected != selected && !this._disposed) {
		this._selected = selected;
		if (!this._initialized) {
			this._initialize();
		}
		if (!this._itemDiv) { return; }

		var didSelect;

		if (selected && (this._selectionEnabled || this._forceNotifySelection) /*&& this._origClassName == "DwtTreeItem"*/) {
			this._itemDiv.className = this._selectedClassName;
			this._setTreeElementStyles("DownArrowSmall", true);
			this._tree.setAttribute('aria-activedescendant', this.getHTMLElId());
            if (!noFocus) {
				this.focus();
			}
			didSelect = true;
		} else {
			this.blur();
			this._setTreeElementStyles("Blank_16", false);
			this._itemDiv.className = this._origClassName;;
			this._tree.removeAttribute('aria-activedescendant');
			didSelect = false;
		}

		this.getHtmlElement().setAttribute('aria-selected', selected);
		/* TODO: disable on IE? screenreaders in IE may announce items twice if
		 * we do the below, which is not strictly necessary */
		var treeEl = this._tree.getHtmlElement();

		if (selected) {
			treeEl.setAttribute('aria-activedescendant', this.getHTMLElId());
		} else {
			treeEl.removeAttribute('aria-activedescendant');
		}

		return didSelect;
	}
};

DwtTreeItem.prototype._setActioned =
function(actioned) {
	if (this._actioned != actioned) {
		this._actioned = actioned;
		if (!this._initialized) {
			this._initialize();
		}

		if (!this._itemDiv) { return; }

		if (actioned && (this._actionEnabled || this._forceNotifyAction) && !this._selected) {
			this._itemDiv.className = this._actionedClassName;
			return true;
		}

		if (!actioned) {
			if (!this._selected) {
				this._itemDiv.className = this._origClassName;
			}
			return false;
		}
	}
};

DwtTreeItem.prototype._focus =
function() {
	if (!this._itemDiv) { return; }
	// focused tree item should always be selected as well
	this._itemDiv.className = this._selectedFocusedClassName;
	this._setTreeElementStyles("DownArrowSmall", true);
};

DwtTreeItem.prototype._blur =
function() {
	if (!this._itemDiv) { return; }
	this._itemDiv.className = this._selected
		? this._selectedClassName : this._origClassName;
	this._setTreeElementStyles(this._selected ? "DownArrowSmall" : "Blank_16", this._selected);
};

DwtTreeItem._mouseDownListener =
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	if (ev.target == treeItem._childDiv) { return; }

	if (ev.button == DwtMouseEvent.LEFT && (treeItem._selectionEnabled || treeItem._forceNotifySelection)) {
		treeItem._gotMouseDownLeft = true;
	} else if (ev.button == DwtMouseEvent.RIGHT && (treeItem._actionEnabled || treeItem._forceNotifyAction)) {
		treeItem._gotMouseDownRight = true;
	}

};

DwtTreeItem._mouseOutListener = 
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	if (ev.target == treeItem._childDiv) { return; }

	treeItem._gotMouseDownLeft = false;
	treeItem._gotMouseDownRight = false;
	if (treeItem._singleClickAction && treeItem._textCell) {
		treeItem._textCell.className = treeItem._textClassName;
	}
    if(!treeItem._selected){
       treeItem._setTreeElementStyles("Blank_16", false);
    }

};

DwtTreeItem._mouseOverListener =
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	if (ev.target == treeItem._childDiv) { return; }

	if (treeItem._singleClickAction && treeItem._textCell) {
		treeItem._textCell.className = treeItem._hoverClassName;
	}
    if(!treeItem._selected){
       treeItem._setTreeElementStyles("ColumnDownArrow", true);
    }
};

DwtTreeItem._mouseUpListener = function(ev) {

	var treeItem = ev.dwtObj;
	if (!treeItem) {
        return false;
    }

	// Ignore any mouse events in the child div i.e. the div which 
	// holds all the items children. In the case of IE, no clicks are
	// reported when clicking in the padding area (note all children
	// are indented using padding-left style); however, mozilla
	// reports mouse events that happen in the padding area
	if (ev.target === treeItem._childDiv) {
        return;
    }

	//ignore the collapse/expand arrow. This is handled in DwtTreeItem._nodeIconMouseDownHdlr. It should only collapse/expand and never select this item, so no point in going on.
	if (treeItem._expandable && ev.target === AjxImg.getImageElement(treeItem._nodeCell)) {
		return;
	}

    var targetElement = DwtUiEvent.getTargetWithProp(ev, "id"),
        isContextCmd = (treeItem._extraCell && targetElement && treeItem._extraCell.id === targetElement.id);

    if ((ev.button === DwtMouseEvent.RIGHT && treeItem._gotMouseDownRight) || isContextCmd) {
        treeItem._tree._itemActioned(treeItem, ev);
    }
    else if (ev.button === DwtMouseEvent.LEFT && treeItem._gotMouseDownLeft) {
		treeItem._tree._itemClicked(treeItem, ev);
	}
};

DwtTreeItem._doubleClickListener =
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	// See comment in DwtTreeItem.prototype._mouseDownListener
	if (ev.target == treeItem._childDiv) { return; }

	var obj = DwtControl.getTargetControl(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, obj);
	if (mouseEv.button == DwtMouseEvent.LEFT || mouseEv.button == DwtMouseEvent.NONE) {	// NONE for IE bug
		mouseEv.dwtObj._tree._itemDblClicked(mouseEv.dwtObj, mouseEv);
	}
};

DwtTreeItem._contextListener =
function(ev) {
	// for Safari, we have to fake a right click
	if (AjxEnv.isSafari) {
		var obj = DwtControl.getTargetControl(ev);
		var prevent = obj ? obj.preventContextMenu() : true;
		if (prevent) {
			obj.notifyListeners(DwtEvent.ONMOUSEDOWN, ev);
			return obj.notifyListeners(DwtEvent.ONMOUSEUP, ev);
		}
	}
};

DwtTreeItem.prototype._emulateSingleClick =
function(params) {
	var mev = new DwtMouseEvent();
	this._setMouseEvent(mev, params);
	mev.kbNavEvent = params.kbNavEvent;
	this.notifyListeners(DwtEvent.ONMOUSEUP, mev);
};

DwtTreeItem.prototype.getTooltipBase =
function(hoverEv) {
	return this._itemDiv;
};

DwtTreeItem._listeners = {};
DwtTreeItem._listeners[DwtEvent.ONMOUSEDOWN] = new AjxListener(null, DwtTreeItem._mouseDownListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEOUT] = new AjxListener(null, DwtTreeItem._mouseOutListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSELEAVE] = new AjxListener(null, DwtTreeItem._mouseOutListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEENTER] = new AjxListener(null, DwtTreeItem._mouseOverListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEOVER] = new AjxListener(null, DwtTreeItem._mouseOverListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEUP] = new AjxListener(null, DwtTreeItem._mouseUpListener);
DwtTreeItem._listeners[DwtEvent.ONDBLCLICK] = new AjxListener(null, DwtTreeItem._doubleClickListener);
DwtTreeItem._listeners[DwtEvent.ONCONTEXTMENU] = new AjxListener(null, DwtTreeItem._contextListener);


/**
 * Minimal class for a separator (some vertical space) between other tree items.
 * The functions it has are to handle a dispose() call when the containing tree
 * is disposed.
 * 
 * TODO: At some point we should just make this a DwtControl, or find some other
 * 		 way of keeping it minimal.
 * 
 * 
 * @private
 */
DwtTreeItemSeparator = function(parent) {
	this.parent = parent;
	this._isSeparator = true;
	this._initialized = true;
};

DwtTreeItemSeparator.prototype.dispose =
function() {
	DwtComposite.prototype.removeChild.call(this.parent, this);
};

DwtTreeItemSeparator.prototype.isInitialized =
function() {
	return this._initialized;
};

DwtTreeItemSeparator.prototype.getHtmlElement =
function() {
	return this.div;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtHeaderTreeItem")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates a Header Tree Item.
 * @constructor
 * @class
 * This class implements a tree item widget.
 *
 * @author Dave Comfort
 *
 * @param {hash}	params				a hash of parameters
 * @param {DwtComposite}      params.parent				the parent widget
 * @param {number}      params.index 				the index at which to add this control among parent's children
 * @param {string}      params.text 					the label text for the tree item
 * @param {string}      params.imageInfo				the icon for the tree item
 * @param {boolean}      params.deferred				if <code>true</code>, postpone initialization until needed.
 * @param {string}      params.className				the CSS class
 * @param  {constant}	params.posStyle				the positioning style
 * @param {boolean}      params.forceNotifySelection	force notify selection even if checked style
 * @param {boolean}      params.forceNotifyAction		force notify action even if checked style
 * @param {hash}		  params.optButton				a hash of data for showing a options button in the item: image, tooltip, callback
 * @param {boolean}      params.selectable			if <code>true</code>, this item is selectable
 *        
 * @extend		DwtTreeItem
 */
DwtHeaderTreeItem = function(params) {
	this.overview = params.overview;
	this._optButton = params.optButton;
	this._noNodeCell = params.noNodeCell;
	DwtTreeItem.call(this, params);
	this._arrowDisabled = true; //override what DwTreeItem constructor sets.
};

DwtHeaderTreeItem.prototype = new DwtTreeItem;
DwtHeaderTreeItem.prototype.constructor = DwtHeaderTreeItem;

DwtHeaderTreeItem.prototype.TEMPLATE = "dwt.Widgets#ZHeaderTreeItem";

DwtHeaderTreeItem.prototype.toString =
function() {
	return "DwtHeaderTreeItem";
};

DwtHeaderTreeItem.prototype._createHtmlFromTemplate =
function(template, data) {
	data.noNodeCell = this._noNodeCell;
	DwtTreeItem.prototype._createHtmlFromTemplate.apply(this, arguments);
};

DwtHeaderTreeItem.prototype._initialize =
function() {
	DwtTreeItem.prototype._initialize.apply(this, arguments);

	// We must label the tree root, otherwise IE will let screen readers read
	// THE ENTIRE TREE when it gets focus
	var treeEl = this._tree.getHtmlElement();
	treeEl.setAttribute("aria-labelledby", this._textCell.id);

	if (this._optButton) {
		this._optButtonId = this._htmlElId + "_optButton";
		var optButtonEl = document.getElementById(this._optButtonId);
		if (optButtonEl) {
			this._optButtonItem = new DwtBorderlessButton({parent:this, style:DwtLabel.IMAGE_LEFT});
			this._optButtonItem.setToolTipContent(this._optButton.tooltip);
			this._optButtonItem.callback = this._optButton.callback;
			this._optButtonItem.addSelectionListener(new AjxListener(this, this._onclickHandler));
			this._optButtonItem.replaceElement(this._optButtonId);
			this._optButtonItem.setImage("ContextMenu");
			this._optButtonItem.setIconEl(this._optButtonItem.getHtmlElement()); // image container is button
		}
	}
};

DwtHeaderTreeItem.prototype._onclickHandler =
function(ev) {
    this._tree._itemActioned(this, ev);
};


DwtHeaderTreeItem.prototype._focusByMouseUpEvent =
function(ev)  {
	var targetId = ev.target && ev.target.id;
	if (targetId && (targetId == this._headerButtonId)) { return; }
	DwtTreeItem.prototype._focusByMouseUpEvent.apply(this, arguments);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtTree")) {
    /*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates a Tree widget.
 * @constructor
 * @class
 * This class implements a tree widget. Tree widgets may contain one or more DwtTreeItems.
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params				a hash of parameters
 * @param  {DwtComposite}     params.parent			the parent widget
 * @param  {DwtTree.SINGLE_STYLE|DwtTree.MULTI_STYLE|DwtTree.CHECKEDITEM_STYLE}     params.style 	the tree style
 * @param  {string}     params.className				the CSS class
 * @param  {constant}     params.posStyle				the positioning style (see {@link DwtControl})
 * @param  {boolean}     params.isCheckedByDefault	default checked state if tree styles is "checked"
 * 
 * @extends		DwtComposite
 */
DwtTree = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtTree.PARAMS);
	params.className = params.className || "DwtTree";
	DwtComposite.call(this, params);

	var events = [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONDBLCLICK];
	if (!AjxEnv.isIE) {
		events = events.concat([DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT]);
	}
	this._setEventHdlrs(events);

	var style = params.style;
	if (!style) {
		this._style = DwtTree.SINGLE_STYLE;
	} else {
		if (style == DwtTree.CHECKEDITEM_STYLE) {
			style |= DwtTree.SINGLE_STYLE;
		}
		this._style = style;
	}
	this.isCheckedStyle = ((this._style & DwtTree.CHECKEDITEM_STYLE) != 0);
	this.isCheckedByDefault = params.isCheckedByDefault;

	this._selectedItems = new AjxVector();
	this._selEv = new DwtSelectionEvent(true);
	this._selByClickEv = new DwtSelectionEvent(true);
	this._selByClickEv.clicked = true;
	this._selByEnterEv = new DwtSelectionEvent(true);
	this._selByEnterEv.enter = true;

    // Let tree be a single tab stop, then manage focus among items using arrow keys
    this.tabGroupMember = this;
};

DwtTree.PARAMS = ["parent", "style", "className", "posStyle"];

DwtTree.prototype = new DwtComposite;
DwtTree.prototype.constructor = DwtTree;
DwtTree.prototype.role = "tree";

DwtTree.prototype.toString = 
function() {
	return "DwtTree";
};

/**
 * Defines the "single" style.
 */
DwtTree.SINGLE_STYLE = 1;
/**
 * Defines the "multi" style.
 */
DwtTree.MULTI_STYLE = 2;
/**
 * Defines the "checked-item" style.
 */
DwtTree.CHECKEDITEM_STYLE = 4;

DwtTree.ITEM_SELECTED = 0;
DwtTree.ITEM_DESELECTED = 1;
DwtTree.ITEM_CHECKED = 2;
DwtTree.ITEM_ACTIONED = 3;
DwtTree.ITEM_DBL_CLICKED = 4;

DwtTree.ITEM_EXPANDED = 1;
DwtTree.ITEM_COLLAPSED = 2;

/**
 * Gets the style.
 * 
 * @return	{constant}	the style
 */
DwtTree.prototype.getStyle =
function() {
	return this._style;
};

/**
 * Get the nesting level; this is zero for trees.
 *
 * @return	{number}	the child item count
 */
DwtTree.prototype.getNestingLevel =
function() {
	return 0;
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.removeSelectionListener = 
function(listener) {
	this.removeListener(DwtEvent.SELECTION, listener);    	
};

/**
 * Adds a tree listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.addTreeListener = 
function(listener) {
	this.addListener(DwtEvent.TREE, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.removeTreeListener = 
function(listener) {
	this.removeListener(DwtEvent.TREE, listener);
};

/**
 * Gets the tree item count.
 * 
 * @return	{number}	the item count
 */
DwtTree.prototype.getItemCount =
function() {
	return this.getItems().length;
};

/**
 * Gets the items.
 * 
 * @return	{array}	an array of {@link DwtTreeItem} objects
 */
DwtTree.prototype.getItems =
function() {
	return this._children.getArray();
};

/** Clears the tree items. */
DwtTree.prototype.clearItems = function() {
    var items = this.getItems();
    for (var i = 0; i < items.length; i++) {
        this.removeChild(items[i]);
    }
    this._getContainerElement().innerHTML = "";
};


/**
 * De-selects all items.
 * 
 */
DwtTree.prototype.deselectAll =
function() {
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	for (var i = 0; i < sz; i++) {
		if (a[i]) {
			a[i]._setSelected(false);
		}
	}
	if (sz > 0) {
		this._notifyListeners(DwtEvent.SELECTION, this._selectedItems.getArray(), DwtTree.ITEM_DESELECTED, null, this._selEv);
	}
	this._selectedItems.removeAll();
};

/**
 * Gets an array of selection items.
 * 
 * @return	{array}	an array of {@link DwtTreeItem} objects
 */
DwtTree.prototype.getSelection =
function() {
	return this._selectedItems.getArray();
};

DwtTree.prototype.setEnterSelection =
function(treeItem, kbNavEvent) {
	if (!treeItem) {
		return;
	}
	this._notifyListeners(DwtEvent.SELECTION, [treeItem], DwtTree.ITEM_SELECTED, null, this._selByEnterEv, kbNavEvent);
};


DwtTree.prototype.setSelection =
function(treeItem, skipNotify, kbNavEvent, noFocus) {
	if (!treeItem || !treeItem.isSelectionEnabled()) {
		return;
	}

	// Remove currently selected items from the selection list. if <treeItem> is in that list, then note it and return
	// after we are done processing the selected list
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	var da;
	var j = 0;
	var alreadySelected = false;
	for (var i = 0; i < sz; i++) {
		if (a[i] == treeItem) {
			alreadySelected = true;
		} else {
			a[i]._setSelected(false);
			this._selectedItems.remove(a[i]);
			if (da == null) {
				da = new Array();
			}
			da[j++] = a[i];
		}
	}

	if (da && !skipNotify) {
		this._notifyListeners(DwtEvent.SELECTION, da, DwtTree.ITEM_DESELECTED, null, this._selEv, kbNavEvent);
	}

	if (alreadySelected) { return; }
	this._selectedItems.add(treeItem);

	// Expand all parent nodes, and then set item selected
	this._expandUp(treeItem);
	if (treeItem._setSelected(true, noFocus) && !skipNotify) {
		this._notifyListeners(DwtEvent.SELECTION, [treeItem], DwtTree.ITEM_SELECTED, null, this._selEv, kbNavEvent);
	}
};

DwtTree.prototype.getSelectionCount =
function() {
	return this._selectedItems.size();
};

DwtTree.prototype.addChild = function(child) {

    // HACK: Tree items are added via _addItem. But we need to keep
    // HACK: the original addChild behavior for other controls that
    // HACK: may be added to the tree view.
    if (child.isDwtTreeItem) {
        return;
    }

    DwtComposite.prototype.addChild.apply(this, arguments);
};

/**
 * Adds a separator.
 * 
 */
DwtTree.prototype.addSeparator =
function() {
	var sep = document.createElement("div");
	sep.className = "vSpace";
	this._getContainerElement().appendChild(sep);
};

// Expand parent chain from given item up to root
DwtTree.prototype._expandUp =
function(item) {
	var parent = item.parent;
	while (parent instanceof DwtTreeItem) {
		parent.setExpanded(true);
		parent.setVisible(true);
		parent = parent.parent;
	}
};

DwtTree.prototype._addItem = function(item, index) {

	this._children.add(item, index);
	var thisHtmlElement = this._getContainerElement();
	var numChildren = thisHtmlElement.childNodes.length;
	if (index == null || index > numChildren) {
		thisHtmlElement.appendChild(item.getHtmlElement());
	} else {
		//IE Considers undefined as an illegal value for second argument in the insertBefore method
		thisHtmlElement.insertBefore(item.getHtmlElement(), thisHtmlElement.childNodes[index] || null);
	}
};

DwtTree.prototype._getContainerElement = DwtTree.prototype.getHtmlElement;

DwtTree.prototype.sort =
function(cmp) {
    var children = this.getItems();
    children.sort(cmp);
    var fragment = document.createDocumentFragment();
    AjxUtil.foreach(children, function(item, i){
        fragment.appendChild(item.getHtmlElement());
        item._index = i;
    });
    this._getContainerElement().appendChild(fragment);
};

DwtTree.prototype.removeChild =
function(child) {
	this._children.remove(child);
	this._selectedItems.remove(child);
    var childEl = child.getHtmlElement();
    if (childEl.parentNode) {
        childEl.parentNode.removeChild(childEl);
    }
};

/**
 * Returns the next (or previous) tree item relative to the currently selected
 * item, in top-to-bottom order as the tree appears visually. Items such as
 * separators that cannot be selected are skipped.
 * </p><p>
 * If there is no currently selected item, return the first or last item. If we go past
 * the beginning or end of the tree, return null.
 * </p><p>
 * For efficiency, a flattened list of the visible and selectable tree items is maintained.
 * It will be cleared on any change to the tree's display, then regenerated when it is
 * needed.
 *
 * @param {boolean}	next		if <code>true</code>, return next tree item; otherwise, return previous tree item
 * 
 * @private
 */
DwtTree.prototype._getNextTreeItem =
function(next) {

	var sel = this.getSelection();
	var curItem = (sel && sel.length) ? sel[0] : null;

	var nextItem = null, idx = -1;
	var list = this.getTreeItemList(true);
	if (curItem) {
		for (var i = 0, len = list.length; i < len; i++) {
			var ti = list[i];
			if (ti == curItem) {
				idx = next ? i + 1 : i - 1;
				break;
			}
		}
		nextItem = list[idx]; // if array index out of bounds, nextItem is undefined
	} else {
		// if nothing is selected yet, return the first or last item
		if (list && list.length) {
			nextItem = next ? list[0] : list[list.length - 1];
		}
	}
	return nextItem;
};

DwtTree.prototype._getFirstTreeItem =
function() {
	var a = this.getTreeItemList(true);
	if (a && a.length > 0) {
		return a[0];
	}
	return null;
};

DwtTree.prototype._getLastTreeItem =
function() {
	var a = this.getTreeItemList(true);
	if (a && a.length > 0) {
		return a[a.length - 1];
	}
	return null;
};

/**
 * Creates a flat list of this tree's items, going depth-first.
 *
 * @param {boolean}	visible		if <code>true</code>, only include visible/selectable items
 * @return	{array}	an array of {@link DwtTreeItem} objects
 */
DwtTree.prototype.getTreeItemList =
function(visible) {
	return this._addToList([], visible);
};

DwtTree.prototype._addToList =
function(list, visible, treeItem) {
	if (treeItem && !treeItem._isSeparator &&
		(!visible || (treeItem.getVisible() && treeItem._selectionEnabled))) {

		list.push(treeItem);
	}
	if (!treeItem || !visible || treeItem._expanded) {
		var parent = treeItem || this;
		var children = parent.getChildren ? parent.getChildren() : [];
		for (var i = 0; i < children.length; i++) {
			this._addToList(list, visible, children[i]);
		}
	}
	return list;
};

DwtTree.prototype._deselect =
function(item) {
	if (this._selectedItems.contains(item)) {
		this._selectedItems.remove(item);
		item._setSelected(false);
		this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DESELECTED, null, this._selEv);
	}
};

DwtTree.prototype._itemActioned =
function(item, ev) {
	if (this._actionedItem && !this._actionedItem.isDisposed()) {
		this._actionedItem._setActioned(false);
		this._notifyListeners(DwtEvent.SELECTION, [this._actionedItem], DwtTree.ITEM_DESELECTED, ev, this._selEv);
	}
	this._actionedItem = item;
	item._setActioned(true);
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_ACTIONED, ev, this._selEv);
};

DwtTree.prototype._itemChecked =
function(item, ev) {
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_CHECKED, ev, this._selEv);
};

DwtTree.prototype._itemClicked =
function(item, ev) {
	var i;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();
	if (this._style & DwtTree.SINGLE_STYLE || (!ev.shiftKey && !ev.ctrlKey)) {
		if (numSelectedItems > 0) {
			for (i = 0; i < numSelectedItems; i++) {
				a[i]._setSelected(false);
			}
			// Notify listeners of deselection
			this._notifyListeners(DwtEvent.SELECTION, this._selectedItems.getArray(), DwtTree.ITEM_DESELECTED, ev, this._selByClickEv);
			this._selectedItems.removeAll();
		}
		this._selectedItems.add(item);
		if (item._setSelected(true)) {
			this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selByClickEv);
		}
	} else {
		if (ev.ctrlKey) {
			if (this._selectedItems.contains(item)) {
				this._selectedItems.remove(item);
				item._setSelected(false);
				this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DESELECTED, ev, this._selByClickEv);
			} else {
				this._selectedItems.add(item);
				if (item._setSelected(true)) {
					this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selByClickEv);
				}
			}
		} else {
			// SHIFT KEY
		}
	}
};

DwtTree.prototype._itemDblClicked = 
function(item, ev) {
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DBL_CLICKED, ev, this._selEv);
};

DwtTree.prototype._itemExpanded =
function(item, ev, skipNotify) {
	if (!skipNotify) {
		this._notifyListeners(DwtEvent.TREE, [item], DwtTree.ITEM_EXPANDED, ev, DwtShell.treeEvent);
	}
};

DwtTree.prototype._itemCollapsed =
function(item, ev, skipNotify) {
	var i;
	if (!skipNotify) {
		this._notifyListeners(DwtEvent.TREE, [item], DwtTree.ITEM_COLLAPSED, ev, DwtShell.treeEvent);
	}
	var setSelection = false;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();
	var da;
	var j = 0;
	for (i = 0; i < numSelectedItems; i++) {
		if (a[i]._isChildOf(item)) {
			setSelection = true;
			if (da == null) {
				da = new Array();
			}
			da[j++] = a[i];
			a[i]._setSelected(false);
			this._selectedItems.remove(a[i]);
		}		
	}

	if (da) {
		this._notifyListeners(DwtEvent.SELECTION, da, DwtTree.ITEM_DESELECTED, ev, this._selEv);
	}

	if (setSelection && !this._selectedItems.contains(item)) {
		if (item._setSelected(true)) {
			this._selectedItems.add(item);
			this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selEv);
		}
	}
};

DwtTree.prototype._notifyListeners =
function(listener, items, detail, srcEv, destEv, kbNavEvent) {
	if (this.isListenerRegistered(listener)) {
		if (srcEv) {
			DwtUiEvent.copy(destEv, srcEv);
		}
		destEv.items = items;
		if (items.length == 1) {
			destEv.item = items[0];
		}
		destEv.detail = detail;
		destEv.kbNavEvent = kbNavEvent;
		this.notifyListeners(listener, destEv);
		if (listener == DwtEvent.SELECTION) {
			this.shell.notifyGlobalSelection(destEv);
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtCheckbox")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a checkbox.
 * @constructor
 * @class
 * This class represents a checkbox.
 * 
 * @param {hash}	params	a hash of parameters
 * @param {DwtComposite}	params.parent	the parent widget
 * @param {DwtCheckbox.TEXT_LEFT|DwtCheckbox.TEXT_RIGHT}       [params.style=DwtCheckbox.TEXT_RIGHT] 	the text style
 * @param {string}       params.name		the input control name (required for IE)
 * @param {string}       params.value     the input control value
 * @param {boolean}       params.checked	the input control checked status (required for IE)
 * @param {string}       params.className	the CSS class
 * @param {constant}       params.posStyle	the positioning style (see {@link Dwt})
 * @param {string}       params.id		an explicit ID to use for the control's HTML element
 * @param {number}       params.index 	the index at which to add this control among parent's children
 * 
 *  @extends		DwtControl
 */
DwtCheckbox = function(params) {
	if (arguments.length == 0) { return; }

	params = Dwt.getParams(arguments, DwtCheckbox.PARAMS);
	params.className = params.className || "DwtCheckbox";

	DwtControl.call(this, params);

	this._textPosition = DwtCheckbox.DEFAULT_POSITION;
	this._initName = params.name;
    this._initValue = params.value;
	this._createHtml();

	this.setSelected(params.checked);
};

DwtCheckbox.prototype = new DwtControl;
DwtCheckbox.prototype.constructor = DwtCheckbox;

DwtCheckbox.prototype.isDwtCheckbox = true;
DwtCheckbox.prototype.isInputControl = true;
DwtCheckbox.prototype.toString = function() { return "DwtCheckbox"; };

//
// Constants
//
DwtCheckbox.PARAMS = [
	"parent",
	"style",
	"name",
	"checked",
	"className",
	"posStyle",
	"id",
	"index",
    "value"
];
/**
 * Defines the "left" text style position.
 */
DwtCheckbox.TEXT_LEFT			= "left";
/**
 * Defines the "right" text style position.
 */
DwtCheckbox.TEXT_RIGHT			= "right";
/**
 * Defines the default text style position.
 */
DwtCheckbox.DEFAULT_POSITION	= DwtCheckbox.TEXT_RIGHT;

//
// Data
//
DwtCheckbox.prototype.TEMPLATE = "dwt.Widgets#DwtCheckbox";

DwtCheckbox.prototype.INPUT_TYPE = 'checkbox';

//
// Public methods
//
DwtCheckbox.prototype.getInputElement =
function() {
	return this._inputEl;
};

DwtCheckbox.prototype._focus =
function() {
	Dwt.addClass(this.getHtmlElement(), DwtControl.FOCUSED);
};

DwtCheckbox.prototype._blur =
function() {
	Dwt.delClass(this.getHtmlElement(), DwtControl.FOCUSED);
};

// listeners

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCheckbox.prototype.addSelectionListener =
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCheckbox.prototype.removeSelectionListener =
function(listener) {
	this.removeListener(DwtEvent.SELECTION, listener);
};

// properties

/**
 * Sets the enabled state.
 * 
 * @param	{boolean}	enabled		if <code>true</code>, the checkbox is enabled
 */
DwtCheckbox.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtControl.prototype.setEnabled.call(this, enabled);
		this._inputEl.disabled = !enabled;
		var className = enabled ? "Text" : "DisabledText";
		if (this._textElLeft) this._textElLeft.className = className;
		if (this._textElRight) this._textElRight.className = className;
	}
};

/**
 * Sets the selected state.
 * 
 * @param	{boolean}	selected		if <code>true</code>, the checkbox is selected
 */
DwtCheckbox.prototype.setSelected =
function(selected) {
	if (this._inputEl && this._inputEl.checked != selected) {
		this._inputEl.checked = selected;
	}
};

/**
 * Checks if the checkbox is selected state.
 * 
 * @return	{boolean}	<code>true</code> if the checkbox is selected
 */
DwtCheckbox.prototype.isSelected =
function() {
	return this._inputEl && this._inputEl.checked;
};

/**
 * Sets the checkbox text.
 * 
 * @param		{string}	text		the text
 */
DwtCheckbox.prototype.setText =
function(text) {
	if (this._textEl && this._text != text) {
		this._text = text;
		this._textEl.innerHTML = text || "";
	}
};

/**
 * Gets the checkbox text.
 * 
 * @return	{string}	the text
 */
DwtCheckbox.prototype.getText =
function() {
	return this._text;
};

/**
 * Sets the text position.
 * 
 * @param	{DwtCheckbox.TEXT_LEFT|DwtCheckbox.TEXT_RIGHT}		position	the position
 */
DwtCheckbox.prototype.setTextPosition =
function(position) {
	this._textEl = position == DwtCheckbox.TEXT_LEFT ? this._textElLeft : this._textElRight;
	if (this._textPosition != position) {
		this._textPosition = position;
		if (this._textElLeft) this._textElLeft.innerHTML = "";
		if (this._textElRight) this._textElRight.innerHTML = "";
		this.setText(this._text);
	}
};

/**
 * Gets the text position.
 * 
 * @return	{DwtCheckbox.TEXT_LEFT|DwtCheckbox.TEXT_RIGHT}		the position
 */
DwtCheckbox.prototype.getTextPosition =
function() {
	return this._textPosition;
};

/**
 * Sets the value.
 * 
 * @param	{string}		value		the value
 */
DwtCheckbox.prototype.setValue =
function(value) {
    var object = this._inputEl || this;
	if (object.value !== value) {
        object.value = value;
    }
};

/**
 * Gets the value.
 * 
 * @return		{string}		the value
 */
DwtCheckbox.prototype.getValue =
function() {
    var object = this._inputEl || this;
	return object.value != null ? object.value : this.getText();
};

/**
 * Gets the input element.
 * 
 * @return		{Element}		the element
 */
DwtCheckbox.prototype.getInputElement =
function() {
	return this._inputEl;
};

//
// DwtControl methods
//

DwtCheckbox.prototype.setToolTipContent = function(content) {
    if (content && !this.__mouseEventsSet) {
        // NOTE: We need mouse events in order to initiate tooltips on hover.
        // TODO: This should be done transparently in DwtControl for all
        // TODO: controls with tooltips.
        this.__mouseEventsSet = true;
        this._setMouseEvents();
    }
    DwtControl.prototype.setToolTipContent.apply(this, arguments);
};

//
// Protected methods
//

/**
 * The input field inherits the id for accessibility purposes.
 * 
 * @private
 */
DwtCheckbox.prototype._replaceElementHook =
function(oel, nel, inheritClass, inheritStyle) {
	nel = this.getInputElement();
	DwtControl.prototype._replaceElementHook.call(this, oel, nel, inheritClass, inheritStyle);
	if (oel.id) {
		this.setHtmlElementId(oel.id+"_control");
		nel.id = oel.id;
		if (this._textEl) {
			this._textEl.setAttribute(AjxEnv.isIE ? "htmlFor" : "for", oel.id);
		}
	}
};

//
// Private methods
//

DwtCheckbox.prototype._createHtml =
function(templateId) {
	var data = { id: this._htmlElId };
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

DwtCheckbox.prototype._createHtmlFromTemplate =
function(templateId, data) {
	// NOTE: If  you don't set the name and checked status when
	//       creating checkboxes and radio buttons on IE, they will
	//       not take the first programmatic value. So we pass in
	//       the init values from the constructor.
	data.name = this._initName || this._htmlElId;
    data.value = this._initValue;
	data.type = this.INPUT_TYPE;
	DwtControl.prototype._createHtmlFromTemplate.call(this, templateId, data);
	this._inputEl = document.getElementById(data.id+"_input");
	if (this._inputEl) {
		var keyboardMgr = DwtShell.getShell(window).getKeyboardMgr();
		var handleFocus = AjxCallback.simpleClosure(keyboardMgr.grabFocus, keyboardMgr, this.getInputElement());
		Dwt.setHandler(this._inputEl, DwtEvent.ONFOCUS, handleFocus);
		Dwt.setHandler(this._inputEl, DwtEvent.ONCLICK, DwtCheckbox.__handleClick);
		this.setFocusElement();
	}
	this._textElLeft = document.getElementById(data.id+"_text_left");
	this._textElRight = document.getElementById(data.id+"_text_right");
	this.setTextPosition(this._textPosition);
};

//
// Private functions
//

DwtCheckbox.__handleClick =
function(evt) {
	var event = DwtUiEvent.getEvent(evt);
	var target = DwtUiEvent.getTarget(event);

	var selEv = DwtShell.selectionEvent;
	DwtUiEvent.copy(selEv, event);
	selEv.item = this;
	selEv.detail = target.checked;

	var checkbox = DwtControl.findControl(target);
	checkbox.setSelected(target.checked);
	checkbox.focus();
	checkbox.notifyListeners(DwtEvent.SELECTION, selEv);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtRadioButton")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a radio button.
 * @constructor
 * @class
 * This class implements a radio button.
 * 
 * @param {hash}	params	a hash of parameters
 * @param  {DwtComposite}     params.parent	the parent widget
 * @param  {constant}     params.style 	the text style. May be one of: {@link DwtCheckbox.TEXT_LEFT} or
 * 									{@link DwtCheckbox.TEXT_RIGHT} arithimatically or'd (|) with one of:
 * 									{@link DwtCheckbox.ALIGN_LEFT}, {@link DwtCheckbox.ALIGN_CENTER}, or
 * 									{@link DwtCheckbox.ALIGN_LEFT}.
 * 									The first determines were in the checkbox the text will appear
 * 									(if set), the second determine how the content of the text will be
 * 									aligned. The default value for this parameter is: 
 * 									{@link DwtCheckbox.TEXT_LEFT} | {@link DwtCheckbox.ALIGN_CENTER}
 * @param  {string}     params.name		the input control name (required for IE)
 * @param  {string}     params.value     the input control value.
 * @param  {boolean}     params.checked	the input control checked status (required for IE)
 * @param  {string}     params.className	the CSS class
 * @param  {constant}     params.posStyle	the positioning style (see {@link DwtControl})
 * @param  {string}     params.id		an explicit ID to use for the control's HTML element
 * @param  {number}     params.index 	the index at which to add this control among parent's children
 * 
 * @extends	DwtCheckbox
 */
DwtRadioButton = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtRadioButton.PARAMS);
	params.className = params.className || "DwtRadioButton";
	DwtCheckbox.call(this, params);
}

DwtRadioButton.PARAMS = DwtCheckbox.PARAMS;

DwtRadioButton.prototype = new DwtCheckbox;
DwtRadioButton.prototype.constructor = DwtRadioButton;

DwtRadioButton.prototype.isDwtRadioButton = true;
DwtRadioButton.prototype.isInputControl = true;
DwtRadioButton.prototype.toString = function() { return "DwtRadioButton"; };

//
// Data
//

DwtRadioButton.prototype.INPUT_TYPE = 'radio';
}
if (AjxPackage.define("ajax.dwt.widgets.DwtRadioButtonGroup")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates a radio button group.
 * @constructor
 * @class
 * This class implements a group of radio buttons
 *
 * @param {hash} [radios] 	a hash whose keys are the ids of the radio button elements
 * 		and whose values are the values associated with those buttons
 * @param {string} [selectedId]	the id of the button to select initially
 * 
 * TODO: this really should be a DwtComposite
 * 
 * @private
 */
DwtRadioButtonGroup = function(radios, selectedId) {
	this._radios = {};
	this._radioButtons = {};
	this._values = {};
	this._value2id = {};
	this._eventMgr = new AjxEventMgr();
	
	for (var id in radios) {
		this.addRadio(id, radios[id], (id == selectedId));
	}
};

DwtRadioButtonGroup.prototype.toString =
function() {
	return "DwtRadioButtonGroup";
};

//
// Data
//

DwtRadioButtonGroup.prototype._enabled = true;
DwtRadioButtonGroup.prototype._visible = true;

//
// Public methods
//

DwtRadioButtonGroup.prototype.addSelectionListener = function(listener) {
	return this._eventMgr.addListener(DwtEvent.SELECTION, listener);
};

DwtRadioButtonGroup.prototype.removeSelectionListener = function(listener) {
	return this._eventMgr.removeListener(DwtEvent.SELECTION, listener);
};

DwtRadioButtonGroup.prototype.setEnabled = function(enabled) {
	this._enabled = enabled;
	for (var id in this._radios) {
		this._radios[id].disabled = !enabled;
	}
};
DwtRadioButtonGroup.prototype.isEnabled = function() {
	return this._enabled;
};

DwtRadioButtonGroup.prototype.setVisible = function(visible) {
	this._visible = visible;
	for (var id in this._radioButtons) {
		this._radioButtons[id].setVisible(visible);
	}
	for (var id in this._radios) {
		Dwt.setVisible(this._radios[id], visible);
	}
};
DwtRadioButtonGroup.prototype.isVisible = function() {
	return this._visible;
};

DwtRadioButtonGroup.prototype.addRadio =
function(id, radioButtonOrValue, selected) {
	var isRadioButton = radioButtonOrValue instanceof DwtRadioButton;
	var radioButton = isRadioButton ? radioButtonOrValue : null;
	var value = radioButton ? radioButton.getValue() : radioButtonOrValue;

	this._values[id] = value;
	this._value2id[value] = id;
	var element = document.getElementById(id);
	this._radios[id] = element;
	this._radioButtons[id] = radioButton;
	var handler = AjxCallback.simpleClosure(this._handleClick, this);
	Dwt.setHandler(element, DwtEvent.ONCLICK, handler);
   	element.checked = selected;
    if (selected) {
    	this._selectedId = id;
    }
};

DwtRadioButtonGroup.prototype.getRadioByValue = function(value) {
	var id = this._value2id[value];
	return this._radios[id];
};

DwtRadioButtonGroup.prototype.getRadioButtonByValue = function(value) {
	var id = this._value2id[value];
	return this._radioButtons[id];
};

DwtRadioButtonGroup.prototype.setSelectedId =
function(id, skipNotify) {
	if (id != this._selectedId) {
		var el = document.getElementById(id);
		if (!el) return;
		el.checked = true;
		this._selectedId = id;
		if (!skipNotify) {
			var selEv = DwtShell.selectionEvent;
			selEv.reset();
			this._notifySelection(selEv);
		}
	}
};

DwtRadioButtonGroup.prototype.setSelectedValue =
function(value, skipNotify) {
	var id = this._valueToId(value);
	this.setSelectedId(id, skipNotify);
};

DwtRadioButtonGroup.prototype.getSelectedId =
function() {
	return this._selectedId;
};

DwtRadioButtonGroup.prototype.getSelectedValue =
function() {
	return this._values[this._selectedId];
};

DwtRadioButtonGroup.prototype.getValue =
function() {
	return this.getSelectedValue();
};

DwtRadioButtonGroup.prototype.getData =
function(key) {
	var selectedRadio = !AjxUtil.isUndefined(this._selectedId) && this._radioButtons[this._selectedId];
	if (selectedRadio) {
		return selectedRadio.getData(key);
	}
	// return undefined;
}

//
// Protected methods
//

DwtRadioButtonGroup.prototype._valueToId =
function(value) {
	for (var id in this._values) {
		if (this._values[id] == value) {
			return id;
		}
		if (value === true && this._values[id] == "true") {
			return id;
		}
		if (value === false && (this._values[id] == "false" || this._values[id] == "")) {
			return id;
		}
	}
	return null;
};

DwtRadioButtonGroup.prototype._notifySelection = 
function(selEv) {
    selEv.item = this;
    selEv.detail = { id: this._selectedId, value: this._values[this._selectedId] };
    this._eventMgr.notifyListeners(DwtEvent.SELECTION, selEv);
};

DwtRadioButtonGroup.prototype._handleClick = 
function(event) {
	event = DwtUiEvent.getEvent(event);

	var target = DwtUiEvent.getTarget(event);
	if (target && target.nodeName.match(/label/i)) {
        target = document.getElementById(target.getAttribute(AjxEnv.isIE ? "htmlFor" : "for"));
    }

	var id = target.id;
	// NOTE: When you use the arrows on radio button groups in FF,
	//       the radio button that is being unselected is the target
	//       of the event. So we need to check to see if this target
	//       is the one that is checked.
	if (!target.checked) {
		for (id in this._radios) {
			if (this._radios[id].checked) {
				break;
			}
		}
	}
	if (id != this._selectedId) {
		this._selectedId = id;
	    var selEv = DwtShell.selectionEvent;
	    DwtUiEvent.copy(selEv, event);
		this._notifySelection(selEv);
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtForm")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a form.
 * @class
 * This class represents a form.
 * 
 * @param	{hash}	params		a hash of parameters
 * 
 * @extends		DwtComposite
 * 
 * @private
 */
DwtForm = function(params) {
	if (arguments.length == 0) return;
	params = Dwt.getParams(arguments, DwtForm.PARAMS);
	params.className = params.className || "DwtForm";
	DwtComposite.apply(this, arguments);
	this.setScrollStyle(DwtControl.SCROLL);

	// data
	this._tabGroup = new DwtTabGroup(this._htmlElId);

	// context
	this._context = {
		set: AjxCallback.simpleClosure(this.set, this),
		get: AjxCallback.simpleClosure(this.get, this)
	};

	// construct form
	this._dirty = {};
	this._ignore = {};
	this._invalid = {};
	this._errorMessages = {};
	this.setModel(params.model);
	this.setForm(params.form);
	this.reset();
};
DwtForm.prototype = new DwtComposite;
DwtForm.prototype.constructor = DwtForm;

DwtForm.prototype.toString = function() {
	return "DwtForm";
};

//
// Constants
//

DwtForm.PARAMS = DwtControl.PARAMS.concat("form", "model");

//
// Public methods
//

/**
 * Sets the value.
 * 
 * @param	{string}	id	the id
 * @param	{string}	value		the value
 * @param	{boolean}	force		if <code>true</code>, to force update
 */
DwtForm.prototype.setValue = function(id, value, force) {
	if (typeof id != "string") id = String(id);
	if (id.match(/\./) || id.match(/\[/)) {
		var parts = id.replace(/\[(\d+)\](\.)?/,".$1$2").split(".");
		var control = this.getControl(parts[0]);
		if (Dwt.instanceOf(control, "DwtForm")) {
			control.setValue(parts.slice(1).join("."), value, force);
		}
		return;
	}
	var item = this._items[id];
	if (!item) return;
	if (!force && value == item.value) return;
	this._setModelValue(id, value);
	this._setControlValue(id, value);
};

/**
 * Gets the value.
 * 
 * @param	{string}	id	the id
 * @param	{string}	defaultValue		the default value
 * @return	{string}	the value
 */
DwtForm.prototype.getValue = function(id, defaultValue) {
	if (typeof id !== "string") {
		id = String(id);
	}
	if (id.match(/\./) || id.match(/\[/)) {
		var parts = id.replace(/\[(\d+)\](\.)?/,".$1$2").split(".");
		var control = this.getControl(parts[0]);
		if (Dwt.instanceOf(control, "DwtForm")) {
			return control.getValue(parts.slice(1).join("."));
		}
		return null;
	}
	var item = this._items[id];
	if (!item) {
		return;
	}
	if (item.getter) {
		return this._call(item.getter) || defaultValue;
	}
	var value = this._getControlValue(id);
    if (value == null) {
		value = item.value;
	}

    //added <|| ""> because ... if value="" than it always returns defaultValue which could be undefined.
	return value || defaultValue || "";
};

/**
 * Gets the control for the item.
 * 
 * @param	{string}	id		the id
 * @return	{DwtControl}	the control
 */
DwtForm.prototype.getControl = function(id) {
	if (typeof id != "string") id = String(id);
	var item = this._items[id];
	return item && item.control;
};

/**
 * Checks if the id is relevant (meaning: is visible and is enabled).
 * 
 * @param	{string}	id 		the id
 * @return	 {boolean}	<code>true</code> if the item is relevant
 */
DwtForm.prototype.isRelevant = function(id) {
	return this.isVisible(id) && this.isEnabled(id);
};

DwtForm.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

// control methods

/**
 * Sets the label.
 * 
 * @param	{string}	id 		the id
 * @param	{string}	label 		the label
 */
DwtForm.prototype.setLabel = function(id, label) {
	var item = this._items[id];
	if (!item) return;
	if (label == this.getLabel(id)) return;
	var control = item.control;
	if (!control) return;
	if (control.setLabel) { control.setLabel(label); return; }
	if (control.setText) { control.setText(label); return; }
};

/**
 * Sets the image.
 *
 * @param	{string}	id 		the id
 * @param	{string}	image 	the image
 * @param	{string}	altText	alternate text for non-visual users
 */
DwtForm.prototype.setImage = function(id, image, altText) {
	var item = this._items[id];
	if (!item) {
		return;
	}
	var control = item.control;
	if (!control) {
		return;
	}
	control.setImage(image, null, altText);
};


/**
 * Gets the label.
 * 
 * @param	{string}	id 		the id
 * @return	{string}	the label
 */
DwtForm.prototype.getLabel = function(id) {
	var item = this._items[id];
	var control = item && item.control;
	if (control) {
		if (control.getLabel) return control.getLabel();
		if (control.getText) return control.getText();
	}
	return "";
};

DwtForm.prototype.setVisible = function(id, visible) {
	// set the form's visibility
	if (arguments.length == 1) {
		DwtComposite.prototype.setVisible.call(this, arguments[0]);
		return;
	}
	// set control's visibility
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return;
	if (control.setVisible) {
		control.setVisible(visible);
	}
	else {
		Dwt.setVisible(control, visible);
	}
	// if there's a corresponding "*_row" element
	var el = document.getElementById([this._htmlElId, id, "row"].join("_"));
	if (el) {
		Dwt.setVisible(el, visible);
	}
};

DwtForm.prototype.isVisible = function(id) {
	// this form's visibility
	if (arguments.length == 0) {
		return DwtComposite.prototype.isVisible.call(this);
	}
	// control's visibility
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return false;
	if (control.getVisible) return control.getVisible();
	if (control.isVisible) return control.isVisible();
	return  Dwt.getVisible(control);
};

/**
 * Sets the enabled flag.
 * 
 * @param	{string}	id 		the id
 * @param	{boolean}	enabled		if <code>true</code>, the item is enabled
 */
DwtForm.prototype.setEnabled = function(id, enabled) {
	// set the form enabled
	if (arguments.length == 1) {
		DwtComposite.prototype.setEnabled.call(this, arguments[0]);
		return;
	}
	// set the control enabled
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return;
	if (control.setEnabled) {
		control.setEnabled(enabled);
	}
	else {
		control.disabled = !enabled;
	}
};

/**
 * Checks if the item is enabled.
 * 
 * @param	{string}	id 		the id
 * @return	{boolean}	<code>true</code> if the item is enabled
 */
DwtForm.prototype.isEnabled = function(id) {
	// this form enabled?
	if (arguments.length == 0) {
		return DwtComposite.prototype.isEnabled.call(this);
	}
	// the control enabled?
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return false;
	if (control.isEnabled) return control.isEnabled();
	if (control.getEnabled) return control.getEnabled();
	return  !control.disabled;
};

/**
 * Sets the valid flag.
 * 
 * @param	{string}	id 		the id
 * @param	{boolean}	valid		if <code>true</code>, the item is valid
 */
DwtForm.prototype.setValid = function(id, valid) {
	if (typeof(id) == "boolean") {
		valid = arguments[0];
		for (id in this._items) {
			this.setValid(id, valid);
		}
		return;
	}
	if (valid) {
		delete this._invalid[id]; 
	}
	else {
		this._invalid[id] = true;
	}
};

/**
 * Checks if the item is valid.
 * 
 * @param	{string}	id 		the id
 * @return	{boolean}	<code>true</code> if the item is valid
 */
DwtForm.prototype.isValid = function(id) {
	if (arguments.length == 0 || AjxUtil.isUndefined(id)) {
		for (var id in this._invalid) {
			return false;
		}
		return true;
	}
	return !(id in this._invalid);
};

/**
 * Sets the error message.
 * 
 * @param	{string}	id 		the id
 * @param	{string}	message	the message
 */
DwtForm.prototype.setErrorMessage = function(id, message) {
	if (!id || id == "") {
		this._errorMessages = {};
		return;
	}
	if (!message) {
		delete this._errorMessages[id]; 
	} else {
		this._errorMessages[id] = message;
	}
};

/**
 * Gets the error message.
 * 
 * @param	{string}	id 		the id
 * @return	{string|array}	the message(s)
 */
DwtForm.prototype.getErrorMessage = function(id) {
	if (arguments.length == 0) {
		var messages = {};
		for (var id in this._invalid) {
			messages[id] = this._errorMessages[id];
		}
		return messages;
	}
	return this._errorMessages[id];
};

DwtForm.prototype.getInvalidItems = function() {
	return AjxUtil.keys(this._invalid);
};

DwtForm.prototype.setDirty = function(id, dirty, skipNotify) {
	if (typeof id == "boolean") {
		dirty = arguments[0];
		for (id in this._items) {
			this.setDirty(id, dirty, true);
		}
		if (!skipNotify && this._ondirty) {
			this._call(this._ondirty, ["*"]);
		}
		return;
	}
	if (dirty) {
		this._dirty[id] = true;
	}
	else {
		delete this._dirty[id]; 
	}
	if (!skipNotify && this._ondirty) {
		var item = this._items[id];
		if (!item.ignore || !this._call(item.ignore)) {
			this._call(this._ondirty, [id]);
		}
	}
};
DwtForm.prototype.isDirty = function(id) {
	if (arguments.length == 0) {
		for (var id in this._dirty) {
			var item = this._items[id];
			if (item.ignore && this._call(item.ignore)) {
				continue;
			}
			return true;
		}
		return false;
	}
	var item = this._items[id];
	return item.ignore && this._call(item.ignore) ? false : id in this._dirty;
};
DwtForm.prototype.getDirtyItems = function() {
	// NOTE: This avoids needing a closure
	DwtForm.__acceptDirtyItem.form = this;
	return AjxUtil.keys(this._dirty, DwtForm.__acceptDirtyItem);
};
DwtForm.__acceptDirtyItem = function(id) {
	var form = arguments.callee.form;
	var item = form._items[id];
	return !item.ignore || !form._call(item.ignore);
};

DwtForm.prototype.setIgnore = function(id, ignore) {
	if (typeof id == "boolean") {
		this._ignore = {};
		return;
	}
	if (ignore) {
		this._ignore[id] = true;
		return;
	}
	delete this._ignore[id];
};
DwtForm.prototype.isIgnore = function(id) {
	return id in this._ignore;
};

// convenience control methods

DwtForm.prototype.set = function(id, value) {
	this.setValue(id, value, true);
	this.update();
};
DwtForm.prototype.get = DwtForm.prototype.getValue;

// properties

DwtForm.prototype.setModel = function(model, reset) {
	this._context.model = this.model = model;
};

DwtForm.prototype.setForm = function(form) {
	this._context.form = this.form = form;
	this._createHtml(form.template);
};

// form maintenance

DwtForm.prototype.validate = function(id) {
	if (arguments.length == 0) {
		this.setValid(true);
		for (var id in this._items) {
			this._validateItem(id);
		}
		return this.isValid();
	}
	return this._validateItem(id);
};

DwtForm.prototype._validateItem = function(id) {
	if (!id) return true;
	var item = this._items[id];
	if (!item) return true;
	try {
		var value = this.getValue(id);
		var outcome = item.validator ? item.validator(value) : ((item.control && item.control.validator) ? item.control.validator(value) : true);
		// the validator may return false to signify that the validation failed (but preferably throw an error with a message)
		// it may return true to signify that the field validates
		// It also may return a string or hash (truthy) that we may put into the value field (for normalization of data; e.g. if 13/10/2009 is transformed to 1/10/2010 by the validator)
		this.setValid(id, Boolean(outcome) || outcome === "");
		if (AjxUtil.isString(outcome) || AjxUtil.isObject(outcome)) {
			this._setControlValue(id, outcome); // Set display value
			item.value = item.setter ? this._call(item.setter, [outcome]) : outcome; // Set model value
			var dirty = !Boolean(this._call(item.equals, [item.value,item.ovalue]));
			this.setDirty(id, dirty);
		}
	}
	catch (e) {
		this.setErrorMessage(id, AjxUtil.isString(e) ? e : e.message);
		this.setValid(id, false);
	}
	return !(id in this._invalid);
};

DwtForm.prototype.reset = function(useCurrentValues) {
	// init state
	this._dirty = {};
	this._ignore = {};
	this._invalid = {};
	for (var id in this._items) {
		var item = this._items[id];
		if (item.control instanceof DwtForm) {
			item.control.reset(useCurrentValues);
		}
		var itemDef = this._items[id].def;
		if (!itemDef) continue;
		this._initControl(itemDef, useCurrentValues);
	}
	// update values
	this.update();
	for (var id in this._items) {
		var item = this._items[id];
		item.ovalue = item.value;
	}
	// clear state
	this.validate();
    this.setDirty(false);
	// call handler
	if (this._onreset) {
		this._call(this._onreset);
	}
};

DwtForm.prototype.update = function() {
	// update all the values first
	for (var id in this._items) {
		var item = this._items[id];
		if (item.control instanceof DwtForm) {
			item.control.update();
		}
		if (item.getter) {
			this.setValue(id, this._call(item.getter));
		}
	}
	// now set visible/enabled/ignore based on values
	for (var id in this._items) {
		var item = this._items[id];
		if (item.visible) {
			this.setVisible(id, Boolean(this._call(item.visible)));
		}
		if (item.enabled) {
			this.setEnabled(id, Boolean(this._call(item.enabled)));
		}
		if (item.ignore) {
			this.setIgnore(id, Boolean(this._call(item.ignore)));
		}
	}
	// call handler
	if (this._onupdate) {
		this._call(this._onupdate);
	}
};

//
// Protected methods
//

DwtForm.prototype._setModelValue = function(id, value) {
	var item = this._items[id];
	item.value = item.setter ? this._call(item.setter, [value]) : value;
	var dirty = !Boolean(this._call(item.equals, [item.value,item.ovalue]));
	this.setDirty(id, dirty);
	this.validate(id);
	return dirty;
};

DwtForm.prototype._setControlValue = function(id, value) {
	var control = this._items[id].control;
	if (control) {
		// TODO: display value
		if (control instanceof DwtCheckbox || control instanceof DwtRadioButton) {
			control.setSelected(value);
			return;
		}
		if (control instanceof DwtMenuItem && control.isStyle(DwtMenuItem.CHECK_STYLE)) {
			control.setChecked(value, true);
			return;
		}
		if (control.setSelectedValue) { control.setSelectedValue(value); return; }
		if (control.setValue) { control.setValue(value); return; }
		if (control.setText && !(control instanceof DwtButton)) { control.setText(value); return; }
		if (!(control instanceof DwtControl)) {
			// TODO: support other native form elements like select
			if (control.type == "checkbox" || control == "radio") {
				control.checked = value;
			}
			else {
				// TODO: handle error setting form input value
				control.value = value;
			}
			return;
		}
	}
};
DwtForm.prototype._getControlValue = function(id) {
	var control = this._items[id].control;
	if (control) {
		if (control instanceof DwtCheckbox || control instanceof DwtRadioButton) {
			return control.isSelected();
		}
		if (control.getSelectedValue) {
			return control.getSelectedValue();
		}
		if (control.getValue) {
			return control.getValue();
		}
		if (control.getText && !(control instanceof DwtButton)) {
			return control.getText();
		}
		if (!(control instanceof DwtControl)) {
			if (control.type == "checkbox" || control == "radio") return control.checked;
			return control.value;
		}
	}
};

DwtForm.prototype._deleteItem = function(id) {
	delete this._items[id];
	delete this._dirty[id];
	delete this._invalid[id];
	delete this._ignore[id];
};

// utility

DwtForm.prototype._call = function(func, args) {
	if (func) {
		if (args) return func.apply(this, args);
		// NOTE: Hack for IE which barfs with null args on apply
		return func.call(this);
	}
};

// html creation

DwtForm.prototype._createHtml = function(templateId) {
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, { id: this._htmlElId });
};

DwtForm.prototype._createHtmlFromTemplate = function(templateId, data) {
	DwtComposite.prototype._createHtmlFromTemplate.apply(this, arguments);

	// initialize state
	var tabIndexes = [];
	this._items = {};
	this._tabGroup.removeAllMembers();
	this._onupdate = null;
	this._onreset = null;
	this._ondirty = null;

	// create form
	var form = this.form;
	if (form && form.items) {
		// create controls
		this._registerControls(form.items, null, tabIndexes);
		// create handlers
		this._onupdate = DwtForm.__makeFunc(form.onupdate);
		this._onreset = DwtForm.__makeFunc(form.onreset);
		this._ondirty = DwtForm.__makeFunc(form.ondirty);
	}

	// add links to list of tabIndexes
	var links = this.getHtmlElement().getElementsByTagName("A");
	for (var i = 0; i < links.length; i++) {
		var link = links[i];
		if (!link.href || link.getAttribute("notab") == "true") continue;
        var controlId = link.id && link.id.substr(this.getHTMLElId().length+1);
		if (this._items[controlId]) continue;
		tabIndexes.push({
			tabindex:	link.getAttribute("tabindex") || Number.MAX_VALUE,
			control:	link
		});
	}

	// add controls to tab group
	tabIndexes.sort(DwtForm.__byTabIndex);
	for (var i = 0; i < tabIndexes.length; i++) {
		var control = tabIndexes[i].control;
		var member = (control.getTabGroupMember && control.getTabGroupMember()) || control;
		this._tabGroup.addMember(member);
	}
};

DwtForm.prototype._registerControls = function(itemDefs, parentDef,
                                               tabIndexes, params,
                                               parent, defaultType) {
	for (var i = 0; i < itemDefs.length; i++) {
		this._registerControl(itemDefs[i], parentDef, tabIndexes, params, parent, defaultType);
	}
};

DwtForm.prototype._registerControl = function(itemDef, parentDef,
                                              tabIndexes, params,
                                              parent, defaultType) {
	// create item entry
	var id = itemDef.id || [this._htmlElId, Dwt.getNextId()].join("_");
	var item = this._items[id] = {
		id:			id, // for convenience
		def:		itemDef,
		parentDef:	parentDef,
		equals:		DwtForm.__makeFunc(itemDef.equals) || DwtForm.__equals,
		getter:		DwtForm.__makeGetter(itemDef),
		setter:		DwtForm.__makeSetter(itemDef),
		value:		itemDef.value,
		visible:	DwtForm.__makeFunc(itemDef.visible),
		enabled:	DwtForm.__makeFunc(itemDef.enabled),
		validator:	DwtForm.__makeFunc(itemDef.validator),
		ignore:		DwtForm.__makeFunc(itemDef.ignore),
		control:	itemDef.control
	};
	// NOTE: This is used internally for indexing of rows
	if (itemDef.aka) {
		this._items[id].aka = itemDef.aka;
		this._items[itemDef.aka] = item;
	}

	// is control already created?
	var control = item.control;
	if (control) {
		return control;
	}

	// create control
	parent = parent || this;
	var type = itemDef.type = itemDef.type || defaultType;
	var isMenu = (parentDef && parentDef.menu == itemDef);
	var element = document.getElementById([parent._htmlElId,id].join("_"));
	if (Dwt.instanceOf(type, "DwtRadioButtonGroup")) {
		// create control
		control = new window[type]({});
		item.control = control;

		// add children
		var nparams = {
			name:  [parent._htmlElId, id].join("_"),
			value: itemDef.value
		};
		if (itemDef.items) {
			for (var i = 0; i < itemDef.items.length; i++) {
				var radioItemDef = itemDef.items[i];
				var checked = radioItemDef.checked || radioItemDef.value == itemDef.value;
				var radio = this._registerControl(radioItemDef, itemDef, tabIndexes, nparams, parent, "DwtRadioButton");
				this._items[radioItemDef.id].value = checked;
				if (radio) {
					control.addRadio(radio.getInputElement().id, radio, checked);
					// handlers
					var handler = DwtForm.__makeFunc(radioItemDef.onclick || itemDef.onclick);
					radio.addSelectionListener(new AjxListener(this, this._radio2group2model, [radioItemDef.id, id, handler]));
					// HACK: Work around fact that the DwtRadioButtonGroup overwrites
					//       the radio button input element's onclick handler.
					DwtForm.__hack_fixRadioButtonHandler(radio);
				}
			}
		}
	}
	else if (type) {
		if (Dwt.instanceOf(type, "DwtInputField")) {
			item.value = item.value || "";
		}
		if (Dwt.instanceOf(type, "DwtFormRows")) {
		    item.equals = DwtFormRows.__equals;
		}
		if (element || isMenu) {
			control = item.control = this._createControl(itemDef, parentDef, tabIndexes, params, parent, defaultType);
		}
	}
	else if (element) {
		this._attachElementHandlers(itemDef, parentDef, tabIndexes, parent, element);
		control = item.control = element;
		if (itemDef.items) {
			this._registerControls(itemDef.items, itemDef, tabIndexes, null, parent, null);
		}
	}
	if (element && control instanceof DwtControl) {
		control.replaceElement(element);
	}
	if (element && control instanceof DwtInputField) {
		control.getInputElement().id += "_input";
		control.setHandler(DwtEvent.ONPASTE, this._onPaste.bind(this, id));
	}

	// add to list of tab indexes
	if (itemDef.notab == null) {
		itemDef.notab = element && element.getAttribute("notab") == "true";
	}
	if (tabIndexes && control && !itemDef.notab && !(control instanceof DwtRadioButtonGroup)) {
		tabIndexes.push({
			tabindex:	(element && element.getAttribute("tabindex")) || Number.MAX_VALUE,
			control:	control
		});
	}

	// clean up
	if (control instanceof DwtListView) {
		item.getter = item.getter || AjxCallback.simpleClosure(this.__list_getValue, this, id);
		item.setter = item.setter || AjxCallback.simpleClosure(this.__list_setValue, this, id);
	}

	// return control
	return control;
};


DwtForm.prototype._onPaste = function(id, evt) {
	// Delay the value processing - the paste text will not be applied to the control till after this event
	AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._applyPasteInput, [id]), 100);
};

DwtForm.prototype._applyPasteInput = function(id, value) {
	this._setModelValue(id, this._getControlValue(id));
}


DwtForm.prototype._attachElementHandlers = function(itemDef, parentDef, tabIndexes, parent, element) {
	var id = itemDef.id;
	var name = element.nodeName.toLowerCase();
	var type = element.type;
	if (type == "checkbox" || type == "radio") {
		var parentId;
		if (type == "radio") {
			parentId = element.name;
			if (!this._items[parentId]) this._items[parentId] = { id: parentId };
			if (element.checked) {
				this._items[parentId].value = element.value;
			}
		}
		// checked
		var onclick = element.onclick ;
		var handler = DwtForm.__makeFunc(itemDef.onclick);
		element.onclick = AjxCallback.simpleClosure(this._htmlInput_checked, this, id, parentId, handler, onclick);
	}
	else if (name == "select") {
		// map selectedIndex to value of option
		var onchange = element.onchange;
		var handler = DwtForm.__makeFunc(itemDef.onchange);
		element.onchange = AjxCallback.simpleClosure(this._htmlSelect_selectedIndex, this, id, handler, onchange);
	}
	else if (name == "button" || name == "a" || 
	         type == "button" || type == "reset" || type == "submit") {
		// checked
		var onclick = element.onclick ;
		var handler = DwtForm.__makeFunc(itemDef.onclick);
		element.onclick = AjxCallback.simpleClosure(this._htmlElement, this, id, handler, onclick);
	}
	else if (name == "textarea" || name == "input") { // type == "text" ||  || type == "file" || type == "password") {
		// value
		var onchange = element.onchange;
		var handler = DwtForm.__makeFunc(itemDef.onchange);
		element.onchange = AjxCallback.simpleClosure(this._htmlInput_value, this, id, handler, onchange);
	}
	// TODO: attach other handlers
	return element;
};

DwtForm.prototype._createControl = function(itemDef, parentDef,
                                            tabIndexes, params,
                                            parent, defaultType) {
	var id = itemDef.id || [this._htmlElId, Dwt.getNextId()].join("_");
	var type = itemDef.type = itemDef.type || defaultType;
	params = params ? AjxUtil.createProxy(params) : {};
	params.id = params.id || [this._htmlElId, id].join("_");
	params.parent = parent || this;
	params.template = itemDef.template || params.template;
	params.className = itemDef.className || params.className;

	// constructor params for radio buttons
	var isRadioButton = Dwt.instanceOf(type, "DwtRadioButton");
	var isCheckBox = Dwt.instanceOf(type, "DwtCheckbox");
	if (isRadioButton || isCheckBox) {
		params.name = itemDef.name || params.name;
        params.value = itemDef.value || params.value;
		params.checked = itemDef.checked != null ? itemDef.checked : params.checked;
	}

	// constructor params for input fields
	var isTextField = Dwt.instanceOf(type, "DwtInputField");
	if (isTextField) {
		params.type = itemDef.password ? DwtInputField.PASSWORD : null;
		params.size = itemDef.cols;
		params.rows = itemDef.rows;
	}

	var isTabPage = Dwt.instanceOf(type, "DwtTabViewPage");
	if (isTabPage) {
		params.contentTemplate = itemDef.template;
		delete itemDef.template;
	}

    var isTree = Dwt.instanceOf(type, "DwtTree");
    if (isTree) {
        params.style = itemDef.style;
    }

	// add extra params
	params.formItemDef = itemDef;
	if (itemDef.params) {
		for (var p in itemDef.params) {
			params[p] = itemDef.params[p];
		}
	}

	// create control
	var control = new window[type](params);

	// init select
	if (control instanceof DwtSelect) {
		var options = itemDef.items;
		if (options) {
			for (var i = 0; i < options.length; i++) {
				var option = options[i];
				// convert to format that DwtSelect#addOption recognizes
				option.displayValue = option.label || option.value;
				control.addOption(option);
			}
		}
		var handler = DwtForm.__makeFunc(itemDef.onchange);
		control.addChangeListener(new AjxListener(this, this._control2model, [id, handler]));
	}

	// init button, menu item
	else if (control instanceof DwtButton || control instanceof DwtMenuItem) {
		if (itemDef.label) { control.setText(itemDef.label); }
		if (itemDef.image) { control.setImage(itemDef.image, null, itemDef.imageAltText); }
		if (itemDef.menu) {
			var isMenu = Dwt.instanceOf(itemDef.menu.type || "DwtMenu", "DwtMenu");
			var menu;
			if (isMenu) {
				menu = this._registerControl(itemDef.menu, itemDef, null, null, control, "DwtMenu");
			}
			else {
				menu = new DwtMenu({parent:control});
				var style = Dwt.instanceOf(itemDef.menu.type, "DwtCalendar") ?
							DwtMenu.CALENDAR_PICKER_STYLE : DwtMenu.GENERIC_WIDGET_STYLE;
				this._registerControl(itemDef.menu, itemDef, null, { style: style }, menu);
			}
			control.setMenu(menu);
		}
		var parentId;
		if (parent instanceof DwtToolBar || parent instanceof DwtMenu) {
			parentId = parentDef.id;
		}
		// handlers
		var handler = DwtForm.__makeFunc(itemDef.onclick || (parentDef && parentDef.onclick));
		control.addSelectionListener(new AjxListener(this, this._item2parent, [id, parentId, handler]));
	}

	// init checkbox, radio button
	else if (control instanceof DwtCheckbox && !(control instanceof DwtRadioButton)) {
		var handler = DwtForm.__makeFunc(itemDef.onclick);
		control.addSelectionListener(new AjxListener(this, this._control2model, [id, handler]));
	}

	// init input field
	else if (control instanceof DwtInputField) {
		var changehandler = DwtForm.__makeFunc(itemDef.onchange);
		var onkeyup = AjxCallback.simpleClosure(this._input2model2handler, this, id, changehandler);
		control.addListener(DwtEvent.ONKEYUP, onkeyup);
        if (AjxEnv.isFirefox){
            var onkeydown = this._onkeydownhandler.bind(this, id, changehandler);
            control.addListener(DwtEvent.ONKEYDOWN, onkeydown);
        }
		var blurhandler = DwtForm.__makeFunc(itemDef.onblur);
        if (blurhandler) {
		    var onblur = AjxCallback.simpleClosure(this._input2model2handler, this, id, blurhandler);
		    control.addListener(DwtEvent.ONBLUR, onblur);
        }

		itemDef.tooltip = itemDef.tooltip || itemDef.hint;
		control.setHint(itemDef.hint);
		control.setLabel(itemDef.label || itemDef.tooltip);
	}

	// init list
	else if (control instanceof DwtListView) {
		control.addSelectionListener(new AjxListener(this, this._handleListSelection, [id]));
	}

	// init menu
	else if (control instanceof DwtMenu) {
		if (itemDef.items) {
			var menuItemDefs = itemDef.items;
			for (var i = 0; i < menuItemDefs.length; i++) {
				var menuItemDef = menuItemDefs[i];
				if (menuItemDef.type == DwtMenuItem.SEPARATOR_STYLE) {
					new DwtMenuItem({parent:control, style:DwtMenuItem.SEPARATOR_STYLE});
					continue;
				}
				this._registerControl(menuItemDef, itemDef, null, null, control, "DwtMenuItem");
			}
		}
	}

	// init tabs
	else if (control instanceof DwtTabView) {
		var pageDefs = itemDef.items;
		if (pageDefs) {
			this._registerControls(pageDefs, itemDef, null, null, control, "DwtTabViewPage");
		}
	}

	// init tab page
	else if (control instanceof DwtTabViewPage && parent instanceof DwtTabView) {
		var key = parent.addTab(itemDef.label, control);
		if (itemDef.image) {
			parent.getTabButton(key).setImage(itemDef.image, null, itemDef.imageAltText);
		}
		if (itemDef.items) {
			this._registerControls(itemDef.items, itemDef, tabIndexes, null, control);
		}
	}

	// init toolbar
	else if (control instanceof DwtToolBar) {
		var toolbarItemDefs = itemDef.items;
		if (toolbarItemDefs) {
			for (var i = 0; i < toolbarItemDefs.length; i++) {
				var toolbarItemDef = toolbarItemDefs[i];
				if (toolbarItemDef.type == DwtToolBar.SPACER) {
					control.addSpacer(toolbarItemDef.size);
					continue;
				}
				if (toolbarItemDef.type == DwtToolBar.SEPARATOR) {
					control.addSeparator(toolbarItemDef.className);
					continue;
				}
				if (toolbarItemDef.type == DwtToolBar.FILLER) {
					control.addFiller(toolbarItemDef.className);
					continue;
				}
				this._registerControl(toolbarItemDef, itemDef, null, null, control, "DwtToolBarButton");
			}
		}
	}
	else if (control instanceof DwtCalendar) {
		if (itemDef.onselect instanceof AjxListener) {
			control.addSelectionListener(itemDef.onselect);
		}
	}

	// TODO: other controls (e.g. combobox, listview, slider, spinner, tree)

	// init anonymous composites
	else if (control instanceof DwtComposite) {
		if (itemDef.items) {
			this._registerControls(itemDef.items, itemDef, tabIndexes, null, control);
		}
	}

    // size control
    if (itemDef.width || itemDef.height) {
        if (control instanceof DwtInputField) {
            Dwt.setSize(control.getInputElement(), itemDef.width, itemDef.height);
        }
        else {
            control.setSize(itemDef.width, itemDef.height);
        }
    }

	if (itemDef.tooltip) {
		control.setToolTipContent(itemDef.tooltip);
	}

	// return control
	return control;
};

DwtForm.prototype._onkeydownhandler  = function(id, changehandler){
    setTimeout(this._input2model2handler.bind(this, id, changehandler), 500);
};

DwtForm.prototype._initControl = function(itemDef, useCurrentValues) {
	var id = itemDef.id;
	if (itemDef.label) this.setLabel(id, itemDef.label);
	var item = this._items[id];
	if (useCurrentValues) {
		item.ovalue = item.value;
	}
	else if (itemDef.value) {
		if (Dwt.instanceOf(itemDef.type, "DwtRadioButton")) {
			item.ovalue = item.value = item.control && item.control.isSelected();
		}
		else {
			this.setValue(id, itemDef.value, true);
			item.ovalue = item.value;
		}
	}
	else {
		item.ovalue = null;
	}
	if (typeof itemDef.enabled == "boolean") this.setEnabled(id, itemDef.enabled);
	if (typeof itemDef.visible == "boolean") this.setVisible(id, itemDef.visible);
};

// html handlers

DwtForm.prototype._htmlElement = function(id, formHandler, elementHandler, evt) {
	if (formHandler) {
		this._call(formHandler, [id]);
	}
	if (elementHandler) {
		elementHandler(evt);
	}
};

DwtForm.prototype._htmlInput_checked = function(id, parentId, handler, onclick, evt) {
	var control = this.getControl(id);
	var checked = control.checked;
	this._setModelValue(id, checked);
	if (parentId && checked) {
		this._setModelValue(parentId, control.value);
	}
	this.update();
	this._htmlElement(id, handler, onclick, evt);
};

DwtForm.prototype._htmlInput_value = function(id, handler, onchange, evt) {
	this._setModelValue(id, this.getControl(id).value);
	this.update();
	this._htmlElement(id, handler, onchange, evt);
};

DwtForm.prototype._htmlSelect_selectedIndex = function(id, handler, onchange, evt) {
	var select = this.getControl(id);
	this._setModelValue(id, select.options[select.selectedIndex].value);
	this.update();
	this._htmlElement(id, handler, onchange, evt);
};

// dwt handlers

DwtForm.prototype._control2model = function(id, handler) {
	this._setModelValue(id, this._getControlValue(id));
	this.update();
	if (handler) {
		this._call(handler, [id]);
	}
};

DwtForm.prototype._radio2group2model = function(radioId, groupId, handler) {
	this._setModelValue(groupId, this.getControl(radioId).getValue());
	this._setModelValue(radioId, this._getControlValue(radioId));
	this.update();
	if (handler) {
		this._call(handler, [radioId]);
	}
};

DwtForm.prototype._input2model2handler = function(id, handler) {
	this._setModelValue(id, this._getControlValue(id));
	this.update();
	if (handler) {
		this._call(handler, [id]);
	}
};

DwtForm.prototype._item2parent = function(itemId, parentId, handler) {
	var control = this.getControl(itemId);
	var itemDef = this._items[itemId].def;
	if (control instanceof DwtButtonColorPicker || (itemDef.menu && !itemDef.onclick)) {
		control._toggleMenu(); // HACK: button should have public API
	}
	else if (parentId) {
		this._setModelValue(parentId, this._getControlValue(itemId) || itemId);
		this.update();
	}
	if (handler) {
		this._call(handler, [itemId]);
	}
};

DwtForm.prototype._handleListSelection = function(id, evt) {
	this.update();
};

// setters and getters

DwtForm.prototype.__list_getValue = function(id) {
	return this.getControl(id).getSelection();
};
DwtForm.prototype.__list_setValue = function(id, value) {
	this.getControl(id).setSelection(value);
};

//
// Private functions
//

// code generation

DwtForm.__makeGetter = function(item) {
	var getter = item.getter;
	if (getter) return DwtForm.__makeFunc(getter);

	var ref = item.ref;
	if (!ref) return null;

	var parts = ref.split(".");
	var body = [
		"var context = this.model;"
	];
	for (var i = 0; i < parts.length; i++) {
		var name = parts[i];
		var fname = DwtForm.__makeFuncName(name);
		if (i == parts.length - 1) break;
		body.push(
			"context = context && (context.",fname," ? context.",fname,"() : context.",name,");"
		);
	}
	body.push(
		"var value = context ? (context.",fname," ? context.",fname,"() : context.",name,") : this._items.",name,".value;",
		"return value !== undefined ? value : defaultValue;"
	);
	return new Function("defaultValue", body.join(""));
};

DwtForm.__makeSetter = function(item) {
	var setter = item.setter;
	if (setter) return DwtForm.__makeFunc(setter);

	var ref = item.ref;
	if (!ref) return null;

	var parts = ref.split(".");
	var body = [
		"var context = this.model;"
	];
	for (var i = 0; i < parts.length; i++) {
		var isLast = i == parts.length - 1;
		var name = parts[i];
		var fname = DwtForm.__makeFuncName(name, isLast ? "set" : "get");
		if (isLast) break;
		body.push(
			"context = context && (context.",fname," ? context.",fname,"() : context.",name,");"
		);
	}
	body.push(
		"if (context) {",
			"if (context.",fname,") {",
				"context.",fname,"(value);",
			"}",
			"else {",
				"context.",name," = value;",
			"}",
		"}"
	);
	return new Function("value", body.join("\n"));
};

DwtForm.__makeFuncName = function(name, prefix) {
	return [prefix||"get",name.substr(0,1).toUpperCase(),name.substr(1)].join("");
};

DwtForm.__makeFunc = function(value) {
	if (value == null) return null;
	if (typeof value == "function" && !(value instanceof RegExp)) return value;
	var body = [
		"with (this._context) {",
			"return (",value,");",
		"}"
	].join("");
	return new Function(body);
};

DwtForm.__equals = function(a, b) {
	return a == b;
};

// Array.sort

DwtForm.__byTabIndex = function(a, b) {
	return a.tabindex - b.tabindex;
};

// hacks

DwtForm.__hack_fixRadioButtonHandler = function(radio) {
	var handlers = [radio.getInputElement().onclick, DwtCheckbox.__handleClick];
	var handler = function(evt) {
		for (var i = 0; i < handlers.length; i++) {
			var func = handlers[i];
			if (func) {
				func(evt);
			}
		}
	};
	Dwt.setHandler(radio.getInputElement(), DwtEvent.ONCLICK, handler);
};

//
// Class: DwtFormRows
//

// TODO: tab-group

/**
 * 
 * @extends		DwtForm
 * 
 * @private
 */
DwtFormRows = function(params) {
	if (arguments.length == 0) return;
	this._itemDef = params.formItemDef || {};
	params.className = params.className || "DwtFormRows";
	DwtForm.call(this, {
		id:params.id, parent:params.parent,
		form:{}, template:this._itemDef.template
	});

	// init state
	this._rowsTabGroup = new DwtTabGroup(this._htmlElId);

	// save state
	this._rowDef = this._itemDef.rowitem || {};
	this._equals = DwtForm.__makeFunc(this._rowDef.equals) || DwtForm.__equals;
	this._rowCount = 0;
	this._minRows = this._itemDef.minrows || 1;
	this._maxRows = this._itemDef.maxrows || Number.MAX_VALUE;
	if (this._itemDef.rowtemplate) {
		this.ROW_TEMPLATE = this._itemDef.rowtemplate;
	}

	// add default rows
	var itemDefs = this._itemDef.items || [];
	for (var i = 0; i < itemDefs .length; i++) {
		this.addRow(itemDefs[i]);
	}

	// add empty rows to satisfy minimum row count
	for ( ; i < this._minRows; i++) {
		this.addRow();
	}

	// remember listeners
	this._onaddrow = DwtForm.__makeFunc(this._itemDef.onaddrow);
	this._onremoverow = DwtForm.__makeFunc(this._itemDef.onremoverow);
};
DwtFormRows.prototype = new DwtForm;
DwtFormRows.prototype.constructor = DwtFormRows;

DwtFormRows.prototype.toString = function() {
	return "DwtFormRows";
};

// Data

DwtFormRows.prototype.TEMPLATE = "dwt.Widgets#DwtFormRows";
DwtFormRows.prototype.ROW_TEMPLATE = "dwt.Widgets#DwtFormRow";

// Public methods

DwtFormRows.prototype.getTabGroupMember = function() {
	return this._rowsTabGroup;
};

DwtFormRows.prototype.setValue = function(array) {
	if (arguments.length > 1) {
		DwtForm.prototype.setValue.apply(this, arguments);
		return;
	}
	// adjust row count
	var min = Math.max(array.length, this._minRows);
	for (var i = this._rowCount; i > min; i--) {
		this.removeRow(i-1);
	}
	var max = Math.min(array.length, this._maxRows);
	for (var i = this._rowCount; i < max; i++) {
		this.addRow();
	}
	// initialize values
	for (var i = 0; i < max; i++) {
		this.setValue(String(i), array[i], true);
	}
	for (var i = array.length; i < this._rowCount; i++) {
		this.setValue(String(i), null, true);
	}
};

DwtFormRows.prototype.getValue = function() {
	if (arguments.length > 0) {
		return DwtForm.prototype.getValue.apply(this, arguments);
	}
	var array = new Array(this._rowCount);
	for (var i = 0; i < this._rowCount; i++) {
		array[i] = this.getValue(String(i));
	}
	return array;
};

DwtFormRows.prototype.getRowCount = function() {
	return this._rowCount;
};

DwtFormRows.prototype.addRow = function(itemDef, index) {
	if (this._rowCount >= this._maxRows) {
		return;
	}
	itemDef = itemDef || (this._rowDef && AjxUtil.createProxy(this._rowDef));
	if (!itemDef) {
		return;
	}

	if (index == null) index = this._rowCount;

	// move other rows "up"
	for (var i = this._rowCount - 1; i >= index; i--) {
		var oindex = i, nindex = i+1;
		var item = this._items[oindex];
		item.aka = String(nindex);
		delete this._items[oindex];
		this._items[item.aka] = item;
		this._setControlIds(item.id, item.aka);
	}

	// initialize definition
	itemDef.id = itemDef.id || Dwt.getNextId();
	itemDef.aka = String(index);
	this._rowCount++;

	// create row html
	var data = { id: [this.getHTMLElId(), itemDef.id].join("_") };
	var rowHtml = AjxTemplate.expand(this.ROW_TEMPLATE, data);

	var rowsEl = this._rowsEl;
	rowsEl.appendChild(Dwt.toDocumentFragment(rowHtml, data.id+"_row"));
	var rowEl = rowsEl.lastChild;
	if (index != this._rowCount - 1) {
		rowsEl.insertBefore(rowEl, rowsEl.childNodes[index]);
	}

	// create controls
	var tabIndexes = [];
	var rowControl = this._registerControl(itemDef, null, tabIndexes);

	var addDef = this._itemDef.additem ? AjxUtil.createProxy(this._itemDef.additem) : { image: "Add", tooltip: ZmMsg.addRow };
	addDef.id = addDef.id || itemDef.id+"_add";
	addDef.visible = "this.getRowCount() < this.getMaxRows()";
	addDef.ignore = true;
	var addButton = this._registerControl(addDef,null,tabIndexes,null,null,"DwtButton");
	if (!addDef.onclick) {
		addButton.addSelectionListener(new AjxListener(this, this._handleAddRow, [itemDef.id]));
	}

	var removeDef = this._itemDef.removeitem ? AjxUtil.createProxy(this._itemDef.removeitem) : { image: "Remove", tooltip: ZmMsg.removeRow };
	removeDef.id = removeDef.id || itemDef.id+"_remove";
	removeDef.visible = "this.getRowCount() > this.getMinRows()";
	removeDef.ignore = true;
	var removeButton = this._registerControl(removeDef,null,tabIndexes,null,null,"DwtButton");
	if (!removeDef.onclick) {
		removeButton.addSelectionListener(new AjxListener(this, this._handleRemoveRow, [itemDef.id]));
	}

	// remember where we put it
	var item = this._items[itemDef.id];
	item._rowEl = rowEl;
	item._addId= addDef.id;
	item._removeId = removeDef.id;

	// set control identifiers
	this._setControlIds(item.id, index);

	// create tab group for row
	var tabGroup = new DwtTabGroup(itemDef.id);
	tabIndexes.sort(DwtForm.__byTabIndex);
	for (var i = 0; i < tabIndexes.length; i++) {
		var control = tabIndexes[i].control;
		tabGroup.addMember(control.getTabGroupMember() || control);
	}

	// add to tab group
	if (index == this._rowCount - 1) {
		this._rowsTabGroup.addMember(tabGroup);
	}
	else {
		var indexItemDef = this._items[String(index+1)];
		this._rowsTabGroup.addMemberBefore(tabGroup, DwtTabGroup.getByName(indexItemDef.id));
	}

	// update display and notify handler
	this.update();
	if (this._onaddrow) {
		this._call(this._onaddrow, [index]);
	}

	return rowControl;
};

DwtFormRows.prototype.removeRow = function(indexOrId) {
	if (this._rowCount <= this._minRows) {
		return;
	}

	var item = this._items[indexOrId];

	// this only recognizes if a properly accessible widgets (i.e. those that
	// receive browser focus) had focus
	var hadFocus = Dwt.isAncestor(item._rowEl, document.activeElement);

	// delete item at specified index
	if (item.control instanceof DwtControl) {
		this.removeChild(item.control);
	}
	delete this._items[item.aka];
	this._deleteItem(item.id);

	// delete add item
	var addItem = this._items[item._addId];
	if (addItem) {
		this.removeChild(addItem.control);
		this._deleteItem(addItem.id);
	}

	// delete remove item
	var removeItem = this._items[item._removeId];
	if (removeItem) {
		this.removeChild(removeItem.control);
		this._deleteItem(removeItem.id);
	}

	// shift everything down one, removing old last row
	var fromIndex = Number(item.aka);
	for (var i = fromIndex + 1; i < this._rowCount; i++) {
		var oindex = i, nindex = i-1;
		this._items[nindex] = this._items[oindex];
		this._items[nindex].aka = String(nindex);
		this._setControlIds(this._items[nindex].id, this._items[nindex].aka);
	}
	this._deleteItem(String(--this._rowCount));

	// remove row element
	var rowEl = item._rowEl;
	rowEl.parentNode.removeChild(rowEl);
	delete item._rowEl;

	// remove from tab group
	var tabGroup = DwtTabGroup.getByName(item.id);
	this._rowsTabGroup.removeMember(tabGroup);

	// update display and notify handler
	this.update();

	if (hadFocus) {
		var otherItem = this._items[item.aka] || this._items[this._rowCount - 1];
		otherItem.control.getTabGroupMember().focus();
	}

	if (this._onremoverow) {
		this._call(this._onremoverow, [Number(item.aka)]);
	}
};

DwtFormRows.prototype.getMinRows = function() {
	return this._minRows;
};
DwtFormRows.prototype.getMaxRows = function() {
	return this._maxRows;
};
DwtFormRows.prototype.getRowCount = function() {
	return this._rowCount;
};

DwtFormRows.prototype.getIndexForRowId = function(rowId) {
	var children = this._rowsEl.childNodes;
	for (var i = 0; i < children.length; i++) {
		if (children[i].id == [this._htmlElId,rowId,"row"].join("_")) {
			return i;
		}
	}
	return -1;
};

DwtFormRows.__equals = function(a,b) {
	if (a === b) return true;
	if (!a || !b || a.length != b.length) return false;
	for (var i = 0; i < a.length; i++) {
		if (!this._call(this._equals, [a[i],b[i]])) {
			return false;
		}
	}
	return true;
};

// Protected methods

/** Override to set child controls' identifiers. */
DwtFormRows.prototype._setControlIds = function(rowId, index) {
	var id = [this.getHTMLElId(), index].join("_");
	var item = this._items[rowId];
	this._setControlId(item && item.control, id);
	var addButton = this._items[item._addId];
	this._setControlId(addButton && addButton.control, id+"_add");
	var removeButton = this._items[item._removeId];
	this._setControlId(removeButton && removeButton.control, id+"_remove");
	// TODO: update parentid attribute of children
};

DwtFormRows.prototype._setControlId = function(control, id) {
	if (!control) return;
	if (control instanceof DwtControl) {
		control.setHtmlElementId(id);
	}
	else {
		control.id = id;
	}
};

DwtFormRows.prototype._handleAddRow = function(rowId) {
	if (this.getRowCount() < this.getMaxRows()) {
		var index = this.getIndexForRowId(rowId) + 1;
		this.addRow(null, index);
	}
};

DwtFormRows.prototype._handleRemoveRow = function(rowId) {
	this.removeRow(rowId);
};

// DwtForm methods

DwtFormRows.prototype._setModelValue = function(id, value) {
	if (DwtForm.prototype._setModelValue.apply(this, arguments)) {
		this.parent.setDirty(this._itemDef.id, true);
	}
};

// DwtControl methods

DwtFormRows.prototype._createHtmlFromTemplate = function(templateId, data) {
	DwtForm.prototype._createHtmlFromTemplate.apply(this, arguments);
	this._rowsEl = document.getElementById(this._htmlElId+"_rows");
};


}
if (AjxPackage.define("ajax.dwt.widgets.DwtCalendar")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a calendar widget
 * @constructor
 * @class
 * This class provides a calendar view.
 *
 * @author Ross Dargahi
 * @author Roland Schemers
 *
 * @param {hash}		params			a hash of parameters
 * @param {DwtComposite}      params.parent			the parent widget
 * @param {string}      params.className			the CSS class
 * @param {constant}      params.posStyle			the positioning style (see {@link Dwt})
 * @param {constant}     [params.firstDayOfWeek=DwtCalendar.SUN]		the first day of the week
 * @param {boolean}	[params.forceRollOver=true] 	if <code>true</code>, then clicking on (or setting) the widget to a 
 *												date that is not part of the current month (i.e. one of 
 *												the grey prev or next month days) will result in the 
 *												widget rolling 	the date to that month.
 * @param {array}      params.workingDays		a list of days that are work days. This array assumes that
 * 												index 0 is Sunday. Defaults to Mon-Fri being work days.
 * @param {boolean}      params.hidePrevNextMo 	a flag indicating whether widget should hide days of the 
 *												previous/next month
 * @param {boolean}      params.readOnly 		a flag indicating that this widget is read-only (should not 
 *												process events such as mouse clicks)
 * @param {boolean}      params.showWeekNumber	a flag indicating whether widget should show week number
 *        
 * @extends		DwtComposite
 */
DwtCalendar = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtCalendar.PARAMS);
	params.className = params.className || "DwtCalendar";
	DwtComposite.call(this, params);

	this._skipNotifyOnPage = false;
	this._hidePrevNextMo = params.hidePrevNextMo;
	this._readOnly = params.readOnly;
	this._showWeekNumber = params.showWeekNumber;
	this._uuid = Dwt.getNextId();
	var cn = this._origDayClassName = params.className + "Day";
	this._todayClassName = " " + params.className + "Day-today";
	this._selectedDayClassName = " " + cn + "-" + DwtCssStyle.SELECTED;
	this._hoveredDayClassName = " " + cn + "-" + DwtCssStyle.HOVER;
	this._activeDayClassName = " " + cn + "-" + DwtCssStyle.ACTIVE;
	this._hiliteClassName = " " + cn + "-hilited";
	this._greyClassName = " " + cn + "-grey";
	
	if (!this._readOnly) {
		this._installListeners();
	}

	this._selectionMode = DwtCalendar.DAY;
	
	this._init();

	this._weekDays = new Array(7);
	this._workingDays = params.workingDays || DwtCalendar._DEF_WORKING_DAYS;
    this._useISO8601WeekNo = params.useISO8601WeekNo;
	this.setFirstDayOfWeek(params.firstDayOfWeek || DwtCalendar.SUN);
	
	this._forceRollOver = (params.forceRollOver !== false);
};

DwtCalendar.PARAMS = ["parent", "className", "posStyle", "firstDayOfWeek", "forceRollOver",
					  "workingDaysArray", "hidePrevNextMo", "readOnly"];

DwtCalendar.prototype = new DwtComposite;
DwtCalendar.prototype.constructor = DwtCalendar;

/**
 * Sunday.
 */
DwtCalendar.SUN = 0;
/**
 * Monday.
 */
DwtCalendar.MON = 1;
/**
 * Tuesday.
 */
DwtCalendar.TUE = 2;
/**
 * Wednesday.
 */
DwtCalendar.WED = 3;
/**
 * Thursday.
 */
DwtCalendar.THU = 4;
/**
 * Friday.
 */
DwtCalendar.FRI = 5;
/**
 * Saturday.
 */
DwtCalendar.SAT = 6;

// Selection modes
/**
 * Defines the "day" selection mode.
 */
DwtCalendar.DAY = 1;
/**
 * Defines the "week" selection mode.
 */
DwtCalendar.WEEK = 2;
/**
 * Defines the "work week" selection mode.
 */
DwtCalendar.WORK_WEEK = 3;
/**
 * Defines the "month" selection mode.
 */
DwtCalendar.MONTH = 4;

DwtCalendar.RANGE_CHANGE = "DwtCalendar.RANGE_CHANGE";

DwtCalendar._FULL_WEEK = [1, 1, 1, 1, 1, 1, 1];
DwtCalendar._DEF_WORKING_DAYS = [0, 1, 1, 1, 1, 1, 0];
DwtCalendar._DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

DwtCalendar._NO_MONTH = -2;
DwtCalendar._PREV_MONTH = -1;
DwtCalendar._THIS_MONTH = 0;
DwtCalendar._NEXT_MONTH = 1;

DwtCalendar._NORMAL = 1;
DwtCalendar._HOVERED = 2;
DwtCalendar._ACTIVE = 3;
DwtCalendar._SELECTED = 4;
DwtCalendar._DESELECTED = 5;

DwtCalendar.DATE_SELECTED 		= 1;
DwtCalendar.DATE_DESELECTED 	= 2;
DwtCalendar.DATE_DBL_CLICKED 	= 3;

DwtCalendar._LAST_DAY_CELL_IDX = 41;

DwtCalendar._BUTTON_CLASS = "DwtCalendarButton";
DwtCalendar._BUTTON_HOVERED_CLASS = DwtCalendar._BUTTON_CLASS + "-" + DwtCssStyle.HOVER;
DwtCalendar._BUTTON_ACTIVE_CLASS = DwtCalendar._BUTTON_CLASS + "-" + DwtCssStyle.ACTIVE;

DwtCalendar._TITLE_CLASS = "DwtCalendarTitle";
DwtCalendar._TITLE_HOVERED_CLASS = DwtCalendar._TITLE_CLASS + "-" + DwtCssStyle.HOVER;
DwtCalendar._TITLE_ACTIVE_CLASS = DwtCalendar._TITLE_CLASS + "-" + DwtCssStyle.ACTIVE;

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtCalendar.prototype.toString = 
function() {
	return "DwtCalendar";
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.removeSelectionListener = 
function(listener) { 
	this.removeListener(DwtEvent.SELECTION, listener);
};

/**
 * Adds an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.addActionListener = 
function(listener) {
	this.addListener(DwtEvent.ACTION, listener);
};

/**
 * Removes an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.removeActionListener = 
function(listener) { 
	this.removeListener(DwtEvent.ACTION, listener);
};

/**
 * Adds a date range listener. Date range listeners are called whenever the date range of the calendar
 * changes (i.e. when it rolls over due to a programatic action via {@link #setDate} or
 * via user selection).
 *
 * @param 	{AjxListener}		listener		the listener
 */
DwtCalendar.prototype.addDateRangeListener = 
function(listener) {
	this.addListener(DwtEvent.DATE_RANGE, listener);
};

/**
 * Removes a date range listener.
 * 
 * @param 	{AjxListener}		listener		the listener
 */
DwtCalendar.prototype.removeDateRangeListener = 
function(listener) { 
	this.removeListener(DwtEvent.DATE_RANGE, listener);
};

/**
 * Sets the skip notify on page. This method notify (or not) selection when paging arrow buttons
 * are clicked.
 *
 * @param	{boolean}	skip		if <code>true</code>, do not notify selection
 */
DwtCalendar.prototype.setSkipNotifyOnPage = 
function(skip) {
	this._skipNotifyOnPage = skip;
};

/**
 * Gets the skip notify on page setting.
 * 
 * @return	{boolean}	<code>true</code>, do not notify selection
 */
DwtCalendar.prototype.getSkipNotifyOnPage = 
function() {
	return this._skipNotifyOnPage;
};

/**
 * Sets the date.
 * 
 * @param	{Date}	date	the date
 * @param	{boolean}	skipNotify		if <code>true</code>, do not notify selection
 * @param {boolean}	forceRollOver 	if <code>true</code>, then clicking on (or setting) the widget to a 
 *												date that is not part of the current month (i.e. one of 
 *												the grey prev or next month days) will result in the 
 *												widget rolling 	the date to that month.
 * @param	{boolean}	dblClick		if <code>true</code>, require a double click
 */
DwtCalendar.prototype.setDate =
function(date, skipNotify, forceRollOver, dblClick) {

	forceRollOver = (forceRollOver == null) ? this._forceRollOver : forceRollOver;
	
	// Check if the date is available for selection. Basically it is unless we are in
	// work week selection mode and <date> is not a working day
	//if (this._selectionMode == DwtCalendar.WORK_WEEK && !this._currWorkingDays[date.getDay()])
	//	return false;

	if(!date) {
		date = new Date();
	}
	var newDate = new Date(date.getTime());
	var oldDate = this._date;

	var layout = false;
	var notify = false;
	var cellId;

	if (this._date2CellId != null) {
		var idx = (newDate.getFullYear() * 10000) + (newDate.getMonth() * 100) + newDate.getDate();
		var cellId = this._date2CellId[idx];
		
		if (cellId) {
		 	if (cellId == this._selectedCellId)
		 		notify = true;

			var cell = document.getElementById(cellId);
			if (cell._dayType == DwtCalendar._THIS_MONTH)
				notify = true;
			else if (forceRollOver)
				notify = layout = true;
			else
				notify = true;
		} else {
			 notify = layout = true;
		}
	} else {
		notify = layout = true;
	}

	// update before layout, notify after layout
	if (notify) {
		if (this._date){
			// 5/13/2005 EMC -- I'm not sure why this was setting the hours to 0.
			// I think it should respect what the user passed in, and only change
			// the parts of the date that it is responsible for.
			//newDate.setHours(0,0,0,0);
			//handle daylight saving
			if(AjxDateUtil.isDayShifted(newDate)) {
				AjxDateUtil.rollToNextDay(newDate);
			}
			newDate.setHours(this._date.getHours(), this._date.getMinutes(), this._date.getSeconds(), 0);            
		}

		this._date = newDate;
		if (!layout && !this._readOnly) {
			this._setSelectedDate();
			this._setToday();
		}
	}

	if (layout) {
		this._layout();
	}

	if (notify && !skipNotify) {
		var type = dblClick ? DwtCalendar.DATE_DBL_CLICKED : DwtCalendar.DATE_SELECTED;
		this._notifyListeners(DwtEvent.SELECTION, type, this._date);
	}
	
	return true;
};

/**
 * Checks if the cell is selected.
 * 
 * @param	{string}	cellId			the cell id	
 * @return	{boolean}	<code>true</code> if the cell is the selected day
 */
DwtCalendar.prototype.isSelected =
function(cellId) {
	// if cellId is the selected day, then return true, else if we are NOT in
	// day selection mode (i.e. week/work week) then compute the row and index
	// of cellId and look it up in the week array to see if it is a selectable day
	if (cellId == this._selectedDayElId) {
		return true;
	} else if (this._selectionMode != DwtCalendar.DAY) {
		// If the cell is in the same row as the currently selected cell and it
		// is a selectable day (i.e. a working day in the case of work week),
		// then say it is selected
		var cellIdx = this._getDayCellIndex(cellId);
		if (Math.floor(cellIdx / 7) == Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7)
			&& this._currWorkingDays[cellIdx % 7])
			return true;
	}
	return false;
};

/**
 * Gets the force roll over setting. Force roll over is occurs when a date that
 * is not part of the current month (i.e. one of the grey prev or next month
 * days) will result in the widget rolling 	the date to that month.
 * 
 * @return	{boolean}	<code>true</code> if force roll over is set
 */
DwtCalendar.prototype.getForceRollOver =
function() {
	return this._forceRollOver;
};

/**
 * Sets the force roll over setting. Force roll over is occurs when a date that
 * is not part of the current month (i.e. one of the grey prev or next month
 * days) will result in the widget rolling 	the date to that month.
 * 
 * @param	{boolean}	force		if <code>true</code>, force roll over
 */
DwtCalendar.prototype.setForceRollOver =
function(force) {
	if (force == null) { return; }
	
	if (this._forceRollOver != force) {
		this._forceRollOver = force;
		this._layout();
	}
};

/**
 * Gets the selection mode.
 * 
 * @return	{constant}		the selection mode
 */
DwtCalendar.prototype.getSelectionMode =
function() {
	return this._selectionMode;
};

/**
 * Sets the selection mode.
 * 
 * @return	{constant}		selectionMode		the selection mode
 */
DwtCalendar.prototype.setSelectionMode =
function(selectionMode) {
	if (this._selectionMode == selectionMode) { return; }

	this._selectionMode = selectionMode;
	if (selectionMode == DwtCalendar.WEEK) {
		this._currWorkingDays = DwtCalendar._FULL_WEEK;
	} else if (selectionMode == DwtCalendar.WORK_WEEK) {
		this._currWorkingDays = this._workingDays;
	}

	this._layout();
};

/**
 * Sets the working week.
 * 
 * @param	{array}	workingDaysArray		an array of days
 */
DwtCalendar.prototype.setWorkingWeek =
function(workingDaysArray) {
	// TODO Should really create a copy of workingDaysArray
	this._workingDays = this._currWorkingDays = workingDaysArray;
	
	if (this._selectionMode == DwtCalendar.WORK_WEEK) {
		DBG.println("FOO!!!");
		this._layout();
	}
};

/**
 * Enables/disables the highlight (i.e. "bolding") on the dates in <code>&lt;dates&gt;</code>.
 *
 * @param {object} dates associative array of {@link Date} objects for
 * which to enable/disable highlighting
 * @param {boolean}	enable 	if <code>true</code>, enable highlighting
 * @param {boolean}	clear 	if <code>true</code>, clear current highlighting
 */
DwtCalendar.prototype.setHilite =
function(dates, enable, clear) {
	if (this._date2CellId == null) { return; }

	var cell;
	var aDate;
	if (clear) {
		for (aDate in this._date2CellId) {
			cell = document.getElementById(this._date2CellId[aDate]);
			if (cell._isHilited) {
				cell._isHilited = false;
				this._setClassName(cell, DwtCalendar._NORMAL);
			}	
		}
	}

	var cellId;
	for (var i in dates) {
        // NOTE: Protect from prototype extensions.
        if (dates.hasOwnProperty(i)) {
            aDate = dates[i];
            cellId = this._date2CellId[aDate.getFullYear() * 10000 + aDate.getMonth() * 100 + aDate.getDate()];

            if (cellId) {
                cell = document.getElementById(cellId);
                if (cell._isHilited != enable) {
                    cell._isHilited = enable;
                    this._setClassName(cell, DwtCalendar._NORMAL);
                }
            }
        }
	}
};

/**
 * Gets the date.
 * 
 * @return	{Date}	the date
 */
DwtCalendar.prototype.getDate =
function() {
	return this._date;
};

/**
 * Sets the first date of week.
 * 
 * @param	{constant}		firstDayOfWeek		the first day of week
 */
DwtCalendar.prototype.setFirstDayOfWeek =
function(firstDayOfWeek) {
	for (var i = 0; i < 7; i++) {
		this._weekDays[i] = (i < firstDayOfWeek)
			? (6 - (firstDayOfWeek -i - 1))
			: (i - firstDayOfWeek);

		var dowCell = document.getElementById(this._getDOWCellId(i));
		dowCell.innerHTML = AjxDateUtil.WEEKDAY_SHORT[(firstDayOfWeek + i) % 7];
	}
    this._firstDayOfWeek = firstDayOfWeek
	this._layout();
};

/**
 * Gets the date range.
 * 
 * @return	{Object}		the range (<code>range.start</code> and <code>range.end</code>)
 */
DwtCalendar.prototype.getDateRange =
function () {
	return this._range;
};

DwtCalendar.prototype._getDayCellId =
function(cellId) {
	return ("c:" + cellId + ":" + this._uuid);
};

DwtCalendar.prototype._getDayCellIndex =
function(cellId) {
	return cellId.substring(2, cellId.indexOf(":", 3));
};

DwtCalendar.prototype._getDOWCellId =
function(cellId) {
	return ("w:" + cellId + ":" + this._uuid);
};

DwtCalendar.prototype._getWeekNumberCellId =
function(cellId) {
	return ("k:" + cellId + ":" + this._uuid);
};

DwtCalendar.prototype._getDaysInMonth =
function(mo, yr) {
	/* If we are not dealing with Feb, then simple lookup
	 * Leap year rules
	 *  1. Every year divisible by 4 is a leap year.
	 *  2. But every year divisible by 100 is NOT a leap year
	 *  3. Unless the year is also divisible by 400, then it is still a leap year.*/
	if (mo != 1) {
		return DwtCalendar._DAYS_IN_MONTH[mo];
	}

	if (yr % 4 != 0 || (yr % 100 == 0 && yr % 400 != 0)) {
		return 28;
	}

	return 29;
};

DwtCalendar.prototype._installListeners =
function() {
	this._setMouseEventHdlrs();
	this.addListener(DwtEvent.ONMOUSEOVER, new AjxListener(this, this._mouseOverListener));
	this.addListener(DwtEvent.ONMOUSEOUT, new AjxListener(this, this._mouseOutListener));
	this.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
	this.addListener(DwtEvent.ONMOUSEUP, new AjxListener(this, this._mouseUpListener));
	this.addListener(DwtEvent.ONDBLCLICK, new AjxListener(this, this._doubleClickListener));
};

DwtCalendar.prototype._notifyListeners =
function(eventType, type, detail, ev) {
	if (!this.isListenerRegistered(eventType)) { return; }

	var selEv = DwtShell.selectionEvent;
	if (ev) {
		DwtUiEvent.copy(selEv, ev);
	} else {
		selEv.reset();
	}
	selEv.item = this;
	selEv.detail = detail;
	selEv.type = type;
	this.notifyListeners(eventType, selEv);
};

DwtCalendar.prototype._layout =
function() {
	if (this._date == null) { this._date = new Date(); }

	if (!this._calWidgetInited) {
		this._init();
	}

	var date = new Date(this._date.getTime());
	date.setDate(1);
	var year = date.getFullYear();
	var month  = date.getMonth();
	var firstDay = date.getDay();
	var daysInMonth = this._getDaysInMonth(month, year);
	var day = 1;
	var nextMoDay = 1;

	this._date2CellId = new Object();
	this._selectedDayElId = null;

	// Figure out how many days from the previous month we have to fill in
	// (see comment below)
	var lastMoDay, lastMoYear, lastMoMonth, nextMoMonth, nextMoYear;
	if (!this._hidePrevNextMo) {
		if (month != 0) {
			lastMoDay = this._getDaysInMonth(month - 1, year) - this._weekDays[firstDay] + 1;
			lastMoYear = year;
			lastMoMonth = month - 1;
			if (month != 11) {
				nextMoMonth = month + 1;
				nextMoYear = year;
			} else {
				nextMoMonth = 0;
				nextMoYear = year + 1;
			}
		} else {
			lastMoDay = this._getDaysInMonth(11, year - 1) - this._weekDays[firstDay] + 1;
			lastMoYear = year - 1;
			lastMoMonth = 11;
			nextMoMonth = 1;
			nextMoYear = year;
		}
	}

	for (var i = 0; i < 6; i++) {
		for (var j = 0; j < 7; j++) {
			var dayCell = document.getElementById(this._getDayCellId(i * 7 + j));

			if (dayCell._isHilited == null) {
				dayCell._isHilited = false;
			}

			if (day <= daysInMonth) {
				/* The following if statement deals with the first day of this month not being
				 * the first day of the week. In this case we must fill the preceding days with
				 * the final days of the previous month */
				if (i != 0 || j >= this._weekDays[firstDay]) {
					this._date2CellId[(year * 10000) + (month * 100) + day] = dayCell.id;
					dayCell._day = day;
					dayCell._month = month;
					dayCell._year = year;
					dayCell.innerHTML = day++;
					dayCell._dayType = DwtCalendar._THIS_MONTH;
					if (this._readOnly) {
						dayCell.style.fontFamily = "Arial";
						dayCell.style.fontSize = "10px";
					}
				} else {
					if (this._hidePrevNextMo) {
						dayCell.innerHTML = "";
					} else {
						this._date2CellId[(lastMoYear * 10000) + (lastMoMonth * 100) + lastMoDay] = dayCell.id;
						dayCell._day = lastMoDay;
						dayCell._month = lastMoMonth;
						dayCell._year = lastMoYear;
						dayCell.innerHTML = lastMoDay++;
						dayCell._dayType = DwtCalendar._PREV_MONTH;
					}
				}
			} else if (!this._hidePrevNextMo) {
				// Fill any remaining slots with days from next month
				this._date2CellId[(nextMoYear * 10000) + (nextMoMonth * 100) + nextMoDay] = dayCell.id;
				dayCell._day = nextMoDay;
				dayCell._month = nextMoMonth;
				dayCell._year = nextMoYear;
				dayCell.innerHTML = nextMoDay++;
				dayCell._dayType = DwtCalendar._NEXT_MONTH;
			}
			this._setClassName(dayCell, DwtCalendar._NORMAL);
		}

		if (this._showWeekNumber) {
			var kwCellId = this._getWeekNumberCellId('kw' + i * 7);
			var kwCell = document.getElementById(kwCellId);
			if (kwCell) {
				var firstDayCell = document.getElementById(this._getDayCellId(i * 7));
				kwCell.innerHTML = AjxDateUtil.getWeekNumber(new Date(firstDayCell._year, firstDayCell._month, firstDayCell._day), this._firstDayOfWeek, null, this._useISO8601WeekNo);
			}
		}
	}

	this._setTitle(month, year);

	// Compute the currently selected day
	if (!this._readOnly) {
		this._setSelectedDate();
		this._setToday();
	}
	
	this._setRange();
};

DwtCalendar.prototype._setRange =
function() {
	var cell = document.getElementById(this._getDayCellId(0));
	var start = new Date(cell._year, cell._month, cell._day, 0, 0, 0, 0);

	cell = document.getElementById(this._getDayCellId(DwtCalendar._LAST_DAY_CELL_IDX));
	
	var daysInMo = this._getDaysInMonth(cell._month, cell._year);
	var end;
	if (cell._day < daysInMo) {
		end = new Date(cell._year, cell._month, cell._day + 1, 0, 0, 0, 0);
	} else if (cell._month < 11) {
		end = new Date(cell._year, cell._month + 1, 1, 0, 0, 0, 0);
	} else {
		end = new Date(cell._year + 1, 0, 1, 0, 0, 0, 0);
	}

	if (this._range == null) {
		this._range = {};
	} else if (this._range.start.getTime() == start.getTime() && this._range.end.getTime() == end.getTime()) {
		return false;
	}

	this._range.start = start;
	this._range.end = end;

	// Notify any listeners
	if (!this.isListenerRegistered(DwtEvent.DATE_RANGE)) { return; }

	if (!this._dateRangeEvent) {
		this._dateRangeEvent = new DwtDateRangeEvent(true);
	}

	this._dateRangeEvent.item = this;
	this._dateRangeEvent.start = start;
	this._dateRangeEvent.end = end;
	this.notifyListeners(DwtEvent.DATE_RANGE, this._dateRangeEvent);
};

DwtCalendar.prototype._setToday =
function() {
	var cell;
	var today = new Date();
	var todayDay = today.getDate();

	if (!this._todayDay || this._todayDay != todayDay) {
		if (this._todayCellId != null) {
			cell = document.getElementById(this._todayCellId);
			cell._isToday = false;
			this._setClassName(cell, DwtCalendar._NORMAL);
		}

		this._todayCellId = this._date2CellId[(today.getFullYear() * 10000) + (today.getMonth() * 100) + todayDay];
		if (this._todayCellId != null) {
			cell = document.getElementById(this._todayCellId);
			cell._isToday = true;
			this._setClassName(cell, DwtCalendar._NORMAL);
		}
	}
};

DwtCalendar.prototype._setSelectedDate =
function() {
	var day = this._date.getDate();
	var month = this._date.getMonth();
	var year = this._date.getFullYear();
	var cell;

	if (this._selectedDayElId) {
		cell = document.getElementById(this._selectedDayElId);
		this._setClassName(cell, DwtCalendar._DESELECTED);
	}

	var cellId = this._date2CellId[(year * 10000) + (month * 100) + day];
	cell = document.getElementById(cellId);
	this._selectedDayElId = cellId;
	this._setClassName(cell, DwtCalendar._SELECTED);
};

DwtCalendar.prototype._setCellClassName = 
function(cell, className, mode) {
	if (cell._dayType != DwtCalendar._THIS_MONTH) {
		className += this._greyClassName;
	}

	if (this._selectionMode == DwtCalendar.DAY &&
		cell.id == this._selectedDayElId &&
		mode != DwtCalendar._DESELECTED)
	{
		className += this._selectedDayClassName;
	}
	else if (this._selectionMode != DwtCalendar.DAY &&
			 mode != DwtCalendar._DESELECTED &&
			 this._selectedDayElId != null)
	{
		var idx = this._getDayCellIndex(cell.id);
		if (Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7) == Math.floor(idx / 7) &&
			this._currWorkingDays[idx % 7])
		{
			className += this._selectedDayClassName;
		}
	}

	if (cell._isHilited) {
		className += this._hiliteClassName;
	}

	if (cell._isToday) {
		className += this._todayClassName;
	}

	return className;
};

DwtCalendar.prototype._setClassName = 
function(cell, mode) {
	var className = "";
	
	if (mode == DwtCalendar._NORMAL) {
		className = this._origDayClassName;
	} else if (mode == DwtCalendar._HOVERED) {
		className = this._hoveredDayClassName;
	} else if (mode == DwtCalendar._ACTIVE) {
		className = this._activeDayClassName;
	} else if (mode == DwtCalendar._DESELECTED && this._selectionMode == DwtCalendar.DAY) {
		className = this._origDayClassName;
	} else if (this._selectionMode != DwtCalendar.DAY &&
			(mode == DwtCalendar._SELECTED || mode == DwtCalendar._DESELECTED))
	{
		// If we are not in day mode, then we need to highlite multiple cells
		// e.g. the whole week if we are in week mode
		var firstCellIdx = Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7) * 7;

		for (var i = 0; i < 7; i++) {
			className = this._origDayClassName;
			var aCell = document.getElementById(this._getDayCellId(firstCellIdx++));
			aCell.className = this._setCellClassName(aCell, className, mode);
		}
		return;
	}

	cell.className = this._setCellClassName(cell, className, mode);
};

DwtCalendar.prototype._setTitle =
function(month, year) {
	var cell = document.getElementById(this._monthCell);
	var formatter = DwtCalendar.getMonthFormatter();
	var date = new Date(year, month);
	cell.innerHTML = formatter.format(date);
};

DwtCalendar.prototype._init =
function() {
	var html = new Array(100);
	var idx = 0;
	this._monthCell = "t:" + this._uuid;

	// Construct the header row with the prev/next year and prev/next month
	// icons as well as the month/year title cell
	html[idx++] =	"<table width=100%>";
	html[idx++] =		"<tr><td class='DwtCalendarTitlebar'>";
	html[idx++] =			"<table>";
	html[idx++] =				"<tr>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:py:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("FastRevArrowSmall", null, ["id='b:py:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:pm:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("RevArrowSmall", null, ["id='b:pm:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =					"<td class='DwtCalendarTitleCell' 'nowrap' style='width: 60%'><span class='";
	html[idx++] =						DwtCalendar._TITLE_CLASS;
	html[idx++] = 						"' id='";
	html[idx++] =						this._monthCell;
	html[idx++] =					"'></span></td>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:nm:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("FwdArrowSmall", null, ["id='b:nm:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:ny:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("FastFwdArrowSmall", null, ["id='b:ny:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =				"</tr>";
	html[idx++] =			"</table>";
	html[idx++] =		"</td></tr>";
	html[idx++] =	"<tr><td class='DwtCalendarBody'>";
	html[idx++] =		"<table width='100%' style='border-collapse:separate;' cellspacing='0'>";
	html[idx++] =			"<tr>";

	if (this._showWeekNumber) {
		html[idx++] = "<td class='DwtCalendarWeekNoTitle' width='14%' id='";
		html[idx++] = this._getWeekNumberCellId('kw');
		html[idx++] = "'>";
		html[idx++] = AjxMsg.calendarWeekTitle;
		html[idx++] = "</td>";
	}

	for (var i = 0; i < 7; i++) {
		html[idx++] = "<td class='DwtCalendarDow' width='";
		html[idx++] = (i < 5 ? "14%" : "15%");
		html[idx++] = "' id='";
		html[idx++] = this._getDOWCellId(i);
		html[idx++] = "'>&nbsp;</td>";
	}
	html[idx++] = "</tr>";

	for (var i = 0; i < 6; i++) {
		html[idx++] = "<tr>";
		if (this._showWeekNumber) {
			html[idx++] = "<td class='DwtCalendarWeekNo' id='" + this._getWeekNumberCellId('kw' + i * 7) + "'>&nbsp;</td>";
		}
		for (var j = 0; j < 7; j++) {
			html[idx++] = "<td id='";
			html[idx++] = this._getDayCellId(i * 7 + j);
			html[idx++] = "'>&nbsp;</td>";
		}
		html[idx++] ="</tr>";
	}

	html[idx++] = "</td></tr></table></table>";

	this.getHtmlElement().innerHTML = html.join("");
	if (!this._readOnly) {
		document.getElementById("b:py:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FastRevArrowSmall");
		document.getElementById("b:pm:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("RevArrowSmall");
		document.getElementById("b:nm:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FwdArrowSmall");
		document.getElementById("b:ny:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FastFwdArrowSmall");
	}

	this._calWidgetInited = true;
};

/**
 * Sets the mouse over day callback.
 * 
 * @param	{AjxCallback}		callback		the callback
 */
DwtCalendar.prototype.setMouseOverDayCallback =
function(callback) {
	this._mouseOverDayCB = callback;
};

/**
 * Sets the mouse out day callback.
 * 
 * @param	{AjxCallback}		callback		the callback
 */
DwtCalendar.prototype.setMouseOutDayCallback =
function(callback) {
	this._mouseOutDayCB = callback;
};

/**
 * Gets the date value for the last cell that the most recent
 * Drag-and-drop operation occurred over. Typically it will be called by a DwtDropTarget
 * listener when an item is dropped onto the mini calendar
 * 
 * @return	{Date}		the date or <code>null</code> for none
 */
DwtCalendar.prototype.getDndDate =
function() {
	var dayCell = this._lastDndCell;
	if (dayCell) {
		return new Date(dayCell._year, dayCell._month, dayCell._day);
	}

	return null;
};

// Temp date used for callback in mouseOverListener
DwtCalendar._tmpDate = new Date();
DwtCalendar._tmpDate.setHours(0, 0, 0, 0);

DwtCalendar.prototype._mouseOverListener = 
function(ev) {
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._HOVERED);
		// If a mouse over callback has been registered, then call it to give it
		// chance do work like setting the tooltip content
		if (this._mouseOverDayCB) {
			DwtCalendar._tmpDate.setFullYear(target._year, target._month, target._day);
			this._mouseOverDayCB.run(this, DwtCalendar._tmpDate);
		}
	} else if (target.id.charAt(0) == 't') {
		// Dont activate title for now
		return;
	} else if (target.id.charAt(0) == 'b') {
		var img;
		if (target.firstChild == null) {
			img = target;
			AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_HOVERED_CLASS;
		} else {
			target.className = DwtCalendar._BUTTON_HOVERED_CLASS;
			img = AjxImg.getImageElement(target);
		}
		img.className = img._origClassName;
	}

	ev._stopPropagation = true;
};

DwtCalendar.prototype._mouseOutListener = 
function(ev) {
	this.setToolTipContent(null);
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._NORMAL);
		if (this._mouseOutDayCB) {
			this._mouseOutDayCB.run(this);
		}
	} else if (target.id.charAt(0) == 'b') {
		var img;
		target.className = DwtCalendar._BUTTON_CLASS;
		if (target.firstChild == null) {
			img = target;
			AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_CLASS;
		} else {
			target.className = DwtCalendar._BUTTON_CLASS;
			img = AjxImg.getImageElement(target);
		}
		img.className = img._origClassName;
	}
};

DwtCalendar.prototype._mouseDownListener = 
function(ev) {
	if (ev.button == DwtMouseEvent.LEFT) {
		var target = ev.target;
		if (target.id.charAt(0) == 'c') {
			this._setClassName(target, DwtCalendar._ACTIVE);
		} else if (target.id.charAt(0) == 't') {
			target.className = DwtCalendar._TITLE_ACTIVE_CLASS;
		} else if (target.id.charAt(0) == 'b') {
			var img;
			if (target.firstChild == null) {
				img = target;
				AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_ACTIVE_CLASS;
			} else {
				target.className = DwtCalendar._BUTTON_ACTIVE_CLASS;
				img = AjxImg.getImageElement(target);
			}
			img.className = img._origClassName;
		} else if (target.id.charAt(0) == 'w') {
		}
	}
};

DwtCalendar.prototype._mouseUpListener = 
function(ev) {
	var target = ev.target;
	if (ev.button == DwtMouseEvent.LEFT) {
		if (target.id.charAt(0) == 'c') {
			// If our parent is a menu then we need to have it close
			if (this.parent instanceof DwtMenu)
				DwtMenu.closeActiveMenu();

            var sDate = new Date(target._year, target._month, target._day);
            if(sDate.getDate() != target._day) {
                sDate.setDate(target._day);                 
            }
			if (this.setDate(sDate)) { return; }

			this._setClassName(target, DwtCalendar._HOVERED);
		} else if (target.id.charAt(0) == 'b') {
			var img;
			if (target.firstChild == null) {
				img = target;
				AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_HOVERED_CLASS;
			} else {
				target.className = DwtCalendar._BUTTON_HOVERED_CLASS;
				img = AjxImg.getImageElement(target);
			}
			img.className = img._origClassName;
			
			if (img.id.indexOf("py") != -1) {
				this._prevYear();
			} else if (img.id.indexOf("pm") != -1) {
				this._prevMonth();
			} else if (img.id.indexOf("nm") != -1) {
				this._nextMonth();
			} else {
				this._nextYear();
			}
		} else if (target.id.charAt(0) == 't') {
			// TODO POPUP MENU
			target.className = DwtCalendar._TITLE_HOVERED_CLASS;
			this.setDate(new Date(), this._skipNotifyOnPage);
			// If our parent is a menu then we need to have it close
			if (this.parent instanceof DwtMenu) {
				DwtMenu.closeActiveMenu();
			}
		}
	} else if (ev.button == DwtMouseEvent.RIGHT && target.id.charAt(0) == 'c') {
		this._notifyListeners(DwtEvent.ACTION, 0, new Date(target._year, target._month, target._day), ev);
	}
};

DwtCalendar.prototype._doubleClickListener =
function(ev) {
	var target = ev.target;
	if (this._selectionEvent) {
		this._selectionEvent.type = DwtCalendar.DATE_DBL_CLICKED;
	}
	if (target.id.charAt(0) == 'c') {
		// If our parent is a menu then we need to have it close
		if (this.parent instanceof DwtMenu) {
			DwtMenu.closeActiveMenu();
		}
		this.setDate(new Date(target._year, target._month, target._day), false, false, true)
	}
};

DwtCalendar.prototype._prevMonth = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.MONTH, -1), this._skipNotifyOnPage);
};

DwtCalendar.prototype._nextMonth = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.MONTH, 1), this._skipNotifyOnPage);
};

DwtCalendar.prototype._prevYear = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.YEAR, -1), this._skipNotifyOnPage);
};

DwtCalendar.prototype._nextYear = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.YEAR, 1), this._skipNotifyOnPage);
};

/**
 * Gets the date formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDateFormatter =
function() {
	if (!DwtCalendar._dateFormatter) {
		DwtCalendar._dateFormatter = new AjxDateFormat(AjxMsg.formatCalDate);
	}
	return DwtCalendar._dateFormatter;
};

/**
 * Gets the date long formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDateLongFormatter =
function() {
	if (!DwtCalendar._dateLongFormatter) {
		DwtCalendar._dateLongFormatter = new AjxDateFormat(AjxMsg.formatCalDateLong);
	}
	return DwtCalendar._dateLongFormatter;
};

/**
 * Gets the date full formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDateFullFormatter =
function() {
	if (!DwtCalendar._dateFullFormatter) {
		DwtCalendar._dateFullFormatter = new AjxDateFormat(AjxMsg.formatCalDateFull);
	}
	return DwtCalendar._dateFullFormatter;
};

/**
 * Gets the hour formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getHourFormatter =
function() {
	if (!DwtCalendar._hourFormatter) {
		DwtCalendar._hourFormatter = new AjxMessageFormat(AjxMsg.formatCalHour);
	}
	return DwtCalendar._hourFormatter;
};

/**
 * Gets the day formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDayFormatter =
function() {
	if (!DwtCalendar._dayFormatter) {
		DwtCalendar._dayFormatter = new AjxDateFormat(AjxMsg.formatCalDay);
	}
	return DwtCalendar._dayFormatter;
};

/**
 * Gets the month formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getMonthFormatter =
function() {
	if (!DwtCalendar._monthFormatter) {
		DwtCalendar._monthFormatter = new AjxDateFormat(AjxMsg.formatCalMonth);
	}
	return DwtCalendar._monthFormatter;
};

/**
 * Gets the short month formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getShortMonthFormatter =
function() {
	if (!DwtCalendar._shortMonthFormatter) {
		DwtCalendar._shortMonthFormatter = new AjxDateFormat(AjxMsg.formatShortCalMonth);
	}
	return DwtCalendar._shortMonthFormatter;
};

DwtCalendar.prototype._dragEnter =
function(ev) {
};

DwtCalendar.prototype._dragHover =
function(ev) {
};

DwtCalendar.prototype._dragOver =
function(ev) {
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._HOVERED);
		this._lastDndCell = target;
	} else {
		this._lastDndCell = null;
	}
};

DwtCalendar.prototype._dragLeave =
function(ev) {
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtMessageComposite")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */


/**
 * Creates a composite that is populated from a message pattern.
 * @constructor
 * @class
 * This class allows you to create a composite that is populated from
 * a message pattern and inserts controls at the appropriate places.
 * For example, say that the message <code>MyMsg.repeatTimes</code> is
 * defined as the following:
 * <pre>
 * MyMsg.repeatTimes = "Repeat: {0} times";
 * </pre>
 * and you want to replace "{0}" with an input field or perhaps a
 * drop-down menu that enumerates a specific list of choices as part of
 * the application. To do this, you just create a
 * {@link DwtMessageComposite} and set the message format, like so:
 * <pre>
 * var comp = new DwtMessageComposite(parent);
 * comp.setFormat(MyMsg.repeatTimes);
 * </pre>
 * <p>
 * The message composite instantiates an {@link AjxMessageFormat}
 * from the specified message pattern. Then, for each segment it creates
 * static text or a {@link DwtInputField} for replacement segments
 * such as "{0}".
 * <p>
 * To have more control over the controls that are created and inserted
 * into the resulting composite, you can pass a callback object to the
 * method. Each time that a replacement segment is found in the
 * message pattern, the callback is called with the following parameters:
 * <ul>
 * <li>a reference to this message composite object;
 * <li>a reference to the segment object.
 * <li>the index at which the segment was found in the message pattern; and
 * </ul>
 * The segment object will be an instance of
 * <code>AjxMessageFormat.MessageSegment</code> and has the following
 * methods of interest:
 * <ul>
 * <li>toSubPattern
 * <li>getIndex
 * <li>getType
 * <li>getStyle
 * <li>getSegmentFormat
 * </ul>
 * <p>
 * The callback can use this information to determine whether or not
 * a custom control should be created for the segment. If the callback
 * returns <code>null</code>, a standard {@link DwtInputField} is
 * created and inserted. Note: if the callback returns a custom control,
 * it <em>must</em> be an instance of {@link AjxControl}.
 * <p>
 * Here is an example of a message composite created with a callback
 * that generates a custom control for each replacement segment:
 * <pre>
 * function createCustomControl(parent, segment, i) {
 *     return new DwtInputField(parent);
 * }
 *
 * var compParent = ...;
 * var comp = new DwtMessageComposite(compParent);
 *
 * var message = MyMsg.repeatTimes;
 * var callback = new AjxCallback(null, createCustomControl);
 * comp.setFormat(message, callback);
 * </pre>
 *
 * @author Andy Clark
 *
 * @param {Object}		params		hash of params:
 * @param {DwtComposite}	parent    the parent widget.
 * @param {string}	className 	the CSS class
 * @param {constant}	posStyle  		the position style (see {@link DwtControl})
 * @param {DwtComposite}	parent    the parent widget.
 * @param {string}	format   the message that defines the text and controls within this composite control
 * @param {AjxCallback}	[controlCallback]   the callback to create UI components (only used with format specified)
 * @param {AjxCallback}	[hintsCallback]   the callback to provide display hints for the container element of the UI component (only used with format specified)
 * 
 * @extends		DwtComposite
 */
DwtMessageComposite = function(params) {
	if (arguments.length == 0) return;

	params = Dwt.getParams(arguments, DwtMessageComposite.PARAMS);

	if (!params.className) {
		params.className = "DwtMessageComposite";
	}

	DwtComposite.call(this, params);

	this._tabGroup = new DwtTabGroup("DwtMessageComposite");

	if (params.format) {
		this.setFormat(params.format,
		               params.controlCallback,
		               params.hintsCallback);
	}
}

DwtMessageComposite.PARAMS = ['parent', 'className', 'posStyle'];

DwtMessageComposite.prototype = new DwtComposite;
DwtMessageComposite.prototype.constructor = DwtMessageComposite;
DwtMessageComposite.prototype.isDwtMessageComposite = true;

DwtMessageComposite.prototype.toString =
function() {
	return "DwtMessageComposite";
}

// Public methods

/**
 * Sets the format.
 * 
 * @param {string}	message   the message that defines the text and controls that comprise this composite
 * @param {AjxCallback}	[callback]   the callback to create UI components
 * @param {AjxCallback}	[hintsCallback]   the callback to provide display hints for the container element of the UI component
 */
DwtMessageComposite.prototype.setFormat =
function(message, callback, hintsCallback) {
    // create formatter
    this._formatter = new AjxMessageFormat(message);
    this._controls = {};

    // create HTML
    var id = this._htmlElId;
    this.getHtmlElement().innerHTML = "<table class='DwtCompositeTable' border='0' cellspacing='0' cellpadding='0'><tr valign='center'></tr></table>";
    var row = this.getHtmlElement().firstChild.rows[0];

    var segments = this._formatter.getSegments();
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        var isMsgSegment = segment instanceof AjxMessageFormat.MessageSegment;

        var cid = [id,i].join("_");
        var cell = document.createElement('TD');

        cell.id = cid;
        cell.className = 'DwtCompositeCell';
        row.appendChild(cell);

        if (isMsgSegment) {
            cell.className += ' MessageControl' + segment.getIndex();
            var control = callback ? callback.run(this, segment, i) : null;
            if (!control) {
                control = new DwtInputField({parent:this, parentElement: cell});
            } else {
                control.reparentHtmlElement(cell);
            }
            this._tabGroup.addMember(control.getTabGroupMember());
            if (hintsCallback) {
                var hints = hintsCallback.run(this, segment, i);

                AjxUtil.hashUpdate(control.getHtmlElement(), hints, true);
            }

            var sindex = segment.getIndex();
            this._controls[sindex] = this._controls[sindex] || control;
        }
        else {
            control = new DwtText({parent:this, parentElement: cell});
            control.setText(segment.toSubPattern());
            this._tabGroup.addMember(control);
        }
    }
};

/**
 * Gets the format.
 * 
 * @return	{string}	the format
 */
DwtMessageComposite.prototype.format = function() {
    var args = [];
    for (var sindex in this._controls) {
        args[sindex] = this._controls[sindex].getValue();
    }
    return this._formatter.format(args);
};

DwtMessageComposite.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};
}

if (AjxPackage.define("ajax.util.AjxDateUtil")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * 
 * @private
 */
AjxDateUtil = function() {
};

AjxDateUtil.YEAR		= 1;
AjxDateUtil.MONTH		= 2;
AjxDateUtil.WEEK		= 3;
AjxDateUtil.DAY			= 4;
AjxDateUtil.TWO_WEEKS	= 5;

AjxDateUtil.MSEC_PER_MINUTE = 60000;
AjxDateUtil.MSEC_PER_FIFTEEN_MINUTES = 900000;
AjxDateUtil.MSEC_PER_HALF_HOUR = 1800000;
AjxDateUtil.MSEC_PER_HOUR = 3600000;
AjxDateUtil.MSEC_PER_DAY = 24 * AjxDateUtil.MSEC_PER_HOUR;

AjxDateUtil.MINUTES_PER_DAY = 60 * 24;
AjxDateUtil.SECONDS_PER_DAY = 60 * 60 * 24;

AjxDateUtil.DAYS_PER_WEEK = 7;

AjxDateUtil.WEEKDAY_SHORT = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.SHORT];
AjxDateUtil.WEEKDAY_MEDIUM = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.MEDIUM];
AjxDateUtil.WEEKDAY_LONG = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.LONG];

AjxDateUtil.MONTH_SHORT = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT];
AjxDateUtil.MONTH_MEDIUM = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM];
AjxDateUtil.MONTH_LONG = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG];

AjxDateUtil._daysPerMonth = {
	0:31,
	1:29,
	2:31,
	3:30,
	4:31,
	5:30,
	6:31,
	7:31,
	8:30,
	9:31,
	10:30,
	11:31
};

AjxDateUtil.MAX_DAYS_PER_MONTH = 31;

AjxDateUtil.WEEK_ONE_JAN_DATE = 1;

AjxDateUtil._init =
function() {
	AjxDateUtil._dateFormat = AjxDateFormat.getDateInstance(AjxDateFormat.SHORT).clone();
	var segments = AjxDateUtil._dateFormat.getSegments();
	for (var i = 0; i < segments.length; i++) {
		if (segments[i] instanceof AjxDateFormat.YearSegment) {
			segments[i] = new AjxDateFormat.YearSegment(AjxDateUtil._dateFormat, "yyyy");
		}
	}
	AjxDateUtil._dateTimeFormat = 
		new AjxDateFormat(AjxDateUtil._dateFormat.toPattern() + " " + AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT));

	AjxDateUtil._dateFormatNoYear = new AjxDateFormat(AjxMsg.formatDateMediumNoYear);
};

AjxDateUtil._init();                    

/* return true if the specified date (yyyy|yy, m (0-11), d (1-31)) 
 * is valid or not.
 */
AjxDateUtil.validDate =
function(y, m, d) {
	var date = new Date(y, m, d);
	var year = y > 999 ? date.getFullYear() : date.getYear();
	return date.getMonth() == m && date.getDate() == d && year == y;
};

/* return number of days (1-31) in specified month (yyyy, mm (0-11))
 */
AjxDateUtil.daysInMonth =
function(y, m) {
	var date = new Date(y, m, 1, 12);
	date.setMonth(date.getMonth()+1);
	date.setDate(date.getDate()-1);
	return date.getDate();
};

/* return true if year is a leap year
 */
AjxDateUtil.isLeapYear =
function(y) {
	return (new Date(y, 1, 29)).getMonth() == 1;
};

/* returns true if user's locale uses 24-hour time
 */
AjxDateUtil.isLocale24Hour =
function() {
	// XXX: is there better/easier way to determine this?!
	var timeFormatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	var len = timeFormatter._segments.length;
	for (var j = 0; j < len; j++) {
		if (timeFormatter._segments[j]._s == "a")
			return false;
	}
	return true;
};

/**
 * rolls the month/year. If the day of month in the date passed in is greater
 * then the max day in the new month, set it to the max. The date passed in is
 * modified and also returned.
 */
AjxDateUtil.roll = 
function(date, field, offset) {
	var d = date.getDate();
	 // move back to first day before rolling in case previous
	 // month/year has less days

	if (field == AjxDateUtil.MONTH) {
		date.setDate(1);	
		date.setMonth(date.getMonth() + offset);
		var max = AjxDateUtil.daysInMonth(date.getFullYear(), date.getMonth());
		date.setDate(Math.min(d, max));		
	} else if (field == AjxDateUtil.YEAR) {
		date.setDate(1);		
		date.setFullYear(date.getFullYear() + offset);
		var max = AjxDateUtil.daysInMonth(date.getFullYear(), date.getMonth());
		date.setDate(Math.min(d, max));		
	} else if (field == AjxDateUtil.WEEK) {
		date.setDate(date.getDate() + 7*offset);
	} else if (field == AjxDateUtil.DAY) {
		date.setDate(date.getDate() + offset);
	} else if (field == AjxDateUtil.TWO_WEEKS) {
		date.setDate(date.getDate() + 14*offset);
	} else {
		return date;
	}
	return date;
};

/**
 * checks whether given date is derived from DST shift
 */
AjxDateUtil.isDayShifted =
function(date) {
    var refDate = new Date(date.getTime());

    //advance it by 1 day and reset to beginning of the day
    refDate.setDate(refDate.getDate() +1)
    refDate.setHours(0,0,0,0);

    //if DST has no effect the advanced time should differ from given time
    return refDate.getTime() == date.getTime();
};

/**
 * rolls to next day. This can be used to roll to next day avoiding the daylight saving shift in time.
 */
AjxDateUtil.rollToNextDay =
function(date) {
    date.setHours(0,0,0,0);
    date.setTime(date.getTime() + AjxDateUtil.MSEC_PER_DAY);
};

// Computes the difference between now and <dateMSec>. Returns a string describing
// the difference
AjxDateUtil.computeDateDelta =
function(dateMSec) {
	var deltaMSec = (new Date()).getTime() - dateMSec;
	var durationStr = AjxDateUtil.computeDuration(deltaMSec);
	return durationStr ? (durationStr + " " + AjxMsg.ago) : null;
};

// Computes the difference between now and <dateMSec>. Returns a simplified string describing
// the difference
AjxDateUtil.agoTime =
function(dateMSec) {
	var deltaMSec = (new Date()).getTime() - dateMSec;
	var durationStr = AjxDateUtil.computeDuration(deltaMSec, false, true);
	return durationStr ? (durationStr + " " + AjxMsg.ago) : null;
};



// Returns a string describing the duration, which is in milliseconds.
AjxDateUtil.computeDuration =
function(duration, brief, simplified) {
	// bug fix #2203 - if delta is less than zero, dont bother computing
	if (duration < 0) return null;

	var years =  Math.floor(duration / (AjxDateUtil.MSEC_PER_DAY * 365));
	if (years != 0)
		duration -= years * AjxDateUtil.MSEC_PER_DAY * 365;
	var months = Math.floor(duration / (AjxDateUtil.MSEC_PER_DAY * 30.42));
	if (months > 0)
		duration -= Math.floor(months * AjxDateUtil.MSEC_PER_DAY * 30.42);
	var days = Math.floor(duration / AjxDateUtil.MSEC_PER_DAY);
	if (days > 0)
		duration -= days * AjxDateUtil.MSEC_PER_DAY;
	var hours = Math.floor(duration / AjxDateUtil.MSEC_PER_HOUR);
	if (hours > 0) 
		duration -= hours * AjxDateUtil.MSEC_PER_HOUR;
	var mins = Math.floor(duration / 60000);
	if (mins > 0)
		duration -= mins * 60000;
	var secs = Math.floor(duration / 1000);

	var formatter = brief ? AjxDurationFormatConcise : AjxDurationFormatVerbose;
	if (years > 0) {
		return simplified
            ? formatter.formatYears(years)
            : formatter.formatYears(years, months);
	} else if (months > 0) {
		return simplified
            ? formatter.formatMonths(months)
            : formatter.formatMonths(months, days);
	} else if (days > 0) {
		return simplified
            ? formatter.formatDays(days)
            : formatter.formatDays(days, hours);
	} else if (hours > 0) {
		return simplified
            ? formatter.formatHours(hours)
            : formatter.formatHours(hours, mins);
	} else if (mins > 0) {
		return simplified
            ? formatter.formatMinutes(mins)
            : formatter.formatMinutes(mins, secs);
	} else {
		return formatter.formatSeconds(secs);
	}
};

AjxDateUtil.simpleComputeDateStr = 
function(date, stringToPrepend) {
	var dateStr = AjxDateUtil._dateFormat.format(date);
	return stringToPrepend ? stringToPrepend + dateStr : dateStr;
};
AjxDateUtil.simpleParseDateStr =
function(dateStr) {
	return AjxDateUtil._dateFormat.parse(dateStr);
};

AjxDateUtil.simpleComputeDateTimeStr = 
function(date, stringToPrepend) {
	var dateTimeStr = AjxDateUtil._dateTimeFormat.format(date);
	return stringToPrepend ? stringToPrepend + dateTimeStr : dateTimeStr;
};
AjxDateUtil.simpleParseDateTimeStr =
function(dateTimeStr) {
	return AjxDateUtil._dateTimeFormat.parse(dateTimeStr);
};

AjxDateUtil.longComputeDateStr = 
function(date) {
	var formatter = AjxDateFormat.getDateInstance(AjxDateFormat.FULL);
	return formatter.format(date);
}

AjxDateUtil.computeDateStr =
function(now, dateMSec) {
	if (dateMSec == null)
		return "";

	var date = new Date(dateMSec);
	if (now.getTime() - dateMSec < AjxDateUtil.MSEC_PER_DAY &&
		now.getDay() == date.getDay()) {
		return AjxDateUtil.computeTimeString(date);
	}

	if (now.getFullYear() == date.getFullYear()) {
		return AjxDateUtil._dateFormatNoYear.format(date);
	}

	return AjxDateUtil.simpleComputeDateStr(date);
};

AjxDateUtil.computeDateStrNoYear =
function(date) {
    return AjxDateUtil._dateFormatNoYear.format(date);
};

// Example output: "Today, 9:44 AM" "Yesterday, 12:22 PM" "Sun, 1/11/01 1:11 PM"
AjxDateUtil.computeWordyDateStr =
function(now, dateMSec) {
	if (dateMSec == null) {
		return "";
	}

	var date = new Date(dateMSec);
	if (now.getTime() - dateMSec < AjxDateUtil.MSEC_PER_DAY && now.getDay() == date.getDay()) {
		if (!AjxDateUtil._wordyDateToday) {
			AjxDateUtil._wordyDateToday = new AjxDateFormat(AjxMsg.formatWordyDateToday);
		}
		return AjxDateUtil._wordyDateToday.format(date);
	} else if ((now.getTime() - dateMSec) < (2 * AjxDateUtil.MSEC_PER_DAY) && (now.getDay() - 1) == date.getDay()) {
		if (!AjxDateUtil._wordyDateYesterday) {
			AjxDateUtil._wordyDateYesterday = new AjxDateFormat(AjxMsg.formatWordyDateYesterday);
		}
		return AjxDateUtil._wordyDateYesterday.format(date);
	} else {
		if (!AjxDateUtil._wordyDate) {
			AjxDateUtil._wordyDate = new AjxDateFormat(AjxMsg.formatWordyDate);
		}
		return AjxDateUtil._wordyDate.format(date);
	}
};

/* returns true if dateString is a valid and understandable date string
 * in compliance with the locale of the user ie. dd/mm/yy or mm/dd/yy etc.
 * Also for date strings like 1/32/2000 (that roll over to 2/1/2000), false is returned.
 */
AjxDateUtil.isValidSimpleDateStr =
function(str){
        if(!str) {return false};
        var dateValue = AjxDateUtil.getSimpleDateFormat().parse(str);
        if (!dateValue) {return false};
        var dateValueStr = AjxDateUtil.simpleComputeDateStr(dateValue);
        return (str == dateValueStr);
}

AjxDateUtil.computeTimeString =
function(date) {
	var formatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	return formatter.format(date);
};

AjxDateUtil.computeDateTimeString =
function(date) {
	var formatter = AjxDateFormat.getDateTimeInstance(AjxDateFormat.LONG);
	return formatter.format(date);
};

AjxDateUtil._getHoursStr =
function(date, pad, useMilitary) {
	var myVal = date.getHours();
	if (!useMilitary) {
		myVal %= 12;
		if (myVal == 0) myVal = 12;
	}
	return pad ? AjxDateUtil._pad(myVal) : myVal;
};

AjxDateUtil._getMinutesStr = 
function(date) {
	return AjxDateUtil._pad(date.getMinutes());
};

AjxDateUtil._getSecondsStr = 
function(date) {
	return AjxDateUtil._pad(date.getSeconds());
};

AjxDateUtil._getAMPM = 
function (date, upper) {
	var myHour = date.getHours();
	return (myHour < 12) ? (upper ? 'AM' : 'am') : (upper ? 'PM' : 'pm');
};

AjxDateUtil._getMonthName = 
function(date, abbreviated) {
	return abbreviated
		? AjxDateUtil.MONTH_MEDIUM[date.getMonth()]
		: AjxDateUtil.MONTH_LONG[date.getMonth()];
};

AjxDateUtil._getMonth = 
function(date, pad) {
	var myMonth = date.getMonth() + 1;
	if (pad) {
		return AjxDateUtil._pad(myMonth);
	} else {
		return myMonth;
	}
};

AjxDateUtil._getDate = 
function(date, pad) {
	var myVal = date.getDate();
	return pad ? AjxDateUtil._pad(myVal) : myVal;
};

AjxDateUtil._getWeekday =
function (date) {
	var myVal = date.getDay();
	return AjxDateUtil.WEEKDAY_LONG[myVal];
};

// Returns "Mon", "Tue", etc.
AjxDateUtil._getWeekdayMedium =
function (date) {
	var myVal = date.getDay();
	return AjxDateUtil.WEEKDAY_MEDIUM[myVal];
};

AjxDateUtil._getFullYear =
function(date) {
	return date.getFullYear();
};

AjxDateUtil.getFirstDayOfWeek =
function (dt, startOfWeek) {
    startOfWeek = startOfWeek || 0;
    var dayOfWeekIndex = dt.getDay();
    var dayOfWeek = (dayOfWeekIndex - startOfWeek + 7) % 7;
    dt.setDate(dt.getDate() - dayOfWeek);
    return dt;
};

AjxDateUtil.getLastDayOfWeek =
function (dt, startOfWeek) {
    startOfWeek = startOfWeek || 0;
    var dayOfWeekIndex = dt.getDay();
    var dayOfWeek = (dayOfWeekIndex - startOfWeek + 7) % 7;
    dt.setDate(dt.getDate() - dayOfWeek + 6);
    dt.setHours(23, 59, 59, 999);
    return dt;
};

AjxDateUtil.getWeekNumber =
function(date, firstDayOfWeek, janDate, isISO8601WeekNum) {

    // Setup Defaults
    firstDayOfWeek = firstDayOfWeek || 0;
    janDate = janDate || AjxDateUtil.WEEK_ONE_JAN_DATE;
    date = date || new Date();

    date.setHours(12,0,0,0);
    var targetDate = date,
            startOfWeek,
            endOfWeek;

    if (targetDate.getDay() === firstDayOfWeek) {
        startOfWeek = targetDate;
    } else {
        startOfWeek = AjxDateUtil.getFirstDayOfWeek(targetDate, firstDayOfWeek);
    }

    var startYear = startOfWeek.getFullYear(),
            startTime = startOfWeek.getTime();

    // DST shouldn't be a problem here, math is quicker than setDate();
    endOfWeek = new Date(startOfWeek.getTime() + 6*AjxDateUtil.MSEC_PER_DAY);

    var weekNum;

    if(!isISO8601WeekNum) {
        if (startYear !== endOfWeek.getFullYear() && endOfWeek.getDate() >= janDate) {
            weekNum = 1;
        } else {
            var weekOne = (new Date(startYear, 0, janDate));
            weekOne.setHours(12,0,0,0);
            var weekOneDayOne = AjxDateUtil.getFirstDayOfWeek(weekOne, firstDayOfWeek);

            // Round days to smoothen out 1 hr DST diff
            var daysDiff  = Math.round((targetDate.getTime() - weekOneDayOne.getTime())/AjxDateUtil.MSEC_PER_DAY);

            // Calc. Full Weeks
            var rem = daysDiff % 7;
            var weeksDiff = (daysDiff - rem)/7;
            weekNum = weeksDiff + 1;
        }
        return weekNum;
    }else {

        var newYear = new Date(date.getFullYear(),0,1);
        var day = newYear.getDay() - 1;
        day = (day >= 0 ? day : day + 7);
        var dayOftheYear = Math.floor((date.getTime()-newYear.getTime() - (date.getTimezoneOffset()-newYear.getTimezoneOffset())*60000)/AjxDateUtil.MSEC_PER_DAY) + 1;

        if(day < 4)
        {
            weekNum = Math.floor((dayOftheYear+day-1)/7) + 1;
            if(weekNum > 52)
            {
                var nxtYear = new Date(date.getFullYear() + 1,0,1);
                var nxtDay = nxtYear.getDay() - 1;
                nxtDay = nxtDay >= 0 ? nxtDay : nxtDay + 7;
                weekNum = nxtDay < 4 ? 1 : 53;
            }
        }else {
            weekNum = Math.floor((dayOftheYear+day -1 )/7);
            if(weekNum == 0)
            {
                var prevYear = new Date(date.getFullYear()-1,0,1);
                var prevDay = prevYear.getDay()-1;
                prevDay = (prevDay >= 0 ? prevDay : prevDay + 7);
                weekNum = ( prevDay==3 || ( AjxDateUtil.isLeapYear(prevYear.getFullYear()) && prevDay==2 ) ) ? 53 : 52;
            }
        }
        return weekNum;
    }
};

AjxDateUtil.getTimeStr = 
function(date, format) {
	var s = format;
	s = s.replace(/%d/g, AjxDateUtil._getDate(date, true));				// zero padded day of the month
	s = s.replace(/%D/g, AjxDateUtil._getDate(date, false));			// day of the month without padding
	s = s.replace(/%w/g, AjxDateUtil._getWeekday(date));				// day of the week
	s = s.replace(/%M/g, AjxDateUtil._getMonthName(date));				// full month name
	s = s.replace(/%t/g, AjxDateUtil._getMonthName(date, true));		// abbr. month name
	s = s.replace(/%n/g, AjxDateUtil._getMonth(date, true));		    // zero padded month
	s = s.replace(/%Y/g, AjxDateUtil._getFullYear(date));				// full year
	s = s.replace(/%h/g, AjxDateUtil._getHoursStr(date, false, false));	// non-padded hours
	s = s.replace(/%H/g, AjxDateUtil._getHoursStr(date, true, false ));	// padded hours
	s = s.replace(/%m/g, AjxDateUtil._getMinutesStr(date));				// padded minutes
	s = s.replace(/%s/g, AjxDateUtil._getSecondsStr(date));				// padded seconds
	s = s.replace(/%P/g, AjxDateUtil._getAMPM(date, true));				// upper case AM PM
	s = s.replace(/%p/g, AjxDateUtil._getAMPM(date, false));			// lower case AM PM
	return s;
};

AjxDateUtil.getRoundedMins = 
function (date, roundTo) {
	var mins = date.getMinutes();
	if (mins != 0 && roundTo)
		mins = (Math.ceil( (mins/roundTo) )) * roundTo;
	return mins;
};

AjxDateUtil.roundTimeMins = 
function(date, roundTo) {
	var mins = date.getMinutes();
	var hours = date.getHours();
	if (mins != 0 && roundTo){
		mins = (Math.ceil( (mins/roundTo) )) * roundTo;
		if (mins == 60) {
			mins = 0;
			hours++;
		}
		date.setMinutes(mins);
		date.setHours(hours);
	}
	return date;
};

AjxDateUtil.isInRange = 
function(startTime1, endTime1, startTime2, endTime2) {
	return (startTime1 < endTime2 && endTime1 > startTime2);
}

AjxDateUtil.getSimpleDateFormat =
function() {
	return AjxDateUtil._dateFormat;
};

/**
 * The following are helper routines for processing server date/time which comes
 * in this format: YYYYMMDDTHHMMSSZ
*/
AjxDateUtil.getServerDate = 
function(date) {
	if (!AjxDateUtil._serverDateFormatter) {
		AjxDateUtil._serverDateFormatter = new AjxDateFormat("yyyyMMdd");
	}
	return AjxDateUtil._serverDateFormatter.format(date);
};

AjxDateUtil.getServerDateTime = 
function(date, useUTC) {
	var newDate = date;
	var formatter = null;

	if (useUTC) {
		if (!AjxDateUtil._serverDateTimeFormatterUTC) {
			AjxDateUtil._serverDateTimeFormatterUTC = new AjxDateFormat("yyyyMMdd'T'HHmmss'Z'");
		}
		formatter = AjxDateUtil._serverDateTimeFormatterUTC;
		// add timezone offset to this UTC date
		newDate = new Date(date.getTime());
		newDate.setMinutes(newDate.getMinutes() + newDate.getTimezoneOffset());
	} else {
		if (!AjxDateUtil._serverDateTimeFormatter) {
			AjxDateUtil._serverDateTimeFormatter = new AjxDateFormat("yyyyMMdd'T'HHmmss");
		}
		formatter = AjxDateUtil._serverDateTimeFormatter;
	}

	return formatter.format(newDate);
};

AjxDateUtil.parseServerTime = 
function(serverStr, date, noSpecialUtcCase) {
	if (serverStr.charAt(8) == 'T') {
		var hh = parseInt(serverStr.substr(9,2), 10);
		var mm = parseInt(serverStr.substr(11,2), 10);
		var ss = parseInt(serverStr.substr(13,2), 10);
		if (!noSpecialUtcCase && serverStr.charAt(15) == 'Z') {
			mm += AjxTimezone.getOffset(AjxTimezone.DEFAULT, date);
		}
		date.setHours(hh, mm, ss, 0);
	}
	return date;
};

AjxDateUtil.parseISO8601Date = function(s) {
    var formatters = AjxDateUtil.__ISO8601_formats;
    if (!formatters) {
        formatters = AjxDateUtil.__ISO8601_formats = [
            new AjxDateUtil.TZDFormat("yyyy-MM-dd'T'HH:mm:ss.SZ"),
            new AjxDateUtil.TZDFormat("yyyy-MM-dd'T'HH:mm:ssZ"),
            new AjxDateUtil.TZDFormat("yyyy-MM-dd'T'HH:mmZ"),
            new AjxDateFormat("yyyy-MM-dd"),
            new AjxDateFormat("yyyy-MM"),
            new AjxDateFormat("yyyy")
        ];
    }
    for (var i = 0; i < formatters.length; i++) {
        var date = formatters[i].parse(s);
        if (date) return date;
    }
    return null;
};

AjxDateUtil.TZDFormat = function(pattern) {
    if (arguments.length == 0) return;
    AjxDateFormat.apply(this, arguments);
    var segments = this._segments || [];
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment instanceof AjxDateFormat.TimezoneSegment) {
            segments[i] = new AjxDateUtil.TZDSegment(segment.toSubPattern());
        }
    }
};
AjxDateUtil.TZDFormat.prototype = new AjxDateFormat;
AjxDateUtil.TZDFormat.prototype.constructor = AjxDateUtil.TZDFormat;
AjxDateUtil.TZDFormat.prototype.toString = function() { return "TZDFormat"; };

AjxDateUtil.TZDSegment = function(pattern) {
    if (arguments.length == 0) return;
    AjxDateFormat.TimezoneSegment.apply(this, arguments);
};
AjxDateUtil.TZDSegment.prototype = new AjxDateFormat.TimezoneSegment;
AjxDateUtil.TZDSegment.prototype.constructor = AjxDateUtil.TZDSegment;
AjxDateUtil.TZDSegment.prototype.toString = function() { return "TZDSegment"; };

AjxDateUtil.TZDSegment.prototype.parse = function(o, s, i) {
    var m = /^(Z)|^(\+|\-)(\d\d):(\d\d)/.exec(s.substr(i));
    if (m) {
        var offset = new Date().getTimezoneOffset();
        if (m[1]) o.timezone = offset;
        else {
            var hours = parseInt(m[3],10), mins = parseInt(m[4],10);
            o.timezone = hours * 60 + mins;
            if (m[2] != "-") o.timezone *= -1;
            o.timezone -= offset;
        }
    }
    return i + (m ? m[0].length : 0);
};

AjxDateUtil.parseServerDateTime = 
function(serverStr, noSpecialUtcCase) {
	if (serverStr == null) return null;

	var d = new Date();
	var yyyy = parseInt(serverStr.substr(0,4), 10);
	var MM = parseInt(serverStr.substr(4,2), 10);
	var dd = parseInt(serverStr.substr(6,2), 10);
	d.setFullYear(yyyy);
	d.setMonth(MM - 1);
	d.setMonth(MM - 1); // DON'T remove second call to setMonth (see bug #3839)
	d.setDate(dd);
	AjxDateUtil.parseServerTime(serverStr, d, noSpecialUtcCase);
	return d;
};

AjxDateUtil._pad = 
function(n) {
	return n < 10 ? ('0' + n) : n;
};

/**
 * Returns the year portion of the given date as a YYYY string.
 *
 * @param {Date}    date    (optional, defaults to current date) a date
 * @returns {string}    year as YYYY
 */
AjxDateUtil.getYearStr = function(date) {
    date = date || new Date();
    return date.getFullYear() + "";
};

AjxDurationFormatVerbose = function() { }

AjxDurationFormatVerbose.formatYears =
function(years, months) {
	var deltaStr =  years + " ";
	deltaStr += (years > 1) ? AjxMsg.years : AjxMsg.year;
	if (years <= 3 && months > 0) {
		deltaStr += " " + months;
		deltaStr += " " + ((months > 1) ? AjxMsg.months : AjxMsg.months);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatMonths =
function(months, days) {
	var deltaStr =  months + " ";
	deltaStr += (months > 1) ? AjxMsg.months : AjxMsg.month;
	if (months <= 3 && days > 0) {
		deltaStr += " " + days;
		deltaStr += " " + ((days > 1) ? AjxMsg.days : AjxMsg.day);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatDays =
function(days, hours) {
	var deltaStr = days + " ";
	deltaStr += (days > 1) ? AjxMsg.days : AjxMsg.day;
	if (days <= 2 && hours > 0) {
		deltaStr += " " + hours;
		deltaStr += " " + ((hours > 1) ? AjxMsg.hours : AjxMsg.hour);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatHours =
function(hours, mins) {
	var deltaStr = hours + " ";
	deltaStr += (hours > 1) ? AjxMsg.hours : AjxMsg.hour;
	if (hours < 5 && mins > 0) {
		deltaStr += " " + mins;
		deltaStr += " " + ((mins > 1) ? AjxMsg.minutes : AjxMsg.minute);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatMinutes =
function(mins, secs) {
	var deltaStr = mins + " ";
	deltaStr += ((mins > 1) ? AjxMsg.minutes : AjxMsg.minute);
	if (mins < 5 && secs > 0) {
		deltaStr += " " + secs;
		deltaStr += " " + ((secs > 1) ? AjxMsg.seconds : AjxMsg.second);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatSeconds =
function(secs) {
	return (secs + " " + ((secs > 1) ? AjxMsg.seconds : AjxMsg.second));
};

AjxDurationFormatConcise = function() { }

AjxDurationFormatConcise.formatYears =
function(years, months) {
	return this._format(years, months);
};

AjxDurationFormatConcise.formatMonths =
function(months, days) {
	return this._format(months, days);
};

AjxDurationFormatConcise.formatDays =
function(days, hours) {
	return this._format(days, hours);
};

AjxDurationFormatConcise.formatHours =
function(hours, mins) {
	return this._format(hours, mins);
};

AjxDurationFormatConcise.formatMinutes =
function(mins, secs) {
	return this._format(mins, secs);
};

AjxDurationFormatConcise.formatSeconds =
function(secs) {
	return this._format(0, secs);
};

AjxDurationFormatConcise._format =
function(a, b) {
	var i = 0;
	var result = [];
	result[i++] = a;
	result[i++] = ':';
	if (b < 10) {
		result[i++] = '0';
	}
	result[i++] = b;
	return result.join('');
};

/**
 * Added more utility functions for date finding and navigating
 */

AjxDateUtil.SUNDAY = 0;
AjxDateUtil.MONDAY = 1;
AjxDateUtil.TUESDAY = 2;
AjxDateUtil.WEDNESDAY = 3;
AjxDateUtil.THURSDAY = 4;
AjxDateUtil.FRIDAY = 5;
AjxDateUtil.SATURDAY = 6;                                                                              

/**
 *
 * @param fromThisDate The searching starts from this date.
 * @param thisWeekday  The day to find ( eg. AjxDateUtil.SUNDAY)
 * @param count Which occurence, like first, second.. has to be always positive
 * 
 */
AjxDateUtil.getDateForNextDay =
function(fromThisDate, thisWeekday, count) {
	count = count || 1;
	var r = new Date(fromThisDate);
	for (var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForNextWeekday(r, thisWeekday);
		if (i < count-1) {
			r.setDate(r.getDate() + 1);
		}
	}
	return r;
}

/**
 *
 * @param fromThisDate The searching work week days starting from this date
 * @param count Which occurence, like first, second.. has to be always positive
 *
 */
AjxDateUtil.getDateForNextWorkWeekDay =
function(fromThisDate, count) {
	count = count?count:1;
	var r = new Date(fromThisDate);
	for (var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForNextWorkWeekday(r);
		if (i < count-1) {
			r.setDate(r.getDate() + 1);
		}
	}
	return r;
}

/**
 *
 * @param fromThisDate The starting point
 * @param thisWeekday  The day to find
 * @param count this many positions to navigate, if negative goes in reverse, if positive goes forward
 */
AjxDateUtil.getDateForThisDay =
function(fromThisDate, thisWeekday, count) {
	if (count < 0 ) {
		return AjxDateUtil.getDateForPrevDay(fromThisDate, thisWeekday, -count);//-(-)  is plus
	} else {
		return AjxDateUtil.getDateForNextDay(fromThisDate, thisWeekday, count);
	}
}

/**
 *
 * @param fromThisDate The starting point
 * @param count this many positions to navigate, if negative goes in reverse, if positive goes forward
 */
AjxDateUtil.getDateForThisWorkWeekDay =
function(fromThisDate, count) {
	if (count < 0 ) {
		return AjxDateUtil.getDateForPrevWorkWeekDay(fromThisDate, -count);		//-(-)  is plus
	}else{
		return AjxDateUtil.getDateForNextWorkWeekDay(fromThisDate, count);
	}
}

/**
 *
 * @param fromThisDate The searching starts from this date in reverse direction. 
 * @param thisWeekday  The day to find ( eg. AjxDateUtil.SUNDAY)
 * @param count Which occurence, like first, second..has to be always positive
 */
AjxDateUtil.getDateForPrevDay =
function(fromThisDate,thisWeekday,count) {
	count = count || 1;
	var r = new Date(fromThisDate);
	for (var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForPrevWeekday(r, thisWeekday);
		if (i < count-1) {
			r.setDate(r.getDate()-1);
		}
	}
	return r;
}

/**
 *
 * @param fromThisDate The searching for work week days starting from this date in reverse direction.
 * @param count Which occurence, like first, second..has to be always positive
 */

AjxDateUtil.getDateForPrevWorkWeekDay =
function(fromThisDate, count) {
	count = count || 1;
	var r = new Date(fromThisDate);
	for(var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForPrevWorkWeekday(r);
		if (i < count-1) {
			r.setDate(r.getDate()-1);
		}
	}
	return r;
}

/**
 * note - this deals with the format we save from Prefs page. Careful if using for other cases.
 * @param value
 * @return {String}
 */
AjxDateUtil.dateLocal2GMT =
function(value) {
	if (!value) { return ""; }

	var yr, mo, da, hr, mi, se; // really smart parsing.
	yr = parseInt(value.substr(0,  4), 10);
	mo = parseInt(value.substr(4,  2), 10);
	da = parseInt(value.substr(6,  2), 10);
	hr = parseInt(value.substr(8,  2), 10);
	mi = parseInt(value.substr(10, 2), 10);
	se = parseInt(value.substr(12, 2), 10);
	var date = new Date(yr, mo - 1, da, hr, mi, se, 0);
	yr = date.getUTCFullYear();
	mo = date.getUTCMonth() + 1;
	da = date.getUTCDate();
	hr = date.getUTCHours();
	mi = date.getUTCMinutes();
	se = date.getUTCSeconds();
	var a = [ yr, mo, da, hr, mi, se ];
	for (var i = a.length; --i > 0;) {
		var n = a[i];
		if (n < 10)
			a[i] = "0" + n;
	}
	return (a.join("") + "Z");
};

/**
 * note - this deals with the format we save from Prefs page. Careful if using for other cases.
 * @param value
 * @return {String}
 */
AjxDateUtil.dateGMT2Local =
function(value) {
	if (!value) { return ""; }

	var yr, mo, da, hr, mi, se; // really smart parsing.
	yr = parseInt(value.substr(0,  4), 10);
	mo = parseInt(value.substr(4,  2), 10);
	da = parseInt(value.substr(6,  2), 10);
	hr = parseInt(value.substr(8,  2), 10);
	mi = parseInt(value.substr(10, 2), 10);
	se = parseInt(value.substr(12, 2), 10);
	var date = new Date();
	date.setUTCMilliseconds(0);
	date.setUTCSeconds(se);
	date.setUTCMinutes(mi);
	date.setUTCHours(hr);
	date.setUTCDate(da);
	date.setUTCMonth(mo - 1);
	date.setUTCFullYear(yr);
	yr = date.getFullYear();
	mo = date.getMonth() + 1;
	da = date.getDate();
	hr = date.getHours();
	mi = date.getMinutes();
	se = date.getSeconds();
	var a = [yr, mo, da, hr, mi, se];
	for (var i = a.length; --i > 0;) {
		var n = a[i];
		if (n < 10)
			a[i] = "0" + n;
	}
	return (a.join("") + "Z");
};


AjxDateUtil._getDateForNextWeekday =
function(fromThisDate,thisWeekday) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == thisWeekday) {
		return newDate;
	}
	var diff = (thisWeekday-weekDay);
	if (diff > 0) {
		newDate.setDate(fromThisDate.getDate() + diff);
	} else {
		newDate.setDate(fromThisDate.getDate() + (7 + diff));
	}
	return newDate;
}

AjxDateUtil._getDateForNextWorkWeekday =
function(fromThisDate) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == AjxDateUtil.SUNDAY) {
		newDate.setDate(fromThisDate.getDate()+1);
	} else if (weekDay == AjxDateUtil.SATURDAY) {
		newDate.setDate(fromThisDate.getDate()+2);
	}
	return newDate;
}

AjxDateUtil._getDateForPrevWeekday =
function(fromThisDate, thisWeekday) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == thisWeekday) {
		return newDate;
	}
	var diff = (weekDay-thisWeekday);
	if (diff > 0) {
		newDate.setDate(fromThisDate.getDate() - diff);
	} else {
		newDate.setDate(fromThisDate.getDate() - (7 + diff));
	}
	return newDate;
}

AjxDateUtil._getDateForPrevWorkWeekday =
function(fromThisDate) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == AjxDateUtil.SUNDAY) {
		newDate.setDate(fromThisDate.getDate() - 2);
	} else if (weekDay == AjxDateUtil.SATURDAY) {
		newDate.setDate(fromThisDate.getDate() - 1);
	}
	return newDate;
}

//
// Date calculator functions
//

AjxDateUtil.calculate =
function(rule, date) {
	// initialize
	if (!AjxDateUtil.__calculate_initialized) {
		AjxDateUtil.__calculate_initialized = true;
		AjxDateUtil.__calculate_init();
	}

	var now = date || new Date;
	rule = rule.replace(/^\s*|\s*$/, "").replace(/\s*=\s*/g,"=").replace(/\s*,\s*/g,",");
	var a = rule.split(/\s+/g);
	var s, m, plusminus, number, type, amount, weekord, daynum;
	for (var i = 0; i < a.length; i++) {
		s = a[i];
		// comment
		if (s.match(AjxDateUtil.RE_COMMENT)) {
			break;
		}
		// context date
		if (s.match(AjxDateUtil.RE_NOW)) {
			date = new Date(now.getTime());
			continue;
		}
		// add
		if (m = s.match(AjxDateUtil.RE_ADD_NUMBER)) {
			plusminus = m[1];
			number = AjxDateUtil.__calculate_parseInt(m[2]);
			type = a[++i];
			amount = plusminus == '+' ? number : number * -1;
			AjxDateUtil.__calculate_add(date, type, amount);
			continue;
		}
		// set
		if (m = s.match(AjxDateUtil.RE_SET)) {
			AjxDateUtil.__calculate_set(date, m[1], m[2]);
			continue;
		}
		// try to parse as a date
		date = AjxDateFormat.parse("yyyyy-MM-dd", s);
		if (!date && (date = AjxDateFormat.parse("yyyy-MM-dd'T'hh:mm:ss'Z'", s))) {
			date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
		}
		if (!date) date = AjxDateFormat.parse("yyyy-MM-dd'T'HH:mm:ss", s);
		if (!date) throw "invalid date pattern: \""+s+"\"";
	}
	return date;
};

//
// Date calculator constants
//

AjxDateUtil.S_DAYNAME = [
	AjxMsg["calc.dayname.sunday"],
	AjxMsg["calc.dayname.monday"],
	AjxMsg["calc.dayname.tuesday"],
	AjxMsg["calc.dayname.wednesday"],
	AjxMsg["calc.dayname.thursday"],
	AjxMsg["calc.dayname.friday"],
	AjxMsg["calc.dayname.saturday"]
].join("|");

AjxDateUtil.S_MONTHNAME = [
	AjxMsg["calc.monthname.january"],
	AjxMsg["calc.monthname.february"],
	AjxMsg["calc.monthname.march"],
	AjxMsg["calc.monthname.april"],
	AjxMsg["calc.monthname.may"],
	AjxMsg["calc.monthname.june"],
	AjxMsg["calc.monthname.july"],
	AjxMsg["calc.monthname.august"],
	AjxMsg["calc.monthname.september"],
	AjxMsg["calc.monthname.october"],
	AjxMsg["calc.monthname.november"],
	AjxMsg["calc.monthname.december"]
].join("|");

AjxDateUtil.S_WEEKORD = [
	AjxMsg["calc.ordinal.first"],
	AjxMsg["calc.ordinal.second"],
	AjxMsg["calc.ordinal.third"],
	AjxMsg["calc.ordinal.fourth"],
	AjxMsg["calc.ordinal.fifth"],
	AjxMsg["calc.ordinal.last"]
].join("|");

AjxDateUtil.WEEKORD_RE = [
    new RegExp("(first|"+AjxMsg["calc.ordinal.first"]+")",  "i"),
    new RegExp("(second|"+AjxMsg["calc.ordinal.second"]+")", "i"),
    new RegExp("(third|"+AjxMsg["calc.ordinal.third"]+")",  "i"),
    new RegExp("(fourth|"+AjxMsg["calc.ordinal.fourth"]+")", "i"),
    new RegExp("(last|"+AjxMsg["calc.ordinal.last"]+")",   "i")
];

// NOTE: Originally, the keywords for the date calculation rules
//       were in the message bundle so that they could be translated.
//       But while the keywords were translated, the rules were not
//       updated to use the translated keywords. So none of the date
//       matching worked in other languages. So I am reverting that
//       decision and hard-coding all of the relevant keywords. The
//       ordinals, day names, and month names still need to be
//       translated, though.

AjxMsg["calc.now"]	= "now";
AjxMsg["calc.date"]	= "date";

AjxMsg["calc.duration.year"]		= "year|years";
AjxMsg["calc.duration.month"]		= "mons|month|months";
AjxMsg["calc.duration.day"]			= "day|days";
AjxMsg["calc.duration.hour"]		= "hour|hours";
AjxMsg["calc.duration.minute"]		= "min|mins|minute|minutes";
AjxMsg["calc.duration.week"]        = "week";
AjxMsg["calc.duration.second"]		= "sec|secs|second|seconds";
AjxMsg["calc.duration.millisecond"]	= "milli|millis|millisecond|milliseconds";

AjxDateUtil.S_DURATION = [
	AjxMsg["calc.duration.year"],
	AjxMsg["calc.duration.month"],
    AjxMsg["calc.duration.week"],
	AjxMsg["calc.duration.day"],
	AjxMsg["calc.duration.hour"],
	AjxMsg["calc.duration.minute"],
	AjxMsg["calc.duration.second"],
	AjxMsg["calc.duration.millisecond"]
].join("|");

//
// Date calculator private functions
//

AjxDateUtil.__calculate_init =
function() {
	AjxDateUtil.WEEKDAYS = {};
	var weekdays = [
		"sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"
	];
	for (var i = 0; i < weekdays.length; i++) {
		var weekday = AjxMsg["calc.dayname."+weekdays[i]].split("|");
		for (var j = 0; j < weekday.length; j++) {
			AjxDateUtil.WEEKDAYS[weekday[j].toLowerCase()] = i;
		}
	}

	AjxDateUtil.MONTHNAME2MONTHNUM = {};
	var months = [
		"january", "february", "march", "april", "may", "june",
		"july", "august", "september", "october", "november", "december"
	];
	for (var i = 0; i < months.length; i++) {
		var month = AjxMsg["calc.monthname."+months[i]].split("|");
		for (var j = 0; j < month.length; j++) {
			AjxDateUtil.MONTHNAME2MONTHNUM[month[j].toLowerCase()] = i;
		}
	}

	AjxDateUtil.RE_YEAR = new RegExp("^("+AjxMsg["calc.duration.year"]+")$", "i");
	AjxDateUtil.RE_MONTH = new RegExp("^("+AjxMsg["calc.duration.month"]+")$", "i");
	AjxDateUtil.RE_WEEK = new RegExp("^("+AjxMsg["calc.duration.week"]+")$", "i");
	AjxDateUtil.RE_DAY = new RegExp("^("+AjxMsg["calc.duration.day"]+")$", "i");
	AjxDateUtil.RE_HOUR = new RegExp("^("+AjxMsg["calc.duration.hour"]+")$", "i");
	AjxDateUtil.RE_MINUTE = new RegExp("^("+AjxMsg["calc.duration.minute"]+")$", "i");
	AjxDateUtil.RE_SECOND = new RegExp("^("+AjxMsg["calc.duration.second"]+")$", "i");
	AjxDateUtil.RE_MILLISECOND = new RegExp("^("+AjxMsg["calc.duration.millisecond"]+")$", "i");

	AjxDateUtil.RE_DATE = new RegExp("^("+AjxMsg["calc.date"]+")$", "i");
	
	AjxDateUtil.RE_DAYNAME = new RegExp("^("+AjxDateUtil.S_DAYNAME+")$", "i");
	AjxDateUtil.RE_MONTHNAME = new RegExp("^("+AjxDateUtil.S_MONTHNAME+")$", "i");
	AjxDateUtil.RE_WEEKORD = new RegExp("^("+AjxDateUtil.S_WEEKORD+")$", "i");

	AjxDateUtil.RE_COMMENT = /^#/;
	AjxDateUtil.RE_NOW = new RegExp("^("+AjxMsg["calc.now"]+")$", "i");
	AjxDateUtil.RE_ADD_NUMBER = new RegExp("^([+\\-])(\\d+)$", "i");
	AjxDateUtil.RE_SET = new RegExp("^("+AjxDateUtil.S_DURATION+"|"+AjxMsg["calc.date"]+")=(.*)$", "i");
};

AjxDateUtil.__calculate_normalizeFullWidthDigit =
function(digit) {
	var charCode = "0".charCodeAt(0) + digit.charCodeAt(0) - "\uff10".charCodeAt(0);
	return String.fromCharCode(charCode);
};

/** This is needed to handle asian full-width digits. */
AjxDateUtil.__calculate_replaceFullWidthDigit =
function($0, digit) {
	return AjxDateUtil.__calculate_normalizeFullWidthDigit(digit);
};

AjxDateUtil.__calculate_parseInt =
function(s) {
	s = s.replace(/([\uFF10-\uFF19])/g, AjxDateUtil.__calculate_normalizeFullWidthDigit);
	return parseInt(s, 10);
};

AjxDateUtil.__calculate_add =
function(date, type, amount) {
	if (type.match(AjxDateUtil.RE_YEAR)) {
		date.setFullYear(date.getFullYear() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MONTH)) {
		var month = date.getMonth();
		date.setMonth(month + amount);
		// avoid roll
		if (Math.abs(month + amount) % 12 != date.getMonth()) {
			date.setDate(0);
		}
		return;
	}
	if (type.match(AjxDateUtil.RE_WEEK)) {
		date.setDate(date.getDate() + amount * 7);
		return;
	}
	if (type.match(AjxDateUtil.RE_DAY)) {
		date.setDate(date.getDate() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_HOUR)) {
		date.setHours(date.getHours() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MINUTE)) {
		date.setMinutes(date.getMinutes() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_SECOND)) {
		date.setSeconds(date.getSeconds() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MILLISECOND)) {
		date.setMilliseconds(date.getMilliseconds() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MONTHNAME)) {
		var monthnum = AjxDateUtil.MONTHNAME2MONTHNUM[type.toLowerCase()];
		if (monthnum < date.getMonth()) {
			amount += amount > 0 ? 0 : 1;
		}
		else if (monthnum > date.getMonth()) {
			amount += amount > 0 ? -1 : 0;
		}
		date.setFullYear(date.getFullYear() + amount, monthnum, 1);
		return;
	}
	if (type.match(AjxDateUtil.RE_DAYNAME)) {
		var daynum = AjxDateUtil.WEEKDAYS[type.toLowerCase()];
		if (daynum < date.getDay()) {
			amount += amount > 0 ? 0 : 1;
		}
		else if (daynum > date.getDay()) {
			amount += amount > 0 ? -1 : 0;
		}
		date.setDate(date.getDate() + (daynum - date.getDay()) + 7 * amount);
		return;
	}
	throw "unknown type: "+type;
};

AjxDateUtil.__calculate_add_ordinal =
function() {
	throw "TODO: not implemented";
};

AjxDateUtil.__calculate_set =
function(date, type, value) {
	var args = value.split(/,/);
	//Add support for Japanese Heisei year format represented by H{year-number}
	//The year is H23 in H23/12/31, means 2011/12/31; we get that by adding year 1988 to 23
	//For example: H23 = 23 + 1988 = 2011(English year)
	if(args[0].indexOf("H") == 0) {
		args[0] = parseInt(args[0].replace("H", "")) + 1988;
	}
	if (type.match(AjxDateUtil.RE_YEAR)) {
		args[0] = AjxDateUtil.__calculate_fullYear(args[0]); // year
		if (args[1] != null) args[1] = AjxDateUtil.__calculate_month(args[1]); // month
		if (args[2] != null) args[2] = parseInt(args[2], 10); // date
		date.setFullYear.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_MONTH)) {
		args[0] = AjxDateUtil.__calculate_month(args[0]); // month
		if (args[1] != null) args[1] = parseInt(args[1], 10); // date
		date.setMonth.apply(date, args);
		return;
	}
    if (type.match(AjxDateUtil.RE_WEEK)) {
        var ord = AjxDateUtil.__calculate_week(args[0]); // week
        var day = args[1] ? AjxDateUtil.__calculate_day(args[1]) : date.getDay(); // day

        var target;
        if (ord != -1) {
            var firstday = new Date(date.getFullYear(), date.getMonth(), 1, 12, 0, 0, 0);
            var firstdow = firstday.getDay();
            var delta = firstdow - day;

            target = new Date(firstday.getTime());
            target.setDate(1 - delta);
            if (delta > 0) {
                target.setDate(target.getDate() + 7);
            }
            target.setDate(target.getDate() + 7 * ord);
        }
        else {
            var lastday = new Date(date.getFullYear(), date.getMonth()+1, 0, 12, 0, 0, 0);

            target = new Date(lastday.getTime());
            target.setDate(target.getDate() - (target.getDay() - day));
            if (target.getMonth() != lastday.getMonth()) {
                target.setDate(target.getDate() - 7);
            }
        }

        if (target && (date.getMonth() == target.getMonth())) {
            date.setTime(target.getTime());
        }
        return;
    }
	if (type.match(AjxDateUtil.RE_DATE)) {
		args[0] = parseInt(args[0], 10); // date
		date.setDate.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_HOUR)) {
		args[0] = parseInt(args[0], 10); // hour
		if (args[1] != null) args[1] = parseInt(args[1], 10); // minutes
		if (args[2] != null) args[2] = parseInt(args[2], 10); // seconds
		if (args[3] != null) args[3] = parseInt(args[3], 10); // milliseconds
		date.setHours.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_MINUTE)) {
		args[0] = parseInt(args[0], 10); // minutes
		if (args[1] != null) args[1] = parseInt(args[1], 10); // seconds
		if (args[2] != null) args[2] = parseInt(args[2], 10); // milliseconds
		date.setMinutes.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_SECOND)) {
		args[0] = parseInt(args[0], 10); // seconds
		if (args[1] != null) args[1] = parseInt(args[1], 10); // milliseconds
		date.setSeconds.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_MILLISECOND)) {
		date.setMilliseconds.apply(date, args); // milliseconds
		return;
	}
	throw "unknown type: "+type;
};

AjxDateUtil.__calculate_fullYear =
function(value) {
	if (value.length == 2) {
		var d = new Date;
		d.setYear(parseInt(value, 10));
        var fullYear = d.getFullYear();
        if (fullYear <= AjxMsg.dateParsing2DigitStartYear) {
            value = String(fullYear + 100);
        }
        else {
            value = String(fullYear).substr(0,2) + value;
        }
	}
	return parseInt(value, 10);
};

AjxDateUtil.__calculate_month =
function(value) {
	var monthnum = AjxDateUtil.MONTHNAME2MONTHNUM[value.toLowerCase()];
	return monthnum != null ? monthnum : parseInt(value, 10) - 1;
};

AjxDateUtil.__calculate_week = function(value) {
    for (var i = 0; i < AjxDateUtil.WEEKORD_RE.length; i++) {
        if (value.match(AjxDateUtil.WEEKORD_RE[i])) {
            if (i == AjxDateUtil.WEEKORD_RE.length - 1) {
                return -1;
            }
            return i;
        }
    }
    return 0;
};

AjxDateUtil.__calculate_day =
function(value) {
	var daynum = AjxDateUtil.WEEKDAYS[value.toLowerCase()];
	return daynum != null ? daynum : parseInt(value, 10);
};
}
if (AjxPackage.define("ajax.util.AjxPluginDetector")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Does nothing (static class).
 * @constructor
 * @class
 * 
 * This class provides static methods to determine which standard plugins are
 * installed in the browser.
 *
 * @private
 */
AjxPluginDetector = function() {
}

AjxPluginDetector.canDetectPlugins =
function() {
	return AjxEnv.isIE || (navigator.plugins && navigator.plugins.length > 0);
};

AjxPluginDetector.detectFlash =
function() {
	if(AjxEnv.isIE) {
		return AjxPluginDetector.detectActiveXControl('ShockwaveFlash.ShockwaveFlash.1');
	} else {
		return AjxPluginDetector.detectPlugin('Shockwave','Flash'); 
	}
};

AjxPluginDetector.detectPDFReader =
function(){
    if(AjxEnv.isIE){
        return  ( AjxPluginDetector.detectActiveXControl('PDF.PdfCtrl.5')
                || AjxPluginDetector.detectActiveXControl('AcroExch.Document') );
    }else{
        var hasPDFReader = false;
        if(AjxEnv.isChrome){
            hasPDFReader = AjxPluginDetector.detectPlugin('Chrome PDF Viewer');
        }else if(AjxEnv.isFirefox){
            hasPDFReader = AjxPluginDetector.detectPlugin('Firefox PDF Plugin for Mac OS X');
        }
        if(!hasPDFReader){
            hasPDFReader = AjxPluginDetector.detectPlugin('Adobe Acrobat');
        }
        return hasPDFReader;
    }
};

AjxPluginDetector.detectDirector =
function() { 
	if(AjxEnv.isIE) {
		return AjxPluginDetector.detectActiveXControl('SWCtl.SWCtl.1');
	} else {
		return AjxPluginDetector.detectPlugin('Shockwave','Director');
	}
};

AjxPluginDetector.detectQuickTime =
function() {
	if(AjxEnv.isIE) {
		return AjxPluginDetector.detectQuickTimeActiveXControl();
	} else {
		return AjxPluginDetector.detectPlugin('QuickTime');
	}
};

// If quicktime is installed, returns the version as an array: [major, minor, build]
AjxPluginDetector.getQuickTimeVersion =
function() {
	if(AjxEnv.isIE) {
		var object = new ActiveXObject("QuickTimeCheckObject.QuickTimeCheck.1");
		DBG.println(AjxDebug.DBG1, "AjxPluginDetector: Quicktime is " + object.IsQuickTimeAvailable(0) ? "available" : "not available");
		if (object.IsQuickTimeAvailable(0)) {
			try {
				var version = Number(object.QuickTimeVersion).toString(16);
				var result = [];
				for(var i = 0; i < 3; i++) {
					result[i] = Number(version.charAt(i));
				}
				return result;
			} catch(e) {
				DBG.println(AjxDebug.DBG1, "AjxPluginDetector: Error while checking QuickTimeVersion: " + e);
			}
		}
		return null;
	} else {
		var match = AjxPluginDetector.matchPluginName(/QuickTime Plug-in (\d+)\.?(\d+)?\.?(\d+)?/);
		if (match) {
			DBG.println("AjxPluginDetector: able to find match for QuickTime plugin with version: " + match);
			var result = [];
			for(var i = 0; i < 3; i++) {
				result[i] = Number(match[i + 1] || 0);
			}
			return result;
		} else {
			DBG.println("AjxPluginDetector: unable to find match for QuickTime plugin with version");
			return null;
		}
	}
};

/**
 * This code is part of JQuery's Flash plugin.
 * http://jquery.lukelutman.com/plugins/flash/
 *
 * @return Flash plugin version
 */
AjxPluginDetector.getFlashVersion =
function() {
    var flashVersion = "0,0,0";
    // ie
    try {
        try {
            // avoid fp6 minor version lookup issues
            // see: http://blog.deconcept.com/2006/01/11/getvariable-setvariable-crash-internet-explorer-flash-6/
            var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6');
            try {
                axo.AllowScriptAccess = 'always';
            }
            catch(e) {
                return '6,0,0';
            }
        } catch(e) {
            }
        flashVersion = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
        // other browsers
    } catch(e) {
        try {
            if (navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin) {
                flashVersion = (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]).description.replace(/\D+/g, ",").match(/^,?(.+),?$/)[1];
            }
        } catch(e) {
        }
    }
	return flashVersion;
};

AjxPluginDetector.detectReal =
function() {
	if(AjxEnv.isIE) {
		return AjxPluginDetector.detectActiveXControl('rmocx.RealPlayer G2 Control') ||
		       AjxPluginDetector.detectActiveXControl('RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)') ||
		       AjxPluginDetector.detectActiveXControl('RealVideo.RealVideo(tm) ActiveX Control (32-bit)');
	} else {
		return AjxPluginDetector.detectPlugin('RealPlayer');
	}
};

AjxPluginDetector.detectWindowsMedia =
function() {
	if(AjxEnv.isIE) {
		return AjxPluginDetector.detectActiveXControl('MediaPlayer.MediaPlayer.1');
	} else {
		return AjxPluginDetector.detectPlugin('Windows Media');
	}
};

AjxPluginDetector.detectPlugin =
function() {
	DBG.println(AjxDebug.DBG1, "-----------------------<br>AjxPluginDetector: Looking for plugin: [" + AjxPluginDetector._argumentsToString(AjxPluginDetector.detectPlugin.arguments) + "]");
	var names = AjxPluginDetector.detectPlugin.arguments;
	var allPlugins = navigator.plugins;
	var pluginsArrayLength = allPlugins.length;
	for (var pluginsArrayCounter=0; pluginsArrayCounter < pluginsArrayLength; pluginsArrayCounter++ ) {
	    // loop through all desired names and check each against the current plugin name
	    var numFound = 0;
	    for(var namesCounter=0; namesCounter < names.length; namesCounter++) {
			// if desired plugin name is found in either plugin name or description
			if (allPlugins[pluginsArrayCounter]) {
				if( (allPlugins[pluginsArrayCounter].name.indexOf(names[namesCounter]) >= 0)) {
					// this name was found
					DBG.println(AjxDebug.DBG1, "AjxPluginDetector: found name match '" + allPlugins[pluginsArrayCounter].name + "'");
					numFound++;
				} else if (allPlugins[pluginsArrayCounter].description.indexOf(names[namesCounter]) >= 0) {
					// this name was found
					DBG.println(AjxDebug.DBG1, "AjxPluginDetector: found description match '" + allPlugins[pluginsArrayCounter].description + "'");
					numFound++;
				}
			}
	    }
	    // now that we have checked all the required names against this one plugin,
	    // if the number we found matches the total number provided then we were successful
	    if(numFound == names.length) {
			DBG.println(AjxDebug.DBG1, "AjxPluginDetector: Found plugin!<br>-----------------------");
			return true;
	    } else if (numFound) {
			DBG.println(AjxDebug.DBG1, "AjxPluginDetector: Found partial plugin match, numFound=" + numFound);
		}
	}
	DBG.println(AjxDebug.DBG1, "AjxPluginDetector: Failed to find plugin.<br>-----------------------");
	return false;
};

AjxPluginDetector.matchPluginName =
function(regExp) {
	var allPlugins = navigator.plugins;
	var pluginsArrayLength = allPlugins.length;
	for (var pluginsArrayCounter=0; pluginsArrayCounter < pluginsArrayLength; pluginsArrayCounter++ ) {
		var match = allPlugins[pluginsArrayCounter].name.match(regExp);
		if (match) {
			return match;
		}
	}
	return null;
};

AjxPluginDetector.detectActiveXControl =
function(progId) {
	try {
		new ActiveXObject(progId);
		DBG.println(AjxDebug.DBG1, "AjxPluginDetector: found ActiveXObject '" + progId + "'");
		return true;
	} catch (e) {
		DBG.println(AjxDebug.DBG1, "AjxPluginDetector: unable to find ActiveXObject '" + progId + "'");
		return false;
	}
};

AjxPluginDetector.detectQuickTimeActiveXControl =
function(progId) {
	try {
		var object = new ActiveXObject("QuickTimeCheckObject.QuickTimeCheck.1");
		return object.IsQuickTimeAvailable(0);
	} catch (e) {
		return false;
	}
};

// Util method to log arguments, which to my surprise are not actually an array.
AjxPluginDetector._argumentsToString =
function(args) {
	var array = [];
	for (var i = 0, count = args.length; i < count; i++) {
		array[i] = args[i];
	}
	return array.join(',')
};
}
if (AjxPackage.define("ajax.3rdparty.clipboard")) {
//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd
(function(name, definition) {
    if (typeof module != "undefined") module.exports = definition();
    else if (typeof define == "function" && typeof define.amd == "object") define(definition);
    else this[name] = definition();
}("clipboard", function() {
  if (!document.addEventListener) {
    return null;
  }

  var clipboard = {};

  clipboard.copy = (function() {
    var _intercept = false;
    var _data; // Map from data type (e.g. "text/html") to value.

    document.addEventListener("copy", function(e){
      if (_intercept) {
        _intercept = false;
        for (var key in _data) {
          e.clipboardData.setData(key, _data[key]);
        }
        e.preventDefault();
      }
    });

    return function(data) {
      return new Promise(function(resolve, reject) {
        _intercept = true;
        if (typeof data === "string") {
          _data = {"text/plain": data};
        } else if (data instanceof Node) {
          _data = {"text/html": new XMLSerializer().serializeToString(data)};
        } else {
          _data = data;
        }
        try {
          if (document.execCommand("copy")) {
            // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis
            // So we can call resolve() back here.
            resolve();
          }
          else {
            _intercept = false;
            reject(new Error("Unable to copy. Perhaps it's not available in your browser?"));
          }
        }
        catch (e) {
          _intercept = false;
          reject(e);
        }
      });
    };
  }());

  clipboard.paste = (function() {
    var _intercept = false;
    var _resolve;
    var _dataType;

    document.addEventListener("paste", function(e) {
      if (_intercept) {
        _intercept = false;
        e.preventDefault();
        _resolve(e.clipboardData.getData(_dataType));
      }
    });

    return function(dataType) {
      return new Promise(function(resolve, reject) {
        _intercept = true;
        _resolve = resolve;
        _dataType = dataType || "text/plain";
        try {
          if (!document.execCommand("paste")) {
            _intercept = false;
            reject(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."));
          }
        } catch (e) {
          _intercept = false;
          reject(new Error(e));
        }
      });
    };
  }());

  // Handle IE behaviour.
  if (typeof ClipboardEvent === "undefined" &&
      typeof window.clipboardData !== "undefined" &&
      typeof window.clipboardData.setData !== "undefined") {

    /*! promise-polyfill 2.0.1 */
    (function(a){function b(a,b){return function(){a.apply(b,arguments)}}function c(a){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof a)throw new TypeError("not a function");this._state=null,this._value=null,this._deferreds=[],i(a,b(e,this),b(f,this))}function d(a){var b=this;return null===this._state?void this._deferreds.push(a):void j(function(){var c=b._state?a.onFulfilled:a.onRejected;if(null===c)return void(b._state?a.resolve:a.reject)(b._value);var d;try{d=c(b._value)}catch(e){return void a.reject(e)}a.resolve(d)})}function e(a){try{if(a===this)throw new TypeError("A promise cannot be resolved with itself.");if(a&&("object"==typeof a||"function"==typeof a)){var c=a.then;if("function"==typeof c)return void i(b(c,a),b(e,this),b(f,this))}this._state=!0,this._value=a,g.call(this)}catch(d){f.call(this,d)}}function f(a){this._state=!1,this._value=a,g.call(this)}function g(){for(var a=0,b=this._deferreds.length;b>a;a++)d.call(this,this._deferreds[a]);this._deferreds=null}function h(a,b,c,d){this.onFulfilled="function"==typeof a?a:null,this.onRejected="function"==typeof b?b:null,this.resolve=c,this.reject=d}function i(a,b,c){var d=!1;try{a(function(a){d||(d=!0,b(a))},function(a){d||(d=!0,c(a))})}catch(e){if(d)return;d=!0,c(e)}}var j=c.immediateFn||"function"==typeof setImmediate&&setImmediate||function(a){setTimeout(a,1)},k=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)};c.prototype["catch"]=function(a){return this.then(null,a)},c.prototype.then=function(a,b){var e=this;return new c(function(c,f){d.call(e,new h(a,b,c,f))})},c.all=function(){var a=Array.prototype.slice.call(1===arguments.length&&k(arguments[0])?arguments[0]:arguments);return new c(function(b,c){function d(f,g){try{if(g&&("object"==typeof g||"function"==typeof g)){var h=g.then;if("function"==typeof h)return void h.call(g,function(a){d(f,a)},c)}a[f]=g,0===--e&&b(a)}catch(i){c(i)}}if(0===a.length)return b([]);for(var e=a.length,f=0;f<a.length;f++)d(f,a[f])})},c.resolve=function(a){return a&&"object"==typeof a&&a.constructor===c?a:new c(function(b){b(a)})},c.reject=function(a){return new c(function(b,c){c(a)})},c.race=function(a){return new c(function(b,c){for(var d=0,e=a.length;e>d;d++)a[d].then(b,c)})},"undefined"!=typeof module&&module.exports?module.exports=c:a.Promise||(a.Promise=c)})(this);

    clipboard.copy = function(data) {
      return new Promise(function(resolve, reject) {
        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx
        // We only support the string type for now.
        if (typeof data !== "string" && !("text/plain" in data)) {
          throw new Error("You must provide a text/plain type.")
        }

        var strData = (typeof data === "string" ? data : data["text/plain"]);
        var copySucceeded = window.clipboardData.setData("Text", strData);
        copySucceeded ? resolve() : reject(new Error("Copying was rejected."));
      });
    };

    clipboard.paste = function(data) {
      return new Promise(function(resolve, reject) {
        var strData = window.clipboardData.getData("Text");
        if (strData) {
          resolve(strData);
        } else {
          // The user rejected the paste request.
          reject(new Error("Pasting was rejected."));
        }
      });
    };
  }

  return clipboard;
}));
}
if (AjxPackage.define("ajax.util.AjxClipboard")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Clipboard access. Current implementation is built on clipboard.js
 *
 * @class
 * @constructor
 */
AjxClipboard = function() {

};

/**
 * Returns true if clipboard access is supported.
 * @returns {Boolean}   true if clipboard access is supported
 */
AjxClipboard.isSupported = function() {
	// clipboard.js works on all browsers except IE8 and Safari
	return !AjxEnv.isIE8 && !(AjxEnv.isSafari && !AjxEnv.isChrome);
};

/**
 * Initialize clipboard action
 *
 * @param {DwtControl}          op          widget that initiates copy (eg button or menu item)
 * @param {Object}              listeners   hash of events
 */
AjxClipboard.prototype.init = function(op, listeners) {
	if (listeners.onComplete) {
		this._completionListener = listeners.onComplete.bind(null, this);
	}
	if (op && listeners.onMouseDown) {
		op.addSelectionListener(listeners.onMouseDown.bind(null, this));
	}
};

AjxClipboard.prototype.setText = function(text) {
	if (window.clipboard) {
		clipboard.copy(text).then(this._completionListener, this._onError);
	}
};

AjxClipboard.prototype._onError = function(error) {
	appCtxt.setStatusMsg(error && error.message, ZmStatusView.LEVEL_WARNING);
};
}
if (AjxPackage.define("ajax.util.AjxSHA1")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */
/*
 * Based on code by Paul Johnston:
 *
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var AjxSHA1 = function() {

	/*
	 * Configurable variables. You may need to tweak these to be compatible with
	 * the server-side, but the defaults work in most cases.
	 */
	var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
	var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
	var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));};
	function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));};
	function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));};
	function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));};
	function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));};
	function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));};

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function sha1_vm_test()
	{
		return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
	};

	/*
	 * Calculate the SHA-1 of an array of big-endian words, and a bit length
	 */
	function core_sha1(x, len)
	{
		/* append padding */
		x[len >> 5] |= 0x80 << (24 - len % 32);
		x[((len + 64 >> 9) << 4) + 15] = len;

		var w = Array(80);
		var a =  1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d =  271733878;
		var e = -1009589776;

		for(var i = 0; i < x.length; i += 16) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;

			for(var j = 0; j < 80; j++) {
				if(j < 16) w[j] = x[i + j];
				else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
				var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
						 safe_add(safe_add(e, w[j]), sha1_kt(j)));
				e = d;
				d = c;
				c = rol(b, 30);
				b = a;
				a = t;
			}

			a = safe_add(a, olda);
			b = safe_add(b, oldb);
			c = safe_add(c, oldc);
			d = safe_add(d, oldd);
			e = safe_add(e, olde);
		}
		return Array(a, b, c, d, e);

	};

	/*
	 * Perform the appropriate triplet combination function for the current
	 * iteration
	 */
	function sha1_ft(t, b, c, d)
	{
		if(t < 20) return (b & c) | ((~b) & d);
		if(t < 40) return b ^ c ^ d;
		if(t < 60) return (b & c) | (b & d) | (c & d);
		return b ^ c ^ d;
	};

	/*
	 * Determine the appropriate additive constant for the current iteration
	 */
	function sha1_kt(t)
	{
		return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
			(t < 60) ? -1894007588 : -899497514;
	};

	/*
	 * Calculate the HMAC-SHA1 of a key and some data
	 */
	function core_hmac_sha1(key, data)
	{
		var bkey = str2binb(key);
		if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

		var ipad = Array(16), opad = Array(16);
		for(var i = 0; i < 16; i++) {
			ipad[i] = bkey[i] ^ 0x36363636;
			opad[i] = bkey[i] ^ 0x5C5C5C5C;
		}

		var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
		return core_sha1(opad.concat(hash), 512 + 160);
	};

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
		var lsw = (x & 0xFFFF) + (y & 0xFFFF);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return (msw << 16) | (lsw & 0xFFFF);
	};

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function rol(num, cnt)
	{
		return (num << cnt) | (num >>> (32 - cnt));
	};

	/*
	 * Convert an 8-bit or 16-bit string to an array of big-endian words
	 * In 8-bit function, characters >255 have their hi-byte silently ignored.
	 */
	function str2binb(str)
	{
		var bin = Array();
		var mask = (1 << chrsz) - 1;
		for(var i = 0; i < str.length * chrsz; i += chrsz)
			bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
		return bin;
	};

	/*
	 * Convert an array of big-endian words to a string
	 */
	function binb2str(bin)
	{
		var str = "";
		var mask = (1 << chrsz) - 1;
		for(var i = 0; i < bin.length * 32; i += chrsz)
			str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
		return str;
	};

	/*
	 * Convert an array of big-endian words to a hex string.
	 */
	function binb2hex(binarray)
	{
		var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
		var str = "";
		for(var i = 0; i < binarray.length * 4; i++) {
			str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
				hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
		}
		return str;
	};

	/*
	 * Convert an array of big-endian words to a base-64 string
	 */
	function binb2b64(binarray)
	{
		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var str = "";
		for(var i = 0; i < binarray.length * 4; i += 3) {
			var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
				| (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
				|  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
			for(var j = 0; j < 4; j++) {
				if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
				else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
			}
		}
		return str;
	};

	// export functions
	this.hex_sha1 = hex_sha1;
	this.b64_sha1 = b64_sha1;
	this.str_sha1 = str_sha1;
	this.hex_hmac_sha1 = hex_hmac_sha1;
	this.b64_hmac_sha1 = b64_hmac_sha1;
	this.str_hmac_sha1 = str_hmac_sha1;

	this.sha1_vm_test = sha1_vm_test;

};

AjxSHA1 = new AjxSHA1();
}

if (AjxPackage.define("zimbra.csfe.ZmBatchCommand")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the batch command class.
 */

/**
 * Creates an empty batch command. Use the {@link #add} method to add commands to it,
 * and {@link #run} to invoke it.
 * @class
 * This class represent a batch command, which is a collection of separate 
 * requests. Each command is a callback with a method, arguments, and (usually) an
 * object on which to call the method. Normally, when the command is run, it creates
 * a SOAP document or JSON object which it hands to the app controller's <code>sendRequest()</code>
 * method. It may also pass a response callback and/or an error callback.
 * <p>
 * Instead of calling sendRequest(), the command should hand the batch command its SOAP
 * document or JSON object, response callback, and error callback. The last argument that
 * the command receives is a reference to the batch command; that's how it knows it's in batch mode.
 * </p>
 * <p>
 * After all commands have been added to the batch command, call its run() method. That will
 * create a BatchRequest out of the individual commands' requests and send it to the
 * server. Each subrequest gets an ID. When the BatchResponse comes back, it is broken into
 * individual responses. If a response indicates success (it is a <code>*Response</code>), the corresponding
 * response callback is called with the result. If the response is a fault, the corresponding
 * error callback is called with the exception.
 * </p>
 * <p>
 * A command does not have to be the method that generates a SOAP document or JSON object.
 * It can be higher-level. Just make sure that the reference to the batch command gets passed down to it.
 * </p>
 * @author Conrad Damon
 * 
 * @param {Boolean}	continueOnError	if <code>true</code>, the batch request continues processing when a subrequest fails (defaults to <code>true</code>)
 * @param {String}	accountName		the account name to run this batch command as.
 * @param {Boolean}	useJson			if <code>true</code>, send JSON rather than XML
 */
ZmBatchCommand = function(continueOnError, accountName, useJson) {
	
	this._onError = (continueOnError === false) ? ZmBatchCommand.STOP : ZmBatchCommand.CONTINUE;
	this._accountName = accountName;
	this._useJson = useJson;
    this._requestBody = null;

	this.curId = 0;
    this._cmds = [];
	this._requests = [];
	this._respCallbacks = [];
	this._errorCallbacks = [];
};

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmBatchCommand.prototype.toString =
function() {
	return "ZmBatchCommand";
};

//
// Data
//

ZmBatchCommand.prototype._sensitive = false;
ZmBatchCommand.prototype._noAuthToken = false;

//
// Constants
//
ZmBatchCommand.STOP = "stop";
ZmBatchCommand.CONTINUE = "continue";

//
// Public methods
//

/**
 * Sets the sensitive flag. This indicates that this batch command
 * contains a request with sensitive data. Note: There is no way to unset
 * this value for the batch command.
 * 
 * @param	{Boolean}	sensitive		<code>true</code> to set command as sensitive
 */
ZmBatchCommand.prototype.setSensitive = function(sensitive) {
	this._sensitive = this._sensitive || sensitive;
};

/**
 * Sets the noAuthToken flag.
 *
 * @param	{Boolean}	noAuthToken		<code>true</code> to send command with noAuthToken
 */
ZmBatchCommand.prototype.setNoAuthToken = function(noAuthToken) {
	this._noAuthToken = noAuthToken;
};

/**
 * Checks if the command is sensitive.
 * 
 * @return	{Boolean}	<code>true</code> if the command is sensitive
 */
ZmBatchCommand.prototype.isSensitive = function() {
	return this._sensitive;
};

/**
 * Adds a command to the list of commands to run as part of this batch request.
 * 
 * @param {AjxCallback}	cmd		the command
 */
ZmBatchCommand.prototype.add =
function(cmd) {
	this._cmds.push(cmd);
};

/**
 * Gets the number of commands that are part of this batch request.
 * 
 * @return	{int}	the size
 */
ZmBatchCommand.prototype.size =
function() {
	return this.curId || this._cmds.length;
};

/**
 * Runs the batch request. For each individual request, either a response or an
 * error callback will be called.
 * 
 * @param {AjxCallback}		callback		the callback to run after entire batch request has completed
 * @param {AjxCallback}		errorCallback	the error callback called if anything fails.
 *										The error callbacks arguments are all
 *										of the exceptions that occurred. Note:
 *										only the first exception is passed if
 *										this batch command's onError is set to
 *										stop.
 */
ZmBatchCommand.prototype.run =
function(callback, errorCallback, offlineCallback) {

	// Invoke each command so that it hands us its SOAP doc, response callback,
	// and error callback
	for (var i = 0; i < this._cmds.length; i++) {
		var cmd = this._cmds[i];
		cmd.run(this);
		this.curId++;
	}

	var params = {
		sensitive:		this._sensitive,
        noAuthToken:	this._noAuthToken,
		asyncMode:		true,
		callback:		new AjxCallback(this, this._handleResponseRun, [callback, errorCallback]),
		errorCallback:	errorCallback,
		offlineCallback: offlineCallback,
		accountName:	this._accountName
	};

	// Create the BatchRequest
	if (this._useJson) {
		var jsonObj = {BatchRequest:{_jsns:"urn:zimbra", onerror:this._onError}};
		var batchRequest = jsonObj.BatchRequest;
		var size = this.size();
		if (size && this._requests.length) {
			for (var i = 0; i < size; i++) {
				var request = this._requests[i];
                //Bug fix # 67110 the request object is sometimes undefined
                if(request) {
                    request.requestId = i;
                    var methodName = ZmCsfeCommand.getMethodName(request);
                    if (!batchRequest[methodName]) {
                        batchRequest[methodName] = [];
                    }
				    request[methodName].requestId = i;
				    batchRequest[methodName].push(request[methodName]);
                }
			}
			params.jsonObj = jsonObj;
            this._requestBody = jsonObj;
		}
	}
	else {
		var batchSoapDoc = AjxSoapDoc.create("BatchRequest", "urn:zimbra");
		batchSoapDoc.setMethodAttribute("onerror", this._onError);
		// Add each command's request element to the BatchRequest, and set its ID
		var size = this.size();
		if (size > 0) {
			for (var i = 0; i < size; i++) {
				var soapDoc = this._requests[i];
				var reqEl = soapDoc.getMethod();
				reqEl.setAttribute("requestId", i);
				var node = batchSoapDoc.adoptNode(reqEl);
				batchSoapDoc.getMethod().appendChild(node);
			}
			params.soapDoc = batchSoapDoc;
            this._requestBody = batchSoapDoc;
		}
	}

	// Issue the BatchRequest *but* only when there's something to request
	if (params.jsonObj || params.soapDoc) {
		appCtxt.getAppController().sendRequest(params);
	}
	else if (callback) {
		callback.run();
	}
};

ZmBatchCommand.prototype.getRequestBody =
function() {
    return this._requestBody;
}

/**
 * @private
 */
ZmBatchCommand.prototype._handleResponseRun =
function(callback, errorCallback, result) {
	var batchResponse = result.getResponse();
	if (!batchResponse.BatchResponse) {
		DBG.println(AjxDebug.DBG1, "Missing batch response!");
		return;
	}
	// NOTE: In case the order of the requests is significant, we process
	//       the responses in the same order.
	var responses = [];
	for (var method in batchResponse.BatchResponse) {
		if (method.match(/^_/)) continue;

		var methodResponses = batchResponse.BatchResponse[method];
		for (var i = 0; i < methodResponses.length; i++) {
			responses[methodResponses[i].requestId] = { method: method, resp: methodResponses[i] };
		}
	}
	var exceptions = [];
	for (var i = 0; i < responses.length; i++) {
		var response = responses[i];
		try {
			this._processResponse(response.method, response.resp);
		}
		catch (ex) {
			exceptions.push(ex);
			if (this._onError == ZmBatchCommand.STOP) {
				break;
			}
		}
	}
	if (exceptions.length > 0 && errorCallback) {
		errorCallback.run.apply(errorCallback, exceptions);
	}
	else if (callback) {
		callback.run(result);
	}
};

/**
 * Adds the given command parameters to the batch command, as part of a command's
 * invocation. Should be called by a function that was added via {@link #add} earlier; that
 * function should pass the request object.
 * 
 * @param {AjxSoapDoc|Object}	request		a SOAP document or JSON object with the command's request
 * @param {AjxCallback}	respCallback	the next callback in chain for async request
 * @param {AjxCallback}		errorCallback	the callback to run if there is an exception
 * 
 * @see		#add
 */
ZmBatchCommand.prototype.addRequestParams =
function(request, respCallback, errorCallback) {
	this._requests[this.curId] = request;
	this._respCallbacks[this.curId] = respCallback;
	this._errorCallbacks[this.curId] = errorCallback;
};

/**
 * Adds the given command parameters to the batch command, as part of a command's
 * invocation. Should be called without a previous {@link #add} command, when the request
 * object can immediately generate its request object.
 * 
 * @param {AjxSoapDoc|object}	request		a SOAP document or JSON object with the command's request
 * @param {AjxCallback}	respCallback	the next callback in chain for async request
 * @param {AjxCallback}	errorCallback	the callback to run if there is an exception
 * 
 * @see		#add
 */
ZmBatchCommand.prototype.addNewRequestParams =
function(request, respCallback, errorCallback) {
    this.addRequestParams(request, respCallback, errorCallback);
    this.curId++;
};

/**
 * Each type of request will return an array of <code>*Response</code> elements. There may also be
 * an array of Fault elements. Each element has an ID, so we can match it to its
 * response or error callback, and run whichever is appropriate.
 * 
 * @private
 */
ZmBatchCommand.prototype._processResponse =
function(method, resp) {
	var id = resp.requestId;

	// handle error
	if (method == "Fault") {
		var ex = ZmCsfeCommand.faultToEx(resp, "ZmBatchCommand.prototype.run");
		if (this._errorCallbacks[id]) {
			var handled = this._errorCallbacks[id].run(ex);
			if (!handled) {
				appCtxt.getAppController()._handleException(ex);
			}
		}
		throw ex;
	}

	// process response callback
	if (this._respCallbacks[id]) {
		var data = {};
		data[method] = resp;
		var result = new ZmCsfeResult(data);
		this._respCallbacks[id].run(result, resp);
	}
};
}
if (AjxPackage.define("zimbra.csfe.ZmCsfeCommand")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the command class.
 */

/**
 * Creates a command.
 * @class
 * This class represents a command.
 * 
 */
ZmCsfeCommand = function() {
};

ZmCsfeCommand.prototype.isZmCsfeCommand = true;
ZmCsfeCommand.prototype.toString = function() { return "ZmCsfeCommand"; };

// Static properties

// Global settings for each CSFE command
ZmCsfeCommand._COOKIE_NAME = "ZM_AUTH_TOKEN";
ZmCsfeCommand.serverUri = null;

ZmCsfeCommand._sessionId = null;	// current session ID
ZmCsfeCommand._staleSession = {};	// old sessions

// Reasons for re-sending a request
ZmCsfeCommand.REAUTH	= "reauth";
ZmCsfeCommand.RETRY		= "retry";

// Static methods

/**
 * Gets the auth token cookie.
 * 
 * @return	{String}	the auth token
 */
ZmCsfeCommand.getAuthToken =
function() {
	return AjxCookie.getCookie(document, ZmCsfeCommand._COOKIE_NAME);
};

/**
 * Sets the auth token cookie name.
 * 
 * @param	{String}	cookieName		the cookie name to user
 */
ZmCsfeCommand.setCookieName =
function(cookieName) {
	ZmCsfeCommand._COOKIE_NAME = cookieName;
};

/**
 * Sets the server URI.
 * 
 * @param	{String}	uri		the URI
 */
ZmCsfeCommand.setServerUri =
function(uri) {
	ZmCsfeCommand.serverUri = uri;
};

/**
 * Sets the auth token.
 * 
 * @param	{String}	authToken		the auth token
 * @param	{int}		lifetimeMs		the token lifetime in milliseconds
 * @param	{String}	sessionId		the session id
 * @param	{Boolean}	secure		<code>true</code> for secure
 * 
 */
ZmCsfeCommand.setAuthToken =
function(authToken, lifetimeMs, sessionId, secure) {
	ZmCsfeCommand._curAuthToken = authToken;
	if (lifetimeMs != null) {
		var exp = null;
		if(lifetimeMs > 0) {
			exp = new Date();
			var lifetime = parseInt(lifetimeMs);
			exp.setTime(exp.getTime() + lifetime);
		}
		AjxCookie.setCookie(document, ZmCsfeCommand._COOKIE_NAME, authToken, exp, "/", null, secure);
	} else {
		AjxCookie.deleteCookie(document, ZmCsfeCommand._COOKIE_NAME, "/");
	}
	if (sessionId) {
		ZmCsfeCommand.setSessionId(sessionId);
	}
};

/**
 * Clears the auth token cookie.
 * 
 */
ZmCsfeCommand.clearAuthToken =
function() {
	AjxCookie.deleteCookie(document, ZmCsfeCommand._COOKIE_NAME, "/");
};

/**
 * Gets the session id.
 * 
 * @return	{String}	the session id
 */
ZmCsfeCommand.getSessionId =
function() {
	return ZmCsfeCommand._sessionId;
};

/**
 * Sets the session id and, if the session id is new, designates the previous
 * session id as stale.
 * 
 * @param	{String}	sessionId		the session id
 * 
 */
ZmCsfeCommand.setSessionId =
function(sessionId) {
    var sid = ZmCsfeCommand.extractSessionId(sessionId);
    if (sid) {
        if (sid && !ZmCsfeCommand._staleSession[sid]) {
            if (sid != ZmCsfeCommand._sessionId) {
                if (ZmCsfeCommand._sessionId) {
                    // Mark the old session as stale...
                    ZmCsfeCommand._staleSession[ZmCsfeCommand._sessionId] = true;
                }
                // ...before accepting the new session.
                ZmCsfeCommand._sessionId = sid;
            }
        }
    }
};

ZmCsfeCommand.clearSessionId =
function() {
	ZmCsfeCommand._sessionId = null;
};

/**
 * Isolates the parsing of the various forms of session types that we
 * might have to handle.
 *
 * @param {mixed} session Any valid session object: string, number, object,
 * or array.
 * @return {Number|Null} If the input contained a valid session object, the
 * session number will be returned. If the input is not valid, null will
 * be returned.
 */
ZmCsfeCommand.extractSessionId =
function(session) {
    var id;

    if (session instanceof Array) {
        // Array form
	    session = session[0].id;
    }
    else if (session && session.id) {
        // Object form
        session = session.id;
    }

    // We either have extracted the id or were given some primitive form.
    // Whatever we have at this point, attempt conversion and clean up response.
    id = parseInt(session, 10);
    // Normalize response
    if (isNaN(id)) {
        id = null;
    }

	return id;
};

/**
 * Converts a fault to an exception.
 * 
 * @param	{Hash}	fault		the fault
 * @param	{Hash}	params		a hash of parameters
 * @return	{ZmCsfeException}	the exception
 */
ZmCsfeCommand.faultToEx =
function(fault, params) {
	var newParams = {
		msg: AjxStringUtil.getAsString(fault.Reason.Text),
		code: AjxStringUtil.getAsString(fault.Detail.Error.Code),
		method: (params ? params.methodNameStr : null),
		detail: AjxStringUtil.getAsString(fault.Code.Value),
		data: fault.Detail.Error.a,
		trace: (fault.Detail.Error.Trace || "")
	};

	var request;
	if (params) {
		if (params.soapDoc) {
			// note that we don't pretty-print XML if we get a soapDoc
			newParams.request = params.soapDoc.getXml();
		} else if (params.jsonRequestObj) {
			if (params.jsonRequestObj && params.jsonRequestObj.Header && params.jsonRequestObj.Header.context) {
				params.jsonRequestObj.Header.context.authToken = "(removed)";
			}
			newParams.request = AjxStringUtil.prettyPrint(params.jsonRequestObj, true);
		}
	}

	return new ZmCsfeException(newParams);
};

/**
 * Gets the method name of the given request or response.
 *
 * @param {AjxSoapDoc|Object}	request	the request
 * @return	{String}			the method name or "[unknown]"
 */
ZmCsfeCommand.getMethodName =
function(request) {

	// SOAP request
	var methodName = (request && request._methodEl && request._methodEl.tagName)
		? request._methodEl.tagName : null;

	if (!methodName) {
		for (var prop in request) {
			if (/Request|Response$/.test(prop)) {
				methodName = prop;
				break;
			}
		}
	}
	return (methodName || "[unknown]");
};

/**
 * Sends a SOAP request to the server and processes the response. The request can be in the form
 * of a SOAP document, or a JSON object.
 *
 * @param	{Hash}			params				a hash of parameters:
 * @param	{AjxSoapDoc}	soapDoc				the SOAP document that represents the request
 * @param	{Object}		jsonObj				the JSON object that represents the request (alternative to soapDoc)
 * @param	{Boolean}		noAuthToken			if <code>true</code>, the check for an auth token is skipped
 * @param	{Boolean}		authToken			authToken to use instead of the local one
 * @param	{String}		serverUri			the URI to send the request to
 * @param	{String}		targetServer		the host that services the request
 * @param	{Boolean}		useXml				if <code>true</code>, an XML response is requested
 * @param	{Boolean}		noSession			if <code>true</code>, no session info is included
 * @param	{String}		changeToken			the current change token
 * @param	{int}			highestNotifySeen 	the sequence # of the highest notification we have processed
 * @param	{Boolean}		asyncMode			if <code>true</code>, request sent asynchronously
 * @param	{AjxCallback}	callback			the callback to run when response is received (async mode)
 * @param	{Boolean}		logRequest			if <code>true</code>, SOAP command name is appended to server URL
 * @param	{String}		accountId			the ID of account to execute on behalf of
 * @param	{String}		accountName			the name of account to execute on behalf of
 * @param	{Boolean}		skipAuthCheck		if <code>true</code> to skip auth check (i.e. do not check if auth token has changed)
 * @param	{constant}		resend				the reason for resending request
 * @param	{boolean}		useStringify1		use JSON.stringify1 (gets around IE child win issue with Array)
 * @param	{boolean}		emptyResponseOkay	if true, empty or no response from server is not an erro
 */
ZmCsfeCommand.prototype.invoke =
function(params) {
	this.cancelled = false;
	if (!(params && (params.soapDoc || params.jsonObj))) { return; }

	var requestStr = ZmCsfeCommand.getRequestStr(params);

	var rpcCallback;
	try {
		var uri = (params.serverUri || ZmCsfeCommand.serverUri) + params.methodNameStr;
		this._st = new Date();
		
		var requestHeaders = {"Content-Type": "application/soap+xml; charset=utf-8"};
		if (AjxEnv.isIE6 && (location.protocol == "https:")) { //bug 22829
			requestHeaders["Connection"] = "Close";
		}
			
		if (params.asyncMode) {
			//DBG.println(AjxDebug.DBG1, "set callback for asynchronous response");
			rpcCallback = new AjxCallback(this, this._runCallback, [params]);
			this._rpcId = AjxRpc.invoke(requestStr, uri, requestHeaders, rpcCallback);
		} else {
			//DBG.println(AjxDebug.DBG1, "parse response synchronously");
			var response = AjxRpc.invoke(requestStr, uri, requestHeaders);
			return (!params.returnXml) ? (this._getResponseData(response, params)) : response;
		}
	} catch (ex) {
		this._handleException(ex, params, rpcCallback);
	}
};

/**
 * Sends a REST request to the server via GET and returns the response.
 *
 * @param {Hash}	params			a hash of parameters
 * @param	{String}       params.restUri			the REST URI to send the request to
 * @param	{Boolean}       params.asyncMode			if <code>true</code> request sent asynchronously
 * @param	{AjxCallback}	params.callback			the callback to run when response is received (async mode)
 */
ZmCsfeCommand.prototype.invokeRest =
function(params) {

	if (!(params && params.restUri)) { return; }

	var rpcCallback;
	try {
		this._st = new Date();
		if (params.asyncMode) {
			rpcCallback = new AjxCallback(this, this._runCallback, [params]);
			this._rpcId = AjxRpc.invoke(null, params.restUri, null, rpcCallback, true);
		} else {
			var response = AjxRpc.invoke(null, params.restUri, null, null, true);
			return response.text;
		}
	} catch (ex) {
		this._handleException(ex, params, rpcCallback);
	}
};

/**
 * Cancels this request (which must be async).
 * 
 */
ZmCsfeCommand.prototype.cancel =
function() {
	DBG.println("req", "CSFE cancel: " + this._rpcId);
	if (!this._rpcId) { return; }
	this.cancelled = true;
	var req = AjxRpc.getRpcRequestById(this._rpcId);
	if (req) {
		req.cancel();
		if (AjxEnv.isFirefox3_5up) {
			AjxRpc.removeRpcCtxt(req);
		}
	}
};

/**
 * Gets the request string.
 * 
 * @param	{Hash}	params		a hash of parameters
 * @return	{String}	the request string
 */
ZmCsfeCommand.getRequestStr =
function(params) {
	return 	params.soapDoc ? ZmCsfeCommand._getSoapRequestStr(params) : ZmCsfeCommand._getJsonRequestStr(params);
};

/**
 * @private
 */
ZmCsfeCommand._getJsonRequestStr =
function(params) {

	var obj = {Header:{}, Body:params.jsonObj};

	var context = obj.Header.context = {_jsns:"urn:zimbra"};
	var ua_name = ["ZimbraWebClient - ", AjxEnv.browser, " (", AjxEnv.platform, ")"].join("");
	context.userAgent = {name:ua_name};
	if (ZmCsfeCommand.clientVersion) {
		context.userAgent.version = ZmCsfeCommand.clientVersion;
	}
	if (params.noSession) {
		context.nosession = {};
	} else {
		var sessionId = ZmCsfeCommand.getSessionId();
		if (sessionId) {
			context.session = {_content:sessionId, id:sessionId};
		} else {
			context.session = {};
		}
	}
	if (params.targetServer) {
		context.targetServer = {_content:params.targetServer};
	}
	if (params.highestNotifySeen) {
		context.notify = {seq:params.highestNotifySeen};
	}
	if (params.changeToken) {
		context.change = {token:params.changeToken, type:"new"};
	}

	// if we're not checking auth token, we don't want token/acct mismatch	
	if (!params.skipAuthCheck) {
		if (params.accountId) {
			context.account = {_content:params.accountId, by:"id"}
		} else if (params.accountName) {
			context.account = {_content:params.accountName, by:"name"}
		}
	}
	
	// Tell server what kind of response we want
	if (params.useXml) {
		context.format = {type:"xml"};
	}

	params.methodNameStr = ZmCsfeCommand.getMethodName(params.jsonObj);

	// Get auth token from cookie if required
	if (!params.noAuthToken) {
		var authToken = params.authToken || ZmCsfeCommand.getAuthToken();
		if (!authToken) {
			throw new ZmCsfeException(ZMsg.authTokenRequired, ZmCsfeException.NO_AUTH_TOKEN, params.methodNameStr);
		}
		if (ZmCsfeCommand._curAuthToken && !params.skipAuthCheck && 
			(params.resend != ZmCsfeCommand.REAUTH) && (authToken != ZmCsfeCommand._curAuthToken)) {
			throw new ZmCsfeException(ZMsg.authTokenChanged, ZmCsfeException.AUTH_TOKEN_CHANGED, params.methodNameStr);
		}
		context.authToken = ZmCsfeCommand._curAuthToken = authToken;
	}
	else if (ZmCsfeCommand.noAuth) {
		throw new ZmCsfeException(ZMsg.authRequired, ZmCsfeException.NO_AUTH_TOKEN, params.methodNameStr);
	}

	if (window.csrfToken) {
		context.csrfToken = window.csrfToken;
	}

	AjxDebug.logSoapMessage(params);
	DBG.dumpObj(AjxDebug.DBG1, obj);

	params.jsonRequestObj = obj;
	
	var requestStr = (params.useStringify1 ?
	                  JSON.stringify1(obj) : JSON.stringify(obj));

	// bug 74240: escape non-ASCII characters to prevent the browser from
	// combining decomposed characters in paths
	return AjxStringUtil.jsEncode(requestStr)
};

/**
 * @private
 */
ZmCsfeCommand._getSoapRequestStr =
function(params) {

	var soapDoc = params.soapDoc;

	if (!params.resend) {

		// Add the SOAP header and context
		var hdr = soapDoc.createHeaderElement();
		var context = soapDoc.set("context", null, hdr, "urn:zimbra");
	
		var ua = soapDoc.set("userAgent", null, context);
		var name = ["ZimbraWebClient - ", AjxEnv.browser, " (", AjxEnv.platform, ")"].join("");
		ua.setAttribute("name", name);
		if (ZmCsfeCommand.clientVersion) {
			ua.setAttribute("version", ZmCsfeCommand.clientVersion);
		}
	
		if (params.noSession) {
			soapDoc.set("nosession", null, context);
		} else {
			var sessionId = ZmCsfeCommand.getSessionId();
			var si = soapDoc.set("session", null, context);
			if (sessionId) {
				si.setAttribute("id", sessionId);
			}
		}
		if (params.targetServer) {
			soapDoc.set("targetServer", params.targetServer, context);
		}
		if (params.highestNotifySeen) {
		  	var notify = soapDoc.set("notify", null, context);
		  	notify.setAttribute("seq", params.highestNotifySeen);
		}
		if (params.changeToken) {
			var ct = soapDoc.set("change", null, context);
			ct.setAttribute("token", params.changeToken);
			ct.setAttribute("type", "new");
		}
	
		// if we're not checking auth token, we don't want token/acct mismatch	
		if (!params.skipAuthCheck) {
			if (params.accountId) {
				var acc = soapDoc.set("account", params.accountId, context);
				acc.setAttribute("by", "id");
			} else if (params.accountName) {
				var acc = soapDoc.set("account", params.accountName, context);
				acc.setAttribute("by", "name");
			}
		}
	
		if (params.skipExpiredToken) {
			var tokenControl = soapDoc.set("authTokenControl", null, context);
			tokenControl.setAttribute("voidOnExpired", "1");
		}	
		// Tell server what kind of response we want
		if (!params.useXml) {
			var js = soapDoc.set("format", null, context);
			js.setAttribute("type", "js");
		}
	}

	params.methodNameStr = ZmCsfeCommand.getMethodName(soapDoc);

	// Get auth token from cookie if required
	if (!params.noAuthToken) {
		var authToken = params.authToken || ZmCsfeCommand.getAuthToken();
		if (!authToken) {
			throw new ZmCsfeException(ZMsg.authTokenRequired, ZmCsfeException.NO_AUTH_TOKEN, params.methodNameStr);
		}
		if (ZmCsfeCommand._curAuthToken && !params.skipAuthCheck && 
			(params.resend != ZmCsfeCommand.REAUTH) && (authToken != ZmCsfeCommand._curAuthToken)) {
			throw new ZmCsfeException(ZMsg.authTokenChanged, ZmCsfeException.AUTH_TOKEN_CHANGED, params.methodNameStr);
		}
		ZmCsfeCommand._curAuthToken = authToken;
		if (params.resend == ZmCsfeCommand.REAUTH) {
			// replace old auth token with current one
			var nodes = soapDoc.getDoc().getElementsByTagName("authToken");
			if (nodes && nodes.length == 1) {
				DBG.println(AjxDebug.DBG1, "Re-auth: replacing auth token");
				nodes[0].firstChild.data = authToken;
			} else {
				// can't find auth token, just add it to context element
				nodes = soapDoc.getDoc().getElementsByTagName("context");
				if (nodes && nodes.length == 1) {
					DBG.println(AjxDebug.DBG1, "Re-auth: re-adding auth token");
					soapDoc.set("authToken", authToken, nodes[0]);
				} else {
					DBG.println(AjxDebug.DBG1, "Re-auth: could not find context!");
				}
			}
		} else if (!params.resend){
			soapDoc.set("authToken", authToken, context);
		}
	}
	else if (ZmCsfeCommand.noAuth && !params.ignoreAuthToken) {
		throw new ZmCsfeException(ZMsg.authRequired, ZmCsfeException.NO_AUTH_TOKEN, params.methodNameStr);
	}

	if (window.csrfToken) {
		soapDoc.set("csrfToken", window.csrfToken, context);
	}

	AjxDebug.logSoapMessage(params);
	DBG.printXML(AjxDebug.DBG1, soapDoc.getXml());

	return soapDoc.getXml();
};

/**
 * Runs the callback that was passed to invoke() for an async command.
 *
 * @param {AjxCallback}	callback	the callback to run with response data
 * @param {Hash}	params	a hash of parameters (see method invoke())
 * 
 * @private
 */
ZmCsfeCommand.prototype._runCallback =
function(params, result) {
	if (!result) { return; }
	if (this.cancelled && params.skipCallbackIfCancelled) {	return; }

	var response;
	if (result instanceof ZmCsfeResult) {
		response = result; // we already got an exception and packaged it
	} else {
		response = this._getResponseData(result, params);
	}
	this._en = new Date();

	if (params.callback && response) {
		params.callback.run(response);
	} else if (!params.emptyResponseOkay) {
		DBG.println(AjxDebug.DBG1, "ZmCsfeCommand.prototype._runCallback: Missing callback!");
	}
};

/**
 * Takes the response to an RPC request and returns a JS object with the response data.
 *
 * @param {Object}	response	the RPC response with properties "text" and "xml"
 * @param {Hash}	params	a hash of parameters (see method invoke())
 */
ZmCsfeCommand.prototype._getResponseData =
function(response, params) {
	this._en = new Date();
	DBG.println(AjxDebug.DBG1, "ROUND TRIP TIME: " + (this._en.getTime() - this._st.getTime()));

	var result = new ZmCsfeResult();
	var xmlResponse = false;
	var restResponse = Boolean(params.restUri);
	var respDoc = null;

	// check for un-parseable HTML error response from server
	if (!response.success && !response.xml && (/<html/i.test(response.text))) {
		// bad XML or JS response that had no fault
		var ex = new ZmCsfeException(null, ZmCsfeException.CSFE_SVC_ERROR, params.methodNameStr, "HTTP response status " + response.status);
		if (params.asyncMode) {
			result.set(ex, true);
			return result;
		} else {
			throw ex;
		}
	}

	if (typeof(response.text) == "string" && response.text.indexOf("{") == 0) {
		respDoc = response.text;
	} else if (!restResponse) {
		// an XML response if we requested one, or a fault
		try {
			xmlResponse = true;
			if (!(response.text || (response.xml && (typeof response.xml) == "string"))) {
				if (params.emptyResponseOkay) {
					return null;
				}
				else {
					// If we can't reach the server, req returns immediately with an empty response rather than waiting and timing out
					throw new ZmCsfeException(null, ZmCsfeException.EMPTY_RESPONSE, params.methodNameStr);
				}
			}
			// responseXML is empty under IE
			respDoc = (AjxEnv.isIE || response.xml == null) ? AjxSoapDoc.createFromXml(response.text) :
															  AjxSoapDoc.createFromDom(response.xml);
		} catch (ex) {
			DBG.dumpObj(AjxDebug.DBG1, ex);
			if (params.asyncMode) {
				result.set(ex, true);
				return result;
			} else {
				throw ex;
			}
		}
		if (!respDoc) {
			var ex = new ZmCsfeException(null, ZmCsfeException.SOAP_ERROR, params.methodNameStr, "Bad XML response doc");
			DBG.dumpObj(AjxDebug.DBG1, ex);
			if (params.asyncMode) {
				result.set(ex, true);
				return result;
			} else {
				throw ex;
			}
		}
	}

	var obj = restResponse ? response.text : {};

	if (xmlResponse) {
		DBG.printXML(AjxDebug.DBG1, respDoc.getXml());
		obj = respDoc._xmlDoc.toJSObject(true, false, true);
	} else if (!restResponse) {
		try {
			obj = JSON.parse(respDoc);
		} catch (ex) {
			if (ex.name == "SyntaxError") {
				ex = new ZmCsfeException(null, ZmCsfeException.BAD_JSON_RESPONSE, params.methodNameStr, respDoc);
				AjxDebug.println(AjxDebug.BAD_JSON, "bad json. respDoc=" + respDoc);
			}
			DBG.dumpObj(AjxDebug.DBG1, ex);
			if (params.asyncMode) {
				result.set(ex, true);
				return result;
			} else {
				throw ex;
			}
		}

	}

	params.methodNameStr = ZmCsfeCommand.getMethodName(obj.Body);
	AjxDebug.logSoapMessage(params);
	DBG.dumpObj(AjxDebug.DBG1, obj, -1);

	var fault = obj && obj.Body && obj.Body.Fault;
	if (fault) {
		// JS response with fault
		if (AjxUtil.isString(fault) && fault.indexOf("<")==0) { // We got an xml string
			fault = AjxXmlDoc.createFromXml(fault).toJSObject(true, false, true);
		}
		var ex = ZmCsfeCommand.faultToEx(fault, params);
		if (params.asyncMode) {
			result.set(ex, true, obj.Header);
			return result;
		} else {
			throw ex;
		}
	} else if (!response.success) {
		// bad XML or JS response that had no fault
		var ex = new ZmCsfeException(null, ZmCsfeException.CSFE_SVC_ERROR, params.methodNameStr, "HTTP response status " + response.status);
		if (params.asyncMode) {
			result.set(ex, true);
			return result;
		} else {
			throw ex;
		}
	} else {
		// good response
		if (params.asyncMode) {
			result.set(obj);
		}
	}

	// check for new session ID
	var session = obj.Header && obj.Header.context && obj.Header.context.session;
    ZmCsfeCommand.setSessionId(session);

	return params.asyncMode ? result : obj;
};

/**
 * @private
 */
ZmCsfeCommand.prototype._handleException =
function(ex, params, callback) {
	if (!(ex && (ex instanceof ZmCsfeException || ex instanceof AjxSoapException || ex instanceof AjxException))) {
		var newEx = new ZmCsfeException();
		newEx.method = params.methodNameStr || params.restUri;
		newEx.detail = ex ? ex.toString() : "undefined exception";
		newEx.code = ZmCsfeException.UNKNOWN_ERROR;
		newEx.msg = "Unknown Error";
		ex = newEx;
	}
	if (params.asyncMode) {
		callback.run(new ZmCsfeResult(ex, true));
	} else {
		throw ex;
	}
};
}
if (AjxPackage.define("zimbra.csfe.ZmCsfeException")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the exception class.
 */
/**
 * Creates an exception.
 * @class
 * This class represents an exception returned by the server as a response, generally as a fault. The fault
 * data is converted to properties of the exception.
 *
 * @param {Hash}	params	a hash of parameters
 * @param {String}      params.msg		the explanation (Fault.Reason.Text)
 * @param {String}      params.code		the error code (Fault.Detail.Error.Code)
 * @param {String}      params.method	the request name
 * @param {String}      params.detail	the Fault.Code.Value
 * @param {Object}      [params.data]		an optional structured fault data (Fault.Detail.Error.a)
 * @param {String}      params.trace		the trace info (Fault.Detail.Error.Trace)
 * @param {String}       params.request	the SOAP or JSON that represents the request
 * 
 * @extends		AjxException
 */
ZmCsfeException = function(params) {

	params = Dwt.getParams(arguments, ZmCsfeException.PARAMS);

	AjxException.call(this, params.msg, params.code, params.method, params.detail);
	
	if (params.data) {
		this.data = {};
		for (var i = 0; i < params.data.length; i++) {
			var item = params.data[i];
			var key = item.n;
			if (!this.data[key]) {
				this.data[key] = [];
			}
			this.data[key].push(item._content);
		}
	}
	
	this.trace = params.trace;
	this.request = params.request;
};

ZmCsfeException.PARAMS = ["msg", "code", "method", "detail", "data", "trace"];

ZmCsfeException.prototype = new AjxException;
ZmCsfeException.prototype.constructor = ZmCsfeException;
ZmCsfeException.prototype.isZmCsfeException = true;

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmCsfeException.prototype.toString =
function() {
	return "ZmCsfeException";
};

//
// Constants
//

// structured data keys
ZmCsfeException.MAIL_SEND_ADDRESS_FAILURE_INVALID = "invalid";
ZmCsfeException.MAIL_SEND_ADDRESS_FAILURE_UNSENT = "unsent";

//
// Static functions
//

/**
 * Gets the error messages.
 * 
 * @param	{String}	code	the code
 * @param	{Array}	args		the message format args
 * 
 * @return	{String}	the message
 */
ZmCsfeException.getErrorMsg =
function(code, args) {
	var msg = ZMsg[code];
	if (!msg) {
		ZmCsfeException._unknownFormat = ZmCsfeException._unknownFormat || new AjxMessageFormat(ZMsg.unknownError);
		return ZmCsfeException._unknownFormat.format(code);
	}
	this.msg = this.msg || msg;
	return args ? AjxMessageFormat.format(msg, args) : msg;
};

//
// Public methods
//

/**
 * Gets the error message.
 * 
 * @param	{Array}	args		the message format args
 * @return	{String}	the message
 */
ZmCsfeException.prototype.getErrorMsg =
function(args) {
	return ZmCsfeException.getErrorMsg(this.code, args);
};

/**
 * Gets the data.
 * 
 * @param	{Object}	key		the key
 * 
 * @return	{Object}	the data
 */
ZmCsfeException.prototype.getData =
function(key) {
	return this.data && this.data[key];
};

//
// Constants for server exceptions
//

ZmCsfeException.AUTH_TOKEN_CHANGED					= "AUTH_TOKEN_CHANGED";
ZmCsfeException.BAD_JSON_RESPONSE					= "BAD_JSON_RESPONSE";
ZmCsfeException.CSFE_SVC_ERROR						= "CSFE_SVC_ERROR";
ZmCsfeException.EMPTY_RESPONSE						= "EMPTY_RESPONSE";
ZmCsfeException.NETWORK_ERROR						= "NETWORK_ERROR";
ZmCsfeException.NO_AUTH_TOKEN						= "NO_AUTH_TOKEN";
ZmCsfeException.SOAP_ERROR							= "SOAP_ERROR";

ZmCsfeException.LICENSE_ERROR						= "service.LICENSE_ERROR";
ZmCsfeException.SVC_ALREADY_IN_PROGRESS				= "service.ALREADY_IN_PROGRESS";
ZmCsfeException.SVC_AUTH_EXPIRED					= "service.AUTH_EXPIRED";
ZmCsfeException.SVC_AUTH_REQUIRED					= "service.AUTH_REQUIRED";
ZmCsfeException.SVC_FAILURE							= "service.FAILURE";
ZmCsfeException.SVC_INVALID_REQUEST					= "service.INVALID_REQUEST";
ZmCsfeException.SVC_PARSE_ERROR						= "service.PARSE_ERROR";
ZmCsfeException.SVC_PERM_DENIED						= "service.PERM_DENIED";
ZmCsfeException.SVC_RESOURCE_UNREACHABLE			= "service.RESOURCE_UNREACHABLE";
ZmCsfeException.SVC_UNKNOWN_DOCUMENT				= "service.UNKNOWN_DOCUMENT";
ZmCsfeException.SVC_TEMPORARILY_UNAVAILABLE			= "service.TEMPORARILY_UNAVAILABLE";
ZmCsfeException.SVC_WRONG_HOST						= "service.WRONG_HOST";

ZmCsfeException.ACCT_AUTH_FAILED					= "account.AUTH_FAILED";
ZmCsfeException.ACCT_CHANGE_PASSWORD				= "account.CHANGE_PASSWORD";
ZmCsfeException.ACCT_EXISTS							= "account.ACCOUNT_EXISTS";
ZmCsfeException.ACCT_TOO_MANY_ACCOUNTS      		= "account.TOO_MANY_ACCOUNTS" ;
ZmCsfeException.ACCT_INVALID_ATTR_VALUE				= "account.INVALID_ATTR_VALUE";
ZmCsfeException.ACCT_INVALID_PASSWORD				= "account.INVALID_PASSWORD";
ZmCsfeException.ACCT_INVALID_PREF_NAME				= "account.INVALID_PREF_NAME";
ZmCsfeException.ACCT_INVALID_PREF_VALUE				= "account.INVALID_PREF_VALUE";
ZmCsfeException.ACCT_MAINTENANCE_MODE				= "account.MAINTENANCE_MODE";
ZmCsfeException.ACCT_NO_SUCH_ACCOUNT				= "account.NO_SUCH_ACCOUNT";
ZmCsfeException.ACCT_NO_SUCH_SAVED_SEARCH			= "account.NO_SUCH_SAVED_SEARCH";
ZmCsfeException.ACCT_NO_SUCH_TAG					= "account.ACCT_NO_SUCH_TAG";
ZmCsfeException.ACCT_PASS_CHANGE_TOO_SOON			= "account.PASSWORD_CHANGE_TOO_SOON";
ZmCsfeException.ACCT_PASS_LOCKED					= "account.PASSWORD_LOCKED";
ZmCsfeException.ACCT_PASS_RECENTLY_USED				= "account.PASSWORD_RECENTLY_USED";
ZmCsfeException.COS_EXISTS							= "account.COS_EXISTS";
ZmCsfeException.DISTRIBUTION_LIST_EXISTS			= "account.DISTRIBUTION_LIST_EXISTS";
ZmCsfeException.DOMAIN_EXISTS						= "account.DOMAIN_EXISTS";
ZmCsfeException.DOMAIN_NOT_EMPTY					= "account.DOMAIN_NOT_EMPTY";
ZmCsfeException.IDENTITY_EXISTS						= "account.IDENTITY_EXISTS";
ZmCsfeException.NO_SUCH_DISTRIBUTION_LIST			= "account.NO_SUCH_DISTRIBUTION_LIST";
ZmCsfeException.NO_SUCH_DOMAIN						= "account.NO_SUCH_DOMAIN";
ZmCsfeException.MAINTENANCE_MODE					= "account.MAINTENANCE_MODE";
ZmCsfeException.TOO_MANY_IDENTITIES					= "account.TOO_MANY_IDENTITIES";
ZmCsfeException.TOO_MANY_SEARCH_RESULTS				= "account.TOO_MANY_SEARCH_RESULTS";
ZmCsfeException.NO_SUCH_COS 						= "account.NO_SUCH_COS";
ZmCsfeException.SIGNATURE_EXISTS                    = "account.SIGNATURE_EXISTS";

ZmCsfeException.CANNOT_CHANGE_VOLUME = "volume.CANNOT_CHANGE_TYPE_OF_CURRVOL";
ZmCsfeException.CANNOT_DELETE_VOLUME_IN_USE = "volume.CANNOT_DELETE_VOLUME_IN_USE";
ZmCsfeException.NO_SUCH_VOLUME						= "volume.NO_SUCH_VOLUME";
ZmCsfeException.ALREADY_EXISTS						= "volume.ALREADY_EXISTS";
ZmCsfeException.VOLUME_NO_SUCH_PATH					= "volume.NO_SUCH_PATH";

ZmCsfeException.MAIL_ALREADY_EXISTS					= "mail.ALREADY_EXISTS";
ZmCsfeException.MAIL_IMMUTABLE						= "mail.IMMUTABLE_OBJECT";
ZmCsfeException.MAIL_INVALID_NAME					= "mail.INVALID_NAME";
ZmCsfeException.MAIL_INVITE_OUT_OF_DATE				= "mail.INVITE_OUT_OF_DATE";
ZmCsfeException.MAIL_MAINTENANCE_MODE				= "mail.MAINTENANCE";
ZmCsfeException.MAIL_MESSAGE_TOO_BIG				= "mail.MESSAGE_TOO_BIG";
ZmCsfeException.MAIL_MUST_RESYNC					= "mail.MUST_RESYNC";
ZmCsfeException.MAIL_NO_SUCH_CALITEM				= "mail.NO_SUCH_CALITEM";
ZmCsfeException.MAIL_NO_SUCH_CONV					= "mail.NO_SUCH_CONV";
ZmCsfeException.MAIL_NO_SUCH_CONTACT				= "mail.NO_SUCH_CONTACT";
ZmCsfeException.MAIL_NO_SUCH_FOLDER					= "mail.NO_SUCH_FOLDER";
ZmCsfeException.MAIL_NO_SUCH_ITEM					= "mail.NO_SUCH_ITEM";
ZmCsfeException.MAIL_NO_SUCH_MOUNTPOINT				= "mail.NO_SUCH_MOUNTPOINT";
ZmCsfeException.MAIL_NO_SUCH_MSG					= "mail.NO_SUCH_MSG";
ZmCsfeException.MAIL_NO_SUCH_PART					= "mail.NO_SUCH_PART";
ZmCsfeException.MAIL_NO_SUCH_TAG					= "mail.NO_SUCH_TAG";
ZmCsfeException.MAIL_QUERY_PARSE_ERROR				= "mail.QUERY_PARSE_ERROR";
ZmCsfeException.MAIL_QUOTA_EXCEEDED					= "mail.QUOTA_EXCEEDED";
ZmCsfeException.MAIL_SEND_ABORTED_ADDRESS_FAILURE	= "mail.SEND_ABORTED_ADDRESS_FAILURE";
ZmCsfeException.MAIL_SEND_FAILURE					= "mail.SEND_FAILURE";
ZmCsfeException.MAIL_TOO_MANY_CONTACTS				= "mail.TOO_MANY_CONTACTS";
ZmCsfeException.MAIL_TOO_MANY_TERMS					= "mail.TOO_MANY_QUERY_TERMS_EXPANDED";
ZmCsfeException.MAIL_UNABLE_TO_IMPORT_APPOINTMENTS	= "mail.MAIL_UNABLE_TO_IMPORT_APPOINTMENTS";
ZmCsfeException.MAIL_UNABLE_TO_IMPORT_CONTACTS		= "mail.UNABLE_TO_IMPORT_CONTACTS";
ZmCsfeException.MODIFY_CONFLICT						= "mail.MODIFY_CONFLICT";
ZmCsfeException.TOO_MANY_TAGS						= "mail.TOO_MANY_TAGS";
ZmCsfeException.CANNOT_RENAME                       = "mail.CANNOT_RENAME";
ZmCsfeException.CANNOT_UNLOCK                       = "mail.CANNOT_UNLOCK";
ZmCsfeException.CANNOT_LOCK                         = "mail.CANNOT_LOCK";
ZmCsfeException.LOCKED                              = "mail.LOCKED";
ZmCsfeException.UPLOAD_REJECTED						= "mail.UPLOAD_REJECTED";

ZmCsfeException.MUST_BE_ORGANIZER					= "mail.MUST_BE_ORGANIZER";


ZmCsfeException.OFFLINE_ONLINE_ONLY_OP				= "offline.ONLINE_ONLY_OP";
}
if (AjxPackage.define("zimbra.csfe.ZmCsfeResult")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the result class.
 */

/**
 * Creates a CSFE result object.
 * @class
 * This class represents the result of a CSFE request. The data is either the 
 * response that was received, or an exception. If the request resulted in a 
 * SOAP fault from the server, there will also be a SOAP header present.
 *
 * @author Conrad Damon
 * 
 * @param {Object}	data			the response data
 * @param {Boolean}	isException	if <code>true</code>, the data is an exception object
 * @param {Object}	header			the SOAP header
 * 
 */
ZmCsfeResult = function(data, isException, header) {
	this.set(data, isException, header);
};

ZmCsfeResult.prototype.isZmCsfeResult = true;
ZmCsfeResult.prototype.toString = function() { return "ZmCsfeResult"; };

/**
 * Sets the content of the result.
 *
 * @param {Object}	data			the response data
 * @param {Boolean}	isException	if <code>true</code>, the data is an exception object
 * @param {Object}	header			the SOAP header
 */
ZmCsfeResult.prototype.set =
function(data, isException, header) {
	this._data = data;
	this._isException = (isException === true);
	this._header = header;
};

/**
 * Gets the response data. If there was an exception, throws the exception.
 * 
 * @return	{Object}	the data
 */
ZmCsfeResult.prototype.getResponse =
function() {
	if (this._isException) {
		throw this._data;
	} else {
		return this._data;
	}
};

/**
 * Gets the exception object, if any.
 * 
 * @return	{ZmCsfeException}	the exception or <code>null</code> for none
 */
ZmCsfeResult.prototype.getException =
function() {
	return this._isException ? this._data : null;
};

/**
 * Checks if this result is an exception.
 * 
 * @return	{Boolean}	<code>true</code> if an exception
 */
ZmCsfeResult.prototype.isException = 
function() {
	return this._isException;
};

/**
 * Gets the SOAP header that came with a SOAP fault.
 * 
 * @return	{String}	the header
 */
ZmCsfeResult.prototype.getHeader =
function() {
	return this._header;
};
}

if (AjxPackage.define("zimbraMail.core.ZmId")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains ids.
 * 
 */

/**
 * Constructor
 * @class
 * This class is responsible for providing unique, predictable IDs for HTML elements.
 * That way, code outside the client can easily locate particular elements.
 * <br/>
 * <br/>
 * Not every element that has an associated JS object will have a known ID. Those are
 * allocated only for elements it would be useful to locate: major components of the UI,
 * toolbars, buttons, views, menus, some menu items, some selects, and miscellaneous other
 * components.
 * <br/>
 * <br/>
 * Unless noted otherwise, a getElementById() on any of the non-skin IDs will return a DIV. One exception
 * is input fields. The ID is given to the DwtInputField's actual INPUT, rather than to the
 * DIV that contains it. Most other exceptions are table-related: TABLE, TR, and TD.
 * <br/>
 * <br/>
 * There is a simple naming scheme for the IDs themselves. Each ID starts with a "z" followed
 * by one to a few letters that indicate the type of object (widget) represented by the element:
 * 
 * <ul>
 * <li><b>z</b> a component that is not a special-purpose widget listed below</li>
 * <li><b>ztb</b> 		a toolbar (see {@link ZmId.WIDGET})</li>
 * <li><b>zb</b> 		a button (see {@link ZmId.WIDGET_TOOLBAR})</li>
 * <li><b>zi</b> 		an input field (see {@link ZmId.WIDGET_INPUT})</li>
 * <li><b>zm</b> 		a menu (see {@link ZmId.WIDGET_MENU})</li>
 * <li><b>zmi</b> 		a menu item (see {@link ZmId.WIDGET_MENU_ITEM})</li>
 * <li><b>zs</b> 		a select (see {@link ZmId.WIDGET_SELECT})</li>
 * <li><b>zov</b> 		an overview (see {@link ZmId.WIDGET_OVERVIEW})</li>
 * <li><b>zt</b> 		a tree (see {@link ZmId.WIDGET_TREE})</li>
 * <li><b>zti</b> 		a tree item (see {@link ZmId.WIDGET_TREE_ITEM})</li>
 * <li><b>ztih</b> 	a tree item header (see {@link ZmId.WIDGET_TREE_ITEM_HDR})</li>
 *</ul>
 *
 * The skin defines its own container IDs starting with "skin_", which we provide constants for here.
 * 
 * @author Conrad Damon
 */
ZmId = function() {};

//
// Element IDs, and functions to generate them
//

// widget types (used to prefix IDs)
// TODO: move most of these to DwtId
ZmId.WIDGET					= "z";			// generic element
ZmId.WIDGET_VIEW			= "zv";			// view within content area
ZmId.WIDGET_TOOLBAR			= "ztb";		// toolbar
ZmId.WIDGET_BUTTON			= "zb";			// button
ZmId.WIDGET_INPUT			= "zi";			// text input or textarea
ZmId.WIDGET_MENU			= "zm";			// menu
ZmId.WIDGET_MENU_ITEM		= "zmi";		// menu item
ZmId.WIDGET_SELECT			= "zs";			// dropdown select
ZmId.WIDGET_OVERVIEW_CNTR	= "zovc";		// collection of overviews
ZmId.WIDGET_OVERVIEW		= "zov";		// collection of tree views
ZmId.WIDGET_TREE			= "zt";			// tree view
ZmId.WIDGET_TREE_ITEM_HDR	= "ztih";		// root tree item
ZmId.WIDGET_TREE_ITEM		= "zti";		// tree item (node)
ZmId.WIDGET_TAB				= "ztab";		// tab button
ZmId.WIDGET_AUTOCOMPLETE	= "zac";		// autocomplete list
ZmId.WIDGET_CHECKBOX		= "zcb";		// checkbox
ZmId.WIDGET_COMBOBOX		= "zcombo";		// combo box
ZmId.WIDGET_CHOOSER			= "zchooser";	// folder chooser
ZmId.WIDGET_CALENDAR		= "zcal";		// popup calendar

//
// Preset IDs
//

/*
 * Container IDs defined by the skin.
 * 
 * These must match what's in skin.html. They are used by ZmAppViewMgr to visually
 * match components to the containers in which they should be positioned. 
 */
ZmId.SKIN_APP_BOTTOM_TOOLBAR		= "skin_container_app_bottom_toolbar";
ZmId.SKIN_APP_CHOOSER				= "skin_container_app_chooser";
ZmId.SKIN_APP_MAIN_FULL				= "skin_container_app_main_full";
ZmId.SKIN_APP_MAIN					= "skin_container_app_main";
ZmId.SKIN_APP_MAIN_ROW_FULL			= "skin_tr_main_full";
ZmId.SKIN_APP_MAIN_ROW				= "skin_tr_main";
ZmId.SKIN_APP_TOP_TOOLBAR			= "skin_container_app_top_toolbar";
ZmId.SKIN_APP_NEW_BUTTON			= "skin_container_app_new_button"; 
ZmId.SKIN_LINKS						= "skin_container_links";
ZmId.SKIN_LOGO						= "skin_container_logo";
ZmId.SKIN_QUOTA_INFO				= "skin_container_quota";
ZmId.SKIN_SASH						= "skin_container_tree_app_sash";
ZmId.SKIN_SEARCH_BUILDER			= "skin_container_search_builder";
ZmId.SKIN_SEARCH_BUILDER_TOOLBAR	= "skin_container_search_builder_toolbar";
ZmId.SKIN_SEARCH_BUILDER_TR			= "skin_tr_search_builder";
ZmId.SKIN_SEARCH					= "skin_container_search";
ZmId.SKIN_SEARCH_RESULTS_TOOLBAR	= "skin_container_search_results_toolbar";
ZmId.SKIN_REFRESH					= "skin_container_refresh";
ZmId.SKIN_OFFLINE_STATUS			= "skin_container_offline";
ZmId.SKIN_SHELL						= "skin_outer";
ZmId.SKIN_SPACING_SEARCH			= "skin_spacing_search";
ZmId.SKIN_SPLASH_SCREEN				= "skin_container_splash_screen";
ZmId.SKIN_STATUS					= "skin_container_status";
ZmId.SKIN_STATUS_ROW				= "skin_tr_status";
ZmId.SKIN_TREE_FOOTER				= "skin_container_tree_footer";
ZmId.SKIN_TREE						= "skin_container_tree";
ZmId.SKIN_USER_INFO					= "skin_container_username";
ZmId.SKIN_FOOTER					= "skin_footer";
ZmId.SKIN_AD						= "skin_adsrvc";
ZmId.SKIN_UNITTEST					= "skin_unittest";

//
// Literal IDs
//

/*
 * Top-level components. These are elements that are placed directly into skin containers.
 */
ZmId.SHELL					= "z_shell";			// the main shell
ZmId.LOADING_VIEW			= "z_loading";			// "Loading..." view
ZmId.MAIN_SASH				= "z_sash";				// sash between overview and content
ZmId.BANNER					= "z_banner";			// logo (at upper left by default)
ZmId.SEARCH_TOOLBAR			= "ztb_search";			// search toolbar
ZmId.SEARCHRESULTS_TOOLBAR	= "ztb_searchresults";	// search results toolbar
ZmId.SEARCHRESULTS_PANEL	= "z_filterPanel";		// search results filter panel
ZmId.USER_NAME				= "z_userName";			// account name
ZmId.USER_QUOTA				= "z_userQuota";		// quota
ZmId.PRESENCE				= "z_presence";			// presence
ZmId.NEW_FOLDER_BUTTON		= "zb_newFolder";		// New Folder button on current app toolbar
ZmId.STATUS_VIEW			= "z_status";			// status view (shows toast)
ZmId.TOAST					= "z_toast";			// toast
ZmId.APP_CHOOSER			= "ztb_appChooser";		// app chooser toolbar

//
// Functions for generating IDs
//
// In general, an ID created by one of these functions will consist of several fields joined
// together by a "|" character. The first field indicates the type of element/widget, and will
// be one of the ZmId.WIDGET_* constants. The remaining fields are there to ensure that the ID
// is unique.

/**
 * Generates the ID for a toolbar.
 * 
 * <p>
 * Examples: <code>ztb|CLV ztb|TV|Nav ztb|CV|Inv</code>
 * </p>
 * 
 * @param {String}	context		the toolbar context (ID of owning view)
 * @param {constant}	tbType	the type of toolbar (for example, invite or nav)
 * @return	{String}	the id
 */
ZmId.getToolbarId =
function(context, tbType) {
	return DwtId.makeId(ZmId.WIDGET_TOOLBAR, context, tbType);
};

// special toolbars
ZmId.TB_INVITE	= "Inv";
ZmId.TB_COUNTER	= "Cou";
ZmId.TB_NAV		= "Nav";
ZmId.TB_SHARE	= "Shr";
ZmId.TB_REPLY	= "Rep";
ZmId.TB_SUBSCRIBE = "Sub";

/**
 * Generates the ID for a button. Intended for use with the top toolbar, nav toolbar,
 * and invite toolbar.
 * 
 * <p>
 * Examples: <code>zb|CLV|CHECK_MAIL zb|TV|REPLY zb|COMPOSE|SEND zb|CLV|Nav|PAGE_FORWARD</code>
 * </p>
 * 
 * @param {String}	context	the toolbar context (ID of owning view)
 * @param {constant}	op	the button operation
 * @param {constant}	tbType	the type of toolbar (eg invite or nav)
 * @return	{String}	the id
 */
ZmId.getButtonId =
function(context, op, tbType) {
	return DwtId.makeId(ZmId.WIDGET_BUTTON, context, tbType, op);
};

/**
 * Generates the ID for an action menu.
 * 
 * <p>
 * Examples: <code>zm|CLV zm|Contacts zm|TV|Par</code>
 * </p>
 * 
 * @param {String}	context		the menu context (eg ID of owning view, or app)
 * @param {constant}	menuType		the type of menu (eg participant)
 * @return	{String}	the id
 */
ZmId.getMenuId =
function(context, menuType) {
	return DwtId.makeId(ZmId.WIDGET_MENU, context, menuType);
};

// special menus
ZmId.MENU_PARTICIPANT	= "Par";
ZmId.MENU_DRAFTS		= "Dra";

/**
 * Generates the ID for a menu item in an action menu.
 * 
 * <p>
 * Examples: <code>zmi|CLV|REPLY_ALL zmi|TV|Par|SEARCH</code>
 * </p>
 * 
 * @param {String}	context		the menu context
 * @param {constant}	op			the menu operation
 * @param {constant}	menuType		the type of menu (eg participant)
 * @return	{String}	the id
 */
ZmId.getMenuItemId =
function(context, op, menuType) {
	return DwtId.makeId(ZmId.WIDGET_MENU_ITEM, context, menuType, op);
};

/**
 * Generates the ID for an overview container.
 *
 * @param {String}	overviewContainerId		the overview container ID
 * @return	{String}	the id
 */
ZmId.getOverviewContainerId =
function(overviewContainerId) {
	return DwtId.makeId(ZmId.WIDGET_OVERVIEW_CNTR, overviewContainerId);
};

/**
 * Generates the ID for an overview.
 * 
 * <p>
 * Examples: <code>zov|Mail zov|ZmChooseFolderDialog-ZmListController zov|ZmPickTagDialog</code>
 * </p>
 * 
 * @param {String}	overviewId	the overview ID
 * @return	{String}	the id
 */
ZmId.getOverviewId =
function(overviewId) {
	return DwtId.makeId(ZmId.WIDGET_OVERVIEW, overviewId);
};

/**
 * Generates the ID for a tree within an overview.
 * 
 * <p>
 * Examples: <code>zt|Mail|FOLDER zt|ZmPickTagDialog|TAG</code>
 * </p>
 * 
 * @param {String}	overviewId	the overview ID
 * @param {String}	orgType 		the organizer type (see <code>ZmId.ORG_</code> constants)
 * @return	{String}	the id
 */
ZmId.getTreeId =
function(overviewId, orgType) {
	return DwtId.makeId(ZmId.WIDGET_TREE, overviewId, orgType);
};

/**
 * Generates a tree item ID based on the underlying organizer and the overview ID (since the same
 * organizer may be represented as tree items in more than one overview). Some sample IDs:
 * 
 * <ul>
 * <li><b>zti|Mail|2</b> Inbox</li>
 * <li><b>zti|Mail|172</b>			user-created item in mail overview</li>
 * <li><b>zti|Contacts|7</b>			system Contacts folder</li>
 * <li><b>zti|Calendar|304</b>		user-created item in calendar overview</li>
 * <li><b>ztih|Mail|FOLDER</b>		Folders header in mail overview</li>
 * </ul>
 * 
 * Constants for some system folder tree items have been provided as a convenience.
 * 
 * @param {String}	overviewId	the unique ID for overview
 * @param {ZmOrganizer}	organizerId	the ID of the data object backing tree item
 * @param {constant}	type			the organizer type (for headers only)
 * @return	{String}	the id
 */
ZmId.getTreeItemId =
function(overviewId, organizerId, type) {
	if (!organizerId && !type) { return; }
	if (type) {
		return DwtId.makeId(ZmId.WIDGET_TREE_ITEM_HDR, overviewId, type);
	} else {
		return DwtId.makeId(ZmId.WIDGET_TREE_ITEM, overviewId, organizerId);
	}
};

/**
 * Generates an ID for a view that fills the content area, or for a component of that
 * view. A context should be provided if the view is not a singleton (for example,
 * message view may appear within several double-pane views). The component name
 * is not joined with the "|" character in order to preserve backward compatibility.
 * 
 * <p>
 * Examples: <code>zv|COMPOSE zv|TV zv|TV|MSG zv|TV|MSG_hdrTable</code>
 * </p>
 * 
 * @param {constant}	viewId		the view identifier (see <code>ZmId.VIEW_</code> constants)
 * @param {constant}	component	the component identifier (see <code>ZmId.MV_</code> constants)
 * @param {constant}	context		the ID of owning view
 * @return	{String}	the id
 */
ZmId.getViewId =
function(viewId, component, context) {
	var id = DwtId.makeId(ZmId.WIDGET_VIEW, context, viewId);
	return component ? [id, component].join("") : id;
};

/**
 * Generates an ID for the compose view, or for a component within the compose view. Since
 * only one compose view is created, there is no need for a context to make the ID unique.
 * The component name is not joined with the "|" character for backward compatibility.
 * 
 * <p>
 * Examples: <code>z|ComposeView z|ComposeView_header z|ComposeView_to_row</code>
 * </p>
 * 
 * @param {constant}	component		component identifier (see <code>ZmId.CMP_</code> constants)
 * @return	{String}	the id
 */
ZmId.getComposeViewId =
function(component) {
	var id = DwtId.makeId(ZmId.WIDGET, ZmId.COMPOSE_VIEW);
	return component ? [id, component].join("") : id;
};

/**
 * Generates an ID for a tab (actually the tab button in the tab bar).
 * 
 * <p>
 * Tab contexts and names:
 * 
 * <ul>
 * <li><b>VIEW_PREF</b>			General, Mail, Composing, Signatures, Address Book,
 * 							Accounts, Mail Filters, Calendar, Shortcuts</li>
 * <li><b>VIEW_CONTACT</b>		personal, work, home, other, notes</li>
 * <li><b>VIEW_APPOINTMENT</b>	details, schedule, attendees, locations, equipment</li>
 * <li><b>VIEW_SHORTCUTS</b>		list, {@link ZmId.ORG_FOLDER}, {@link ZmId.ORG_SEARCH}, {@link ZmId.ORG_TAG}</li>
 * </ul>
 * </p>
 * 
 * @param {constant}	context		the owning view identifier (see <code>ZmId.VIEW_</code> constants)
 * @param {String}	tabName		[string]		name of tab
 * @return	{String}	the id
 */
ZmId.getTabId =
function(context, tabName) {
	return DwtId.makeId(ZmId.WIDGET_TAB, context, tabName);
};

/**
 * Generates an ID for a pref page tab.
 *
 * @param	{String}	tabKey		the tab key
 * @return	{String}	the id
 */
ZmId.getPrefPageId = function(tabKey) {
	return "PREF_PAGE_"+tabKey;
};

/*
 * 
 * Gettings IDs for different areas of ZCS
 * 
 */

/*
 * ------------
 * Search Panel
 * ------------
 * 
 * The input box in the search panel has a literal ID. To get the IDs for buttons, menus,
 * and menu items in the search panel, use the functions above.
 * 
 * Buttons:
 * 
 * Pass the context and one of the button constants below:
 * 
 * 		ZmId.getButtonId(ZmId.SEARCH, ZmId.SEARCH_SAVE)
 * 
 * Menus:
 * 
 * There is only one search menu in the panel. Pass the context to get its ID:
 * 
 * 		ZmId.getMenuId(ZmId.SEARCH)
 * 
 * Menu items:
 * 
 * If the search type has a one-to-one mapping with an item type, use the
 * item type constant ZmId.ITEM_* (currently true for contact, appointment, page, and task).
 * Otherwise, pass one of the menu item constants below as the operation:
 * 
 * 		ZmId.getMenuItemId(ZmId.SEARCH, ZmId.ITEM_CONTACT)
 * 		ZmId.getMenuItemId(ZmId.SEARCH, ZmId.SEARCH_SHARED)
 */
 
ZmId.SEARCH_INPUT			= "zi_search";			// text input in search toolbar
ZmId.SEARCH_INPUTFIELD      = ZmId.SEARCH_INPUT + "_inputfield";

// context
ZmId.SEARCH					= "Search";				// element is within search panel

// button, menu item
ZmId.SEARCH_CUSTOM			= "CUSTOM";				// custom search type or button

// button
ZmId.SEARCH_MENU			= "MENU";				// button with dropdown type menu
ZmId.SEARCH_SEARCH			= "SEARCH";				// perform a search
ZmId.SEARCH_SAVE			= "SAVE";				// save a search
ZmId.SEARCH_ADVANCED		= "ADV";				// open/close the search builder
ZmId.SEARCH_LOCAL			= "LOCAL";				// added by the "local" zimlet

// menu item (also see ZmId.ITEM_*)
ZmId.SEARCH_ALL_ACCOUNTS	= "ALL_ACCOUNTS";		// all accounts
ZmId.SEARCH_GAL				= "GAL";				// GAL contacts
ZmId.SEARCH_MAIL			= "MAIL";				// mail items
ZmId.SEARCH_SHARED			= "SHARED";				// include shared items

/*
 * ----------------------
 * Search Results Toolbar
 * ----------------------
 * 
 * This toolbar appears at the top of the search results tab.
 */

ZmId.SEARCHRESULTS_INPUT		= "zi_searchresults";			// text input in search toolbar
ZmId.SEARCHRESULTS_INPUTFIELD	= ZmId.SEARCHRESULTS_INPUT + "_inputfield";

// context
ZmId.SEARCHRESULTS				= "SearchResults";				// element is within search panel

// button
ZmId.SEARCHRESULTS_SEARCH		= "SEARCH";				// perform a search
ZmId.SEARCHRESULTS_SAVE			= "SAVE";				// save a search

/*
 * -----------
 * App toolbar
 * -----------
 * 
 * Also known as the app chooser, the app toolbar contains a button that launches each app.
 * 
 * Buttons:
 * 
 * To get the ID for an app button, pass the app context and an app ID (ZmId.APP_*):
 * 
 * 		ZmId.getButtonId(ZmId.APP, ZmId.APP_MAIL)
 */

// context
ZmId.APP	= "App";

/*
 * ---------
 * Overviews
 * ---------
 * 
 * An overview is a collection of trees. The primary place that the user will see an overview is
 * at the left side of the client. Note that each app has its own overview, since it may want to
 * show a different set of trees. For example, the mail app shows trees for folders, searches, tags,
 * and zimlets by default. Overviews also appear when the user needs to choose something from a tree,
 * for example selecting a folder within a move dialog when moving a message.
 * 
 * A tree is a collection of tree items, each of which may have its own tree items.
 * 
 * The overview IDs for the main overviews that show up at the left are just app names (ZmId.APP_*).
 * The overview IDs elsewhere are more complicated, since they need to be unique for each overview.
 * 
 * Examples: zov|Mail zov|ZmChooseFolderDialog-ZmListController zov|ZmPickTagDialog
 * 
 * Overviews:
 * 
 * 		ZmId.getOverviewId(ZmId.APP_MAIL)
 * 
 * Trees:
 * 
 * 		ZmId.getTreeId(ZmId.APP_MAIL, ZmId.ORG_FOLDER)
 * 
 * Tree items:
 * 
 * 		ZmId.getTreeItemId(ZmId.APP_MAIL, ZmFolder.ID_INBOX)
 * 		ZmId.getTreeItemId(ZmId.APP_MAIL, 2)
 * 		ZmId.TREEITEM_INBOX
 * 
 * TODO: come up with simpler names for other (non-app) overviews
 */

// convenience IDs for system folder tree items
ZmId.TREEITEM_INBOX					= "zti|Mail|2";
ZmId.TREEITEM_JUNK					= "zti|Mail|4";
ZmId.TREEITEM_SENT					= "zti|Mail|5";
ZmId.TREEITEM_DRAFTS				= "zti|Mail|6";
ZmId.TREEITEM_TRASH_MAIL			= "zti|Mail|3";
ZmId.TREEITEM_TRASH_CONTACTS		= "zti|Contacts|3";
ZmId.TREEITEM_CONTACTS				= "zti|Contacts|7";
ZmId.TREEITEM_CALENDAR				= "zti|Calendar|10";
ZmId.TREEITEM_TASKS					= "zti|Tasks|15";
ZmId.TREEITEM_BRIEFCASE				= "zti|Briefcase|16";

/*
 * -----------
 * Top toolbar
 * -----------
 * 
 * To get the ID for the toolbar itself, pass the context (owning view):
 * 
 * 		ZmId.getToolbarId(ZmId.VIEW_TRAD)
 * 
 * Nav toolbar:
 * 
 * 		ZmId.getToolbarId(ZmId.VIEW_TRAD, ZmId.TB_NAV)
 * 
 * Buttons:
 * 
 * 		ZmId.getButtonId(ZmId.VIEW_TRAD, ZmId.OP_CHECK_MAIL)
 * 		ZmId.getButtonId(ZmId.VIEW_TRAD, ZmId.OP_PAGE_FORWARD, ZmId.TB_NAV)
 */

/*
 * -----
 * Views
 * -----
 * 
 * A view is typically a high-level element that occupies the content area. Examples include conversation
 * list view, compose view, and preferences view.
 * 
 * To get the ID for a view, pass the constant for that view:
 * 
 * 		ZmId.getViewId(ZmId.VIEW_CONVLIST)
 */

/*
 * ------------
 * Message view
 * ------------
 * 
 * A message view displays an email message. There are several different instances of message views, which
 * makes it necessary to include a context (owning view) to be able to identify each one of them.
 * 
 * The function to use is:
 * 
 * 		ZmId.getViewId(ZmId.VIEW_MSG, component, context)
 * 
 * Since message views are not singletons, a context is always necessary. Omit the component only when getting
 * an ID for a message view itself.
 * 
 * To get the ID for a message view, pass the constant for the message view as well as the context, which can be
 * ZmId.VIEW_CONVLIST, ZmId.VIEW_CONV, ZmId.VIEW_MSG, or ZmId.VIEW_TRAD:
 * 
 * 		ZmId.getViewId(ZmId.VIEW_MSG, null, ZmId.VIEW_TRAD)
 * 
 * There are also many components within a message view which are useful to retrieve. To get the ID for a
 * message view component, pass the component ID (ZmId.MV_*):
 * 
 * 		ZmId.getViewId(ZmId.VIEW_MSG, ZmId.MV_HDR_TABLE_TOP_ROW, ZmId.VIEW_TRAD)
 * 		ZmId.getViewId(ZmId.VIEW_MSG, ZmId.MV_ATT_LINKS, ZmId.VIEW_TRAD)
 * 
 * 		var bodyId = ZmId.getViewId(ZmId.VIEW_MSG, ZmId.MV_MSG_BODY, ZmId.VIEW_TRAD)
 * 
 * will return the ID for the DIV containing the msg body iframe. To get the ID of the IFRAME element
 * itself, pass that ID as the context for the IFRAME:
 * 
 * 		var iframeId = DwtId.getIframeId(bodyId);
 * 
 * For buttons within msg view, pass the context and operation as usual, and add the identifier for
 * message view (which distinguishes its buttons from, say, those on the VIEW_TRAD toolbar).
 * 
 * 		ZmId.getButtonId(ZmId.VIEW_MSG, ZmId.OP_CLOSE, ZmId.VIEW_CONV)
 * 		ZmId.getButtonId(ZmId.VIEW_MSG, ZmId.OP_EXPAND, ZmId.VIEW_TRAD)
 */

// components that are part of the template
ZmId.MV_HDR_TABLE			= "_hdrTable";			// TABLE that holds header elements
ZmId.MV_HDR_TABLE_TOP_ROW	= "_hdrTableTopRow";	// first TR in header table
ZmId.MV_REPORT_BTN_CELL		= "_reportBtnCell";		// TD that holds Report button (sync failure msg)
ZmId.MV_EXPAND_ROW			= "_expandRow";			// TR that holds expandable headers
ZmId.MV_EXPAND_HDR			= "_expandHeader";		// TD that holds expand button
ZmId.MV_ATT_LINKS			= "_attLinks";			// DIV that holds attachment-related links
ZmId.MV_CONTACT_AREA		= "_contactArea";		// DIV for optional contact actions

// other components
ZmId.MV_HIGHLIGHT_OBJ		= "_highlightObjects";
ZmId.MV_DISPLAY_IMAGES		= "_displayImages";		// DIV with link for showing external images
ZmId.MV_MSG_TRUNC			= "_msgTruncation";		// DIV with link for showing entire msg
ZmId.MV_INFO_BAR			= "_infoBar";			// DIV that is placeholder for optional links above
ZmId.MV_TAG_ROW				= "_tagRow";			// TR for tags
ZmId.MV_TAG_CELL			= "_tagCell";			// TD for tags
ZmId.MV_MSG_BODY			= "_body";				// DIV that contains content iframe
ZmId.MV_MSG_HEADER			= "_header";			// DIV that contains header (conv 2.0 msg capsule view)
ZmId.MV_MSG_FOOTER			= "_footer";			// DIV that contains footer (conv 2.0 msg capsule view)

ZmId.MV_PRIORITY			= "_msgPriority";


/*
 * ------------
 * Compose view
 * ------------
 * 
 * Compose is used to create an email message - a reply, a forward, or a new message.
 * 
 * The function to use is:
 * 
 * 		ZmId.getViewId(ZmId.VIEW_COMPOSE, component)
 * 
 * To get the ID for the compose view:
 * 
 * 		ZmId.getViewId(ZmId.VIEW_COMPOSE)
 * 
 * There are also many components within the compose view which are useful to retrieve. To get the ID for a
 * compose view component, pass the component ID (ZmId.CMP_*):
 * 
 * 		ZmId.getViewId(ZmId.VIEW_COMPOSE, ZmId.CMP_HEADER)
 * 		ZmId.getViewId(ZmId.VIEW_COMPOSE, ZmId.CMP_CC_ROW)
 * 
 * To get the ID of one of the address field buttons, provide the operation:
 * 
 * 		ZmId.getButtonId(ZmId.VIEW_COMPOSE, ZmId.CMP_TO)
 * 
 * To get the ID of the Priority button:
 * 
 * 		ZmId.getButtonId(ZmId.VIEW_COMPOSE, ZmId.CMP_PRIORITY)
 */

// components from the template
ZmId.CMP_HEADER				= "_header";
ZmId.CMP_FROM_SELECT		= "_from_select";
ZmId.CMP_TO_ROW				= "_to_row";
ZmId.CMP_TO_PICKER			= "_to_picker";
ZmId.CMP_TO_INPUT			= "_to_control";
ZmId.CMP_CC_ROW				= "_cc_row";
ZmId.CMP_CC_PICKER			= "_cc_picker";
ZmId.CMP_CC_INPUT			= "_cc_control";
ZmId.CMP_BCC_ROW			= "_bcc_row";
ZmId.CMP_BCC_PICKER			= "_bcc_picker";
ZmId.CMP_BCC_INPUT			= "_bcc_control";
ZmId.CMP_OBO_CHECKBOX		= "_obo_checkbox";
ZmId.CMP_OBO_LABEL			= "_obo_label";
ZmId.CMP_OBO_ROW			= "_obo_row";
ZmId.CMP_OBO_SPAN			= "_obo_span";
ZmId.CMP_BWO_SPAN			= "_bwo_span";
ZmId.CMP_SUBJECT_ROW		= "_subject_row";
ZmId.CMP_SUBJECT_INPUT		= "_subject_control";
ZmId.CMP_IDENTITY_ROW		= "_identity_row";
ZmId.CMP_IDENTITY_SELECT	= "_identity_control";
ZmId.CMP_PRIORITY			= "_priority";
ZmId.CMP_REPLY_ATT_ROW		= "_reply_attachments_link";
ZmId.CMP_ATT_ROW			= "_attachments_row";
ZmId.CMP_ATT_DIV			= "_attachments_div";
ZmId.CMP_ATT_BTN			= "_attachments_btn";
ZmId.CMP_ATT_INP			= "_file_input";
ZmId.CMP_ATT_COMPUTER_INP	= "_file_input_computer";
ZmId.CMP_ATT_INLINE_INP		= "_file_input_inline";
ZmId.CMP_ATT_INCL_ORIG_LINK	= "_show_orig";
ZmId.CMP_DND_TOOLTIP        = "_zdnd_tooltip";

ZmId.CMP_TO_CELL			= "_to_cell";
ZmId.CMP_CC_CELL			= "_cc_cell";
ZmId.CMP_BCC_CELL			= "_bcc_cell";

// compose operations
ZmId.CMP_TO					= "TO";
ZmId.CMP_CC					= "CC";
ZmId.CMP_BCC				= "BCC";

/*
 * 
 * Constants used to generate IDs
 * 
 */

// apps
ZmId.APP_BRIEFCASE		= "Briefcase";
ZmId.APP_CALENDAR		= "Calendar";
ZmId.APP_CONTACTS		= "Contacts";
ZmId.APP_MAIL			= "Mail";
ZmId.APP_PORTAL			= "Portal";
ZmId.APP_PREFERENCES	= "Options";
ZmId.APP_SEARCH			= "Search";
ZmId.APP_SOCIAL			= "Social";
ZmId.APP_TASKS			= "Tasks";
ZmId.APP_VOICE			= "Voice";
ZmId.APP_CHAT           = "Chat";

// views - often used as context for ID
ZmId.VIEW_ACCOUNT				= "ACCT";
ZmId.VIEW_APPOINTMENT 			= "APPT";
ZmId.VIEW_SIMPLE_ADD_APPOINTMENT= "SAPPT";
ZmId.VIEW_APPOINTMENT_READONLY  = "APPTRO";
ZmId.VIEW_APPT_SCHEDULE			= "APPTS";
ZmId.VIEW_BRIEFCASE			    = "BC";
ZmId.VIEW_BRIEFCASE_DETAIL		= "BCD";
ZmId.VIEW_BRIEFCASE_COLUMN		= "BCC";
ZmId.VIEW_BRIEFCASE_ICON		= "BCI";
ZmId.VIEW_BRIEFCASE_PREVIEW     = "BCP";
ZmId.VIEW_BRIEFCASE_REVISION    = "BRLV";
ZmId.VIEW_BRIEFCASE_DETAIL      = "BDLV";
ZmId.VIEW_CAL					= "CAL";
ZmId.VIEW_CAL_APPT				= "CLA";
ZmId.VIEW_CAL_DAY				= "CLD";
ZmId.VIEW_CAL_LIST				= "CLL";
ZmId.VIEW_CAL_MONTH				= "CLM";
ZmId.VIEW_CAL_WEEK				= "CLW";
ZmId.VIEW_CAL_WORK_WEEK			= "CLWW";
ZmId.VIEW_CAL_FB			    = "CLFB";
ZmId.VIEW_CAL_TRASH             = "CLT";
ZmId.VIEW_SUGGEST_TIME_PANE     = "CSTP";
ZmId.VIEW_SUGGEST_LOCATION_PANE = "CSLP";
ZmId.VIEW_CALL_LIST				= "CLIST";
ZmId.VIEW_COMPOSE				= "COMPOSE";
ZmId.VIEW_CONTACT_SIMPLE 		= "CNS";			// dual panes, list and contact
ZmId.VIEW_CONTACT_SRC			= "CNSRC";			// contact picker
ZmId.VIEW_CONTACT_TGT			= "CNTGT";			// contact picker
ZmId.VIEW_CONTACT				= "CN";
ZmId.VIEW_CONV 					= "CV";				// dual-pane conv view
ZmId.VIEW_CONV2 				= "CV2";			// conv shown in reading pane
ZmId.VIEW_CONVLIST 				= "CLV";			// hybrid conv list view
ZmId.VIEW_FILTER_RULES			= "FRV";
ZmId.VIEW_GROUP					= "GRP";
ZmId.VIEW_LOADING				= "LOADING";		// generic placeholder
ZmId.VIEW_MAIL_CONFIRM			= "MAILCONFIRM";
ZmId.VIEW_MOBILE_DEVICES		= "MD";
ZmId.VIEW_MSG 					= "MSG";
ZmId.VIEW_MSG_CAPSULE			= "MSGC";
ZmId.VIEW_PORTAL                = "PORTAL";
ZmId.VIEW_PREF					= "PREF";
//ZmId.VIEW_QUICK_COMMAND			= "QCV";
ZmId.VIEW_SEARCH_RESULTS		= "SR";
ZmId.VIEW_SHARE_PENDING			= "SVP";
ZmId.VIEW_SHARE_MOUNTED			= "SVM";
ZmId.VIEW_SHARE_GRANTS			= "SVG";
ZmId.VIEW_SHORTCUTS				= "SHORTCUTS";
ZmId.VIEW_TASK					= "TKV";
ZmId.VIEW_TASK_NOT_STARTED		= "TKVN";
ZmId.VIEW_TASK_COMPLETED		= "TKVC";
ZmId.VIEW_TASK_IN_PROGRESS		= "TKVI";
ZmId.VIEW_TASK_WAITING			= "TKVW";
ZmId.VIEW_TASK_DEFERRED 		= "TKVD";
ZmId.VIEW_TASK_ALL				= "TKVA";
ZmId.VIEW_TASK_TODO				= "TKVT";
ZmId.VIEW_TASKEDIT				= "TKE";
ZmId.VIEW_TASKLIST				= "TKL";
ZmId.VIEW_TRAD 					= "TV";
ZmId.VIEW_VOICEMAIL				= "VM";
ZmId.VIEW_ATTACHMENTS           = "AV";

// item types
ZmId.ITEM_APPOINTMENT	= "APPT";
ZmId.ITEM_ATT			= "ATT";
ZmId.ITEM_BRIEFCASE		= "BRIEFCASE_ITEM";
ZmId.ITEM_BRIEFCASE_REV	= "BRIEFCASE_REVISION";
ZmId.ITEM_CALL			= "CALL";
ZmId.ITEM_CHAT			= "CHAT";
ZmId.ITEM_CONTACT		= "CONTACT";
ZmId.ITEM_CONV			= "CONV";
ZmId.ITEM_DATA_SOURCE	= "DATA_SOURCE";
ZmId.ITEM_DOCUMENT		= "DOCUMENT";
ZmId.ITEM_GAL_CONTACT	= "GAL";
ZmId.ITEM_GROUP			= "GROUP";
ZmId.ITEM_MSG			= "MSG";
ZmId.ITEM_PAGE			= "PAGE";
ZmId.ITEM_RESOURCE		= "RESOURCE";
ZmId.ITEM_TASK			= "TASK";
ZmId.ITEM_VOICEMAIL		= "VOICEMAIL";

// organizer types - generally appear in overview
ZmId.ORG_ADDRBOOK			= "ADDRBOOK";
ZmId.ORG_BRIEFCASE			= "BRIEFCASE";
ZmId.ORG_CALENDAR			= "CALENDAR";
ZmId.ORG_FOLDER				= "FOLDER";
ZmId.ORG_PREF_PAGE			= "PREF_PAGE";
ZmId.ORG_SEARCH				= "SEARCH";				// saved search
ZmId.ORG_TAG				= "TAG";
ZmId.ORG_TASKS				= "TASKS";
ZmId.ORG_ZIMLET				= "ZIMLET";

// fields of an item - generally equates to a column in a list view
ZmId.FLD_ACCOUNT		= "ac";
ZmId.FLD_ATTACHMENT		= "at";
ZmId.FLD_CAPACITY		= "cp";
ZmId.FLD_COMPANY		= "co";
ZmId.FLD_DATE			= "dt";
ZmId.FLD_DEPARTMENT		= "de";
ZmId.FLD_EMAIL			= "em";
ZmId.FLD_EXPAND			= "ex";	// CLV
ZmId.FLD_FILE_TYPE		= "ft";
ZmId.FLD_FLAG			= "fg";
ZmId.FLD_FOLDER			= "fo";
ZmId.FLD_FRAGMENT		= "fm";
ZmId.FLD_FROM			= "fr";
ZmId.FLD_HOME_PHONE		= "hp"; // Contacts
ZmId.FLD_ID				= "id";
ZmId.FLD_INDEX			= "ix";
ZmId.FLD_ITEM_ROW		= "rw";
ZmId.FLD_ITEM_ROW_3PANE	= "r3";
ZmId.FLD_LOCATION		= "lo";
ZmId.FLD_LOCK           = "loid";
ZmId.FLD_MSG_PRIORITY   = "mp"; //message prioritization
ZmId.FLD_NAME			= "na";
ZmId.FLD_NOTES			= "no";
ZmId.FLD_PARTICIPANT	= "pa";
ZmId.FLD_PCOMPLETE		= "pc"; // Tasks
ZmId.FLD_PRIORITY		= "pr"; // Tasks
ZmId.FLD_RECURRENCE		= "re";	// Calendar
ZmId.FLD_SELECTION		= "se";
ZmId.FLD_SELECTION_CELL	= "sec";
ZmId.FLD_SIZE			= "sz";
ZmId.FLD_SORTED_BY		= "sb";
ZmId.FLD_STATUS			= "st";
ZmId.FLD_READ			= "rd";
ZmId.FLD_MUTE			= "mt";
ZmId.FLD_SUBJECT		= "su";
ZmId.FLD_TAG			= "tg";
ZmId.FLD_TAG_CELL		= "tc";
ZmId.FLD_TYPE			= "ty";
ZmId.FLD_TO             = "to";
ZmId.FLD_VERSION        = "ver";
ZmId.FLD_WORK_PHONE		= "wp"; // Contacts
ZmId.FLD_CREATED        = "cr";   // Application passcode created
ZmId.FLD_LAST_USED      = "lu";   // Application passcode last used

// operations - things the user can do, usually via a button or menu item
ZmId.OP_ACCEPT_PROPOSAL         = "ACCEPT_PROPOSAL";
ZmId.OP_ADD       		     	= "ADD";
ZmId.OP_ADD_FILTER_RULE			= "ADD_FILTER_RULE";
ZmId.OP_ADD_TO_FILTER_RULE		= "ADD_TO_FILTER_RULE";
//ZmId.OP_ADD_QUICK_COMMAND		= "ADD_QUICK_COMMAND";
ZmId.OP_ADD_SIGNATURE			= "ADD_SIGNATURE";
ZmId.OP_ADD_EXTERNAL_CALENDAR	= "ADD_EXTERNAL_CALENDAR";
ZmId.OP_ATTACHMENT				= "ATTACHMENT";
ZmId.OP_ACTIONS_MENU			= "ACTIONS_MENU";
ZmId.OP_BROWSE					= "BROWSE";
ZmId.OP_BROWSE_FOLDER			= "BROWSE_FOLDER";
ZmId.OP_CALL					= "CALL";
ZmId.OP_CAL_REFRESH				= "CAL_REFRESH";
ZmId.OP_CAL_REPLY				= "CAL_REPLY";
ZmId.OP_CAL_REPLY_ALL			= "CAL_REPLY_ALL";
ZmId.OP_CAL_LIST_VIEW			= "CAL_LIST_VIEW";
ZmId.OP_CAL_VIEW_MENU			= "CAL_VIEW_MENU";
ZmId.OP_CANCEL					= "CANCEL";
ZmId.OP_CHECKIN                 = "CHECKIN";
ZmId.OP_CHECKOUT                = "CHECKOUT";
ZmId.OP_CHECK_ALL				= "CHECK_ALL";
ZmId.OP_CHECK_MAIL				= "CHECK_MAIL";
ZmId.OP_GO_OFFLINE				= "GOOFFLINE";
ZmId.OP_CALL_BACK				= "CALL_BACK";
ZmId.OP_CLEAR_ALL				= "CLEAR_ALL";
ZmId.OP_CLOSE					= "CLOSE";
ZmId.OP_COMPOSE_FORMAT			= "COMPOSE_FORMAT";
ZmId.OP_COMPOSE_OPTIONS			= "COMPOSE_OPTIONS";
ZmId.OP_CONTACT					= "CONTACT";
ZmId.OP_CONTACTGROUP_MENU       = "CONTACTGROUP_MENU";
ZmId.OP_COPY		     		= "COPY";
ZmId.OP_CREATE_APPT     		= "CREATE_APPT";
ZmId.OP_CREATE_TASK     		= "CREATE_TASK";
ZmId.OP_DAY_VIEW				= "DAY_VIEW";
ZmId.OP_DECLINE_PROPOSAL        = "DECLINE_PROPOSAL";
ZmId.OP_DELETE					= "DELETE";
ZmId.OP_DELETE_WITHOUT_SHORTCUT		= "DELETE_WITHOUT_SHORTCUT";
ZmId.OP_DELETE_APPT_INSTANCE	= "DELETE_INSTANCE";
ZmId.OP_DELETE_APPT_SERIES  	= "DELETE_SERIES";
ZmId.OP_DELETE_CONV				= "DELETE_CONV";
ZmId.OP_DELETE_MENU				= "DELETE_MENU";
ZmId.OP_DELETE_MSG				= "DELETE_MSG";
ZmId.OP_DELETE_VERSION          = "DELETE_VERSION";
ZmId.OP_DETACH					= "DETACH";
ZmId.OP_DETACH_WIN				= "DETACH_WIN";
ZmId.OP_DETACH_COMPOSE			= "DETACH_COMPOSE";
ZmId.OP_DISCARD_CHECKOUT        = "DISCARD_CHECKOUT";
ZmId.OP_DOWNLOAD_VOICEMAIL		= "DOWNLOAD_VOICEMAIL";
ZmId.OP_NEW_CALL				= "NEW_CALL";
ZmId.OP_DUPLICATE_APPT  		= "DUPLICATE_APPT";
ZmId.OP_DRAFT					= "DRAFT";
ZmId.OP_EDIT					= "EDIT";
ZmId.OP_EDIT_AS_NEW				= "EDIT_AS_NEW";
ZmId.OP_EDIT_CONTACT			= "EDIT_CONTACT";
ZmId.OP_EDIT_FILE				= "EDIT_FILE";
ZmId.OP_EDIT_FILTER_RULE		= "EDIT_FILTER_RULE";
//ZmId.OP_EDIT_QUICK_COMMAND		= "EDIT_QUICK_COMMAND";
ZmId.OP_EDIT_PROPS				= "EDIT_PROPS";
ZmId.OP_EDIT_REPLY_ACCEPT		= "EDIT_REPLY_ACCEPT";
ZmId.OP_EDIT_REPLY_CANCEL		= "EDIT_REPLY_CANCEL";
ZmId.OP_EDIT_REPLY_DECLINE		= "EDIT_REPLY_DECLINE";
ZmId.OP_EDIT_REPLY_TENTATIVE	= "EDIT_REPLY_TENTATIVE";
ZmId.OP_EMPTY_FOLDER			= "EMPTY_FOLDER";
ZmId.OP_EXPAND					= "EXPAND";
ZmId.OP_EXPAND_ALL				= "EXPAND_ALL";
//ZmId.OP_EXPORT_FOLDER			= "EXPORT_FOLDER";
ZmId.OP_FB_VIEW				    = "FB_VIEW";
ZmId.OP_FLAG					= "FLAG";
ZmId.OP_UNFLAG					= "UNFLAG";
ZmId.OP_FIND_SHARES				= "FIND_SHARES";
ZmId.OP_FORMAT_HTML				= "FORMAT_HTML";
ZmId.OP_FORMAT_HTML_SOURCE		= "FORMAT_HTML_SOURCE";
ZmId.OP_FORMAT_MEDIA_WIKI		= "FORMAT_MEDIA_WIKI";
ZmId.OP_FORMAT_RICH_TEXT		= "FORMAT_RICH_TEXT";
ZmId.OP_FORMAT_TEXT				= "FORMAT_TEXT";
ZmId.OP_FORMAT_TWIKI			= "FORMAT_TWIKI";
ZmId.OP_FORMAT_MORE_OPTIONS		= "FORMAT_MORE_OPTIONS";
ZmId.OP_FORWARD					= "FORWARD";
ZmId.OP_FORWARD_ATT				= "FORWARD_ATT";
ZmId.OP_FORWARD_BY_EMAIL		= "FORWARD_BY_EMAIL";
ZmId.OP_FORWARD_CONV		    = "FORWARD_CONV";
ZmId.OP_FORWARD_INLINE			= "FORWARD_INLINE";
ZmId.OP_FORWARD_MENU			= "FORWARD_MENU";
ZmId.OP_FORWARD_APPT			= "FORWARD_APPT";
ZmId.OP_FORWARD_APPT_INSTANCE	= "FORWARD_APPT_INSTANCE";
ZmId.OP_FORWARD_APPT_SERIES		= "FORWARD_APPT_SERIES";
ZmId.OP_FREE_BUSY_LINK			= "FREE_BUSY_LINK";
ZmId.OP_GROUPBY                 = "GROUPBY";
ZmId.OP_GROUPBY_DATE            = "GROUPBY_DATE";
ZmId.OP_GROUPBY_NONE            = "GROUPBY_NONE";
ZmId.OP_GROUPBY_FROM            = "GROUPBY_FROM";
ZmId.OP_GROUPBY_PRIORITY        = "GROUPBY_PRIORITY";
ZmId.OP_GROUPBY_SIZE            = "GROUPBY_SIZE";
ZmId.OP_GROUPBY_TAG             = "GROUPBY_TAG";
ZmId.OP_GO_TO_URL				= "GO_TO_URL";
ZmId.OP_IMPORT_FILE				= "IMPORT_FILE";
//ZmId.OP_IMPORT_FOLDER			= "IMPORT_FOLDER";
ZmId.OP_INC_ATTACHMENT			= "INC_ATTACHMENT";
ZmId.OP_INC_BODY				= "INC_BODY";
ZmId.OP_INC_NONE				= "INC_NONE";
ZmId.OP_INC_SMART				= "INC_SMART";
ZmId.OP_INCLUDE_HEADERS			= "INCLUDE_HEADERS";
ZmId.OP_INVITE_ATTENDEES		= "INVITE_ATTENDEES";
ZmId.OP_INVITE_REPLY_ACCEPT		= "INVITE_REPLY_ACCEPT";
ZmId.OP_INVITE_REPLY_DECLINE	= "INVITE_REPLY_DECLINE";
ZmId.OP_INVITE_REPLY_MENU		= "INVITE_REPLY_MENU";
ZmId.OP_INVITE_REPLY_TENTATIVE	= "INVITE_REPLY_TENTATIVE";
ZmId.OP_KEEP_READING			= "KEEP_READING";
ZmId.OP_MARK_ALL_READ			= "MARK_ALL_READ";
ZmId.OP_MARK_HEARD				= "MARK_HEARD";
ZmId.OP_MARK_READ				= "MARK_READ";
ZmId.OP_MARK_UNHEARD			= "MARK_UNHEARD";
ZmId.OP_MARK_UNREAD				= "MARK_UNREAD";
ZmId.OP_MARK_AS_COMPLETED		= "MARK_AS_COMPLETED";
ZmId.OP_MOBILE_REMOVE			= "MOBILE_REMOVE";
ZmId.OP_MOBILE_CANCEL_WIPE		= "MOBILE_CANCEL_WIPE";
ZmId.OP_MOBILE_RESUME_SYNC		= "MOBILE_RESUME_SYNC";
ZmId.OP_MOBILE_SUSPEND_SYNC		= "MOBILE_SUSPEND_SYNC";
ZmId.OP_MOBILE_WIPE				= "MOBILE_WIPE";
ZmId.OP_MONTH_VIEW				= "MONTH_VIEW";
ZmId.OP_MOUNT_ADDRBOOK			= "MOUNT_ADDRBOOK";
ZmId.OP_MOUNT_BRIEFCASE			= "MOUNT_BRIEFCASE";
ZmId.OP_MOUNT_CALENDAR			= "MOUNT_CALENDAR";
ZmId.OP_MOUNT_FOLDER			= "MOUNT_FOLDER";
ZmId.OP_MOUNT_TASK_FOLDER		= "MOUNT_TASK_FOLDER";
ZmId.OP_MOVE					= "MOVE";
ZmId.OP_MOVE_MENU				= "MOVE_MENU";
ZmId.OP_MOVE_DOWN_FILTER_RULE	= "MOVE_DOWN_FILTER_RULE";
ZmId.OP_MOVE_TO_BCC				= "MOVE_TO_BCC";
ZmId.OP_MOVE_TO_CC				= "MOVE_TO_CC";
ZmId.OP_MOVE_TO_TO				= "MOVE_TO_TO";
ZmId.OP_MOVE_UP_FILTER_RULE		= "MOVE_UP_FILTER_RULE";
ZmId.OP_MUTE_CONV		        = "MUTE_CONV";
ZmId.OP_NEW_ADDRBOOK			= "NEW_ADDRBOOK";
ZmId.OP_NEW_ALLDAY_APPT			= "NEW_ALLDAY_APPT";
ZmId.OP_NEW_APPT				= "NEW_APPT";
ZmId.OP_NEW_BRIEFCASE			= "NEW_BRIEFCASE";
ZmId.OP_NEW_CALENDAR			= "NEW_CALENDAR";
ZmId.OP_NEW_CONTACT				= "NEW_CONTACT";
ZmId.OP_NEW_DISTRIBUTION_LIST	= "NEW_DISTRIBUTION_LIST";
ZmId.OP_NEW_DOC                 = "NEW_DOC";
ZmId.OP_NEW_FILE				= "NEW_FILE";
ZmId.OP_NEW_FOLDER				= "NEW_FOLDER";
ZmId.OP_NEW_GROUP				= "NEW_GROUP";
ZmId.OP_NEW_MENU				= "NEW_MENU";
ZmId.OP_NEW_MESSAGE				= "NEW_MESSAGE";
ZmId.OP_NEW_MESSAGE_WIN			= "NEW_MESSAGE_WIN";
ZmId.OP_NEW_BRIEFCASE_WIN		= "NEW_BRIEFCASE_WIN";
ZmId.OP_NEW_PAGE				= "NEW_PAGE";
ZmId.OP_NEW_TAG					= "NEW_TAG";
ZmId.OP_NEW_TASK				= "NEW_TASK";
ZmId.OP_NOTIFY                  = "NOTIFY";
ZmId.OP_NEW_TASK_FOLDER			= "NEW_TASK_FOLDER";
ZmId.OP_OPEN_APPT_INSTANCE		= "OPEN_APPT_INSTANCE";
ZmId.OP_OPEN_APPT_SERIES		= "OPEN_APPT_SERIES";
ZmId.OP_OPEN_FILE				= "OPEN_FILE";
ZmId.OP_OPEN_IN_TAB				= "OPEN_IN_TAB";
ZmId.OP_PAGE_BACK				= "PAGE_BACK";
ZmId.OP_PAGE_FORWARD			= "PAGE_FORWARD";
ZmId.OP_PAUSE_TOGGLE			= "PAUSE_TOGGLE";
ZmId.OP_PRINT					= "PRINT";
ZmId.OP_PRINT_ADDRBOOK			= "PRINT_ADDRBOOK";
ZmId.OP_PRINT_CALENDAR			= "PRINT_CALENDAR";
ZmId.OP_PRINT_CONTACT			= "PRINT_CONTACT";
ZmId.OP_PRIORITY_FILTER         = "PRIORITY_FILTER";
ZmId.OP_PRIORITY_HIGH           = "PRIORITY_HIGH";
ZmId.OP_PRIORITY_LOW            = "PRIORITY_LOW";
ZmId.OP_PRIORITY_NORMAL         = "PRIORITY_NORMAL";
ZmId.OP_PROPOSE_NEW_TIME        = "PROPOSE_NEW_TIME";
ZmId.OP_OPTS         			= "OPTIONS";
//ZmId.OP_QUICK_COMMANDS  	    = "QUICK_COMMANDS";
ZmId.OP_RECOVER_DELETED_ITEMS	= "RECOVER_DELETED_ITEMS";
ZmId.OP_REDIRECT				= "REDIRECT";
ZmId.OP_REFRESH					= "REFRESH";
ZmId.OP_REINVITE_ATTENDEES      = "REINVITE_ATTENDEES";
ZmId.OP_REMOVE_FILTER_RULE		= "REMOVE_FILTER_RULE";
//ZmId.OP_REMOVE_QUICK_COMMAND	= "REMOVE_QUICK_COMMAND";
ZmId.OP_RENAME_FILE             = "RENAME_FILE";
ZmId.OP_RENAME_FOLDER			= "RENAME_FOLDER";
ZmId.OP_RENAME_SEARCH			= "RENAME_SEARCH";
ZmId.OP_RENAME_TAG				= "RENAME_TAG";
ZmId.OP_REPLY					= "REPLY";
ZmId.OP_REPLY_ACCEPT			= "REPLY_ACCEPT";
ZmId.OP_REPLY_ACCEPT_IGNORE		= "REPLY_ACCEPT_IGNORE";
ZmId.OP_REPLY_ACCEPT_NOTIFY		= "REPLY_ACCEPT_NOTIFY";
ZmId.OP_REPLY_ALL				= "REPLY_ALL";
ZmId.OP_REPLY_BY_EMAIL			= "REPLY_BY_EMAIL";
ZmId.OP_REPLY_CANCEL			= "REPLY_CANCEL";
ZmId.OP_REPLY_CANCEL			= "REPLY_CANCEL";
ZmId.OP_REPLY_DECLINE			= "REPLY_DECLINE";
ZmId.OP_REPLY_DECLINE_IGNORE	= "REPLY_DECLINE_IGNORE";
ZmId.OP_REPLY_DECLINE_NOTIFY	= "REPLY_DECLINE_NOTIFY";
ZmId.OP_REPLY_MENU				= "REPLY_MENU";
ZmId.OP_REPLY_MODIFY			= "REPLY_MODIFY";
ZmId.OP_REPLY_MODIFY			= "REPLY_MODIFY";
ZmId.OP_REPLY_NEW_TIME			= "REPLY_NEW_TIME";
ZmId.OP_REPLY_NEW_TIME			= "REPLY_NEW_TIME";
ZmId.OP_REPLY_TENTATIVE			= "REPLY_TENTATIVE";
ZmId.OP_REPLY_TENTATIVE_IGNORE	= "REPLY_TENTATIVE_IGNORE";
ZmId.OP_REPLY_TENTATIVE_NOTIFY	= "REPLY_TENTATIVE_NOTIFY";
ZmId.OP_REPORT					= "REPORT";
ZmId.OP_REQUEST_READ_RECEIPT	= "REQUEST_READ_RECEIPT";
ZmId.OP_RESET                   = "RESET";
ZmId.OP_RESTORE_VERSION         = "RESTORE_VERSION";
ZmId.OP_REVERT_PAGE				= "REVERT_PAGE";
ZmId.OP_RUN_FILTER_RULE			= "RUN_FILTER_RULE";
ZmId.OP_SAVE					= "SAVE";
ZmId.OP_SAVE_DRAFT				= "SAVE_DRAFT";
ZmId.OP_SAVE_FILE				= "SAVE_FILE";
ZmId.OP_SEARCH					= "SEARCH";
ZmId.OP_SEARCH_MAIL				= "SEARCH_MAIL";
ZmId.OP_SEARCH_MENU             = "SEARCH_MENU";
ZmId.OP_SEARCH_TO               = "SEARCH_TO";
ZmId.OP_SEND					= "SEND";
ZmId.OP_SEND_FILE				= "SEND_FILE";
ZmId.OP_SEND_FILE_AS_ATT	    = "SEND_FILE_AS_ATT";
ZmId.OP_SEND_FILE_MENU          = "SEND_FILE_MENU";
ZmId.OP_SEND_MENU				= "SEND_MENU";
ZmId.OP_SEND_LATER				= "SEND_LATER";
ZmId.OP_SEND_PAGE				= "SEND_PAGE";
ZmId.OP_SEND_INVITE				= "SEND_INVITE";
ZmId.OP_SEND_FB_HTML			= "SEND_FB_HTML";
ZmId.OP_SEND_FB_ICS			    = "SEND_FB_ICS";
ZmId.OP_SEND_FB_ICS_EVENT	    = "SEND_FB_ICS_EVENT";
ZmId.OP_SHARE					= "SHARE";
ZmId.OP_SHARE_ACCEPT			= "SHARE_ACCEPT";
ZmId.OP_SHARE_ADDRBOOK			= "SHARE_ADDRBOOK";
ZmId.OP_SHARE_BRIEFCASE			= "SHARE_BRIEFCASE";
ZmId.OP_SHARE_CALENDAR			= "SHARE_CALENDAR";
ZmId.OP_SHARE_DECLINE			= "SHARE_DECLINE";
ZmId.OP_SHARE_FOLDER			= "SHARE_FOLDER";
ZmId.OP_SHARE_TASKFOLDER		= "SHARE_TASKFOLDER";
ZmId.OP_SHOW_ALL_ITEM_TYPES		= "SHOW_ALL_ITEM_TYPES";
ZmId.OP_SHOW_BCC				= "SHOW_BCC";
ZmId.OP_SHOW_CONV				= "SHOW_CONV";
ZmId.OP_SHOW_ONLY_MAIL			= "SHOW_ONLY_MAIL";
ZmId.OP_SHOW_ORIG				= "SHOW_ORIG";
ZmId.OP_SORT_ASC                = "SORT_ASC";
ZmId.OP_SORT_DESC               = "SORT_DESC";
ZmId.OP_SPAM					= "SPAM";
ZmId.OP_SPELL_CHECK				= "SPELL_CHECK";
ZmId.OP_SUBSCRIBE_APPROVE		= "SUBSCRIBE_APPROVE";
ZmId.OP_SUBSCRIBE_REJECT		= "SUBSCRIBE_REJECT";
ZmId.OP_SYNC					= "SYNC";
ZmId.OP_SYNC_ALL				= "SYNC_ALL";
ZmId.OP_SYNC_OFFLINE_FOLDER		= "SYNC_OFFLINE_FOLDER";
ZmId.OP_TAG						= "TAG";
ZmId.OP_TAG_COLOR_MENU			= "TAG_COLOR_MENU";
ZmId.OP_TAG_MENU				= "TAG_MENU";
ZmId.OP_PRINT_TASK		    	= "PRINT_TASK";
ZmId.OP_PRINT_TASKFOLDER		= "PRINT_TASKFOLDER";
ZmId.OP_TEXT					= "TEXT";
ZmId.OP_TODAY					= "TODAY";
ZmId.OP_UNDELETE				= "UNDELETE";
ZmId.OP_UNMUTE_CONV		        = "UNMUTE_CONV";
ZmId.OP_USE_PREFIX				= "USE_PREFIX";
ZmId.OP_VERSION_HISTORY         = "VERSION_HISTORY";
ZmId.OP_VIEW					= "VIEW";
ZmId.OP_VIEW_APPOINTMENT		= "VIEW_APPOINTMENT";
ZmId.OP_VIEW_APPT_INSTANCE		= "VIEW_APPT_INSTANCE";
ZmId.OP_VIEW_APPT_SERIES		= "VIEW_APPT_SERIES";
ZmId.OP_VIEW_BY_DATE			= "VIEW_BY_DATE";
ZmId.OP_VIEW_FILE_AS_HTML		= "VIEW_FILE_AS_HTML";
ZmId.OP_VIEW_MENU				= "VIEW_MENU";
ZmId.OP_SORTBY_MENU			    = "SORTBY_MENU";
ZmId.OP_WEEK_VIEW				= "WEEK_VIEW";
ZmId.OP_WORK_WEEK_VIEW			= "WORK_WEEK_VIEW";
ZmId.OP_ZIMLET					= "ZIMLET";

//Group By IDs
ZmId.GROUPBY_DATE               = "GROUPBY_DATE";
ZmId.GROUPBY_FROM               = "GROUPBY_FROM";
ZmId.GROUPBY_NONE               = "GROUPBY_NONE";
ZmId.GROUPBY_PRIORITY           = "GROUPBY_PRIORITY";
ZmId.GROUPBY_SIZE               = "GROUPBY_SIZE";
ZmId.GROUPBY_TAG                = "GROUPBY_TAG";


/*
 * Experimental ID code below. The main idea is to make easier for a third party (such as QA) to find what they're
 * looking for. A secondary goal is to ensure that we always use unique IDs. The systematic approach above is prone
 * to failure in that regard, since the same set of inputs will produce the same ID.
 *
 * The new approach is to introduce a level of indirection between the fields and the ID. IDs will go back to being
 * unique and opaque, based on an incrementing number. A hash will be maintained which maps a collection of fields
 * to the actual ID used in the DOM.
 *
 * The core of the new system is related closely to the old system: a set of params which, taken together, should
 * uniquely identify an element. The possible values for each param are typically constants defined in this class.
 *
 * To make it easy for clients of this ID system to successfully look up IDs, creators of IDs should provide as many
 * parameters as possible. For example, providing both skinComponent and componentType may be redundant, but then
 * the ID can be looked up using either parameter.
 *
 * The parameters and their values:
 *
 * skinComponent
 *
 *      The HTML skin for ZCS defines a number of components and provides containers for them. This param identifies
 *      which skin component contains the element. Note that the IDs for the skin containers themselves (as well as
 *      a few elements within those containers) are defined by the skin (in skin.html), and are not part of this set
 *      of IDs. May often be omitted when looking up an ID.
 *
 *      ZmId.SKIN_*
 *
 * componentType
 *
 *      The general category of view component that maps to the element. It may be a type of widget such as a button
 *      or a menu, something more general like a view, or even a subcomponent like a list view header.
 *
 *      DwtId.WIDGET_*
 *      ZmId.WIDGET_*
 *
 * componentName
 *
 *      The component name identifies the component among components of a similar type. It may be the name of an
 *      operation. For example, a search button would have the type "button" and the name "search". (There may be
 *      more than one search button, so other params may be necessary to uniquely identify each one.)
 *
 *      ZmId.VIEW_*
 *      ZmId.OP_*
 *      ZmId.TB_*
 *      ZmId.SEARCH_*
 *      ZmId.MV_*
 *      ZmId.CMP_*
 *      ZmId.GROUPBY_*
 *
 * app
 *
 *      The name of the application that contains the element. Some elements are global and do not have an associated
 *      application. Elements associated with an app appear within the main content area.
 *
 *      ZmId.APP_*
 *
 * containingView
 *
 *      For an element within the main content area, the identifier of the view that contains it.
 *
 *      ZmId.VIEW_*
 *
 * sessionId
 *
 *      A number identifying a session for a view which can appear in more than one tab at a time. For example, there
 *      may be multiple compose sessions if the user replies to several different messages without sending the replies.
 *
 * itemType
 *
 *      The type of item, such as message, contact, or appointment.
 *
 *      ZmId.ITEM_*
 *
 * itemId
 *
 *      The ID of the item (for example, a mail message) that the element is tied to. For local items, it's a number.
 *      For shared items, it's a compound string comprising an account ID and a local numeric ID.
 *
 * organizerType
 *
 *      The type of organizer, such as folder, tag, or zimlet. Organizers generally appear in the overview.
 *
 *      ZmId.ORG_*
 *
 * organizerId
 *
 *      The ID of the organizer (for example, a mail folder) that the element is tied to. For local organizers, it's a
 *      number. For shared folders, it's a compound string comprising an account ID and a local numeric ID.
 *
 * field
 *
 *      A field identifies a specific sub-part of a component. It might be something that helps make up a widget,
 *      such as the "left icon" in a button, or it might be something ZCS-specific like the "subject" field in a list
 *      view that displays mail messages. The line between componentName and field can be a bit blurry. Generally a
 *      componentName refers to a container of some sort, like a list row or header.
 *
 *      ZmId.FLD_*
 *
 * tagName
 *
 *      The tag name of the HTML element, such as "TABLE" or "TR". May usually be omitted when looking up an ID.
 *
 * sequence
 *
 *      A number used to diffentiate between otherwise identical IDs.
 *
 * parentId
 *
 *      The ID of the parent of this element.
 *
 */

ZmId.BASE = "zcs";
ZmId.SEQ = 1;

ZmId._idList = [];

ZmId._idHash = {};

ZmId._valueToParam = {};

/**
 * Returns a unique ID that can later be looked up. As many params as possible should be provided, in order to
 * make lookup easier. If one or more IDs is found to already have been created with the given set of params,
 * a sequence number is added as a parameter.
 *
 * @param {hash}        params          set of fields describing the ID's element
 * @param {string}      description     (optional) a brief description of the purpose of the ID
 */
ZmId.create = function(params, description) {

	var idParams = AjxUtil.hashCopy(params);
	var ids = ZmId.lookup(params);
	if (ids) {
		idParams.sequence = (typeof ids === "string") ? 1 : ids.length;
	}
	idParams.description = description || "";
	var newId = ZmId.BASE + ZmId.SEQ++;
	idParams.id = newId;
	ZmId._idHash[newId] = idParams;
	ZmId._idList.push(idParams);

	for (var key in params) {
		ZmId._valueToParam[params[key]] = key;
	}

	return newId;
};

/**
 * Returns the DOM ID that matches the given set of params. If more than one ID matches, a list is returned.
 * A partial set of params may be provided. The more params provided, the better the chance of finding just one ID.
 * The best approach is to provide the minimal set of params that will uniquely differentiate the element. If no
 * params are provided, returns all IDs.
 *
 * Optionally, a list of values can be given. An attempt will be made to reverse-engineer the params by figuring
 * out the appropriate key for each value. This method will never be as reliable as providing a hash in the first place.
 *
 * @param {hash|array}  params    set of fields describing the ID(s) being sought
 */
ZmId.lookup = function(params) {

	if (!params) {
		return ZmId._idList;
	}

	if (AjxUtil.isArray(params)) {
		params = ZmId._convertValues(params);
	}

	var ids = [];
	for (var i = 0, len = ZmId._idList.length; i < len; i++) {
		var idParams = ZmId._idList[i];
		var add = true;
		for (var param in params) {
			if (idParams[param] && params[param] !== idParams[param]) {
				add = false;
				continue;
			}
		}
		if (add) {
			ids.push(idParams.id);
		}
	}
	return (ids.length === 0) ? null : (ids.length === 1) ? ids[0] : ids;
};

/**
 * Returns the set of params used to create the given ID.
 *
 * @param id
 */
ZmId.getParams = function(id) {
	return ZmId._idHash[id];
};

/**
 * Displays a list of matching IDs in a popup, with the params used to create them and their descriptions.
 * Intended as a development tool.
 *
 * @param params    set of fields describing the ID(s) being sought
 */
ZmId.showIds = function(params) {

	if (!DBG || DBG.isDisabled()) { return; }

	var ids = ZmId.lookup(params),
		len = ids.length,
		text = "",
		i;

	for (i = 0; i < len; i++) {
		var id = ids[i].id;
		var params = ZmId._idHash[id];
		text += "\n-----\n\n" + id + AjxStringUtil.repeat(" ", 16 - id.length) + params.description + "\n\n";
		var paramNames = AjxUtil.keys(params).sort();
		for (var j = 0; j < paramNames.length; j++) {
			var paramName = paramNames[j];
			if (paramName === 'id' || paramName === 'description') {
				continue;
			}
			var value = params[paramName];
			if (!value) {
				continue;
			}
			value = ZmId._backMap[value] ? "ZmId." + ZmId._backMap[value] : value;
			text += paramName + AjxStringUtil.repeat(" ", 16 - paramName.length) + value + "\n";
		}
	}

	DBG.printRaw(text);
};

ZmId._backMap = AjxUtil.valueHash(ZmId, function(k) {
	return typeof ZmId[k] === 'string';
});

// Create a static hash so we know if a string is a view type (eg "CLV")
ZmId._isViewType = AjxUtil.arrayAsHash(AjxUtil.values(ZmId, function(k) {
	return typeof ZmId[k] === "string" && k.indexOf("VIEW_") === 0;
}));

// Convert a list of values of ID parameters back into a hash by figuring out the matching key for each value.
// View names (such as "CLV") are a bit tricky since they can be either a componentName (for a view widget), or
// a containingView. A small number might be an organizer ID (eg Inbox is 2), or a session ID.
ZmId._convertValues = function(values) {

	var params = {},
		viewValue, numValue;

	for (var i = 0; i < values.length; i++) {
		var value = values[i];
		if (ZmId._isViewType[value]) {
			viewValue = value;
		}
		else if (AjxUtil.isNumber(value) || AjxUtil.isNumeric(value)) {
			var num = parseInt(value);
			if (num < 10) {
				numValue = num;
			}
		}
		else {
			var param = ZmId._valueToParam[value];
			params[param] = value;
		}
	}

	// A view value is a componentName only if the componentType is a view.
	if (viewValue) {
		var viewParam = (params.componentType === ZmId.WIDGET_VIEW) ? "componentName" : "containingView";
		params[viewParam] = viewValue;
	}

	// A single-digit number is probably an organizer ID or a session ID.
	if (numValue) {
		var viewParam = params.organizerType ? "organizerId" : "sessionId";
		params[viewParam] = viewValue;
	}

	return params;
};
}
if (AjxPackage.define("zimbraMail.share.model.events.ZmEvent")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines an event.
 *
 */

/**
 * Creates an empty event of the given type.
 * @class
 * This class represents an event that encapsulates some sort of change to a model (data).
 * The event has a data type (for example, conversation), an event type (for example, delete), a source (the
 * data object generating the event), and a hash of arbitrary information (details).
 * 
 * @param {constant}		type	the source of the event
 */
ZmEvent = function(type) {

	this.type = type;	// source type (conv, msg, contact, folder, etc)
	this.event = null;	// event type (create, modify, etc)
	this.source = null;	// notifying model (often a list)
	this.item = null;	// item that is subject of the notification
	this._details = {};
}

// Listener types
ZmEvent.L_MODIFY = 1;
ZmEvent.L_PICKER = 2;

// Source types (note: there are not separate types for list models)
ZmEvent.S_TAG			= "TAG";
ZmEvent.S_PICKER		= "PICKER";
ZmEvent.S_SEARCH		= "SEARCH";
ZmEvent.S_SETTING		= "SETTING";
ZmEvent.S_SETTINGS		= "SETTINGS";
ZmEvent.S_SHARE         = "SHARE";
ZmEvent.S_MOUNTPOINT	= "MOUNTPOINT";
ZmEvent.S_ZIMLET		= "ZIMLET";

// Event types
/**
 * Defines the "create" event type.
 */
ZmEvent.E_CREATE		= "CREATE";
/**
 * Defines the "delete" event type.
 */
ZmEvent.E_DELETE		= "DELETE";
/**
 * Defines the "modify" event type.
 */
ZmEvent.E_MODIFY		= "MODIFY";
/**
 * Defines the "load" event type.
 */
ZmEvent.E_LOAD			= "LOAD";
/**
 * Defines the "remove" event type.
 */
ZmEvent.E_REMOVE		= "REMOVE";
/**
 * Defines the "remove all" event type.
 */
ZmEvent.E_REMOVE_ALL	= "REMOVE ALL";
/**
 * Defines the "move" event type.
 */
ZmEvent.E_MOVE			= "MOVE";
/**
 * Defines the "flags" event type.
 */
ZmEvent.E_FLAGS			= "FLAGS";
/**
 * Defines the "tags" event type.
 */
ZmEvent.E_TAGS			= "TAGS";
/**
 * Defines the "zimlets" event type.
 */
ZmEvent.E_ZIMLETS		= "ZIMLET";
/**
 * Defines the "complete" event type.
 */
ZmEvent.E_COMPLETE		= "COMPLETE";

// Public methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmEvent.prototype.toString = 
function() {
	return "ZmEvent";
};

/**
 * Sets the event type and source.
 *
 * @param {constant}	event	the event type (see <code>ZmEvent.E_</code> constants)
 * @param {Object}	source		the object that generated the event (typically "this")
 */
ZmEvent.prototype.set =
function(event, source) {
	this.event = event;
	this.source = source;
	this.handled = false;
};

/**
 * Adds info to the event details.
 *
 * @param {String}		field		the detail name
 * @param {Object}		value		the detail value
 */
ZmEvent.prototype.setDetail =
function(field, value) {
	this._details[field] = value;
};

/**
 * Gets info from the event details.
 *
 * @param {String}	field		the detail field name
 * @return	{Object}	the details
 */
ZmEvent.prototype.getDetail =
function(field) {
	return this._details[field];
};

/**
 * Gets items by checking for a detail with a name of "items" and returning it.
 * 
 * @return	{Array}		an array of items or empty array if "items" does not exist
 */
ZmEvent.prototype.getItems =
function() {
    var items = this._details["items"];
    return items ? items : [];
};

/**
 * Sets the event details. Any existing details will be lost.
 *
 * @param {Hash}	details		a hash representing event details
 */
ZmEvent.prototype.setDetails =
function(details) {
	this._details = details ? details : {};
};

/**
 * Gets the event details.
 * 
 * @return	{Hash}	the event details
 */
ZmEvent.prototype.getDetails =
function() {
	return this._details;
};
}
if (AjxPackage.define("zimbraMail.share.model.events.ZmAppEvent")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines an application event.
 *
 */

/**
 * Creates an empty application event.
 * @class
 * This class represents an event related to a change of state for an individual
 * application or for ZCS as a whole.
 * 
 * @param {Object}	the application to which this event applies; if <code>null</code>, the event applies to ZCS
 * 
 * @extends		ZmEvent
 */
ZmAppEvent = function(app) {
	ZmEvent.call(this);
};

ZmAppEvent.prototype = new ZmEvent;
ZmAppEvent.prototype.constructor = ZmAppEvent;

/**
 * Event used to notify listeners before startup (i.e. before the first
 * app is activated). This is a bit of a misnomer because this event occurs
 * after the apps are initialized but before the first app is shown. This
 * allows code to be executed after the apps have registered settings
 * but before the app actually acts on those settings.
 *
 * @see ZmAppEvent.POST_STARTUP
 */
ZmAppEvent.PRE_STARTUP	= "PRESTARTUP";

/**
 * Defines the event used to notify listeners post-startup.
 */
ZmAppEvent.POST_STARTUP	= "POSTSTARTUP";
/**
 * Defines the event used to notify listeners pre-launch.
 */
ZmAppEvent.PRE_LAUNCH	= "PRELAUNCH";
/**
 * Defines the event used to notify listeners post-launch.
 */
ZmAppEvent.POST_LAUNCH	= "POSTLAUNCH";
/**
 * Defines the event used to notify listeners post-render.
 */
ZmAppEvent.POST_RENDER	= "POSTRENDER";

ZmAppEvent.ACTIVATE	= "ACTIVATE";

// Triggered after processing of an async response finishes
ZmAppEvent.RESPONSE = "RESPONSE";

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmAppEvent.prototype.toString =
function() {
	return "ZmAppEvent";
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmModel")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This class represents a data model which can process change events.
 *
 */

/**
 * Creates the data model.
 * @class
 * This class represents a data model which can process change events.
 * 
 * @author Conrad Damon
 *
 * @param {constant}		type	the event source type {@see ZmEvent}
 */
ZmModel = function(type) {
 	if (arguments.length == 0) return;

	this._evt = new ZmEvent(type);
	this._evtMgr = new AjxEventMgr();
}

ZmModel.prototype.isZmModel = true;
ZmModel.prototype.toString = function() { return "ZmModel"; }

/**
* Adds a change listener.
*
* @param {AjxListener}	listener	the change listener to add
*/
ZmModel.prototype.addChangeListener = 
function(listener) {
	return this._evtMgr.addListener(ZmEvent.L_MODIFY, listener);
}

/**
* Removes the given change listener.
*
* @param {AjxListener}	listener		the change listener to remove
*/
ZmModel.prototype.removeChangeListener = 
function(listener) {
	return this._evtMgr.removeListener(ZmEvent.L_MODIFY, listener);    	
}

/**
* Removes all change listeners.
* 
*/
ZmModel.prototype.removeAllChangeListeners = 
function() {
	return this._evtMgr.removeAll(ZmEvent.L_MODIFY);    	
}

/**
* Notifies listeners of the given change event.
*
* @param {constant}		event		the event type {@see ZmEvent}
* @param {Hash}			details		additional information
* 
* @private
*/
ZmModel.prototype._notify =
function(event, details) {
	if (this._evtMgr.isListenerRegistered(ZmEvent.L_MODIFY)) {
		this._evt.set(event, this);
		this._evt.setDetails(details);
		this._evtMgr.notifyListeners(ZmEvent.L_MODIFY, this._evt);
	}
};

/**
 * @private
 */
ZmModel.notifyEach =
function(list, event, details) {
	if (!(list && list.length)) { return; }
	for (var i = 0; i < list.length; i++) {
		list[i]._notify(event, details);
	}
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmSetting")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains a setting class.
 */

/**
 * Creates a setting.
 * @class
 * This class represents a single setting. A setting's default value never changes; it
 * is available in case the user wishes to restore the current value to the default.
 * Most but not all settings have a corollary on the server side. Settings that don't
 * will depend on the environment or user activity to get their value.
 *
 * @author Conrad Damon
 * 
 * @param {String}	id				a unique ID
 * @param {Hash}	params			a hash of parameters
 * @param {String}	params.name				the name of the pref or attr on the server
 * @param {constant}	params.type			config, pref, or COS (see <code>ZmSetting.T_</code> constants)
 * @param {constant}	params.dataType			string, int, or boolean
 * @param {Object}	params.defaultValue		the default value
 * @param {Boolean}	params.isGlobal			if <code>true</code>, this setting is global across accounts
 * @param {Boolean}	params.isImplicit		if <code>true</code>, this setting is not represented in Preferences
 * 
 * @extends		ZmModel
 */
ZmSetting = function(id, params) {

	if (arguments.length == 0) return;
	ZmModel.call(this, ZmEvent.S_SETTING);
	
	this.id = id;
	this.name = params.name;
	this.type = params.type;
	this.dataType = params.dataType || ZmSetting.D_STRING;
	this.defaultValue = params.defaultValue;
	this.canPreset = params.canPreset;
	if (this.type == ZmSetting.T_METADATA) {
		this.section = params.section;
	}
	if (params.isGlobal) {
		ZmSetting.IS_GLOBAL[id] = true;
	}
	if (params.isImplicit) {
		ZmSetting.IS_IMPLICIT[id] = true;
	}
	
	if (this.dataType == ZmSetting.D_HASH) {
		this.value = {};
		this.defaultValue = {};
	} else if (this.dataType == ZmSetting.D_LIST) {
		this.value = [];
		this.defaultValue = [];
	} else {
		this.value = null;
	}

    this.dontSaveDefault = params.dontSaveDefault;
};

ZmSetting.prototype = new ZmModel;
ZmSetting.prototype.constructor = ZmSetting;

// setting types
/**
 * Defines the "config" type.
 */
ZmSetting.T_CONFIG		= "config";
/**
 * Defines the "COS" type.
 */
ZmSetting.T_COS			= "cos";
/**
 * Defines the "domain" type.
 */
ZmSetting.T_DOMAIN		= "domain";
/**
 * Defines the "meta-data" type.
 */
ZmSetting.T_METADATA	= "meta";
/**
 * Defines the "pref" type.
 */
ZmSetting.T_PREF		= "pref";
/**
 * Defines the "pseudo" type.
 */
ZmSetting.T_PSEUDO		= "pseudo";

// metadata sections
ZmSetting.M_IMPLICIT	= "implicit";
ZmSetting.M_OFFLINE		= "offline";
ZmSetting.M_ZIMLET		= "zimlet";

// setting data types
ZmSetting.D_STRING		= "string"; // default type
ZmSetting.D_INT			= "int";
ZmSetting.D_BOOLEAN		= "boolean";
ZmSetting.D_LDAP_TIME 	= "ldap_time";
ZmSetting.D_HASH 		= "hash";
ZmSetting.D_LIST		= "list";
ZmSetting.D_NONE		= "NONE";	// placeholder setting

// constants used as setting values
// TODO: these should be defined in their respective apps
/**
 * Defines the "all" ACL grantee type.
 * @type String
 */
ZmSetting.ACL_AUTH				= "all";
/**
 * Defines the "group" ACL grantee type.
 * @type String
 */
ZmSetting.ACL_GROUP				= "grp";
/**
 * Defines the "none" ACL grantee type.
 * @type String
 */
ZmSetting.ACL_NONE				= "none";
/**
 * Defines the "public" ACL grantee type.
 * @type String
 */
ZmSetting.ACL_PUBLIC			= "pub";
/**
 * Defines the "domain" ACL grantee type.
 * @type String
 */
ZmSetting.ACL_DOMAIN			= "dom";
/**
 * Defines the "user" ACL grantee type.
 * @type String
 */
ZmSetting.ACL_USER				= "usr";
ZmSetting.CAL_DAY				= "day";
ZmSetting.CAL_LIST				= "list";
ZmSetting.CAL_MONTH				= "month";
ZmSetting.CAL_WEEK				= "week";
ZmSetting.CAL_WORK_WEEK			= "workWeek";
ZmSetting.CAL_VISIBILITY_PRIV	= "private";
ZmSetting.CAL_VISIBILITY_PUB	= "public";
ZmSetting.CLIENT_ADVANCED		= "advanced";				// zimbraPrefClientType
ZmSetting.CLIENT_STANDARD		= "standard";
ZmSetting.COMPOSE_FONT_COLOR	= "#000000";	 			// zimbraPrefHtmlEditorDefaultFontColor
ZmSetting.COMPOSE_FONT_FAM 		= "arial,helvetica,sans-serif";		// zimbraPrefHtmlEditorDefaultFontFamily
ZmSetting.COMPOSE_FONT_SIZE 	= AjxMessageFormat.format(ZmMsg.pt,"12"); 			// zimbraPrefHtmlEditorDefaultFontSize
ZmSetting.LTR                   = "LTR";
ZmSetting.RTL                   = "RTL";
ZmSetting.COMPOSE_TEXT 			= "text";					// zimbraPrefComposeFormat
ZmSetting.COMPOSE_HTML 			= "html";
ZmSetting.CV_CARDS				= "cards"; 					// zimbraPrefContactsInitialView
ZmSetting.CV_LIST				= "list";
ZmSetting.DEDUPE_NONE			= "dedupeNone";				// zimbraPrefDedupeMessagesSentToSelf
ZmSetting.DEDUPE_SECOND			= "secondCopyifOnToOrCC";
ZmSetting.DEDUPE_INBOX			= "moveSentMessageToInbox";
ZmSetting.DEDUPE_ALL			= "dedupeAll";
ZmSetting.DELETE_SELECT_NEXT	= "next";					// zimbraPrefMailSelectAfterDelete
ZmSetting.DELETE_SELECT_PREV	= "previous";
ZmSetting.DELETE_SELECT_ADAPT	= "adaptive";
ZmSetting.GROUP_BY_CONV			= "conversation";			// zimbraPrefGroupMailBy
ZmSetting.GROUP_BY_MESSAGE		= "message";
ZmSetting.HTTP_DEFAULT_PORT		= 80;
ZmSetting.HTTPS_DEFAULT_PORT	= 443;
ZmSetting.INC_NONE				= "includeNone";			// zimbraPrefReplyIncludeOriginalText / zimbraPrefForwardIncludeOriginalText
ZmSetting.INC_ATTACH			= "includeAsAttachment";
ZmSetting.INC_BODY				= "includeBody";				// deprecated - same as includeBodyAndHeaders
ZmSetting.INC_BODY_ONLY			= "includeBodyOnly";
ZmSetting.INC_BODY_PRE			= "includeBodyWithPrefix";
ZmSetting.INC_BODY_HDR			= "includeBodyAndHeaders";
ZmSetting.INC_BODY_PRE_HDR		= "includeBodyAndHeadersWithPrefix";
ZmSetting.INC_SMART				= "includeSmart";
ZmSetting.INC_SMART_PRE			= "includeSmartWithPrefix";
ZmSetting.INC_SMART_HDR			= "includeSmartAndHeaders";
ZmSetting.INC_SMART_PRE_HDR		= "includeSmartAndHeadersWithPrefix";
ZmSetting.MARK_READ_NONE		= -1;						// zimbraPrefMarkMsgRead
ZmSetting.MARK_READ_NOW			= 0;						// zimbraPrefMarkMsgRead
ZmSetting.MARK_READ_TIME		= 1;						// zimbraPrefMarkMsgRead
ZmSetting.PRINT_FONT_SIZE 	    = AjxMessageFormat.format(ZmMsg.pt,"12"); 			// zimbraPrefDefaultPrintFontSize
ZmSetting.PROTO_HTTP			= "http:";
ZmSetting.PROTO_HTTPS			= "https:";
ZmSetting.PROTO_MIXED			= "mixed:";
ZmSetting.RIGHT_VIEW_FREE_BUSY	= "viewFreeBusy";
ZmSetting.RIGHT_INVITE			= "invite";
ZmSetting.RP_BOTTOM				= "bottom";					// zimbraPrefReadingPaneLocation / zimbraPrefConvReadingPaneLocation / zimbraPrefTasksReadingPaneLocation / zimbraPrefBriefcaseReadingPaneLocation
ZmSetting.RP_OFF				= "off";
ZmSetting.RP_RIGHT				= "right";
ZmSetting.SIG_INTERNET			= "internet";				// zimbraPrefMailSignatureStyle
ZmSetting.SIG_OUTLOOK			= "outlook";

// values for the 'fetch' param of SearchConvRequest
ZmSetting.CONV_FETCH_NONE                       = "0";
ZmSetting.CONV_FETCH_FIRST_MATCHING             = "1";
ZmSetting.CONV_FETCH_FIRST                      = "!";
ZmSetting.CONV_FETCH_UNREAD                     = "u";
ZmSetting.CONV_FETCH_UNREAD_OR_FIRST_MATCHING   = "u1";
ZmSetting.CONV_FETCH_UNREAD_OR_FIRST            = "u!";
ZmSetting.CONV_FETCH_UNREAD_OR_BOTH_FIRST       = "u1!";
ZmSetting.CONV_FETCH_MATCHES                    = "hits";
ZmSetting.CONV_FETCH_MATCHES_OR_FIRST           = "hits!";
ZmSetting.CONV_FETCH_ALL                        = "all";

// License status (network only)
ZmSetting.LICENSE_GOOD			= "OK";
ZmSetting.LICENSE_NOT_INSTALLED = "NOT_INSTALLED";
ZmSetting.LICENSE_NOT_ACTIVATED = "NOT_ACTIVATED";
ZmSetting.LICENSE_FUTURE		= "IN_FUTURE";
ZmSetting.LICENSE_EXPIRED		= "EXPIRED";
ZmSetting.LICENSE_BAD			= "INVALID";
ZmSetting.LICENSE_GRACE			= "LICENSE_GRACE_PERIOD";
ZmSetting.LICENSE_ACTIV_GRACE	= "ACTIVATION_GRACE_PERIOD";

// warning messages for bad license statuses
ZmSetting.LICENSE_MSG									= {};
ZmSetting.LICENSE_MSG[ZmSetting.LICENSE_NOT_INSTALLED]	= ZmMsg.licenseNotInstalled;
ZmSetting.LICENSE_MSG[ZmSetting.LICENSE_NOT_ACTIVATED]	= ZmMsg.licenseNotActivated;
ZmSetting.LICENSE_MSG[ZmSetting.LICENSE_FUTURE]			= ZmMsg.licenseExpired;
ZmSetting.LICENSE_MSG[ZmSetting.LICENSE_EXPIRED]		= ZmMsg.licenseExpired;
ZmSetting.LICENSE_MSG[ZmSetting.LICENSE_BAD]			= ZmMsg.licenseExpired;

// we need these IDs available when the app classes are parsed
ZmSetting.LOCALE_NAME			= "LOCALE_NAME";
ZmSetting.COMPOSE_INIT_DIRECTION= "COMPOSE_INIT_DIRECTION";
ZmSetting.SHOW_COMPOSE_DIRECTION_BUTTONS = "SHOW_COMPOSE_DIRECTION_BUTTONS";
ZmSetting.FONT_NAME				= "FONT_NAME";
ZmSetting.FONT_SIZE				= "FONT_SIZE";
ZmSetting.SKIN_NAME				= "SKIN_NAME";

ZmSetting.BRIEFCASE_ENABLED		= "BRIEFCASE_ENABLED";
ZmSetting.CALENDAR_ENABLED		= "CALENDAR_ENABLED";
ZmSetting.CONTACTS_ENABLED		= "CONTACTS_ENABLED";
ZmSetting.MAIL_ENABLED			= "MAIL_ENABLED";
ZmSetting.OPTIONS_ENABLED		= "OPTIONS_ENABLED";
ZmSetting.PORTAL_ENABLED		= "PORTAL_ENABLED";
ZmSetting.SEARCH_ENABLED		= "SEARCH_ENABLED";
ZmSetting.SOCIAL_ENABLED		= "SOCIAL_ENABLED";
ZmSetting.TASKS_ENABLED			= "TASKS_ENABLED";
ZmSetting.VOICE_ENABLED			= "VOICE_ENABLED";
ZmSetting.TAGGING_ENABLED		= "TAGGING_ENABLED";
ZmSetting.CHAT_FEATURE_ENABLED  = "CHAT_FEATURE_ENABLED";
ZmSetting.CHAT_ENABLED          = "CHAT_ENABLED";
ZmSetting.CHAT_PLAY_SOUND       = "CHAT_PLAY_SOUND";

ZmSetting.CALENDAR_UPSELL_ENABLED	= "CALENDAR_UPSELL_ENABLED";
ZmSetting.CONTACTS_UPSELL_ENABLED	= "CONTACTS_UPSELL_ENABLED";
ZmSetting.MAIL_UPSELL_ENABLED		= "MAIL_UPSELL_ENABLED";
ZmSetting.SOCIAL_EXTERNAL_ENABLED   = "SOCIAL_EXTERNAL_ENABLED";
ZmSetting.SOCIAL_EXTERNAL_URL	    = "SOCIAL_EXTERNAL_URL";
ZmSetting.VOICE_UPSELL_ENABLED		= "VOICE_UPSELL_ENABLED";

//user selected font
ZmSetting.FONT_CLASSIC	= "classic";
ZmSetting.FONT_MODERN	= "modern";
ZmSetting.FONT_WIDE		= "wide";
ZmSetting.FONT_SYSTEM	= "system";

//user selected font size
ZmSetting.FONT_SIZE_SMALL = "small";
ZmSetting.FONT_SIZE_NORMAL = "normal";
ZmSetting.FONT_SIZE_LARGE = "large";
ZmSetting.FONT_SIZE_LARGER = "larger";


// name for dynamic CSS class created from user font prefs
ZmSetting.USER_FONT_CLASS = "userFontPrefs";

//task filterby setting
ZmSetting.TASK_FILTER_ALL = "";
ZmSetting.TASK_FILTER_TODO = "TODO";
ZmSetting.TASK_FILTER_COMPLETED = "COMPLETED";
ZmSetting.TASK_FILTER_WAITING = "WAITING";
ZmSetting.TASK_FILTER_DEFERRED = "DEFERRED";
ZmSetting.TASK_FILTER_INPROGRESS = "INPROGRESS";
ZmSetting.TASK_FILTER_NOTSTARTED = "NOTSTARTED";

// hash of global settings
ZmSetting.IS_GLOBAL = {};

// hash of implicit settings
ZmSetting.IS_IMPLICIT = {};

// hash of implicit settings that have been changed during the current session
ZmSetting.CHANGED_IMPLICIT = {};

// Send As and Send On Behalf Of settings
ZmSetting.SEND_AS = "sendAs";
ZmSetting.SEND_ON_BEHALF_OF = "sendOnBehalfOf";

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmSetting.prototype.toString =
function() {
	return this.name + ": " + this.value;
};

/**
 * Gets the current value of this setting.
 *
 * @param {String}	key			the optional key for use by hash table data type
 * @param {Boolean}	serialize		if <code>true</code>, serialize non-string value into string
 * @return	{Object}	the value
 */
ZmSetting.prototype.getValue =
function(key, serialize) {

	var value = null;
	if (this.value != null) {
		value = key ? this.value[key] : this.value;
	} else if (this.defaultValue != null) {
		value = key ? this.defaultValue[key] : this.defaultValue;
	} else {
		return null;
	}

    if(this.dontSaveDefault && serialize && !key){
        value = this.getRefinedValue(value);
    }

	return serialize ? ZmSetting.serialize(value, this.dataType) : value;
};

ZmSetting.prototype.getRefinedValue =
function(value){
    if(this.dataType == ZmSetting.D_HASH){
        var refinedValue = {}, dValue = this.defaultValue;
        for(var key in value){
             refinedValue[key] = (dValue[key] != value[key]) ? value[key] : "";
        }
        return refinedValue;
    }
    return value;
};

/**
 * Gets the original value of this setting.
 *
 * @param {String}	key			the optional key for use by hash table data type
 * @param {Boolean}	serialize		if <code>true</code>, serialize non-string value into string
 * @return	{Object}	the value
 */
ZmSetting.prototype.getOrigValue =
function(key, serialize) {

	var origValue = null;
	if (this.origValue != null) {
		origValue = key ? this.origValue[key] : this.origValue;
	} else if (this.defaultValue != null) {
		origValue = key ? this.defaultValue[key] : this.defaultValue;
	} else {
		return null;
	}

	return serialize ? ZmSetting.serialize(origValue, this.dataType) : origValue;
};

/**
 * Gets the default value of this setting.
 *
 * @param {String}	key 			the optional key for use by hash table data type
 * @return	{Object}	the value
 */
ZmSetting.prototype.getDefaultValue =
function(key, serialize) {
	var value = key ? this.defaultValue[key] : this.defaultValue;
	return serialize ? ZmSetting.serialize(value, this.dataType) : value;
};

/**
 * Sets the current value of this setting, performing any necessary data type conversion.
 *
 * @param {Object}	value			the new value for the setting
 * @param {String}	key 			optional key for use by hash table data type
 * @param {Boolean}	setDefault		if <code>true</code>, also set the default value
 * @param {Boolean}	skipNotify		if <code>true</code>, do not notify listeners
 * @param {Boolean}	skipImplicit		if <code>true</code>, do not check for change to implicit pref
 */
ZmSetting.prototype.setValue =
function(value, key, setDefault, skipNotify, skipImplicit) {

	var newValue = value;
	var changed = Boolean(newValue != this.value);
	if (this.dataType == ZmSetting.D_STRING) {
		this.value = newValue;
	} else if (this.dataType == ZmSetting.D_INT) {
		newValue = parseInt(value);
		if (isNaN(newValue)) { // revert to string if NaN
			newValue = value;
		}
		changed = Boolean(newValue != this.value);
		this.value = newValue;
	} else if (this.dataType == ZmSetting.D_BOOLEAN) {
		if (typeof(newValue) == "string") {
			newValue = (newValue.toLowerCase() === "true");
		}
		changed = Boolean(newValue != this.value);
		this.value = newValue;
	} else if (this.dataType == ZmSetting.D_LDAP_TIME) {
		var lastChar = (newValue.toLowerCase) ? lastChar = (newValue.toLowerCase()).charAt(newValue.length-1) : null;
		var num = parseInt(newValue);
		// convert to seconds
		if (lastChar == 'd') {
			newValue = num * 24 * 60 * 60;
		} else if (lastChar == 'h') {
			newValue = num * 60 * 60;
		} else if (lastChar == 'm') {
			newValue = num * 60;
		} else {
			newValue = num;	// default
		}
		changed = Boolean(newValue != this.value);
		this.value = newValue;
	} else if (this.dataType == ZmSetting.D_HASH) {
		changed = true;
        if (key) {
			if (newValue) {
                changed = Boolean(newValue != this.value[key]);
				this.value[key] = newValue;
			} else {
				delete this.value[key];
			}
		} else {
			this.value = newValue;
		}
	} else if (this.dataType == ZmSetting.D_LIST) {
		if (newValue instanceof Array) {
			this.value = newValue;
		} else {
			this.value.push(newValue);
		}
		changed = true;
	}

	if (setDefault) {
		if (key) {
			this.defaultValue[key] = this.value[key];
		} else {
			this.defaultValue = this.value;
		}
	}
	
	if (ZmSetting.IS_IMPLICIT[this.id] && changed && !skipImplicit) {
		if (skipNotify) {
			ZmSetting.CHANGED_IMPLICIT[this.id] = true;
		} else {
			this._notify(ZmEvent.E_MODIFY, key);
			return;
		}
	}

	// Setting an internal pref is equivalent to saving it, so we should notify
	if (!this.name && !skipNotify) {
		this._notify(ZmEvent.E_MODIFY, key);
	}
};

/**
 * Handles modify notification.
 * 
 * @param	{Object}	obj		the object
 */
ZmSetting.prototype.notifyModify = 
function(obj) {
	if (this.id == ZmSetting.QUOTA_USED && obj._name == "mbx" && obj.s != null) {
		this.setValue(obj.s);
		this._notify(ZmEvent.E_MODIFY, {account:obj.account});
	}
};

ZmSetting.prototype.copyValue =
function() {

	if (this.dataType == ZmSetting.D_HASH) {
		return AjxUtil.hashCopy(this.value);
	} else if (this.dataType == ZmSetting.D_LIST) {
		return this.value.concat();
	} else {
		return this.value;
	}
};

ZmSetting.serialize =
function(value, dataType) {

	if (dataType == ZmSetting.D_BOOLEAN) {
		value = value ? "TRUE" : "FALSE";
	} else if (dataType == ZmSetting.D_HASH) {
		var keys = [];
		for (var key in value) {
			keys.push(key);
		}
		keys.sort();
		var pairs = [];
		for (var j = 0; j < keys.length; j++) {
			var key = keys[j];
			pairs.push([key, value[key]].join(":"));
		}
		value = pairs.join(",");
	} else if (dataType == ZmSetting.D_LIST) {
		value = value.join(",");
	}

	return value;
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmAccessControlList")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines an access control list and associated classes.
 *
 */

/**
 * Creates an empty access control list (ACL).
 * @class
 * An access control list is a collection of access control entries (ACEs). Each entry contains
 * information about a certain permission applied by the current user to another user or users
 * for a particular type of action. So far, there are two types of rights that are managed in
 * this way:
 * 
 * <ul>
 * <li><b>viewFreeBusy</b> - governs whether other users may view this user's free/busy information</li>
 * <li><b>invite</b> - determines whether an invite from other users will automatically create a tentative appointment on this user's calendar</li>
 * </ul>
 * 
 * Note: that shared organizers ({@link ZmShare}) manage rights (read/write/manage) in their own way.
 * 
 * @author Conrad Damon
 * 
 * @param {Array}	aces		the list of {@link ZmAccessControlEntry} objects
 */
ZmAccessControlList = function(aces) {
	this._aces = {};
}

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmAccessControlList.prototype.toString =
function() {
	return "ZmAccessControlList";
};

/**
 * Loads the list.
 * 
 * @param	{AjxCallback}	callback	the function to callback after the loaded
 * 
 * @private
 */
ZmAccessControlList.prototype.load =
function(callback) {
	var jsonObj = {GetRightsRequest:{_jsns:"urn:zimbraAccount"}};
	var respCallback = new AjxCallback(this, this._handleResponseLoad, [callback]);
	appCtxt.getAppController().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
};

/**
 * @private
 */
ZmAccessControlList.prototype._handleResponseLoad =
function(callback, result) {
	var response = result.getResponse();
	var aces = response.GetRightsResponse.ace;
	if (aces && aces.length) {
		for (var i = 0; i < aces.length; i++) {
			this.add(ZmAccessControlEntry.createFromDom(aces[i]));
		}
	}
	if (callback) {
		callback.run();
	}
};

/**
 * Gets the access control entry by right.
 * 
 * @param	{String}	right		the right
 * @return	{ZmAccessControlEntry}	the entry
 */
ZmAccessControlList.prototype.getACLByRight =
function(right) {
	return this._aces[right];
};

/**
 * Gets the grantee type.
 * 
 * @param	{String}	right		the right
 * @return	{constant}	the grantee type (see <code>ZmSetting.ACL_</code> constants)
 * 
 * @see		ZmSetting
 */
ZmAccessControlList.prototype.getGranteeType =
function(right) {
	var aces = this._aces[right];
	var gt = ZmSetting.ACL_PUBLIC;
	
	var gtMap = {};
	if(aces && aces.length) {
		for (var i = 0; i < aces.length; i++) {
			var ace = aces[i];
			DBG.println("<font color=red>ace:</font>" + (ace.negative?"-":"") + ace.granteeType +"," +  ace.grantee );
			var aceGranteeType =  (ace.granteeType == ZmSetting.ACL_USER || ace.granteeType == ZmSetting.ACL_GROUP)  ? ZmSetting.ACL_USER : ace.granteeType;
			gtMap[aceGranteeType] = ace.negative ? -1 : 1;
		}
	}
	
	var allowPublic = (gtMap[ZmSetting.ACL_PUBLIC] == 1);
	var denyPublic  = (gtMap[ZmSetting.ACL_PUBLIC] == -1);
	var allowLocal  = (gtMap[ZmSetting.ACL_AUTH] == 1);
	var denyLocal   = (gtMap[ZmSetting.ACL_AUTH] == -1);
    var allowDomainOnly   = (gtMap[ZmSetting.ACL_DOMAIN] == 1);
	
	var allowUser = (gtMap[ZmSetting.ACL_USER] == 1);
	var allowNone = (denyPublic || denyLocal) && (gtMap[ZmSetting.ACL_USER] == null);
				
	if(allowPublic) {
		return ZmSetting.ACL_PUBLIC;
	}
	
	if(allowLocal) {
		return ZmSetting.ACL_AUTH;
	}
	
	if(denyPublic) {
		if(allowLocal) {
			return ZmSetting.ACL_AUTH;
		}
	}
	
	if(allowUser) {
		return ZmSetting.ACL_USER;
	}

    if(allowDomainOnly) {
		return ZmSetting.ACL_DOMAIN;
	}
	
	if(allowNone) {
		return ZmSetting.ACL_NONE;
	}
	return gt;
};

/**
 * Gets the access control entry by grantee type.
 * 
 * @param	{String}	right	the right
 * @param	{constant}	gt		the grantee type (see <code>ZmSetting.ACL_</code> constants)
 * @return	{Array}	an array of {@link ZmAccessControlEntry} objects
 */
ZmAccessControlList.prototype.getACLByGranteeType =
function(right, gt) {
	var aces = this._aces[right];
	var list = [];
	if (aces && aces.length) {
		for (var i = 0; i < aces.length; i++) {
			var ace = aces[i];
			if (ace.granteeType == gt) {
				list.push(ace);
			}
		}
	}
	list.sort();
	return list;
};

/**
 * Gets the grantees.
 * 
 * @param	{String}	right	the right
 * @return	{Array}		an array of grantees
 */
ZmAccessControlList.prototype.getGrantees =
function(right) {
	var aces = this._aces[right];
	var list = [];
	if (aces && aces.length) {
		for (var i = 0; i < aces.length; i++) {
			var ace = aces[i];
			if (ace.granteeType == ZmSetting.ACL_USER || ace.granteeType == ZmSetting.ACL_GROUP) {
				list.push(ace.grantee);
			}
		}
	}
	list.sort();
	return list;
};

/**
 * Gets the grantees info.
 * 
 * @param	{String}	right		the right
 * @return	{Array}	an array of grantree info objects (obj.grantee, obj.zid)
 */
ZmAccessControlList.prototype.getGranteesInfo =
function(right) {
	var aces = this._aces[right];
	var list = [];
	if (aces && aces.length) {
		for (var i = 0; i < aces.length; i++) {
			var ace = aces[i];
			if (ace.granteeType == ZmSetting.ACL_USER || ace.granteeType == ZmSetting.ACL_GROUP) {
				list.push({grantee: ace.grantee, zid: ace.zid});
			}
		}
	}
	list.sort(ZmAccessControlList.sortByGrantee);
	return list;
};

/**
 * Grants permissions on the access control entries.
 * 
 * @param	{Array}	aces		an array of {@link ZmAccessControlEntry} objects
 * @param	{AjxCallback}	callback	the callback
 * @param	{Boolean}	batchCmd	<code>true</code> to submit as a batch command
 */
ZmAccessControlList.prototype.grant =
function(aces, callback, batchCmd) {
	this._setPerms(aces, false, callback, batchCmd);
};

/**
 * Revokes and denies permissions the access control entries.
 * 
 * @param	{Array}	aces		an array of {@link ZmAccessControlEntry} objects
 * @param	{AjxCallback}	callback	the callback
 * @param	{Boolean}	batchCmd	<code>true</code> to submit as a batch command
 */
ZmAccessControlList.prototype.revoke =
function(aces, callback, batchCmd) {
	this._setPerms(aces, true, callback, batchCmd);
};

/**
 * Sets the permissions.
 * 
 * @param	{Array}	aces		an array of {@link ZmAccessControlEntry} objects
 * @param	{Boolean}	revoke	<code>true</code> to deny; <code>false</code> to grant
 * @param	{AjxCallback}	callback	the callback
 * @param	{Boolean}	batchCmd	<code>true</code> to submit as a batch command
 *
 * @private
 */
ZmAccessControlList.prototype._setPerms =
function(aces, revoke, callback, batchCmd) {
	var reqName = revoke ? "RevokeRightsRequest" : "GrantRightsRequest";
	var soapDoc = AjxSoapDoc.create(reqName, "urn:zimbraAccount");
	for (var i = 0; i < aces.length; i++) {
		var ace = aces[i];
		var aceNode = soapDoc.set("ace");
		aceNode.setAttribute("right", ace.right);
		aceNode.setAttribute("gt", ace.granteeType);
		if(ace.grantee) {
			aceNode.setAttribute("d", ace.grantee);
		}
		if (ace.zid) {
			aceNode.setAttribute("zid", ace.zid);
		}
		if (ace.negative) {
			aceNode.setAttribute("deny", 1);
		}
	}
	var respCallback = new AjxCallback(this, this._handleResponseSetPerms, [revoke, callback]);
	if (batchCmd) {
		batchCmd.addNewRequestParams(soapDoc, respCallback);
	} else {
		appCtxt.getAppController().sendRequest({soapDoc:soapDoc, asyncMode:true, callback:respCallback});
	}
};

/**
 * @private
 */
ZmAccessControlList.prototype._handleResponseSetPerms =
function(revoke, callback, result) {
	var response = result.getResponse();
	var resp = revoke ? response.RevokeRightsResponse : response.GrantRightsResponse;
	var aces = resp && resp.ace;
	var aceList = [];
	if (aces && aces.length) {
		for (var i = 0; i < aces.length; i++) {
			var ace = ZmAccessControlEntry.createFromDom(aces[i]);
			aceList.push(ace);
			if (revoke) {
				this.remove(ace);
			} else {
				this.update(ace);
			}
		}
	}

	if (callback) {
		callback.run(aceList);
	}
};

/**
 * Adds the entry to the ACL.
 * 
 * @param	{ZmAccessControlEntry}	ace	the entry to add
 */
ZmAccessControlList.prototype.add =
function(ace) {
	if (!ace) { return; }
	var right = ace.right;
	if (!this._aces[right]) {
		this._aces[right] = [];
	}
	this._aces[right].push(ace);
};

/**
 * Removes the entry to the ACL.
 * 
 * @param	{ZmAccessControlEntry}	ace	the entry to remove
 */
ZmAccessControlList.prototype.remove =
function(ace) {
	if (!ace) { return; }
	var list = this._aces[ace.right];
	var newList = [];
	if (list && list.length) {
		for (var i = 0; i < list.length; i++) {
			if (list[i].grantee != ace.grantee) {
				newList.push(list[i]);
			}
		}
	}
	this._aces[ace.right] = newList;
};

/**
 * Updates the entry to the ACL.
 * 
 * @param	{ZmAccessControlEntry}	ace	the entry to update
 * @param	{Boolean}	removeEnty	not used
 */
ZmAccessControlList.prototype.update =
function(ace, removeEntry) {
	if (!ace || !ace.right) { return; }
	var found = false;
	
	if(!this._aces[ace.right]) {
		this._aces[ace.right] = [];
	}

	var list = this._aces[ace.right];	
	if (list.length) {
		//search for ace to update
		for (var i = 0; i < list.length; i++) {
			if ((list[i].grantee == ace.grantee) && (list[i].granteeType == ace.granteeType)) {
				this._aces[ace.right][i] = ace;
				found = true;
			}
		}
	}
	if(!found) {
		//adding new entry to ace list
		this._aces[ace.right].push(ace);
	}
};

/**
 * Cleans up the ACL.
 * 
 */
ZmAccessControlList.prototype.cleanup =
function() {
	this._aces = {};
};

/**
 * Sorts the ACL by grantee.
 * 
 * @param	{Hash}	a		grantee "a"
 * @param	{String}	a.grantee	the grantee
 * @param	{Hash}	b		grantee "b"
 * @param	{Hash}	b.grantee		grantee "b"
 * @return	{int}	0 if "a" and "b" are the same; 1 if "a" is before "b"; -1 if "b" is before "a"
 */
ZmAccessControlList.sortByGrantee =
function(a, b) {

    var granteeA = a.grantee || "";
    var granteeB = b.grantee || "";

    if (granteeA.toLowerCase() > granteeB.toLowerCase()) { return 1; }
    if (granteeA.toLowerCase() < granteeB.toLowerCase()) { return -1; }
    
	return 0;
};


/**
 * Creates an access control entry.
 * @class
 * An access control entry encapsulates the permission information pertaining to a user or users
 * regarding a certain right.
 * 
 * @param {Hash}	params		a hash of parameters
 * @param	{String}	params.right		the action governed by this ACE
 * @param	{String}	params.grantee		the account name of user or group permission applies to
 * @param	{String}	params.zid			the ZID of grantee
 * @param	{constant}	params.granteeType	type of grantee (see <code>ZmSetting.ACL_</code> constants)
 * @param	{Boolean}	params.negative		if <code>true</code>, permission is denied by this ACE
 * @see		ZmSetting
 */
ZmAccessControlEntry =
function(params) {
	this.grantee = params.grantee;
	this.zid = params.zid;
	this.granteeType = params.granteeType;
	this.right = params.right;
	this.negative = params.negative;
}

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmAccessControlEntry.prototype.toString =
function() {
	return "ZmAccessControlEntry";
};

/**
 * Creates an entry from the DOM object.
 * 
 * @param	{Hash}	obj		the DOM object
 * @param	{String}	obj.right		the action governed by this ACE
 * @param	{String}	obj.d		the account name of user or group permission applies to
 * @param	{String}	obj.zid			the ZID of grantee
 * @param	{constant}	obj.gt		the type of grantee (see <code>ZmSetting.ACL_</code> constants)
 * @param	{Boolean}	obj.deny		if <code>1</code>, permission is denied by this ACE
 * @return	{ZmAccessControlEntry}	the newly created entry
 */
ZmAccessControlEntry.createFromDom =
function(obj) {
	var params = {};
	params.grantee = obj.d;
	params.granteeType = obj.gt;
	params.zid = obj.zid;
	params.right = obj.right;
	params.negative = (obj.deny == "1");
	
	return new ZmAccessControlEntry(params);
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmAutocomplete")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 *
 * This file defines authentication.
 *
 */

/**
 * Creates and initializes support for server-based autocomplete.
 * @class
 * This class manages auto-completion via <code>&lt;AutoCompleteRequest&gt;</code> calls to the server. Currently limited
 * to matching against only one type among people, locations, and equipment.
 *
 * @author Conrad Damon
 */
ZmAutocomplete = function(params) {

	if (arguments.length == 0) {
		return;
	}

	if (appCtxt.get(ZmSetting.CONTACTS_ENABLED)) {
		var listener = this._settingChangeListener.bind(this);
		var settings = [ZmSetting.GAL_AUTOCOMPLETE, ZmSetting.AUTOCOMPLETE_SHARE, ZmSetting.AUTOCOMPLETE_SHARED_ADDR_BOOKS];
		for (var i = 0; i < settings.length; i++) {
			appCtxt.getSettings().getSetting(settings[i]).addChangeListener(listener);
		}
	}
};

// choices for text in the returned match object
ZmAutocomplete.AC_VALUE_FULL = "fullAddress";
ZmAutocomplete.AC_VALUE_EMAIL = "email";
ZmAutocomplete.AC_VALUE_NAME = "name";

// request control
ZmAutocomplete.AC_TIMEOUT = 20;	// autocomplete timeout (in seconds)

// result types
ZmAutocomplete.AC_TYPE_CONTACT = "contact";
ZmAutocomplete.AC_TYPE_GAL = "gal";
ZmAutocomplete.AC_TYPE_TABLE = "rankingTable";

ZmAutocomplete.AC_TYPE_UNKNOWN = "unknown";
ZmAutocomplete.AC_TYPE_LOCATION = "Location";	// same as ZmResource.ATTR_LOCATION
ZmAutocomplete.AC_TYPE_EQUIPMENT = "Equipment";	// same as ZmResource.ATTR_EQUIPMENT

// icons
ZmAutocomplete.AC_ICON = {};
ZmAutocomplete.AC_ICON[ZmAutocomplete.AC_TYPE_CONTACT] = "Contact";
ZmAutocomplete.AC_ICON[ZmAutocomplete.AC_TYPE_GAL] = "GALContact";
ZmAutocomplete.AC_ICON[ZmAutocomplete.AC_TYPE_LOCATION] = "Location";
ZmAutocomplete.AC_ICON[ZmAutocomplete.AC_TYPE_EQUIPMENT] = "Resource";

// cache control
ZmAutocomplete.GAL_RESULTS_TTL = 900000;	// time-to-live for cached GAL autocomplete results (msec)

/**
 * Returns a string representation of the object.
 *
 * @return		{String}		a string representation of the object
 */
ZmAutocomplete.prototype.toString =
		function() {
			return "ZmAutocomplete";
		};

/**
 * Returns a list of matching contacts for a given string. The first name, last
 * name, full name, first/last name, and email addresses are matched against.
 *
 * @param {String}					str				the string to match against
 * @param {closure}					callback		the callback to run with results
 * @param {ZmAutocompleteListView}	aclv			the needed to show wait msg
 * @param {ZmZimbraAccount}			account			the account to fetch cached items from
 * @param {Hash}					options			additional options:
 * @param {constant}				 type			 type of result to match; default is {@link ZmAutocomplete.AC_TYPE_CONTACT}; other valid values are for location or equipment
 * @param {Boolean}					needItem		 if <code>true</code>, return a {@link ZmItem} as part of match result
 * @param {Boolean}					supportForget	allow user to reset ranking for a contact (defaults to true)
 */
ZmAutocomplete.prototype.autocompleteMatch =
		function(str, callback, aclv, options, account, autocompleteType) {

			str = str.toLowerCase().replace(/"/g, '');
			this._curAcStr = str;
			DBG.println("ac", "begin autocomplete for " + str);

			var acType = (options && (options.acType || options.type)) || ZmAutocomplete.AC_TYPE_CONTACT;

			var list = this._checkCache(str, acType, account);
			if (!str || (list !== null)) {
				callback(list);
			}
			else {
				aclv.setWaiting(true, str);
				return this._doSearch(str, aclv, options, acType, callback, account, autocompleteType);
			}
		};

ZmAutocomplete.prototype._doSearch =
		function(str, aclv, options, acType, callback, account, autocompleteType) {

			var params = {query:str, isAutocompleteSearch:true};
			if (acType != ZmAutocomplete.AC_TYPE_CONTACT) {
				params.isGalAutocompleteSearch = true;
				params.isAutocompleteSearch = false;
				params.limit = params.limit * 2;
				var searchType = ((acType === ZmAutocomplete.AC_TYPE_LOCATION) || (acType === ZmAutocomplete.AC_TYPE_EQUIPMENT)) ?  ZmItem.RESOURCE : ZmItem.CONTACT;
				params.types = AjxVector.fromArray([searchType]);
				params.galType = params.galType || ZmSearch.GAL_RESOURCE;
				DBG.println("ac", "AutoCompleteGalRequest: " + str);
			} else {
				DBG.println("ac", "AutoCompleteRequest: " + str);
			}
			params.accountName = account && account.name;

			var search = new ZmSearch(params);
			var searchParams = {
				callback:		this._handleResponseDoAutocomplete.bind(this, str, aclv, options, acType, callback, account),
				errorCallback:	this._handleErrorDoAutocomplete.bind(this, str, aclv),
				timeout:		ZmAutocomplete.AC_TIMEOUT,
				noBusyOverlay:	true
			};
			if (autocompleteType) {
				searchParams.autocompleteType = autocompleteType;
			}
            searchParams.offlineCallback = this._handleOfflineDoAutocomplete.bind(this, str, search, searchParams.callback);
			return search.execute(searchParams);
		};

/**
 * @private
 */
ZmAutocomplete.prototype._handleResponseDoAutocomplete =
		function(str, aclv, options, acType, callback, account, result) {

			DBG.println("ac", "got response for " + str);
			aclv.setWaiting(false);

			var resultList, gotContacts = false, hasGal = false;
			var resp = result.getResponse();
			if (resp && resp.search && resp.search.isGalAutocompleteSearch) {
				var cl = resp.getResults(resp.type);
				resultList = (cl && cl.getArray()) || [];
				gotContacts = hasGal = true;
			} else {
				resultList = resp._respEl.match || [];
			}

			DBG.println("ac", resultList.length + " matches");

			var list = [];
			for (var i = 0; i < resultList.length; i++) {
				var match = new ZmAutocompleteMatch(resultList[i], options, gotContacts, str);
				if (match.acType == acType) {
					if (options.excludeGroups && match.isGroup) continue;
					if (match.type == ZmAutocomplete.AC_TYPE_GAL) {
						hasGal = true;
					}
					list.push(match);
				}
			}
			var complete = !(resp && resp.getAttribute("more"));

			// we assume the results from the server are sorted by ranking
			callback(list);
			this._cacheResults(str, acType, list, hasGal, complete && resp._respEl.canBeCached, null, account);
		};

/**
 * Handle timeout.
 *
 * @private
 */
ZmAutocomplete.prototype._handleErrorDoAutocomplete =
		function(str, aclv, ex) {
			DBG.println("ac", "error on request for " + str + ": " + ex.toString());
			aclv.setWaiting(false);
			appCtxt.setStatusMsg({msg:ZmMsg.autocompleteFailed, level:ZmStatusView.LEVEL_WARNING});

			return true;
		};

/**
 * @private
 */
ZmAutocomplete.prototype._handleOfflineDoAutocomplete =
function(str, search, callback) {
    if (str) {
        var autoCompleteCallback = this._handleOfflineResponseDoAutocomplete.bind(this, search, callback);
        ZmOfflineDB.searchContactsForAutoComplete(str, autoCompleteCallback);
    }
};

ZmAutocomplete.prototype._handleOfflineResponseDoAutocomplete =
function(search, callback, result) {
    var match = [];
    result.forEach(function(contact) {
        var attrs = contact._attrs;
		if (attrs) {
			var obj = {
				id : contact.id,
				l : contact.l
			};
			if (attrs.fullName) {
				var fullName = attrs.fullName;
			}
			else {
				var fullName = [];
				if (attrs.firstName) {
					fullName.push(attrs.firstName);
				}
				if (attrs.middleName) {
					fullName.push(attrs.middleName);
				}
				if (attrs.lastName) {
					fullName.push(attrs.lastName);
				}
				fullName = fullName.join(" ");
			}
			if (attrs.email) {
				obj.email = '"' + fullName + '" <' + attrs.email + '>';
			}
			else if (attrs.type === "group") {
				obj.display = fullName;
				obj.type = ZmAutocomplete.AC_TYPE_CONTACT;
				obj.exp = true;
				obj.isGroup = true;
			}
			match.push(obj);
		}
    });
    if (callback) {
        var zmSearchResult = new ZmSearchResult(search);
        var response = {
            match : match
        };
        zmSearchResult.set(response);
        var zmCsfeResult = new ZmCsfeResult(zmSearchResult);
        callback(zmCsfeResult);
    }
};

/**
 * Sort auto-complete list by ranking scores.
 *
 * @param	{ZmAutocomplete}	a		the auto-complete list
 * @param	{ZmAutocomplete}	b		the auto-complete list
 * @return	{int}	0 if the lists match; 1 if "a" is before "b"; -1 if "b" is before "a"
 */
ZmAutocomplete.acSortCompare =
		function(a, b) {
			var aScore = (a && a.score) || 0;
			var bScore = (b && b.score) || 0;
			return (aScore > bScore) ? 1 : (aScore < bScore) ? -1 : 0;
		};

/**
 * Checks if the given string is a valid email.
 *
 * @param {String}	str		a string
 * @return	{Boolean}	<code>true</code> if a valid email
 */
ZmAutocomplete.prototype.isComplete =
		function(str) {
			return AjxEmailAddress.isValid(str);
		};

/**
 * Asks the server to drop an address from the ranking table.
 *
 * @param {string}	addr		email address
 * @param {closure}	callback	callback to run after response
 */
ZmAutocomplete.prototype.forget =
		function(addr, callback) {

			var jsonObj = {RankingActionRequest:{_jsns:"urn:zimbraMail"}};
			jsonObj.RankingActionRequest.action = {op:"delete", email:addr};
			var respCallback = this._handleResponseForget.bind(this, callback);
			var aCtxt = appCtxt.isChildWindow ? parentAppCtxt : appCtxt;
			aCtxt.getRequestMgr().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
		};

ZmAutocomplete.prototype._handleResponseForget =
		function(callback) {
			appCtxt.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);
			if (appCtxt.isChildWindow) {
				parentAppCtxt.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);
			}
			if (callback) {
				callback();
			}
		};

/**
 * Expands a contact which is a DL and returns a list of its members.
 *
 * @param {ZmContact}	contact		DL contact
 * @param {int}			offset		member to start with (in case we're paging a large DL)
 * @param {closure}		callback	callback to run with results
 */
ZmAutocomplete.prototype.expandDL =
		function(contact, offset, callback) {

			var respCallback = this._handleResponseExpandDL.bind(this, contact, callback);
			contact.getDLMembers(offset, null, respCallback);
		};

ZmAutocomplete.prototype._handleResponseExpandDL =
		function(contact, callback, result) {

			var list = result.list;
			var matches = [];
			if (list && list.length) {
				for (var i = 0, len = list.length; i < len; i++) {
					var addr = list[i];
					var match = {};
					match.type = ZmAutocomplete.AC_TYPE_GAL;
					match.email = addr;
					match.isGroup = result.isDL[addr];
					matches.push(new ZmAutocompleteMatch(match, null, false, contact && contact.str));
				}
			}
			if (callback) {
				callback(matches);
			}
		};

/**
 * @param acType		[constant]			type of result to match
 * @param str			[string]			string to match against
 * @param account		[ZmZimbraAccount]*	account to check cache against
 * @param create		[boolean]			if <code>true</code>, create a cache if none found
 *
 * @private
 */
ZmAutocomplete.prototype._getCache =
		function(acType, str, account, create) {
			var context = AjxEnv.isIE ? window.appCtxt : window.parentAppCtxt || window.appCtxt;
			return context.getAutocompleteCache(acType, str, account, create);
		};

/**
 * @param str			[string]			string to match against
 * @param acType		[constant]			type of result to match
 * @param list			[array]				list of matches
 * @param hasGal		[boolean]*			if true, list includes GAL results
 * @param cacheable		[boolean]*			server indication of cacheability
 * @param baseCache		[hash]*				cache that is superset of this one
 * @param account		[ZmZimbraAccount]*	account to check cache against
 *
 * @private
 */
ZmAutocomplete.prototype._cacheResults =
		function(str, acType, list, hasGal, cacheable, baseCache, account) {

			var cache = this._getCache(acType, str, account, true);
			cache.list = list;
			// we always cache; flag below indicates whether we can do forward matching
			cache.cacheable = (baseCache && baseCache.cacheable) || cacheable;
			if (hasGal) {
				cache.ts = (baseCache && baseCache.ts) || (new Date()).getTime();
			}
		};

/**
 * @private
 *
 * TODO: substring result matching for multiple tokens, eg "tim d"
 */
ZmAutocomplete.prototype._checkCache =
		function(str, acType, account) {

			// check cache for results for this exact string
			var cache = this._getCachedResults(str, acType, null, account);
			var list = cache && cache.list;
			if (list !== null) {
				return list;
			}
			if (str.length <= 1) {
				return null;
			}

			// bug 58913: don't do client-side substring matching since the server matches on
			// fields that are not returned in the results
			return null;

			// forward matching: if we have complete results for a beginning part of this
			// string, we can cull those down to results for this string
			var tmp = str;
			while (tmp && !list) {
				tmp = tmp.slice(0, -1); // remove last character
				DBG.println("ac", "checking cache for " + tmp);
				cache = this._getCachedResults(tmp, acType, true, account);
				list = cache && cache.list;
				if (list && list.length == 0) {
					// substring had no matches, so this string has none
					DBG.println("ac", "Found empty results for substring " + tmp);
					return list;
				}
			}

			var list1 = [];
			if (list && list.length) {
				// found a substring that we've already done matching for, so we just need
				// to narrow those results
				DBG.println("ac", "working forward from '" + tmp + "'");
				// test each of the substring's matches to see if it also matches this string
				for (var i = 0; i < list.length; i++) {
					var match = list[i];
					if (match.matches(str)) {
						list1.push(match);
					}
				}
			} else {
				return null;
			}

			this._cacheResults(str, acType, list1, false, false, cache, account);

			return list1;
		};

/**
 * See if we have cached results for the given string. If the cached results have a
 * timestamp, we make sure they haven't expired.
 *
 * @param str				[string]			string to match against
 * @param acType			[constant]			type of result to match
 * @param checkCacheable	[boolean]			if true, make sure results are cacheable
 * @param account			[ZmZimbraAccount]*	account to fetch cached results from
 *
 * @private
 */
ZmAutocomplete.prototype._getCachedResults =
		function(str, acType, checkCacheable, account) {

			var cache = this._getCache(acType, str, account);
			if (cache) {
				if (checkCacheable && (cache.cacheable === false)) {
					return null;
				}
				if (cache.ts) {
					var now = (new Date()).getTime();
					if (now > (cache.ts + ZmAutocomplete.GAL_RESULTS_TTL)) {
						return null;	// expired GAL results
					}
				}
				DBG.println("ac", "cache hit for " + str);
				return cache;
			} else {
				return null;
			}
		};

/**
 * Clears contact autocomplete cache on change to any related setting.
 *
 * @private
 */
ZmAutocomplete.prototype._settingChangeListener =
		function(ev) {
			if (ev.type != ZmEvent.S_SETTING) {
				return;
			}
			var context = AjxEnv.isIE ? window.appCtxt : window.parentAppCtxt || window.appCtxt;
			context.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);
		};


/**
 * Creates an auto-complete match.
 * @class
 * This class represents an auto-complete result, with fields for the caller to look at, and fields to
 * help with further matching.
 *
 * @param {Object}	match		the JSON match object or a {@link ZmContact} object
 * @param {Object}	options		the matching options
 * @param {Boolean}	isContact	if <code>true</code>, provided match is a {@link ZmContact}
 */
ZmAutocompleteMatch = function(match, options, isContact, str) {
	// TODO: figure out how to minimize loading of calendar code
	AjxDispatcher.require(["MailCore", "CalendarCore"]);
	if (!match) {
		return;
	}
	this.type = match.type;
	this.str = str;
	var ac = window.parentAppCtxt || window.appCtxt;
	if (isContact) {
		this.text = this.name = match.getFullName();
		this.email = match.getEmail();
		this.item = match;
		this.type = ZmContact.getAttr(match, ZmResource && ZmResource.F_type || "zimbraCalResType") || ZmAutocomplete.AC_TYPE_GAL;
		this.fullAddress = (new AjxEmailAddress(this.email, null, this.text)).toString(); //bug:60789 formated the email and name to get fullAddress
	} else {
		this.isGroup = Boolean(match.isGroup);
		this.isDL = (this.isGroup && this.type == ZmAutocomplete.AC_TYPE_GAL);
		if (this.isGroup && !this.isDL) {
			// Local contact group; emails need to be looked up by group member ids. 
			var contactGroup = ac.cacheGet(match.id);
			if (contactGroup && contactGroup.isLoaded) {
				this.setContactGroupMembers(match.id);
			}
			else {
				//not a contact group that is in cache.  we'll need to deref it
				this.needDerefGroup = true;
				this.groupId = match.id;
			}
			this.name = match.display;
			this.text = AjxStringUtil.htmlEncode(match.display) || this.email;
			this.icon = "Group";
		} else {
			// Local contact, GAL contact, or distribution list
			var email = AjxEmailAddress.parse(match.email);
			if (email) {
				this.email = email.getAddress();
				if (this.type == ZmAutocomplete.AC_TYPE_CONTACT) {
					var contactList = AjxDispatcher.run("GetContacts");
					var contact = contactList && contactList.getById(match.id);
					if (contact) {
						var displayName = contact && contact.getFullNameForDisplay(false);
						this.fullAddress = "\"" + displayName + "\" <" + email.getAddress() + ">";
						this.name = displayName;
						this.text = AjxStringUtil.htmlEncode(this.fullAddress);
					}
					else {
						//we assume if we don't get contact object, its a shared contact.
						this.fullAddress = email.toString();
						this.name = email.getName();
						this.email = email.getAddress();
						this.text = AjxStringUtil.htmlEncode(this.fullAddress);
					}
				} else {
					this.fullAddress = email.toString();
					this.name = email.getName();
					this.text = AjxStringUtil.htmlEncode(match.email);
				}
			} else {
				this.email = match.email;
				this.text = AjxStringUtil.htmlEncode(match.email);
			}
			if (options && options.needItem && window.ZmContact) {
				this.item = new ZmContact(null);
				this.item.initFromEmail(email || match.email);
			}
			this.icon = this.isDL ? "Group" : ZmAutocomplete.AC_ICON[match.type];
			this.canExpand = this.isDL && match.exp;
			ac.setIsExpandableDL(this.email, this.canExpand);
		}
	}
	this.score = (match.ranking && parseInt(match.ranking)) || 0;
	this.icon = this.icon || ZmAutocomplete.AC_ICON[ZmAutocomplete.AC_TYPE_CONTACT];
	this.acType = (this.type == ZmAutocomplete.AC_TYPE_LOCATION || this.type == ZmAutocomplete.AC_TYPE_EQUIPMENT)
			? this.type : ZmAutocomplete.AC_TYPE_CONTACT;
	if (this.type == ZmAutocomplete.AC_TYPE_LOCATION || this.type == ZmAutocomplete.AC_TYPE_EQUIPMENT) {
		this.icon = ZmAutocomplete.AC_ICON[this.type];
	}
};

/**
 * Sets the email & fullAddress properties of a contact group
 * @param groupId {String} contact group id to lookup from cache
 * @param callback {AjxCallback} callback to be run
 */
ZmAutocompleteMatch.prototype.setContactGroupMembers =
		function(groupId, callback) {
			var ac = window.parentAppCtxt || window.appCtxt;
			var contactGroup = ac.cacheGet(groupId);
			if (contactGroup) {
				var groups = contactGroup.getGroupMembers();
				var addresses = (groups && groups.good && groups.good.getArray()) || [];
				var emails = [], addrs = [];
				for (var i = 0; i < addresses.length; i++) {
					var addr = addresses[i];
					emails.push(addr.getAddress());
					addrs.push(addr.toString());
				}
				this.email = emails.join(AjxEmailAddress.SEPARATOR);
				this.fullAddress = addrs.join(AjxEmailAddress.SEPARATOR);
			}
			if (callback) {
				callback.run();
			}
		};

/**
 * Returns a string representation of the object.
 *
 * @return		{String}		a string representation of the object
 */
ZmAutocompleteMatch.prototype.toString =
		function() {
			return "ZmAutocompleteMatch";
		};

/**
 * Matches the given string to this auto-complete result.
 *
 * @param {String}	str		the string
 * @return	{Boolean}	<code>true</code> if the given string matches this result
 */
ZmAutocompleteMatch.prototype.matches =
		function(str) {
			if (this.name && !this._nameParsed) {
				var parts = this.name.split(/\s+/, 3);
				var firstName = parts[0];
				this._lastName = parts[parts.length - 1];
				this._firstLast = [firstName, this._lastName].join(" ");
				this._nameParsed = true;
			}

			var fields = [this.email, this.name, this._lastName, this._firstLast];
			for (var i = 0; i < fields.length; i++) {
				var f = fields[i] && fields[i].toLowerCase();
				if (f && (f.indexOf(str) == 0)) {
					return true;
				}
			}
			return false;
		};

/**
 * Creates a search auto-complete.
 * @class
 * This class supports auto-complete for our query language. Each search operator that is supported has an associated handler.
 * A handler is a hash which contains the info needed for auto-complete. A handler can have the following properties:
 *
 * <ul>
 * <li><b>listType</b> - A handler needs a list of objects to autocomplete against. By default, that list is
 *						 identified by the operator. If more than one operator uses the same list, their handlers
 *						 should use this property to identify the list.</li>
 * <li><b>loader</b> - Function that populates the list of objects. Lists used by more than one operator provide
 *						 their loader separately.</li>
 * <li><b>text</b> - Function that returns a string value of data, to autocomplete against and to display in the
 *						 autocomplete list.</li>
 * <li><b>icon</b> - Function that returns an icon to display in the autocomplete list.</li>
 * <li><b>matchText</b> - Function that returns a string to place in the input when the item is selected. Defaults to
 *						 the 'op:' plus the value of the 'text' attribute.</li>
 * <li><b>quoteMatch</b> - If <code>true</code>, the text that goes into matchText will be place in double quotes.</li>
 * </ul>
 *
 */
ZmSearchAutocomplete = function() {

	this._op = {};
	this._list = {};
	this._loadFunc = {};

	var params = {
		loader:		this._loadTags,
		text:		function(o) {
			return o.getName(false, null, true, true);
		},
		icon:		function(o) {
			return o.getIconWithColor();
		},
		matchText:	function(o) {
			return o.createQuery();
		}
	};
	this._registerHandler("tag", params);

	params = {
		listType:	ZmId.ORG_FOLDER,
		text:		function(o) {
			return o.getPath(false, false, null, true, false);
		},
		icon:		function(o) {
			return o.getIconWithColor();
		},
		matchText:	function(o) {
			return o.createQuery();
		}
	};
	this._loadFunc[ZmId.ORG_FOLDER] = this._loadFolders;
	this._registerHandler("in", params);
	params.matchText = function(o) {
		return "under:" + '"' + o.getPath() + '"';
	};
	this._registerHandler("under", params);

	params = { loader:		this._loadFlags };
	this._registerHandler("is", params);

	params = {
		loader:		this._loadObjects,
		icon:		function(o) {
			return ZmSearchAutocomplete.ICON[o];
		}
	};
	this._registerHandler("has", params);

	this._loadFunc[ZmId.ITEM_ATT] = this._loadTypes;
	params = {listType:		ZmId.ITEM_ATT,
		text:			function(o) {
			return o.desc;
		},
		icon:			function(o) {
			return o.image;
		},
		matchText:	function(o) {
			return "type:" + (o.query || o.type);
		},
		quoteMatch:	true
	};
	this._registerHandler("type", params);
	params = {listType:		ZmId.ITEM_ATT,
		text:			function(o) {
			return o.desc;
		},
		icon:			function(o) {
			return o.image;
		},
		matchText:	function(o) {
			return "attachment:" + (o.query || o.type);
		},
		quoteMatch:	true
	};
	this._registerHandler("attachment", params);

	params = {
		loader:		this._loadCommands
	};
	this._registerHandler("set", params);

	var folderTree = appCtxt.getFolderTree();
	if (folderTree) {
		folderTree.addChangeListener(this._folderTreeChangeListener.bind(this));
	}
	var tagTree = appCtxt.getTagTree();
	if (tagTree) {
		tagTree.addChangeListener(this._tagTreeChangeListener.bind(this));
	}
};

ZmSearchAutocomplete.prototype.isZmSearchAutocomplete = true;
ZmSearchAutocomplete.prototype.toString = function() {
	return "ZmSearchAutocomplete";
};

ZmSearchAutocomplete.ICON = {};
ZmSearchAutocomplete.ICON["attachment"] = "Attachment";
ZmSearchAutocomplete.ICON["phone"] = "Telephone";
ZmSearchAutocomplete.ICON["url"] = "URL";

/**
 * @private
 */
ZmSearchAutocomplete.prototype._registerHandler = function(op, params) {

	var loadFunc = params.loader || this._loadFunc[params.listType];
	this._op[op] = {
		loader:     loadFunc.bind(this),
		text:       params.text, icon:params.icon,
		listType:   params.listType || op, matchText:params.matchText || params.text,
		quoteMatch: params.quoteMatch
	};
};

/**
 * Returns a list of matches for a given query operator.
 *
 * @param {String}					str			the string to match against
 * @param {closure}					callback	the callback to run with results
 * @param {ZmAutocompleteListView}	aclv		needed to show wait msg
 * @param {Hash}					options		a hash of additional options
 */
ZmSearchAutocomplete.prototype.autocompleteMatch = function(str, callback, aclv, options) {

	if (ZmSearchAutocomplete._ignoreNextKey) {
		ZmSearchAutocomplete._ignoreNextKey = false;
		return;
	}

	str = str.toLowerCase().replace(/"/g, '');

	var idx = str.lastIndexOf(" ");
	if (idx != -1 && idx <= str.length) {
		str = str.substr(idx + 1);
	}
	var m = str.match(/\b-?\$?([a-z]+):/);
	if (!(m && m.length)) {
		callback();
		return;
	}

	var op = m[1];
	var opHash = this._op[op];
	if (!opHash) {
		callback();
		return;
	}
	var list = this._list[opHash.listType];
	if (list) {
		callback(this._getMatches(op, str));
	} else {
		var respCallback = this._handleResponseLoad.bind(this, op, str, callback);
		this._list[opHash.listType] = [];
		opHash.loader(opHash.listType, respCallback);
	}
};

// TODO - some validation of search ops and args
ZmSearchAutocomplete.prototype.isComplete = function(str, returnStr) {

	var pq = new ZmParsedQuery(str);
	var tokens = pq.getTokens();
	if (!pq.parseFailed && tokens && (tokens.length == 1)) {
		return returnStr ? tokens[0].toString() : true;
	}
	else {
		return false;
	}
};

ZmSearchAutocomplete.prototype.getAddedBubbleClass = function(str) {

	var pq = new ZmParsedQuery(str);
	var tokens = pq.getTokens();
	return (!pq.parseFailed && tokens && (tokens.length == 1) && tokens[0].type);
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._getMatches = function(op, str) {

	var opHash = this._op[op];
	var results = [], app;
	var list = this._list[opHash.listType];
	var rest = str.substr(str.indexOf(":") + 1);
	if (opHash.listType == ZmId.ORG_FOLDER) {
		rest = rest.replace(/^\//, "");	// remove leading slash in folder path
		app = appCtxt.getCurrentAppName();
		if (!ZmApp.ORGANIZER[app]) {
			app = null;
		}
	}
	for (var i = 0, len = list.length; i < len; i++) {
		var o = list[i];
		var text = opHash.text ? opHash.text(o) : o;
		var test = text.toLowerCase();
		if (app && ZmOrganizer.APP[o.type] != app) {
			continue;
		}
		if (!rest || (test.indexOf(rest) == 0)) {
			var matchText = opHash.matchText ? opHash.matchText(o) :
					opHash.quoteMatch ? [op, ":", '"', text, '"'].join("") :
							[op, ":", text].join("");
			matchText = str.replace(op + ":" + rest, matchText);
			results.push({text:			text,
				icon:			opHash.icon ? opHash.icon(o) : null,
				matchText:	matchText,
				exactMatch:	(test.length == rest.length)});
		}
	}

	// no need to show list of one item that is same as what was typed
	if (results.length == 1 && results[0].exactMatch) {
		results = [];
	}

	return results;
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._handleResponseLoad = function(op, str, callback) {
	callback(this._getMatches(op, str));
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._loadTags = function(listType, callback) {

	var list = this._list[listType];
	var tags = appCtxt.getTagTree().asList();
	for (var i = 0, len = tags.length; i < len; i++) {
		var tag = tags[i];
		if (tag.id != ZmOrganizer.ID_ROOT) {
			list.push(tag);
		}
	}
	list.sort(ZmTag.sortCompare);
	if (callback) {
		callback();
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._loadFolders = function(listType, callback) {

	var list = this._list[listType];
	var folderTree = appCtxt.getFolderTree();
	var folders = folderTree ? folderTree.asList({includeRemote:true}) : [];
	for (var i = 0, len = folders.length; i < len; i++) {
		var folder = folders[i];
		if (folder.id !== ZmOrganizer.ID_ROOT && !ZmFolder.HIDE_ID[folder.id] && folder.id !== ZmFolder.ID_DLS) {
			list.push(folder);
		}
	}
	list.sort(ZmFolder.sortComparePath);
	if (callback) {
		callback();
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._loadFlags = function(listType, callback) {

	var flags = AjxUtil.filter(ZmParsedQuery.IS_VALUES, function(flag) {
		return appCtxt.checkPrecondition(ZmParsedQuery.IS_VALUE_PRECONDITION[flag]);
	});
	this._list[listType] = flags.sort();
	if (callback) {
		callback();
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._loadObjects = function(listType, callback) {

	var list = this._list[listType];
	list.push("attachment");
	var idxZimlets = appCtxt.getZimletMgr().getIndexedZimlets();
	if (idxZimlets.length) {
		for (var i = 0; i < idxZimlets.length; i++) {
			list.push(idxZimlets[i].keyword);
		}
	}
	list.sort();
	if (callback) {
		callback();
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._loadTypes = function(listType, callback) {

	AjxDispatcher.require("Extras");
	var attachTypeList = new ZmAttachmentTypeList();
	var respCallback = this._handleResponseLoadTypes.bind(this, attachTypeList, listType, callback);
	attachTypeList.load(respCallback);
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._handleResponseLoadTypes = function(attachTypeList, listType, callback) {

	this._list[listType] = attachTypeList.getAttachments();
	if (callback) {
		callback();
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._loadCommands = function(listType, callback) {

	var list = this._list[listType];
	for (var funcName in ZmClientCmdHandler.prototype) {
		if (funcName.indexOf("execute_") == 0) {
			list.push(funcName.substr(8));
		}
	}
	list.sort();
	if (callback) {
		callback();
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._folderTreeChangeListener = function(ev) {

	var fields = ev.getDetail("fields");
	if (ev.event == ZmEvent.E_DELETE || ev.event == ZmEvent.E_CREATE || ev.event == ZmEvent.E_MOVE ||
			((ev.event == ZmEvent.E_MODIFY) && fields && fields[ZmOrganizer.F_NAME])) {

		var listType = ZmId.ORG_FOLDER;
		if (this._list[listType]) {
			this._list[listType] = [];
			this._loadFolders(listType);
		}
	}
};

/**
 * @private
 */
ZmSearchAutocomplete.prototype._tagTreeChangeListener = function(ev) {

	var fields = ev.getDetail("fields");
	if (ev.event == ZmEvent.E_DELETE || ev.event == ZmEvent.E_CREATE || ev.event == ZmEvent.E_MOVE ||
			((ev.event == ZmEvent.E_MODIFY) && fields && fields[ZmOrganizer.F_NAME])) {

		var listType = "tag";
		if (this._list[listType]) {
			this._list[listType] = [];
			this._loadTags(listType);
		}
	}
};

/**
 * Creates a people search auto-complete.
 * @class
 * This class supports auto-complete for searching the GAL and the user's
 * personal contacts.
 */
ZmPeopleSearchAutocomplete = function() {
	// no need to call ctor
	//	this._acRequests = {};
};

ZmPeopleSearchAutocomplete.prototype = new ZmAutocomplete;
ZmPeopleSearchAutocomplete.prototype.constructor = ZmPeopleSearchAutocomplete;

ZmPeopleSearchAutocomplete.prototype.toString = function() { return "ZmPeopleSearchAutocomplete"; };

ZmPeopleSearchAutocomplete.prototype._doSearch = function(str, aclv, options, acType, callback, account) {

	var params = {
		query: str,
		types: AjxVector.fromArray([ZmItem.CONTACT]),
		sortBy: ZmSearch.NAME_ASC,
		contactSource: ZmId.SEARCH_GAL,
		accountName: account && account.name
	};

	var search = new ZmSearch(params);

	var searchParams = {
		callback:		this._handleResponseDoAutocomplete.bind(this, str, aclv, options, acType, callback, account),
		errorCallback:	this._handleErrorDoAutocomplete.bind(this, str, aclv),
		timeout:		ZmAutocomplete.AC_TIMEOUT,
		noBusyOverlay:	true
	};
	return search.execute(searchParams);
};

/**
 * @private
 */
ZmPeopleSearchAutocomplete.prototype._handleResponseDoAutocomplete = function(str, aclv, options, acType, callback, account, result) {

	// if we get back results for other than the current string, ignore them
	if (str != this._curAcStr) {
		return;
	}

	var resp = result.getResponse();
	var cl = resp.getResults(ZmItem.CONTACT);
	var resultList = (cl && cl.getArray()) || [];
	var list = [];

	for (var i = 0; i < resultList.length; i++) {
		var match = new ZmAutocompleteMatch(resultList[i], options, true);
		list.push(match);
	}
	var complete = !(resp && resp.getAttribute("more"));

	// we assume the results from the server are sorted by ranking
	callback(list);
	this._cacheResults(str, acType, list, true, complete && resp._respEl.canBeCached, null, account);
};
}
if (AjxPackage.define("zimbraMail.core.ZmAppCtxt")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the application context class.
 *
 */

/**
 * Creates an application context.
 * @class
 * This class is a container for application context information.
 * 
 */
ZmAppCtxt = function() {

	this._trees = {};

	this.accountList = new ZmAccountList();
	// create dummy account for startup
	this.accountList.add(new ZmZimbraAccount(ZmAccountList.DEFAULT_ID, null, false));

	// public properties
	this.inStartup = false;				// true if we are starting app (set in ZmZimbraMail)
	this.currentRequestParams = null;	// params of current SOAP request (set in ZmRequestMgr)
	this.rememberMe = null;
	this.userDomain = "";

	// account-specific
	this.isFamilyMbox = false;
	this.multiAccounts = false;
    this.sendAsEmails = [];
    this.sendOboEmails = [];

	this._evtMgr = new AjxEventMgr();

	this._itemCache			= {};
	this._itemCacheDeferred	= {};
	this._acCache			= {};	// autocomplete
	this._isExpandableDL	= {};	// distribution lists

	this._checkAuthTokenWarning();
};

ZmAppCtxt.ONE_MINUTE  = 60 * 1000;
ZmAppCtxt.MAX_TIMEOUT_VALUE = 2147483647;

ZmAppCtxt._ZIMLETS_EVENT = 'ZIMLETS';
ZmAppCtxt._AUTHTOKEN_EVENT = 'AUTHTOKEN';

//Regex constants
//Bug fix # 79986, #81095. Invalid file names are < > , ? | / \ * :
ZmAppCtxt.INVALID_NAME_CHARS = "[\\|?<>:*\"\\\\\/]";
ZmAppCtxt.INVALID_NAME_CHARS_RE = new RegExp(ZmAppCtxt.INVALID_NAME_CHARS);

/**
 * Returns a string representation of the application context.
 * 
 * @return		{String}		a string representation of the application context
 */
ZmAppCtxt.prototype.toString =
function() {
	return "ZmAppCtxt";
};

ZmAppCtxt.prototype._checkAuthTokenWarning =
function() {
	this._authIntervalId = window.setInterval(this._authTokenWarningTimeout.bind(this), ZmAppCtxt.ONE_MINUTE);
};
ZmAppCtxt.prototype._setAuthTokenWarning =
function(delay) {
    window.setTimeout(this._authTokenWarningTimeout.bind(this), delay);
};

/**
 * Adds a listener to the auth token warning event. This listener is fired once
 * per minute when less than five minutes remain before token expiry.
 *
 * @param	{AjxCallback}	listener		the listener
 * @param	{int}		index		the index to where to add the listener
 * @return	{Boolean}	<code>true</code> if the listener is added; <code>false</code> otherwise
 */
ZmAppCtxt.prototype.addAuthTokenWarningListener =
function(listener, index) {
	return this._evtMgr.addListener(ZmAppCtxt._AUTHTOKEN_EVENT, listener, index);
};

/**
 * Removes a listener for the auth token warning event.
 *
 * @param	{AjxCallback}	listener		the listener
 * @return	{Boolean}	<code>true</code> if the listener is removed; <code>false</code> otherwise
 */
ZmAppCtxt.prototype.removeAuthTokenWarningListener =
function(listener) {
	return this._evtMgr.removeListener(ZmAppCtxt._AUTHTOKEN_EVENT, listener);
};

ZmAppCtxt.prototype._authTokenWarningTimeout =
function () {

	if (!window.authTokenExpires) {
		return; //for cases we the auth token expires is not available. (e.g. some new windows we didn't set it for yet, or for saved rest URLs
	}

	var now = new Date().getTime();
	var millisToLive = window.authTokenExpires - now;
    var minutesToLive = Math.round(millisToLive / ZmAppCtxt.ONE_MINUTE);
    var delay;

	if (minutesToLive > 5 || millisToLive <= 0) {
        // Outside the times to issue warnings
        if (minutesToLive === 6) {
            // Line up the timer to go off at exactly 5 minutes (or as exact as we can make it), which is
            // when we start issuing warnings
            window.clearInterval(this._authIntervalId);
            delay = millisToLive - (5 * ZmAppCtxt.ONE_MINUTE);
            this._setAuthTokenWarning(delay);
        }
		return;
	}

	if (this._evtMgr.isListenerRegistered(ZmAppCtxt._AUTHTOKEN_EVENT)) {
		var event = new ZmEvent(ZmAppCtxt._AUTHTOKEN_EVENT);
		this._evtMgr.notifyListeners(ZmAppCtxt._AUTHTOKEN_EVENT, event);
	}

	var msg;
    var decaSecondsToLive = 0;
    var toastDuration;
    if (minutesToLive > 1) {
        msg = AjxMessageFormat.format(ZmMsg.authTokenExpirationWarning, [minutesToLive, ZmMsg.minutes]);
        toastDuration = ZmAppCtxt.ONE_MINUTE / 4;
    } else {
        // Get the number of 10-second intervals remaining - used once we are within 1 minute
        decaSecondsToLive =  Math.round(millisToLive / 10000);
        toastDuration = 8000;
        if (decaSecondsToLive >= 6) {
            // 1 minute+ to go.  But should be pretty close to 1 minute
            msg = AjxMessageFormat.format(ZmMsg.authTokenExpirationWarning, [1, ZmMsg.minute]);
        } else {
            // Seconds remain
            msg = AjxMessageFormat.format(ZmMsg.authTokenExpirationWarning, [decaSecondsToLive * 10, ZmMsg.seconds]);
        }
    }

	var params = {
		msg:    msg,
		level:  ZmStatusView.LEVEL_WARNING,
		transitions: [{type: "fade-in", duration: 500}, {type: "pause", duration: toastDuration}, {type: "fade-out", duration: 500} ]
	};
	this.setStatusMsg(params);

    if (minutesToLive > 1) {
        var floorMinutesToLive = Math.floor(millisToLive / ZmAppCtxt.ONE_MINUTE);
        if (floorMinutesToLive === minutesToLive) {
            floorMinutesToLive--;
        }
        delay = millisToLive - (floorMinutesToLive * ZmAppCtxt.ONE_MINUTE);
    }  else {
        decaSecondsToLive--;
        delay = millisToLive - (decaSecondsToLive * 10000);
    }
    if (delay > 0) {
        this._setAuthTokenWarning(delay);
    }
};

ZmAppCtxt.prototype.setZimbraMail = function(zimbraMail) {
	this._zimbraMail = zimbraMail;
}

ZmAppCtxt.prototype.getZimbraMail = function() {
	return this._zimbraMail;
}

/**
 * Sets the application controller.
 * 
 * @param	{ZmController}	appController	the controller
 */
ZmAppCtxt.prototype.setAppController =
function(appController) {
	this._appController = appController;
};

/**
 * Gets the application controller.
 * 
 * @return	{ZmController}		the controller
 */
ZmAppCtxt.prototype.getAppController =
function() {
	return this._appController;
};

/**
 * Gets the application chooser.
 * 
 * @return	{ZmAppChooser}		the chooser
 */
ZmAppCtxt.prototype.getAppChooser =
function() {
	return this._appController.getAppChooser();
};

/**
 * Sets the request manager.
 * 
 * @param	{ZmRequestMgr}	requestMgr	the request manager
 */
ZmAppCtxt.prototype.setRequestMgr =
function(requestMgr) {
	this._requestMgr = requestMgr;
};

/**
 * Gets the request manager.
 * 
 * @return	{ZmRequestMgr}		the request manager
 */
ZmAppCtxt.prototype.getRequestMgr =
function() {
	return this._requestMgr;
};

/**
 * Sets the status message to display.
 * 
 * 
 * @param {Hash}	params	a hash of parameters
 * @param	{String}	params.msg 		the status message
 * @param	{constant}	params.level	the status level {@link ZmStatusView}  (may be <code>null</code>)
 * @param	{String}	params.detail 	the details (may be <code>null</code>)
 * @param	{Object}	params.transitions 	the transitions (may be <code>null</code>)
 * @param	{Object}	params.toast	the toast control (may be <code>null</code>)
 * @param   {boolean}   params.force    force any displayed toasts out of the way (dismiss them and run their dismissCallback). Enqueued messages that are not yet displayed will not be displayed
 * @param   {AjxCallback} params.dismissCallback    callback to run when the toast is dismissed (by another message using [force], or explicitly calling ZmStatusView.prototype.dismiss())
 * @param   {AjxCallback} params.finishCallback     callback to run when the toast finishes its transitions by itself (not when dismissed)
 * </ul>
 * 
 */
ZmAppCtxt.prototype.setStatusMsg =
function(params) {
	params = Dwt.getParams(arguments, ZmStatusView.MSG_PARAMS);
	this._appController.setStatusMsg(params);
};

/**
 * Dismisses the displayed status message, if any
 */

ZmAppCtxt.prototype.dismissStatusMsg =
function(all) {
	this._appController.dismissStatusMsg(all);
};

/**
 * Gets the settings for the given account.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmSettings}	the settings
 */
ZmAppCtxt.prototype.getSettings =
function(account) {
	var al = this.accountList;

	var acct = account || al.activeAccount || al.mainAccount
			|| al.getAccount(ZmAccountList.DEFAULT_ID); //Probably doesn't ever happen, and if it does, returns null. Might be some historical artifact - did we ever have account with id "main"? I'm still afraid to remove it without being sure it won't cause regression.

	return acct && acct.settings;
};

/**
 * Sets the settings for the given account.
 * 
 * @param	{ZmSettings}	settings		the settings
 * @param	{ZmZimbraAccount}		account			the account
 */
ZmAppCtxt.prototype.setSettings = 
function(settings, account) {
	var al = this.accountList;
	var id = account
		? account.id
		: al.activeAccount ? al.activeAccount.id : ZmAccountList.DEFAULT_ID;

	var acct = al.getAccount(id);
	if (acct) {
		acct.settings = settings;
	}
};

/**
 * Gets the value of the given setting.
 *
 * @param {constant}	id		the setting id
 * @param {String}	key			the setting key (for settings that are of the hash type)
 * @param {ZmZimbraAccount}	account		the account
 * @return	{Object}		the setting value
 */
ZmAppCtxt.prototype.get = function(id, key, account) {

    //use parentAppCtxt in case of new window
    var context = this.isChildWindow ? parentAppCtxt : this;

	// for offline, global settings always come from the "local" parent account
	var acct = (context.multiAccounts && ZmSetting.IS_GLOBAL[id])
		? context.accountList.mainAccount : account;
	return context.getSettings(acct).get(id, key);
};

/**
 * Sets the value of the given setting.
 *
 * @param {constant}	id					the setting id
 * @param {Object}	value					the setting value
 * @param {String}	key					the setting key (for settings that are of the hash type)
 * @param {Boolean}	setDefault			if <code>true</code>, also replace setting default value
 * @param {Boolean}	skipNotify			if <code>true</code>, do not notify setting listeners
 * @param {ZmZimbraAccount}	account		if set, use this account setting instead of the currently active account
 * @param {Boolean}	skipImplicit		if <code>true</code>, do not check for change to implicit pref
 */
ZmAppCtxt.prototype.set =
function(id, value, key, setDefault, skipNotify, account, skipImplicit) {
	// for offline, global settings always come from "parent" account
	var acct = (this.multiAccounts && ZmSetting.IS_GLOBAL[id])
		? this.accountList.mainAccount : account;
	var setting = this.getSettings(acct).getSetting(id);

	if (setting) {
		setting.setValue(value, key, setDefault, skipNotify, skipImplicit);
	}
};

/**
 * Gets the application.
 * 
 * @param	{String}	appName		the application name
 * @return	{ZmApp}	the application or <code>null</code> if not found
 */
ZmAppCtxt.prototype.getApp =
function(appName) {
	return this._appController.getApp(appName);
};

/**
 * Gets the name of the current application.
 * 
 * @return	{String}		the application name
 */
ZmAppCtxt.prototype.getCurrentAppName =
function() {
	var context = this.isChildWindow ? parentAppCtxt : this;
	return context._appController.getActiveApp();
};
/**
 *
 */
ZmAppCtxt.prototype.getLoggedInUsername =
function() {
	return appCtxt.get(ZmSetting.USERNAME);
};

/**
 * Gets the current application.
 * 
 * @return	{ZmApp}		the current application
 */
ZmAppCtxt.prototype.getCurrentApp =
function() {
	return this.getApp(this.getCurrentAppName());
};

/**
 * Gets the application view manager.
 * 
 * @return	{ZmAppViewMgr}		the view manager
 */
ZmAppCtxt.prototype.getAppViewMgr =
function() {
	return this._appController.getAppViewMgr();
};

/**
 * Gets the client command handler.
 * 
 * @param	{ZmClientCmdHandler}	clientCmdHdlr		not used
 * @return	{ZmClientCmdHandler}		the command handler
 */
ZmAppCtxt.prototype.getClientCmdHandler =
function(clientCmdHdlr) {
	if (!this._clientCmdHandler) {
		AjxDispatcher.require("Extras");
		this._clientCmdHandler = new ZmClientCmdHandler();
	}
	return this._clientCmdHandler;
};

/**
 * Gets the search bar controller.
 * 
 * @return	{ZmSearchController}	the search controller
 */
ZmAppCtxt.prototype.getSearchController =
function() {
	if (!this._searchController) {
		this._searchController = new ZmSearchController(this._shell);
	}
	return this._searchController;
};

/**
 * Gets the overview controller. Creates a new one if not already set, unless dontCreate is true. 
 *
 * @param {boolean} dontCreate (optional) - don't create overviewController if not created already. (see ZmApp for usage with dontCreate == true)
 * 
 * @return	{ZmOverviewController}	the overview controller
 */
ZmAppCtxt.prototype.getOverviewController =
function(dontCreate) {
	if (!this._overviewController) {
		if (dontCreate) {
			return null;
		}
		this._overviewController = new ZmOverviewController(this._shell);
	}
	return this._overviewController;
};

/**
 * Gets the import/export controller.
 * 
 * @return	{ZmImportExportController}	the controller
 */
ZmAppCtxt.prototype.getImportExportController = function() {
	if (!this._importExportController) {
		AjxDispatcher.require("ImportExport");
		this._importExportController = new ZmImportExportController();
	}
	return this._importExportController;
};

/**
 * Gets the message dialog.
 * 
 * @return	{DwtMessageDialog}	the message dialog
 */
ZmAppCtxt.prototype.getMsgDialog =
function() {
	if (!this._msgDialog) {
		this._msgDialog = new DwtMessageDialog({parent:this._shell, id: "ZmMsgDialog"});
	}
	return this._msgDialog;
};

/**
 * Gets the message dialog with a help button.
 *
 * @return	{DwtMessageDialog}	the message dialog
 */
ZmAppCtxt.prototype.getHelpMsgDialog =
	function() {
		if (!this._helpMsgDialog) {
			this._helpMsgDialog = new DwtMessageDialog({parent:this._shell, helpText:ZmMsg.help, id: "ZmHelpMsgDialog"});
		}
		return this._helpMsgDialog;
	};

/**
 * Gets the yes/no message dialog.
 * 
 * @return	{DwtMessageDialog}	the message dialog
 */
ZmAppCtxt.prototype.getYesNoMsgDialog =
function(id) {
	if (!this._yesNoMsgDialog) {
		this._yesNoMsgDialog = new DwtMessageDialog({parent:this._shell, buttons:[DwtDialog.YES_BUTTON, DwtDialog.NO_BUTTON], id: "YesNoMsgDialog"});
	}	
	return this._yesNoMsgDialog;
};

/**
 * Gets the yes/no/cancel message dialog.
 * 
 * @return	{DwtMessageDialog}	the message dialog
 */
ZmAppCtxt.prototype.getYesNoCancelMsgDialog =
function() {
	if (!this._yesNoCancelMsgDialog) {
		this._yesNoCancelMsgDialog = new DwtMessageDialog({parent:this._shell, buttons:[DwtDialog.YES_BUTTON, DwtDialog.NO_BUTTON, DwtDialog.CANCEL_BUTTON], id:"YesNoCancel"});
	}	
	return this._yesNoCancelMsgDialog;
};

/**
 * Gets the ok/cancel message dialog.
 * 
 * @return	{DwtMessageDialog}	the message dialog
 */
ZmAppCtxt.prototype.getOkCancelMsgDialog =
function() {
	if (!this._okCancelMsgDialog) {
		this._okCancelMsgDialog = new DwtMessageDialog({parent:this._shell, buttons:[DwtDialog.OK_BUTTON, DwtDialog.CANCEL_BUTTON], id:"OkCancel"});
	}	
	return this._okCancelMsgDialog;
};

/**
 * Gets the cancel message dialog.
 * 
 * @return	{DwtMessageDialog}	the message dialog
 */
ZmAppCtxt.prototype.getCancelMsgDialog =
function() {
	if (!this._cancelMsgDialog) {
		this._cancelMsgDialog = new DwtMessageDialog({parent:this._shell, buttons:[DwtDialog.CANCEL_BUTTON]});
	}
	return this._cancelMsgDialog;
};

/**
 * Gets the error dialog.
 * 
 * @return	{ZmErrorDialog}	the error dialog
 */
ZmAppCtxt.prototype.getErrorDialog = 
function() {
	if (!this._errorDialog) {
		AjxDispatcher.require("Startup2");
		this._errorDialog = new ZmErrorDialog(this._shell, ZmMsg);
	}
	return this._errorDialog;
};

/**
 * Gets the new tag dialog.
 * 
 * @return	{ZmNewTagDialog}	the new tag dialog
 */
ZmAppCtxt.prototype.getNewTagDialog =
function() {
	if (!this._newTagDialog) {
		this._newTagDialog = new ZmNewTagDialog(this._shell);
	}
	return this._newTagDialog;
};

/**
 * Gets the new contact group dialog.
 *
 * @return	{ZmNewContactGroupDialog}	the new contact group dialog
 */
ZmAppCtxt.prototype.getNewContactGroupDialog =
function() {
	if (!this._newContactGroupDialog) {
		this._newContactGroupDialog = new ZmNewContactGroupDialog(this._shell);
	}
	return this._newContactGroupDialog;
};

/**
 * Gets the rename tag dialog.
 * 
 * @return	{ZmRenameTagDialog}		the rename tag dialog
 */
ZmAppCtxt.prototype.getRenameTagDialog =
function() {
	if (!this._renameTagDialog) {
		AjxDispatcher.require("Extras");
		this._renameTagDialog = new ZmRenameTagDialog(this._shell);
	}
	return this._renameTagDialog;
};

/**
 * Gets the password update dialog.
 *
 * @return	{ZmPasswordUpdateDialog}		the rename tag dialog
 */
ZmAppCtxt.prototype.getPasswordChangeDialog =
function() {
	if (!this._passwordUpdateDialog) {
		AjxDispatcher.require("Extras");
		this._passwordUpdateDialog = new ZmPasswordUpdateDialog(this._shell);
	}
	return this._passwordUpdateDialog;
};

/**
 * Gets the new folder dialog.
 * 
 * @return	{ZmNewFolderDialog}		the new folder dialog
 */
ZmAppCtxt.prototype.getNewFolderDialog =
function() {
	if (!this._newFolderDialog) {
        var title = ZmMsg.createNewFolder;
        var type = ZmOrganizer.FOLDER;
        this._newFolderDialog = new ZmNewOrganizerDialog(this._shell, null, title, type)
	}
	return this._newFolderDialog;
};

/**
 * Gets the new address book dialog.
 * 
 * @return	{ZmNewAddrBookDialog}		the new address book dialog
 */
ZmAppCtxt.prototype.getNewAddrBookDialog = 
function() {
	if (!this._newAddrBookDialog) {
		AjxDispatcher.require("Contacts");
		this._newAddrBookDialog = new ZmNewAddrBookDialog(this._shell);
	}
	return this._newAddrBookDialog;
};

/**
 * Gets the new calendar dialog.
 * 
 * @return	{ZmNewCalendarDialog}		the new calendar dialog
 */
ZmAppCtxt.prototype.getNewCalendarDialog =
function() {
	if (!this._newCalendarDialog) {
		AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar", "CalendarAppt"]);
		this._newCalendarDialog = new ZmNewCalendarDialog(this._shell);
	}
	return this._newCalendarDialog;
};

/**
 * Gets the new task folder dialog.
 * 
 * @return	{ZmNewTaskFolderDialog}		the new task folder dialog
 */
ZmAppCtxt.prototype.getNewTaskFolderDialog =
function() {
	if (!this._newTaskFolderDialog) {
		AjxDispatcher.require(["TasksCore", "Tasks"]);
		this._newTaskFolderDialog = new ZmNewTaskFolderDialog(this._shell);
	}
	return this._newTaskFolderDialog;
};

/**
 * Gets the new suggestion Preferences dialog
 *
 * @return	{ZmTimeSuggestionPrefDialog}
 */
ZmAppCtxt.prototype.getSuggestionPreferenceDialog =
function() {
	if (!this._suggestionPrefDialog) {
		AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar"]);
        this._suggestionPrefDialog = new ZmTimeSuggestionPrefDialog(this._shell);
    }
    return this._suggestionPrefDialog;
};

/**
 * Gets the dialog.
 * 
 * @return	{DwtDialog}		the dialog
 */
ZmAppCtxt.prototype.getDialog =
function(){
	if(!this._dialog){
		this._dialog = new DwtDialog({parent:this._shell});
	}
	return this._dialog;
};

/**
 * Gets the new search dialog.
 * 
 * @return	{ZmNewSearchDialog}		the new search dialog
 */
ZmAppCtxt.prototype.getNewSearchDialog =
function() {
	this._newSearchDialogs = this._newSearchDialogs || {};
	this.searchAppName = this.searchAppName || ZmApp.MAIL;
	if (!this._newSearchDialogs[this.searchAppName]) {
		this._newSearchDialogs[this.searchAppName] = new ZmNewSearchDialog(this._shell);
	}
	this._newSearchDialog = this._newSearchDialogs[this.searchAppName];
	return this._newSearchDialog;
};

/**
 * Gets the rename folder dialog.
 * 
 * @return	{ZmRenameFolderDialog}		the rename folder dialog
 */
ZmAppCtxt.prototype.getRenameFolderDialog =
function() {
	if (!this._renameFolderDialog) {
		AjxDispatcher.require("Extras");
		this._renameFolderDialog = new ZmRenameFolderDialog(this._shell);
	}
	return this._renameFolderDialog;
};

/**
 * Gets the choose folder dialog.
 * 
 * @return	{ZmChooseFolderDialog}		the choose folder dialog
 */
ZmAppCtxt.prototype.getChooseFolderDialog =
function(appName) {
	var app = appName ? this.getApp(appName) : this.getCurrentApp();
	// this.getCurrentAppName() returns "Search" for search apps. Let's re-use dialogs from regular apps.
	appName = app.isZmSearchApp ? this.searchAppName : app.getName();
	this._chooseFolderDialogs = this._chooseFolderDialogs || {};
	if (!this._chooseFolderDialogs[appName]) {
		AjxDispatcher.require("Extras");
		this._chooseFolderDialogs[appName] = new ZmChooseFolderDialog(this._shell);
	}
	this._chooseFolderDialog = this._chooseFolderDialogs[appName];
	return this._chooseFolderDialog;
};

ZmAppCtxt.prototype.getChooseAccountDialog =
function() {
	if (!this._chooseAccountDialog) {
		AjxDispatcher.require("Extras");
		this._chooseAccountDialog = new ZmChooseAccountDialog(this._shell);
	}
	return this._chooseAccountDialog;
};

/**
 * Gets the pick tag dialog.
 * 
 * @return	{ZmPickTagDialog}		the pick tag dialog
 */
ZmAppCtxt.prototype.getPickTagDialog =
function() {
	if (!this._pickTagDialog) {
		AjxDispatcher.require("Extras");
		this._pickTagDialog = new ZmPickTagDialog(this._shell);
	}
	return this._pickTagDialog;
};

/**
 * Gets the folder notify dialog.
 * 
 * @return	{ZmFolderNotifyDialog}		the folder notify dialog
 */
ZmAppCtxt.prototype.getFolderNotifyDialog =
function() {
	if (!this._folderNotifyDialog) {
		this._folderNotifyDialog = new ZmFolderNotifyDialog(this._shell);
	}
	return this._folderNotifyDialog;
};

/**
 * Gets the folder properties dialog.
 * 
 * @return	{ZmFolderPropsDialog}		the folder properties dialog
 */
ZmAppCtxt.prototype.getFolderPropsDialog =
function() {
	if (!this._folderPropsDialog) {
		this._folderPropsDialog = new ZmFolderPropsDialog(this._shell);
	}
	return this._folderPropsDialog;
};

/**
 * Gets the share properties dialog.
 * 
 * @return	{ZmSharePropsDialog}		the share properties dialog
 */
ZmAppCtxt.prototype.getSharePropsDialog =
function() {
	if (!this._sharePropsDialog) {
		AjxDispatcher.require("Share");
		this._sharePropsDialog = new ZmSharePropsDialog(this._shell);
	}
	return this._sharePropsDialog;
};

ZmAppCtxt.prototype.getShareSearchDialog = function() {
	if (!this._shareSearchDialog) {
		AjxDispatcher.require("Share");
		this._shareSearchDialog = new ZmShareSearchDialog({parent:this._shell});
	}
	return this._shareSearchDialog;
};

/**
 * Gets the accept share dialog.
 * 
 * @return	{ZmAcceptShareDialog}		the accept share dialog
 */
ZmAppCtxt.prototype.getAcceptShareDialog =
function() {
	if (!this._acceptShareDialog) {
		AjxDispatcher.require("Share");
		this._acceptShareDialog = new ZmAcceptShareDialog(this._shell);
	}
	return this._acceptShareDialog;
};

/**
 * Gets the decline share dialog.
 * 
 * @return	{ZmDeclineShareDialog}		the decline share dialog
 */
ZmAppCtxt.prototype.getDeclineShareDialog =
function() {
	if (!this._declineShareDialog) {
		AjxDispatcher.require("Share");
		this._declineShareDialog = new ZmDeclineShareDialog(this._shell);
	}
	return this._declineShareDialog;
};

/**
 * Gets the revoke share dialog.
 * 
 * @return	{ZmRevokeShareDialog}		the revoke share dialog
 */
ZmAppCtxt.prototype.getRevokeShareDialog =
function() {
	if (!this._revokeShareDialog) {
		AjxDispatcher.require("Share");
		this._revokeShareDialog = new ZmRevokeShareDialog(this._shell);
	}
	return this._revokeShareDialog;
};

/**
 * Gets the timezone picker dialog.
 * 
 * @return	{ZmTimezonePicker}		the timezone picker dialog
 */
ZmAppCtxt.prototype.getTimezonePickerDialog =
function() {
	if (!this._timezonePickerDialog) {
		AjxDispatcher.require("Share");
		this._timezonePickerDialog = new ZmTimezonePicker(this._shell);
	}
	return this._timezonePickerDialog;
};

/**
 * Gets the filter rule add/edit dialog.
 * 
 * @return	{ZmFilterRuleDialog}		the filter rule add/edit dialog
 */
ZmAppCtxt.prototype.getFilterRuleDialog =
function() {
	if (!this._filterRuleDialog) {
		AjxDispatcher.require(["PreferencesCore", "Preferences"]);
		this._filterRuleDialog = new ZmFilterRuleDialog();
	}
	return this._filterRuleDialog;
};

/**
 * Gets the priority message filter dialog.
 * 
 * @return {ZmPriorityMessageFilterDialog}  the priority message filter dialog
 */
ZmAppCtxt.prototype.getPriorityMessageFilterDialog = 
function() {
	if (!this._priorityMessageFilterDialog) {
		AjxDispatcher.require(["PreferencesCore", "Preferences"]);
		this._priorityMessageFilterDialog = new ZmPriorityMessageFilterDialog();
	}
	return this._priorityMessageFilterDialog;
};


/**
 * Gets the activity stream prompt dialog for running activity stream filters
 * 
 * @return {ZmActivityStreamPromptDialog}
*/
ZmAppCtxt.prototype.getActivityStreamFilterDialog = 
function() {
	if (!this._activityStreamFilterDialog) {
		AjxDispatcher.require(["PreferencesCore", "Preferences"]);
		this._activityStreamFilterDialog = new ZmActivityStreamPromptDialog();
	}
	return this._activityStreamFilterDialog;
};

/**
 * Gets the prompt for moving files from the Activity Stream to the Inbox
 * 
 * @return {ZmActivityToInboxPromptDialog}
 */
ZmAppCtxt.prototype.getActivityToInboxFilterDialog =
function() {
	if (!this._activityToInboxFilterDialog) {
		AjxDispatcher.require(["PreferencesCore", "Preferences"]);
		this._activityToInboxFilterDialog = new ZmActivityToInboxPromptDialog();
	}
	return this._activityToInboxFilterDialog;
};

/**
 * Gets the quickadd dialog for creating a contact
 * 
 * @return {ZmContactQuickAddDialog}
 */
ZmAppCtxt.prototype.getContactQuickAddDialog = 
function() {
	if (!this._contactQuickAddDialog) {
		AjxDispatcher.require(["ContactsCore", "Contacts"]);
		this._contactQuickAddDialog = new ZmContactQuickAddDialog();
	}
	return this._contactQuickAddDialog;
};

/**
 * Gets the confirm dialog.
 * 
 * @return	{DwtConfirmDialog}		the confirmation dialog
 */
ZmAppCtxt.prototype.getConfirmationDialog =
function(id) {
	if (!this._confirmDialog) {
		this._confirmDialog = new DwtConfirmDialog(this._shell, null, "CONFIRM_DIALOG");
	}
	return this._confirmDialog;
};

/**
 * Gets the upload dialog.
 * 
 * @return	{ZmUploadDialog}		the upload dialog
 */
ZmAppCtxt.prototype.getUploadDialog =
function() {
	if (!this._uploadDialog) {
		AjxDispatcher.require(["Extras"]);
		this._uploadDialog = new ZmUploadDialog(this._shell);
	}
	return this._uploadDialog;
};

/**
 * Gets the attach dialog.
 * 
 * @return	{ZmAttachDialog}		the attach dialog
 */
ZmAppCtxt.prototype.getAttachDialog =
function() {
	if (!this._attachDialog) {
		AjxDispatcher.require("Share");
		this._attachDialog = new ZmAttachDialog(this._shell);
		this.runAttachDialogCallbacks();
	}
	return this._attachDialog;
};

ZmAppCtxt.prototype.getDumpsterDialog =
function() {
	if (!this._dumpsterDialog) {
		AjxDispatcher.require("Extras");
		this._dumpsterDialog = new ZmDumpsterDialog(this._shell);
	}
	return this._dumpsterDialog;
};


/**
 * Gets the mail redirect dialog.
 *
 * @return	{ZmMailRedirectDialog}	the new mail redirect dialog
 */
ZmAppCtxt.prototype.getMailRedirectDialog =
function() {
	if (!this._mailRedirectDialog) {
		this._mailRedirectDialog = new ZmMailRedirectDialog(this._shell);
	}
	return this._mailRedirectDialog;
};

/**
 * Gets the mail retention warning dialog.
 *
 * @return	{ZmRetetionWarningDialog}	the new mail retention warning dialog
 */
ZmAppCtxt.prototype.getRetentionWarningDialog =
function() {
	if (!this._retentionWarningDialog) {
		this._retentionWarningDialog = new ZmRetentionWarningDialog(this._shell);
	}
	return this._retentionWarningDialog;
};


/**
 * Runs the attach dialog callbacks.
 *
 * @private
 */
ZmAppCtxt.prototype.runAttachDialogCallbacks =
function() {
	while(this._attachDialogCallback && this._attachDialogCallback.length > 0) {
		var callback = this._attachDialogCallback.shift();
		if(callback && (callback instanceof AjxCallback)) {
			callback.run(this._attachDialog);
		}
	}
};

/**
 * Adds the callback to the attachment dialog callbacks.
 *
 * @param	{AjxCallback}	callback		the callback
 */
ZmAppCtxt.prototype.addAttachmentDialogCallback =
function(callback) {
	if(!this._attachDialogCallback) {
		this._attachDialogCallback = [];
	}
	this._attachDialogCallback.push(callback);
};                                              

/**
 * Gets the upload conflict dialog.
 *
 * @return	{ZmUploadConflictDialog}	the upload conflict dialog
 */
ZmAppCtxt.prototype.getUploadConflictDialog =
function() {
	if (!this._uploadConflictDialog) {
		AjxDispatcher.require(["Extras"]);
		this._uploadConflictDialog = new ZmUploadConflictDialog(this._shell);
	}
	return this._uploadConflictDialog;
};

/**
 * Gets the new briefcase dialog.
 *
 * @return	{ZmNewBriefcaseDialog}	the new briefcase dialog
 */
ZmAppCtxt.prototype.getNewBriefcaseDialog =
function() {
	if (!this._newBriefcaseDialog) {
		AjxDispatcher.require(["BriefcaseCore", "Briefcase"]);
		this._newBriefcaseDialog = new ZmNewBriefcaseDialog(this._shell);
	}
	return this._newBriefcaseDialog;
};

/**
 * Gets the find-and-replace dialog.
 *
 * @return	{ZmFindnReplaceDialog}	the find-and-replace dialog
 */
ZmAppCtxt.prototype.getReplaceDialog =
function() {
	if (!this._replaceDialog) {
		AjxDispatcher.require("Share");
		this._replaceDialog = new ZmFindnReplaceDialog(this._shell);
	}
	return this._replaceDialog;
};

/**
 * Gets the debug log dialog.
 *
 * @return	{ZmDebugLogDialog}		the debug log dialog
 */
ZmAppCtxt.prototype.getDebugLogDialog =
function() {
	if (!this._debugLogDialog) {
		AjxDispatcher.require("Extras");
		this._debugLogDialog = new ZmDebugLogDialog(this._shell);
	}
	return this._debugLogDialog;
};

/**
 * Gets the root tab group.
 *
 * @return	{DwtTabGroup}	the root tab group
 */
ZmAppCtxt.prototype.getRootTabGroup =
function() {
	if (this.isChildWindow) {
		if (!this._childWinTabGrp) {
			this._childWinTabGrp = new DwtTabGroup("CHILD_WINDOW");
		}
	} else {		
		if (!this._rootTabGrp) {
			this._rootTabGrp = new DwtTabGroup("ROOT");
		}
	}
	return this.isChildWindow ? this._childWinTabGrp : this._rootTabGrp;
};

/**
 * Gets the shell.
 *
 * @return	{DwtShell}	the shell
 */
ZmAppCtxt.prototype.getShell =
function() {
	return this._shell;
};

/**
 * Sets the shell.
 *
 * @param	{DwtShell}	the shell
 */
ZmAppCtxt.prototype.setShell =
function(shell) {
	this._shell = shell;
};

/**
 * Gets the active account.
 *
 * @return	{ZmZimbraAccount}	the active account
 */
ZmAppCtxt.prototype.getActiveAccount =
function() {
	return this.isChildWindow
		? parentAppCtxt.accountList.activeAccount
		: this.accountList.activeAccount;
};

/**
 * Gets the active account.
 *
 * @return	{ZmZimbraAccount}	the active account
 */
ZmAppCtxt.prototype.isExternalAccount =
function() {
	return this.get(ZmSetting.IS_EXTERNAL);
};

/*
 * This is a list of Aspell (Ver. 0.61) support locale from the result of the following command:
 *   /opt/zimbra/aspell/bin/aspell dump dicts
 *      (use only the items whose format is "<Primary-tag> *( "_" <Subtag> )")
 * When Aspell is upgraded and more locales are added, please update this list too.
 */
ZmAppCtxt.AVAILABLE_DICTIONARY_LOCALES = ["ar", "da", "de", "de_AT", "de_CH", "de_DE", "en", "en_CA", "en_GB", "en_US", "es", "fr", "fr_CH", "fr_FR", "hi", "hu", "it", "nl", "pl", "pt_BR", "ru", "sv"];

/**
 * Gets the availability of the spell check feature based on the current locale and user's configuration
 *
 * @return     {Boolean}       <code>true</code> if the spell checker is available.
 */
ZmAppCtxt.prototype.isSpellCheckerAvailable = function () {

	if (!appCtxt.get(ZmSetting.SPELL_CHECK_ENABLED)) {
		return false;
	}

	if (typeof this._spellCheckAvailable !== 'undefined') {
		return this._spellCheckAvailable;
	}

	this._spellCheckAvailable = false;
	var myLocale = appCtxt.get(ZmSetting.LOCALE_NAME);
	var myDefaultDictionaryName = appCtxt.get(ZmSetting.SPELL_DICTIONARY);

	var myLanguage = myLocale.split('_')[0];

	var dictLocales = ZmAppCtxt.AVAILABLE_DICTIONARY_LOCALES;
	var ln = dictLocales.length;

	for (var i = 0; i < ln; i++) {
		var dictLocale = dictLocales[i];
		if (dictLocale === myLocale ||
		    dictLocale === myLanguage ||
		    dictLocale === myDefaultDictionaryName) {
			this._spellCheckAvailable = true;
			break;
		}
	}

	return this._spellCheckAvailable;
}

/**
 * Gets the identity collection.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmIdentityCollection}	the identity collection
 */
ZmAppCtxt.prototype.getIdentityCollection = function(account) {

    var context = this.isChildWindow ? window && window.opener : window;
	return context && context.AjxDispatcher.run("GetIdentityCollection", account);
};

/**
 * Gets the data source collection.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmModel}	the data source collection
 */
ZmAppCtxt.prototype.getDataSourceCollection = function(account) {

	var context = this.isChildWindow ? window && window.opener : window;
	return context && context.AjxDispatcher.run("GetDataSourceCollection", account);
};

/**
 * Gets the signature collection.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmSignatureCollection}	the signature collection
 */
ZmAppCtxt.prototype.getSignatureCollection = function(account) {

    var context = this.isChildWindow ? window && window.opener : window;
	return context && context.AjxDispatcher.run("GetSignatureCollection", account);
};


ZmAppCtxt.prototype.killMarkReadTimer =
function() {
	if (this.markReadActionId > 0) {
		AjxTimedAction.cancelAction(this.markReadActionId);
		this.markReadActionId = -1;
	}
};
/**
 * Gets the organizer tree.
 * 
 * @param	{ZmOrganizer.FOLDER|ZmOrganizer.TAG|ZmOrganizer.ZIMLET}	type	the type
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmTree}		the tree
 * @see		#getFolderTree
 * @see		#getTagTree
 * @see		#getZimletTree
 */
ZmAppCtxt.prototype.getTree =
function(type, account) {
	if (this.isChildWindow) {
		return parentAppCtxt.getTree(type, account);
	}

	var al = this.accountList;
	var id = account
		? account.id
		: al.activeAccount ? al.activeAccount.id : ZmAccountList.DEFAULT_ID;

	var acct = al.getAccount(id);
	return acct && acct.trees[ZmOrganizer.TREE_TYPE[type]];
};

/**
 * Sets the organizer tree.
 * 
 * @param	{ZmOrganizer.FOLDER|ZmOrganizer.TAG|ZmOrganizer.ZIMLET}	type	the type
 * @param	{ZmTree}	tree		the tree
 * @param	{ZmZimbraAccount}	account		the account
 * @see		#getTree
 */
ZmAppCtxt.prototype.setTree =
function(type, tree, account) {
	var al = this.accountList;
	var id = account
		? account.id
		: al.activeAccount ? al.activeAccount.id : ZmAccountList.DEFAULT_ID;


	var acct = this.accountList.getAccount(id);
	if (acct) {
		acct.trees[type] = tree;
	}
};

/**
 * Gets the folder organizer tree.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmFolderTree}		the tree
 * @see		#getTree
 */
ZmAppCtxt.prototype.getFolderTree =
function(account) {
    return this.getTree(ZmOrganizer.FOLDER, account);
};

/**
 * Gets the tag organizer tree.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmTagTree}		the tree
 * @see		#getTree
 */
ZmAppCtxt.prototype.getTagTree =
function(account) {
	return this.getTree(ZmOrganizer.TAG, account);
};

/**
 * Gets the tag organizer tree's root.
 *
 * @param	{ZmItem}	item		item to look up the account of for and get the account tag list.
 * @return	{ZmTag}		the root of the tree, which is also a list.
 */
ZmAppCtxt.prototype.getAccountTagList =
function(item) {
	var account = (item && appCtxt.multiAccounts) ? item.getAccount() : null;

	return this.getTagTree(account).root;
};


/**
 * Gets the zimlet organizer tree.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{ZmFolderTree}		the tree
 * @see		#getTree
 */
ZmAppCtxt.prototype.getZimletTree =
function(account) {
	return this.getTree(ZmOrganizer.ZIMLET, account);
};

/**
 * Gets the username (which is an email address).
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{String}		the username
 */
ZmAppCtxt.prototype.getUsername =
function(account) { 
	return this.get(ZmSetting.USERNAME, account);
};

/**
 * Gets the user domain.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{String}		the user domain
 */
ZmAppCtxt.prototype.getUserDomain =
function(account) {
	if (!this.userDomain) {
        var username = this.getUsername(account);
		if (username) {
			var parts = username.split("@");
			this.userDomain = (parts && parts.length) ? parts[1] : "";
		}
	}
	return this.userDomain;
};

/**
 * Gets the upload frame id.
 * 
 * @return	{String}		the frame id
 */
ZmAppCtxt.prototype.getUploadFrameId =
function() {
	if (!this._uploadManagerIframeId) {
		var iframeId = Dwt.getNextId();
		var html = [ "<iframe name='", iframeId, "' id='", iframeId,
			     "' src='", (AjxEnv.isIE && location.protocol == "https:") ? appContextPath+"/public/blank.html" : "javascript:\"\"",
			     "' style='position: absolute; top: 0; left: 0; visibility: hidden'></iframe>" ];
		var div = document.createElement("div");
		div.innerHTML = html.join("");
		document.body.appendChild(div.firstChild);
		this._uploadManagerIframeId = iframeId;
	}
	return this._uploadManagerIframeId;
};

ZmAppCtxt.prototype.reloadAppCache =
function(force, retryOnError) {
	AjxDebug.println(AjxDebug.OFFLINE, "reloadAppCache :: " + AjxDebug._getTimeStamp());
    if (this.isWebClientOfflineSupported || force) {
		var localOfflineBrowserKey = localStorage.getItem(ZmSetting.WEBCLIENT_OFFLINE_BROWSER_KEY);
		//If application cache status is downloading browser is already downloading the resources mentioned in the manifest file. Resetting the cookie value will result in application cache error event "Manifest changed during update".
		if (localOfflineBrowserKey && AjxEnv.supported.applicationcache && applicationCache.status !== applicationCache.DOWNLOADING) {
			var cookieValue = localOfflineBrowserKey + "_" + new Date().getTime();
			AjxCookie.setCookie(document, "ZM_OFFLINE_KEY", cookieValue, false, "/");
		}
		var manifestURL = appContextPath + "/appcache/images,common,dwt,msgview,login,zm,spellcheck,skin.appcache?";
        var urlParams = [];
        urlParams.push("v=" + window.cacheKillerVersion);
        urlParams.push("debug=" + window.appDevMode);
        urlParams.push("compress=" + !(window.appDevMode === true));
        urlParams.push("templates=only");
        manifestURL = encodeURIComponent(manifestURL + urlParams.join('&'));
        var offlineIframe = document.getElementById("offlineIframe");
        if (!offlineIframe) {
            offlineIframe = document.createElement("iframe");
            offlineIframe.id = "offlineIframe";
            offlineIframe.style.display = "none";
            document.body.appendChild(offlineIframe);
        }
        if (offlineIframe) {
			retryOnError = AjxUtil.isBoolean(retryOnError) ? retryOnError : true;
			offlineIframe.src = "public/Offline.jsp?url=" + manifestURL + "&isFirefox=" + AjxEnv.isFirefox + "&retryOnError=" + retryOnError;
        }
    }
};

/**
 * Gets the upload manager.
 * 
 * @return	{Object}		the upload manager
 */
ZmAppCtxt.prototype.getUploadManager =
function() {
	if (!this._uploadManager) {
		// Create upload manager (for sending attachments)
		this._uploadManager = new AjxPost(this.getUploadFrameId());
	}
	return this._uploadManager;
};

ZmAppCtxt.prototype.getZmUploadManager =
    function() {
        if (!this._zmUploadManager) {
            // Create upload manager (for sending attachments)
            AjxDispatcher.require("Extras");
            this._zmUploadManager = new ZmUploadManager();
        }
        return this._zmUploadManager;
    };

/**
 * Gets the current search.
 * 
 * @return	{ZmSearch}		the current search
 */
ZmAppCtxt.prototype.getCurrentSearch =
function() {
	var app = this.getCurrentApp();
	if (app && app.currentSearch) {
		return app.currentSearch;
	}
	var ctlr = this.getCurrentController();
	return ctlr && ctlr._currentSearch;
};

/**
 * Gets the current view id. If we're showing search results, returns the ID of the
 * view within the search results (rather than the ID of the search results).
 * 
 * @return	{String}		the current view id
 */
ZmAppCtxt.prototype.getCurrentViewId =
function() {
	var viewId = this.getAppViewMgr().getCurrentViewId();
	if (viewId && viewId.indexOf(ZmId.VIEW_SEARCH_RESULTS) === 0) {
		viewId = this.getCurrentController().getCurrentViewId();
	}
	return viewId;
};

/**
 * Gets the current view type. If we're showing search results, returns the type of the
 * view within the search results (rather than the type of the search results).
 * 
 * @return	{String}		the current view type
 */
ZmAppCtxt.prototype.getCurrentViewType =
function() {
	var viewType = this.getAppViewMgr().getCurrentViewType();
	if (viewType && viewType.indexOf(ZmId.VIEW_SEARCH_RESULTS) === 0) {
		viewType = this.getCurrentController().getCurrentViewType();
	}
	return viewType;
};

/**
 * Extracts the view type from a view ID.
 * 
 * @param	{string}	viewId		a view ID
 * @return	{String}	the view type
 */
ZmAppCtxt.prototype.getViewTypeFromId =
function(viewId) {
	var array = viewId && viewId.split(ZmController.SESSION_ID_SEP);
	return array ? array[0] : "";
};

/**
 * Gets the current view.
 * 
 * @return	{DwtComposite}		the current view
 */
ZmAppCtxt.prototype.getCurrentView =
function() {
	return this.getAppViewMgr().getCurrentView();
};

/**
 * Gets the current controller.
 * 
 * @return	{ZmController}		the current controller
 */
ZmAppCtxt.prototype.getCurrentController =
function() {
	var view = this.getCurrentView();
	return (view && view.getController) ? view.getController() : null;
};

/**
 * Sets the current list.
 * 
 * @param	{ZmList}	list		the current list
 */
ZmAppCtxt.prototype.setCurrentList =
function(list) {
	this._list = list;
};

/**
 * Gets the current list.
 * 
 * @return	{ZmList}		the current list
 */
ZmAppCtxt.prototype.getCurrentList =
function() {
	var ctlr = this.getCurrentController();
	return (ctlr && ctlr.getList) ? ctlr.getList() : this._list ? this._list : null;
};

ZmAppCtxt.prototype.getActionController =
function() {
	if (!this._actionController && !this.isChildWindow) {
		this._actionController = new ZmActionController();
	}
	return this._actionController;
};

/**
 * Gets a new window.
 * 
 * @param	{Boolean}	fullView		<code>true</code> to include the full version
 * @param	{int}		width			the width
 * @param	{int}		height			the height
 * @param   {String}    name            window name
 */
ZmAppCtxt.prototype.getNewWindow = 
function(fullVersion, width, height, name) {
	// build url
	var url = [];
	var i = 0;
	url[i++] = document.location.protocol;
	url[i++] = "//";
	url[i++] = location.hostname;
	url[i++] = (!location.port || location.port == "80") ? "" : (":" + location.port);
	url[i++] = appContextPath;
	url[i++] = "/public/launchNewWindow.jsp?skin=";
	url[i++] = appCurrentSkin;
	url[i++] = "&localeId=";
	url[i++] = AjxEnv.DEFAULT_LOCALE || "";
	if (fullVersion) {
		url[i++] = "&full=1";
	}
	if (window.appDevMode) {
		url[i++] = "&dev=1";
	}
    if (window.appCoverageMode) {
        url[i++] = "&coverage=1";
    }
	this.__childWindowId = (this.__childWindowId+1) || 0;
	url[i++] = "&childId=" + this.__childWindowId;

    name = name || "_blank";
	width = width || 705;
	height = height || 465;
	var args = ["height=", height, ",width=", width, ",location=no,menubar=no,resizable=yes,scrollbars=no,status=yes,toolbar=no"].join("");
	if (window.appDevMode) {
		args = ["height=", height, ",width=", width, ",location=yes,menubar=yes,resizable=yes,scrollbars=no,status=yes,toolbar=yes"].join("");
	}
	var newWin = window.open(url.join(""), name, args);
	this.handlePopupBlocker(newWin);
	if(newWin) {
		// add this new window to global list so parent can keep track of child windows!
		return this.getAppController().addChildWindow(newWin, this.__childWindowId);
	}
};

/**
 * Handle Popup bloker for a given window
 * @param {Object}	win  A Window object
 */
ZmAppCtxt.prototype.handlePopupBlocker =
function(win) {
	if (!win) {
		this.setStatusMsg(ZmMsg.popupBlocker, ZmStatusView.LEVEL_CRITICAL);
	} else if (win && AjxEnv.isChrome) {
		setTimeout(function() { 
					if (win.innerHeight == 0)
						appCtxt.setStatusMsg(ZmMsg.popupBlocker, ZmStatusView.LEVEL_CRITICAL);
				}, 200);
		};
};

/**
 * Caches the given key/value set.
 * 
 * @param	{Object}	key		the key
 * @param	{Object}	value	the value
 * @private
 */
ZmAppCtxt.prototype.cacheSet =
function(key, value) {
	this._itemCache[key] = value;
	delete this._itemCacheDeferred[key];
};

/**
 * Defers caching the given key set.
 * 
 * @param	{Object}	key		the key
 * @param	{String}	appName	the application name
 * @private
 */
ZmAppCtxt.prototype.cacheSetDeferred =
function(key, appName) {
	this._itemCache[key] = this._itemCacheDeferred;
	this._itemCacheDeferred[key] = appName;
};

/**
 * Gets the key from cache.
 * 
 * @param	{Object}	key		the key
 * @return	{Object}	the value
 * @private
 */
ZmAppCtxt.prototype.cacheGet =
function(key) {
	var value = this._itemCache[key];
	if (value === this._itemCacheDeferred) {
		var appName = this._itemCacheDeferred[key];
		this.getApp(appName).createDeferred();
		value = this._itemCache[key];
	}
	return value;
};

/**
 * Removes the key from cache.
 * 
 * @param	{Object}	key		the key
 * @private
 */
ZmAppCtxt.prototype.cacheRemove =
function(key) {
	delete this._itemCache[key];
	delete this._itemCacheDeferred[key];
};

/**
 * Gets the key from cache by id.
 * 
 * @param	{String}	id		the id
 * @return	{Object}	the value
 * @private
 */
ZmAppCtxt.prototype.getById = function(id) {

    // Try parent cache if we're a child window and we don't have it
	return this.cacheGet(id) || (this.isChildWindow && window && window.opener && window.opener.appCtxt && window.opener.appCtxt.getById(id));
};

/**
 * Gets the keyboard manager
 * 
 * @return	{DwtKeyboardMgr}		the keyboard manager
 */
ZmAppCtxt.prototype.getKeyboardMgr =
function() {
	return this._shell.getKeyboardMgr();
};

/**
 * Gets the history manager.
 * 
 * @return	{AjxHistoryMgr}		the history manager
 */
ZmAppCtxt.prototype.getHistoryMgr =
function() {
	if (!this._historyMgr) {
		this._historyMgr = new AjxHistoryMgr();
	}
	return this._historyMgr;
};

/**
 * Checks if the zimlets are present.
 * 
 * @return	{Boolean}		<code>true</code> if zimlets are present
 */
ZmAppCtxt.prototype.zimletsPresent =
function() {
	return this._zimletsPresent;
};

/**
 * Sets if the zimlets are present.
 * 
 * @param	{Boolean}	zimletsPresent		if <code>true</code>, zimlets are present
 */
ZmAppCtxt.prototype.setZimletsPresent =
function(zimletsPresent) {
	this._zimletsPresent = zimletsPresent;
};

/**
 * Gets the zimlet manager
 * 
 * @return	{ZmZimletMgr}	the zimlet manager
 */
ZmAppCtxt.prototype.getZimletMgr =
function() {
	if (!this._zimletMgr) {
		AjxDispatcher.require("Zimlet");
		if (!this._zimletMgr) // Must re-check here, because if this function is called a second time before the "Zimlet" package is loaded, both calls want to set this._zimletMgr, which must NEVER happen (Issue first located in bug #41338)
			this._zimletMgr = new ZmZimletMgr();
	}
	return this._zimletMgr;
};

/**
 * Checks if zimlets are loaded.
 * 
 * @return	{Boolean}		<code>true</code> if zimlets are loaded
 */
ZmAppCtxt.prototype.areZimletsLoaded =
function() {
	return this._zimletsLoaded;
};

/**
 * Adds a listener to the zimlets loaded event.
 * 
 * @param	{AjxCallback}	listener		the listener
 * @param	{int}		index		the index to where to add the listener
 * @return	{Boolean}	<code>true</code> if the listener is added; <code>false</code> otherwise
 */
ZmAppCtxt.prototype.addZimletsLoadedListener =
function(listener, index) {
	if (!this._zimletsLoaded) {
		return this._evtMgr.addListener(ZmAppCtxt._ZIMLETS_EVENT, listener, index);
	}
};

/**
 * Checks is all zimlets are loaded.
 * 
 * @return	{Boolean}	<code>true</code> if all zimlets are loaded
 */
ZmAppCtxt.prototype.allZimletsLoaded =
function() {
	this._zimletsLoaded = true;
	if (this._zimletMgr && !this.isChildWindow && appCtxt.get(ZmSetting.PORTAL_ENABLED)) {
		var portletMgr = this.getApp(ZmApp.PORTAL).getPortletMgr();
		if (portletMgr) {
			portletMgr.allZimletsLoaded();
		}
	}

	if (this._evtMgr.isListenerRegistered(ZmAppCtxt._ZIMLETS_EVENT)) {
		this._evtMgr.notifyListeners(ZmAppCtxt._ZIMLETS_EVENT, new ZmEvent());
		this._evtMgr.removeAll(ZmAppCtxt._ZIMLETS_EVENT);
	}
};

/**
 * Notifies zimlets if they are present and loaded.
 *
 * @param {String}		event		the zimlet event (called as a zimlet function)
 * @param {Array}		args		a list of args to the function
 * @param {Hash}	options			a hash of options
 * @param {Boolean}	options.noChildWindow		if <code>true</code>, skip notify if we are in a child window
 * @param	{Boolean}	options.waitUntilLoaded	if <code>true</code> and zimlets are not yet loaded, add a listener so that notify happens on load
 * @return	{Boolean} Returns <code>true</code> if at least one Zimlet handles the notification
 */
ZmAppCtxt.prototype.notifyZimlets =
function(event, args, options) {
	this.notifySkin(event, args, options); // Also notify skin

	var context = this.isChildWindow ? parentAppCtxt : this;

	if (options && options.noChildWindow && this.isChildWindow) { return false; }

	if (!context.areZimletsLoaded()) {
		if (options && options.waitUntilLoaded) {
			context.addZimletsLoadedListener(new AjxListener(this, this.notifyZimlets, [event, args]));
		}
		return false;
	}

	return this.getZimletMgr().notifyZimlets(event, args);
};

ZmAppCtxt.prototype.notifyZimlet =
function(zimletName, event, args, options) {
	if (options && options.noChildWindow && this.isChildWindow) { return false; }
	return this.getZimletMgr().notifyZimlet(zimletName, event, args);
};

ZmAppCtxt.prototype.notifySkin =
function(event, args, options) {
	var context = this.isChildWindow ? parentAppCtxt : this;
	if (options && options.noChildWindow && this.isChildWindow) { return; }
	try {
		return window.skin && AjxUtil.isFunction(window.skin.handleNotification) && window.skin.handleNotification(event, args);
	} catch (e) {}
};


/**
 * Gets the calendar manager.
 * 
 * @return	{ZmCalMgr}	the calendar manager
 */
ZmAppCtxt.prototype.getCalManager =
function() {
	if (!this._calMgr) {
        AjxDispatcher.require("Startup2");
		this._calMgr = new ZmCalMgr(this._shell);
	}
	return this._calMgr;
};

ZmAppCtxt.prototype.updateOfflineAppt = function(msgId, field, value, nullData, callback) {
	var calMgr = appCtxt.getCalManager();
	if (calMgr) {
		var calViewController = calMgr && calMgr.getCalViewController();
		if (calViewController) {
			var apptCache = calViewController.getApptCache();
			if (apptCache) {
				apptCache.updateOfflineAppt(msgId, field, value, nullData, callback);
			}
		}
	}
}

/**
 * Gets the task manager.
 *
 * @return	{ZmTaskMgr}	the task manager
 */
ZmAppCtxt.prototype.getTaskManager =
function() {
	if (!this._taskMgr) {
		this._taskMgr = new ZmTaskMgr(this._shell);
	}
	return this._taskMgr;
};


/**
 * Gets the ACL.
 * 
 * @param	{ZmZimbrAccount}	account		the account
 * @param	{AjxCallback}	callback	the callback
 * @return	{ZmAccessControlList}	the ACL
 */
ZmAppCtxt.prototype.getACL =
function(account, callback) {
	var al = this.accountList;
	var id = account
		? account.id
		: al.activeAccount ? al.activeAccount.id : ZmAccountList.DEFAULT_ID;

	var acct = al.getAccount(id);
	return acct && acct.acl;
};

/**
 * Gets the shortcut hint.
 *
 * @param {String}		keyMap		the key map
 * @param {String}		shortcut	the shortcut action
 * @return	{String}	the hint
 */
ZmAppCtxt.prototype.getShortcutHint =
function(keyMap, shortcut) {
	
	var text = null;
	keyMap = keyMap || "global";
	while (!text && keyMap) {
		var scKey = [keyMap, shortcut, "display"].join(".");
		var text = AjxKeys[scKey] || ZmKeys[scKey];
		if (text) {
			var list = text.split(/;\s*/);
			var sc = list[0];	// use first shortcut in list
			if (!sc) { return null; }
			sc = sc.replace(/\b[A-Z]\b/g, function(let) { return let.toLowerCase(); });
			text = [" [", sc.replace(",", ""), "]"].join("");
		} else {
			var key = [keyMap, "INHERIT"].join(".");
			keyMap = AjxKeys[key] || ZmKeys[key];
		}
	}

	return text;
};

/**
 * Gets the shortcuts panel.
 * 
 * @return	{ZmShortcutsPanel}	the shortcuts panel
 */
ZmAppCtxt.prototype.getShortcutsPanel =
function() {
	if (!this._shortcutsPanel) {
		AjxDispatcher.require(["PreferencesCore", "Preferences"]);
		var style = this.isChildWindow ? ZmShortcutList.WINDOW_STYLE : ZmShortcutList.PANEL_STYLE;
		this._shortcutsPanel = new ZmShortcutsPanel(style);
	}
	return this._shortcutsPanel;
};

/**
 * Opens a new change password window
 *
 */
ZmAppCtxt.prototype.getChangePasswordWindow =
function(ev) {
    var url = appCtxt.get(ZmSetting.CHANGE_PASSWORD_URL);

    	if (!url) {
    		var isHttp	= appCtxt.get(ZmSetting.PROTOCOL_MODE) == ZmSetting.PROTO_HTTP;
    		var proto	= isHttp ? ZmSetting.PROTO_HTTP : ZmSetting.PROTO_HTTPS;
    		var port	= appCtxt.get(isHttp ? ZmSetting.HTTP_PORT : ZmSetting.HTTPS_PORT);
    		var path	= appContextPath+"/h/changepass";

    		var publicUrl = appCtxt.get(ZmSetting.PUBLIC_URL);
    		if (publicUrl) {
    			var parts = AjxStringUtil.parseURL(publicUrl);
    			path = parts.path + "/h/changepass";
    			var switchMode = (parts.protocol == "http" && proto == ZmSetting.PROTO_HTTPS);
    			proto = switchMode ? proto : parts.protocol;
    			port = switchMode ? port : parts.port;
    		}
			var qsArgs = {skin: appCurrentSkin};
    		url = AjxUtil.formatUrl({protocol: proto, port: port, path: path, qsReset: true, qsArgs: qsArgs});
    	}

    	var args  = "height=465,width=705,location=no,menubar=no,resizable=yes,scrollbars=no,status=yes,toolbar=no";
    	window.open(url,'ChangePasswordWindow', args);
};

/**
 * Gets the skin hint for the given argument(s), which will be used to look
 * successively down the properties chain.
 * 
 * <p>
 * For example, <code>getSkinHint("a", "b")</code> will return the value of <code>skin.hints.a.b</code>.
 * </p>
 * 
 * @return	{String}	the skin hint
 */
ZmAppCtxt.prototype.getSkinHint =
function() {
	if (arguments.length == 0) return "";
	
	var cur = window.skin && window.skin.hints;
	if (!cur) { return ""; }
	for (var i = 0; i < arguments.length; i++) {
		var arg = arguments[i];
		if (!cur[arg]) { return ""; }
		cur = cur[arg];
	}
	return cur;
};

/**
 * Gets the auto completer.
 * 
 * @return	{ZmAutocomplete}	the auto completer
 */
ZmAppCtxt.prototype.getAutocompleter =
function() {
	if (!this._autocompleter) {
		this._autocompleter = new ZmAutocomplete(null);
	}
	return this._autocompleter;
};

/**
 * Checks if my address belongs to the current user (include aliases).
 * 
 * @param {String}		addr			            the address
 * @param {Boolean}		allowLocal		            if <code>true</code>, domain is not required
 * @param {Boolean}		excludeAllowFromAddress		if <code>true</code>, addresses in zimbraAllowFromAddresses are ignored
 * @return	{Boolean}		<code>true</code> if the given address belongs to the current user; <code>false</code> otherwise
 */
ZmAppCtxt.prototype.isMyAddress =
function(addr, allowLocal, excludeAllowFromAddress) {

	if (allowLocal && (addr.indexOf('@') == -1)) {
		addr = [addr, this.getUserDomain()].join("@");
	}
	
	if (addr == this.get(ZmSetting.USERNAME)) {
		return true;
	}

	var allAddresses;
    if(excludeAllowFromAddress){
        allAddresses= appCtxt.get(ZmSetting.MAIL_ALIASES);
    }
    else
    {
        allAddresses= appCtxt.get(ZmSetting.MAIL_ALIASES).concat(appCtxt.get(ZmSetting.ALLOW_FROM_ADDRESSES));
    }

	if (allAddresses && allAddresses.length) {
		for (var i = 0; i < allAddresses.length; i++) {
			if (addr == allAddresses[i])
				return true;
		}
	}

	return false;
};

/**
 * Gets the overview ID, prepending account name if multi-account.
 *
 * @param {Array}		parts		an array of {String} id components
 * @param {ZmAccount}	account		the account
 * @return	{String}	the id
 */
ZmAppCtxt.prototype.getOverviewId =
function(parts, account) {

	var id = (parts instanceof Array) ? parts.join("_") : parts;

	if (appCtxt.multiAccounts && (account !== null)) {
		account = account || appCtxt.getActiveAccount();
		id = [account.name, id].join(":");
	}

	return id;
};

/**
 * Gets the autocomplete cache for the given parameters, optionally creating one.
 *
 * @param	{String}	acType		the item type
 * @param	{String}	str			the autocomplete string
 * @param	{ZmAccount}	account		the account
 * @param	{Boolean}	create		if <code>true</code>, create a cache if none found
 */
ZmAppCtxt.prototype.getAutocompleteCache =
function(acType, str, account, create) {

	var cache = null;
	var acct = account || this.getActiveAccount();
	if (acct) {
		if (this._acCache[acct.id] && this._acCache[acct.id][acType]) {
			cache = this._acCache[acct.id][acType][str];
		}
	}
	if (!cache && create) {
		if (acct && !this._acCache[acct.id]) {
			this._acCache[acct.id] = {};
		}
		if (!this._acCache[acct.id][acType]) {
			this._acCache[acct.id][acType] = {};
		}
		cache = this._acCache[acct.id][acType][str] = {};
	}

	return cache;
};

/**
 * Clears the autocomplete cache.
 *
 * @param	{String}	type		item type
 * @param	{ZmAccount}	account		the account
 */
ZmAppCtxt.prototype.clearAutocompleteCache =
function(type, account) {

	var acct = account || appCtxt.getActiveAccount();
	if (this._acCache[acct.id]) {
		if (type) {
			this._acCache[acct.id][type] = {};
		} else {
			this._acCache[acct.id][ZmAutocomplete.AC_TYPE_CONTACT]		=	{};
			this._acCache[acct.id][ZmAutocomplete.AC_TYPE_LOCATION]		=	{};
			this._acCache[acct.id][ZmAutocomplete.AC_TYPE_EQUIPMENT]	=	{};
		}
	}
};

ZmAppCtxt.prototype.getOutsideMouseEventMgr =
function() {
	return DwtOutsideMouseEventMgr.INSTANCE;
};


/**
* @return Returns language specific charset. Currently supports only Japanese. 
* Returns "Windows-31J" for Japanese or returns "UTF-8" for everything else
*/
ZmAppCtxt.prototype.getCharset =
function() {
	var lang = AjxEnv.isIE ? window.navigator.systemLanguage : window.navigator.language;
	//Currently only differs for Japanese, but can extend for different languages as/if we need it.
	if((AjxEnv.DEFAULT_LOCALE == "ja" || lang == "ja") && AjxEnv.isWindows) {
		return "Windows-31J";
	} else {
		return "UTF-8";
	}
};

/**
 * Returns true if an address is an expandable DL.
 *  
 * @param {string}	addr	email address
 */
ZmAppCtxt.prototype.isExpandableDL =
function(addr) {
	return addr && this._isExpandableDL[addr] && this.get("EXPAND_DL_ENABLED");
};

/**
 * Cache whether an address is an expandable DL.
 * 
 * @param {string}	addr			email address
 * @param {boolean}	isExpandableDL	if true, address is expandable DL
 * 
 * TODO: consider caching AjxEmailAddress objects by addr so we also save display name
 */
ZmAppCtxt.prototype.setIsExpandableDL =
function(addr, isExpandableDL) {
	this._isExpandableDL[addr] = isExpandableDL;
};

ZmAppCtxt.prototype.getToolTipMgr =
function() {
	if (!this._toolTipMgr) {
		this._toolTipMgr = new ZmToolTipMgr();
	}
	return this._toolTipMgr;
};

/**
 * Returns true if Prism and the user is online
 *
 */
ZmAppCtxt.prototype.isZDOnline =
function() {
    var ac = window["appCtxt"].getAppController();
    return !AjxEnv.isPrism || (ac._isPrismOnline && ac._isUserOnline);
};

/**
 * When using pre-auth window.opener.appCtxt may not be accessible.  This function
 * handles appCtxt assignment to avoid a permission denied error
 * @return {Object} ZmAppCtxt
 */
ZmAppCtxt.handleWindowOpener = 
function() {
	try {
		return window && window.opener && window.opener.appCtxt || appCtxt;
	}
	catch (ex) {
		return appCtxt;
	}
};

ZmAppCtxt.prototype.isWebClientOffline =
function() {
    if (this.isWebClientOfflineSupported) {
        return ZmOffline.isServerReachable === false;
    }
    return false;
};

ZmAppCtxt.prototype.initWebOffline =
function() {
    this.isWebClientOfflineSupported = false;
	if (!AjxEnv.isOfflineSupported || !appCtxt.get(ZmSetting.WEBCLIENT_OFFLINE_ENABLED)) {
		AjxDebug.println(AjxDebug.OFFLINE, "isWebClientOfflineSupported :: false");
        return;
    }
    var offlineBrowserKey = appCtxt.get(ZmSetting.WEBCLIENT_OFFLINE_BROWSER_KEY);
    var localOfflineBrowserKey = localStorage.getItem(ZmSetting.WEBCLIENT_OFFLINE_BROWSER_KEY);
    if (offlineBrowserKey && offlineBrowserKey.indexOf(localOfflineBrowserKey) !== -1) {
        this.isWebClientOfflineSupported = true;
        this.webClientOfflineHandler = new ZmOffline();
    }
	AjxDebug.println(AjxDebug.OFFLINE, "isWebClientOfflineSupported :: "+ this.isWebClientOfflineSupported);
};

/**
 * Gets the offline settings dialog.
 *
 * @return	{ZmOfflineSettingsDialog}	offline settings dialog
 */
ZmAppCtxt.prototype.getOfflineSettingsDialog =
function() {
    if (!this._offlineSettingsDialog) {
        this._offlineSettingsDialog = new ZmOfflineSettingsDialog();
    }
    return this._offlineSettingsDialog;
};

/**
 * Returns true if the given ID is not local. That's the case if the ID has
 * an account part that is not the active account.
 *
 * @param {String|Number}   id
 * @returns {Boolean}   true if the given ID is not local
 */
ZmAppCtxt.prototype.isRemoteId = function(id) {
	id = String(id);
	var acct = appCtxt.getActiveAccount();
	return (id.indexOf(":") !== -1) && (id.indexOf(acct.id) !== 0);
};

/**
 * Returns the singleton AjxClipboard instance, if it is supported.
 *
 * @returns {AjxClipboard}
 */
ZmAppCtxt.prototype.getClipboard = function() {
	return AjxClipboard.isSupported() ? new AjxClipboard() : null;
};

/**
 * Checks a precondition which may be in one of several forms: a boolean, a settings constant, a function, or a list.
 *
 * @param {Boolean|String|Function|Array}   precondition    something that evaluates to true or false
 * @param {Boolean}                         listAny         (optional) if a list is provided, whether just one (instead of all) must be true
 *
 * @return boolean  false if the precondition evaluates to false or null, otherwise true
 */
ZmAppCtxt.prototype.checkPrecondition = function(precondition, listAny) {

	// Lack of a precondition evaluates to true
	if (precondition === undefined) {
		return true;
	}

	// A precondition of null should not happen
	if (precondition === null) {
		return false;
	}

	// Boolean speaks for itself
	if (AjxUtil.isBoolean(precondition)) {
		return precondition;
	}

	// Client setting: fetch value from settings
	if (AjxUtil.isString(precondition) && ZmSetting.hasOwnProperty(precondition)) {
		return appCtxt.get(precondition);
	}

	// Function: evaluate and return result
	if (AjxUtil.isFunction(precondition)) {
		return precondition();
	}

	// Array can be treated in one of two modes, where all have to be true, or just one does
	if (AjxUtil.isArray(precondition)) {
		for (var i = 0; i < precondition.length; i++) {
			var result = this.checkPrecondition(precondition[i]);
			if (listAny && result) {
				return true;
			}
			if (!listAny && !result) {
				return false;
			}
		}
		return !listAny;
	}

	return true;
};

/**
 * Displays an error message in  dialog.
 *
 * @param {string}  errMsg      error message
 * @param {string}  details     (optional) additional info to show using Details button
 * @param {string}  style       (optional) style constant DwtMessageDialog.*_STYLE
 * @param {string}  title       (optional) title for dialog (other than one for the style)
 * @apram {boolean} noReport    do not add a Report button/function to the dialog (defaults to true)
 */
ZmAppCtxt.prototype.showError = function(params) {

    params = params || {};
    var errMsg = params.errMsg || params;
    var dlg = this.getErrorDialog();
    dlg.reset();
    dlg.setMessage(errMsg, params.details, params.style || DwtMessageDialog.WARNING_STYLE, params.title);
    dlg.popup(null, params.noReport !== false);
};
}
if (AjxPackage.define("zimbraMail.core.ZmOperation")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the operation class.
 * 
 */

/**
 * Creates the operation object.
 * @class
 * This class provides the idea of an "operation", which is a user-initiated action
 * exposed through a button or menu item. Many operations (such as Delete) are shared
 * across applications/controllers. An operation gets defined by specifying its name,
 * tool tip, and image. Then controllers can simply select which operations they'd like
 * to support.
 * <br/>
 * <br/>
 * The two primary clients of this class are {@link ZmButtonToolBar} and {@link ZmActionMenu}. Clients 
 * should support {@link #createOp} and {@link #getOp} methods. See the two aforementioned clients for
 * examples.
 * 
 * @author Conrad Damon
 */
ZmOperation = function() {};

// Special operations
ZmOperation.NONE 					= "NONE";		// no operations or menu items
ZmOperation.SEP 					= "SEP";		// separator
ZmOperation.SPACER 					= "SPACER";		// spacer (toolbar)
ZmOperation.FILLER 					= "FILLER";		// filler (toolbar)

// suffix for disabled image
ZmOperation.DIS = "Dis";

// text and icons displayed for operation
ZmOperation.SETUP = {};

// special-purpose operations
ZmOperation.SETUP[ZmOperation.NONE]		= {};	// means no operations (as opposed to a default set)
ZmOperation.SETUP[ZmOperation.SEP]		= {};	// a thin vertical or horizontal bar
ZmOperation.SETUP[ZmOperation.SPACER]	= {};	// empty space of a given size
ZmOperation.SETUP[ZmOperation.FILLER]	= {};	// expandable space (for right-align in toolbars)

// preconditions for operations - no automatic checking is done, so a client
// of this class has to check them on its own if it wants
ZmOperation.PRECONDITION = {};

// code to run after an operation has been created - typically used to create
// a menu for a button
ZmOperation.CALLBACK = {};

/**
 * Defines the aspects of an operation, and the ID that refers to it.
 * 
 * @param {String}	op		the name of the operation
 * @param {hash}	params:
 *      @param {String}	text		the msg key for button or menu item text
 *      @param {String}	tooltip	the msg key for tooltip text
 *      @param {String}	image		the icon class for the button or menu item
 *      @param {String}	disImage	the disabled version of image; defaults to image + "Dis"
 *      @param {Boolean|String|Function}    precondition (overrides setting if present)
 * @param {constant}	precondition	must evaluate to true for this operation not to be filtered out
 * @param {AjxCallback}	callback	the callback to run after this operation has been created
 */
ZmOperation.registerOp = function(op, params, precondition, callback) {

	ZmOperation[op] = op;
	ZmOperation.SETUP[op] = params || {};
	if (precondition)	{ ZmOperation.PRECONDITION[op]	= precondition; }
	if (callback)	    { ZmOperation.CALLBACK[op]	    = callback; }
};


ZmOperation.KEY_ID		= "opId";
ZmOperation.MENUITEM_ID	= "menuItemId";

ZmOperation.NEW_ITEM_OPS	= [];
ZmOperation.NEW_ITEM_KEY	= {};
ZmOperation.NEW_ORG_OPS		= [];
ZmOperation.NEW_ORG_KEY		= {};

// Static hash of operation IDs ad descriptors
ZmOperation._operationDesc = {};

/**
 * Initializes and creates standard operations.
 * 
 */
ZmOperation.initialize =
function() {
	ZmOperation.registerOp(ZmId.OP_ACTIONS_MENU, {textKey:"actions", tooltipKey:"", textPrecedence:40});
	
	ZmOperation.registerOp(ZmId.OP_ATTACHMENT, {textKey:"addAttachment", tooltipKey:"attachmentTooltip", image:"Attachment", shortcut:ZmKeyMap.ATTACHMENT, showImageInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_CALL, {image:"Telephone"});
	ZmOperation.registerOp(ZmId.OP_CANCEL, {textKey:"cancel", tooltipKey:"cancelTooltip", image:"Cancel", shortcut:ZmKeyMap.CANCEL});
	ZmOperation.registerOp(ZmId.OP_CHECK_ALL, {textKey:"checkAll", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_CLEAR_ALL, {textKey:"clearAll", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_CLOSE, {textKey:"close", tooltipKey:"closeTooltip", image:"Close", shortcut:ZmKeyMap.CANCEL});
	ZmOperation.registerOp(ZmId.OP_COMPOSE_FORMAT, {textKey:"format", tooltipKey:"formatTooltip", image:"SwitchFormat", shortcut:ZmKeyMap.HTML_FORMAT}, ZmSetting.HTML_COMPOSE_ENABLED);
	ZmOperation.registerOp(ZmId.OP_CONTACTGROUP_MENU, {textKey: "AB_CONTACT_GROUP", tooltipKey:"contactGroupTooltip", image:"Group"}, null,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmOperation.addContactGroupMenu, parent, true);
	}));
	ZmOperation.registerOp(ZmId.OP_COPY, {textKey:"copy", image:"Copy"});
	ZmOperation.registerOp(ZmId.OP_DELETE, {textKey:"del", tooltipKey:"deleteTooltip", image:"Delete", shortcut:ZmKeyMap.DEL, textPrecedence:60});
	ZmOperation.registerOp(ZmId.OP_DELETE_WITHOUT_SHORTCUT, {textKey:"del", tooltipKey:"deleteTooltip", image:"Delete", textPrecedence:60});
	ZmOperation.registerOp(ZmId.OP_DETACH, {textKey:"detach", tooltipKey:"detach", image:"OpenInNewWindow", showImageInToolbar: true});
    ZmOperation.registerOp(ZmId.OP_DETACH_WIN, {textKey:"detach", image:"OpenInNewWindow"});
	ZmOperation.registerOp(ZmId.OP_EDIT, {textKey:"edit", tooltipKey:"editTooltip", image:"Edit", shortcut:ZmKeyMap.EDIT});
	ZmOperation.registerOp(ZmId.OP_EDIT_AS_NEW, {textKey:"editAsNew", tooltipKey:"editTooltip", image:"Edit", shortcut:ZmKeyMap.EDIT});
	ZmOperation.registerOp(ZmId.OP_EDIT_PROPS, {textKey:"editProperties", tooltipKey:"editPropertiesTooltip", image:"Properties"});
	ZmOperation.registerOp(ZmId.OP_EXPAND, {textKey:"expand", image:"Plus"});
	ZmOperation.registerOp(ZmId.OP_EXPAND_ALL, {textKey:"expandAll", image:"Plus"});
//	ZmOperation.registerOp(ZmId.OP_EXPORT_FOLDER, {textKey:"exportFolder", image:"MailExport"});
	ZmOperation.registerOp(ZmId.OP_EMPTY_FOLDER,{textKey:"emptyFolder",image:"EmptyFolder"});
	ZmOperation.registerOp(ZmId.OP_FORMAT_HTML, {textKey: "formatAsHtml"}, ZmSetting.HTML_COMPOSE_ENABLED);
	ZmOperation.registerOp(ZmId.OP_FORMAT_TEXT, {textKey: "formatAsText"}, ZmSetting.HTML_COMPOSE_ENABLED);
	ZmOperation.registerOp(ZmId.OP_FORMAT_MORE_OPTIONS, {textKey: "moreComposeOptions"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY, {textKey:"groupBy"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY_NONE, {textKey:"groupByNone"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY_DATE, {textKey:"groupByDate"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY_FROM, {textKey:"groupByFrom"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY_PRIORITY, {textKey:"groupByPriority"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY_SIZE, {textKey:"groupBySize"});
    ZmOperation.registerOp(ZmId.OP_GROUPBY_TAG,  {textKey:"groupByTag"});
	ZmOperation.registerOp(ZmId.OP_GO_TO_URL, {image:"URL", textKey:"goToUrlAlt"});
//	ZmOperation.registerOp(ZmId.OP_IMPORT_FOLDER, {textKey:"importFolder", image:"MailImport"});
	ZmOperation.registerOp(ZmId.OP_MARK_ALL_READ, {textKey:"markAllRead", image:"ReadMessage"});
//	ZmOperation.registerOp(ZmId.OP_MOUNT_FOLDER, {textKey:"mountFolder", image:"Folder"});
	ZmOperation.registerOp(ZmId.OP_MOVE, {textKey:"move", tooltipKey:"moveTooltip", image:"MoveToFolder", textPrecedence:40, showImageInToolbar: true}); //todo - remove
	ZmOperation.registerOp(ZmId.OP_MOVE_MENU, {textKey: "move", tooltipKey:"moveTooltip", image:"MoveToFolder", showImageInToolbar: true }, null,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmOperation.addMoveMenu, parent, true);
		}));

    ZmOperation.registerOp(ZmId.OP_MUTE_CONV, {textKey:"muteConv", tooltipKey:"muteConvTooltip", image:"Mute", shortcut:ZmKeyMap.MUTE_UNMUTE_CONV});
	ZmOperation.registerOp(ZmId.OP_NEW_FOLDER, {textKey:"newFolder", tooltipKey:"newFolderTooltip", image:"NewFolder", shortcut:ZmKeyMap.NEW_FOLDER}, ZmSetting.USER_FOLDERS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_NEW_MENU, {textKey:"_new", shortcut:ZmKeyMap.NEW, textPrecedence:100}, null,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmOperation.addNewMenu, parent);
		}));
	ZmOperation.registerOp(ZmId.OP_NEW_TAG, {textKey:"newTag", tooltipKey:"newTagTooltip", image:"NewTag", shortcut:ZmKeyMap.NEW_TAG}, ZmSetting.TAGGING_ENABLED);
    ZmOperation.registerOp(ZmId.OP_NOTIFY, {textKey: "notify", image:"Feedback"});
	ZmOperation.registerOp(ZmId.OP_OPEN_IN_TAB, {textKey:"openInTab", image:"OpenInNewTab"});
	ZmOperation.registerOp(ZmId.OP_OPTS, {textKey:"options", tooltipKey:"options", image:"ContextMenu"});
	ZmOperation.registerOp(ZmId.OP_PAGE_BACK, {image:"LeftArrow", shortcut:ZmKeyMap.PREV_PAGE});
	ZmOperation.registerOp(ZmId.OP_PAGE_FORWARD, {image:"RightArrow", shortcut:ZmKeyMap.NEXT_PAGE});
	ZmOperation.registerOp(ZmId.OP_PRINT, {textKey:"print", tooltipKey:"printTooltip", image:"Print", shortcut:ZmKeyMap.PRINT, textPrecedence:30, showImageInToolbar: true}, ZmSetting.PRINT_ENABLED);
    ZmOperation.registerOp(ZmId.OP_PRIORITY_FILTER, {image:"Priority", textKey:"activityStream"}, ZmSetting.PRIORITY_INBOX_ENABLED);
	ZmOperation.registerOp(ZmId.OP_FIND_SHARES, {image:"Group", textKey:"findShares"}, ZmSetting.SHARING_ENABLED);

	//ZmOperation.registerOp(ZmId.OP_QUICK_COMMANDS, {textKey:"quickCommands", image:"QuickCommand"});
	ZmOperation.registerOp(ZmId.OP_RECOVER_DELETED_ITEMS, {textKey:"recoverDeletedItems", image:"Trash", tooltipKey:"recoverDeletedItems"}, ZmSetting.DUMPSTER_ENABLED);
    ZmOperation.registerOp(ZmId.OP_REFRESH, {textKey:"refresh", tooltipKey:"refreshTooltip"});
	ZmOperation.registerOp(ZmId.OP_RENAME_FOLDER, {textKey:"renameFolder", image:"Rename"});
	ZmOperation.registerOp(ZmId.OP_RENAME_SEARCH, {textKey:"renameSearch", image:"Rename"});
	ZmOperation.registerOp(ZmId.OP_RENAME_TAG, {textKey:"renameTag", image:"Rename"}, ZmSetting.TAGGING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SAVE, {textKey:"save", image:"Save", shortcut:ZmKeyMap.SAVE});
	ZmOperation.registerOp(ZmId.OP_SEARCH, {textKey:"findEmailFromSender", image:"Search"}, ZmSetting.SEARCH_ENABLED);
    ZmOperation.registerOp(ZmId.OP_SEARCH_TO, {textKey:"findEmailToSender", image:"Search"}, ZmSetting.SEARCH_ENABLED);
    ZmOperation.registerOp(ZmId.OP_SEARCH_MENU, {textKey:"findEmails", image:"Search"}, ZmSetting.SEARCH_ENABLED,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmOperation.addSearchMenu, parent, true);
		}));
	ZmOperation.registerOp(ZmId.OP_SEND, {textKey:"send", tooltipKey:"sendTooltip", image:"Send", shortcut:ZmKeyMap.SEND});
    ZmOperation.registerOp(ZmId.OP_FREE_BUSY_LINK, {textKey:"freeBusyLink", tooltipKey:"freeBusyLinkTooltip", image:"Send"});
    ZmOperation.registerOp(ZmId.OP_SEND_FB_HTML, {textKey:"sendHTMLLink", tooltipKey:"freeBusyLinkTooltip"});
    ZmOperation.registerOp(ZmId.OP_SEND_FB_ICS, {textKey:"sendICSLink", tooltipKey:"freeBusyLinkTooltip"});
    ZmOperation.registerOp(ZmId.OP_SEND_FB_ICS_EVENT, {textKey:"sendICSEventLink", tooltipKey:"freeBusyLinkTooltip"});
    ZmOperation.registerOp(ZmId.OP_SHARE, {textKey:"share", tooltipKey:"shareTooltip"}, ZmSetting.SHARING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SHARE_ACCEPT, {textKey:"acceptShare", image:"Check"}, ZmSetting.SHARING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SHARE_DECLINE, {textKey:"declineShare", image:"Cancel"}, ZmSetting.SHARING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SUBSCRIBE_APPROVE, {textKey:"dlApprove", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_SUBSCRIBE_REJECT, {textKey:"dlReject", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_SHARE_FOLDER, {textKey:"shareFolder", image:"SharedMailFolder"});
	ZmOperation.registerOp(ZmId.OP_SHOW_ALL_ITEM_TYPES, {textKey:"showAllItemTypes", image:"Globe"});
    ZmOperation.registerOp(ZmId.OP_SORT_ASC, {textKey:"sortAscending"});
    ZmOperation.registerOp(ZmId.OP_SORT_DESC, {textKey:"sortDescending"});
	ZmOperation.registerOp(ZmId.OP_SPELL_CHECK, {textKey:"spellCheck", image:"SpellCheck", tooltipKey:"spellCheckTooltip", shortcut:ZmKeyMap.SPELLCHECK, showImageInToolbar: true}, ZmSetting.SPELL_CHECK_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SYNC, {textKey:"reload", image:"Refresh", shortcut:ZmKeyMap.REFRESH});
    ZmOperation.registerOp(ZmId.OP_SYNC_ALL, {textKey:"checkAllFeed", image:"Refresh"});
	ZmOperation.registerOp(ZmId.OP_SYNC_OFFLINE_FOLDER, {textKey:"syncOfflineFolderOff", image:"Refresh"}, ZmSetting.OFFLINE_ENABLED); /* offline only */
	ZmOperation.registerOp(ZmId.OP_TAG, null, ZmSetting.TAGGING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_TAG_COLOR_MENU, {textKey:"tagColor", image:"TagStack"}, ZmSetting.TAGGING_ENABLED,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmOperation.addColorMenu, parent);
		}));
	ZmOperation.registerOp(ZmId.OP_TAG_MENU, {textKey: "tag", tooltipKey:"tagTooltip", image:"Tag", showImageInToolbar: true }, ZmSetting.TAGGING_ENABLED,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmOperation.addTagMenu, parent, true);
		}));
	// placeholder for toolbar text
	ZmOperation.registerOp(ZmId.OP_TEXT);
	// XXX: need new icon? -
	//      Undelete is stupid. We should either add it for all items types (not just contacts) or just kill it
    ZmOperation.registerOp(ZmId.OP_UNDELETE, {textKey:"undelete", tooltipKey:"undelete", image:"MoveToFolder"});
    ZmOperation.registerOp(ZmId.OP_UNMUTE_CONV, {textKey:"unmuteConv", tooltipKey:"unmuteConvTooltip", image:"Unmute", shortcut:ZmKeyMap.MUTE_UNMUTE_CONV});
	ZmOperation.registerOp(ZmId.OP_VIEW, {textKey:"view", image:"SplitView"});
	ZmOperation.registerOp(ZmId.OP_VIEW_MENU, {tooltipKey:"viewTooltip", textKey:"view", image:"SplitPane", textPrecedence:80, showImageInToolbar: true, showTextInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_ZIMLET, {image:"ZimbraIcon"});

	// invites - needed for both Mail and Calendar
	ZmOperation.registerOp(ZmId.OP_ACCEPT_PROPOSAL, {textKey:"replyAccept", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_DECLINE_PROPOSAL, {textKey:"replyDecline", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_CAL_REPLY, {textKey:"reply", tooltipKey:"replyTooltip", image:"Reply", shortcut:ZmKeyMap.REPLY});
	ZmOperation.registerOp(ZmId.OP_CAL_REPLY_ALL, {textKey:"replyAll", tooltipKey:"replyAllTooltip", image:"ReplyAll", shortcut:ZmKeyMap.REPLY_ALL});
	ZmOperation.registerOp(ZmId.OP_REPLY_ACCEPT, {textKey:"replyAccept", image:"Check", showTextInToolbar: true, showImageInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_REPLY_ACCEPT_NOTIFY, {textKey:"notifyOrganizerLabel", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_REPLY_ACCEPT_IGNORE, {textKey:"dontNotifyOrganizerLabel", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_REPLY_CANCEL);
	ZmOperation.registerOp(ZmId.OP_REPLY_DECLINE, {textKey:"replyDecline", image:"Cancel", showTextInToolbar: true, showImageInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_REPLY_DECLINE_NOTIFY, {textKey:"notifyOrganizerLabel", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_REPLY_DECLINE_IGNORE, {textKey:"dontNotifyOrganizerLabel", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_REPLY_MODIFY);
	ZmOperation.registerOp(ZmId.OP_REPLY_NEW_TIME, {textKey:"replyNewTime", image:"NewTime"});
	ZmOperation.registerOp(ZmId.OP_REPLY_TENTATIVE, {textKey:"replyTentative", image:"QuestionMark", showTextInToolbar: true, showImageInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_REPLY_TENTATIVE_NOTIFY, {textKey:"notifyOrganizerLabel", image:"QuestionMark"});
	ZmOperation.registerOp(ZmId.OP_REPLY_TENTATIVE_IGNORE, {textKey:"dontNotifyOrganizerLabel", image:"QuestionMark"});

	// Compose Options - used by Calendar and Mail
	ZmOperation.registerOp(ZmId.OP_COMPOSE_OPTIONS, {textKey:"options", image:"Preferences"});

	ZmOperation.NEW_ORG_OPS.push(ZmOperation.NEW_FOLDER, ZmOperation.NEW_TAG);
	ZmOperation.NEW_ORG_KEY[ZmOperation.NEW_FOLDER]	= "folder";
	ZmOperation.NEW_ORG_KEY[ZmOperation.NEW_TAG]	= "tag";
};

/**
 * Creates operation descriptors for the given operation IDs,
 * then creates the appropriate widget for each operation based on the type of
 * the parent. If it's a toolbar, then buttons are created. If it's a menu, menu items are
 * created.
 * <p>
 * To override or add properties to a particular operation, pass in a hash of properties and
 * values as a value in overrides, with the operation ID as the key.
 * </p>
 *
 * @param {DwtComposite}	parent		the containing widget (toolbar or menu)
 * @param {Array}	operations	a list of operation IDs
 * @param {Hash}	overrides		a hash of overrides by op ID
 *
 * @returns	{Hash}	a hash of operations by ID
 */
ZmOperation.createOperations =
function(parent, operations, overrides) {
	var obj = new ZmOperation();
	return obj._createOperations(parent, operations, overrides);
}

/**
 * Done through an object so that we can have more than one invocation going
 * without sharing memory (eg, creating New submenu).
 * 
 * @private
 */
ZmOperation.prototype._createOperations =
function(parent, operations, overrides) {
	if (operations == ZmOperation.NONE) {
		operations = null;
	}
	overrides = overrides || {};

	var opHash = {};
	if (operations && operations.length) {
		for (var i = 0; i < operations.length; i++) {
			var id = operations[i];
			ZmOperation.defineOperation(id, overrides[id]);
			ZmOperation.addOperation(parent, id, opHash, null, overrides[id] && overrides[id].htmlElId);
		}
	}

	return opHash;
};

/**
* Creates an operation descriptor. The ID of an existing operation can be passed
* in to use as a base, with overridden properties passed in a hash. A new operation
* can be defined by passing its properties in a hash.
*
* @param {String}	baseId		the ID of an existing operation
* @param {Hash}	overrides	the property overrides for the operation
*/
ZmOperation.defineOperation =
function(baseId, overrides) {
	var id = (overrides && overrides.id) || (baseId && baseId.id) || baseId || Dwt.getNextId();
	var textKey = (overrides && overrides.textKey) || ZmOperation.getProp(baseId, "textKey");
	var text = textKey && ZmMsg[textKey];
	var tooltipKey = (overrides && overrides.tooltipKey) || ZmOperation.getProp(baseId, "tooltipKey");
	var tooltip = tooltipKey && ZmMsg[tooltipKey];
	var image = ZmOperation.getProp(baseId, "image");
	var showImageInToolbar = ZmOperation.getProp(baseId, "showImageInToolbar");
	var showTextInToolbar = ZmOperation.getProp(baseId, "showTextInToolbar");
	var disImage = ZmOperation.getProp(baseId, "disImage");
	var enabled = (overrides && (overrides.enabled !== false));
	var style = ZmOperation.getProp(baseId, "style");
	var shortcut = ZmOperation.getProp(baseId, "shortcut");

    var opDesc = {id:id, text:text, image:image, showImageInToolbar:showImageInToolbar, showTextInToolbar:showTextInToolbar, disImage:disImage, enabled:enabled,
				  tooltip:tooltip, style:style, shortcut:shortcut};
	if (overrides) {
		for (var i in overrides) {
			opDesc[i] = overrides[i];
		}
	}

	ZmOperation._operationDesc[id] = opDesc;
	
	return opDesc;
};

/**
 * Gets the value of a given property for a given operation.
 *
 * @param {String}	id		the operation ID
 * @param {String}	prop	the name of an operation property
 * 
 * @return	{Object}	the value
 */
ZmOperation.getProp =
function(id, prop) {
	var value = null;
	var setup = ZmOperation.SETUP[id];
	if (setup) {
		value = setup[prop];
		if (!value && (prop == "disImage") && setup.image) {
			value = setup.image;
		}
	}

	return value;
};

/**
 * Checks if the operation is a separator or spacer.
 * 
 * @param	{String}	id		the id
 * @return	{Boolean}	<code>true</code> if the operation is a spacer
 */
ZmOperation.isSep =
function(id) {
	return (id == ZmOperation.SEP || id == ZmOperation.SPACER || id == ZmOperation.FILLER);
};

/**
 * Adds the operation.
 * 
 * @param {DwtComposite}	parent		the containing widget (toolbar or menu)
 * @param	{String}		id		the id
 * @param	{Hash}		opHash		a hash
 * @param	{String}	[index]		the index
 */
ZmOperation.addOperation =
function(parent, id, opHash, index, htmlElId) {

	var opDesc = ZmOperation._operationDesc[id] || ZmOperation.defineOperation(id);

	if (id == ZmOperation.SEP) {
        if (parent instanceof DwtMenu) {
            parent.createSeparator(index);
        }
        else {
            parent.addSeparator(null, index);
        }
    } else if (id == ZmOperation.SPACER) {	// toolbar only
		parent.addSpacer(null, index);
	} else if (id == ZmOperation.FILLER) {	// toolbar only
		parent.addFiller(null, index);
	} else {
		if (index != null) {
			opDesc.index = index;
		}
		opHash[id] = parent.createOp(id, opDesc, htmlElId);
	}
	var callback = ZmOperation.CALLBACK[id];
	if (callback) {
		callback.run(opHash[id]);
	}
};

/**
 * Adds a deferred menu.
 * 
 * @param	{function}	addMenuFunc		the add menu function
 * @param {DwtComposite}	parent		the containing widget (toolbar or menu)
 */
ZmOperation.addDeferredMenu =
function(addMenuFunc, parent /* ... */) {
    var args = [parent];
    for (var i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
    }
	var callback = new AjxCallback(null, addMenuFunc, args);
	parent.setMenu(callback);
};

/**
 * Removes the operation.
 * 
 * @param {DwtComposite}	parent		the containing widget (toolbar or menu)
 * @param	{String}	id		the id
 * @param	{Hash}	opHash		a hash
 */
ZmOperation.removeOperation =
function(parent, id, opHash) {
	var op = parent.getOp(id);
	if (op) {
		op.dispose();
		delete opHash[id];
	}
};

/**
 * Replaces the attributes of one operation with those of another, wholly or in part.
 *
 * @param {DwtComposite}	parent		the parent widget
 * @param {String}	oldOp		the ID of operation to replace
 * @param {String}	newOp		the ID of new operation to get replacement attributes from
 * @param {String}	text		the new text (overrides text of newOp)
 * @param {String}	image		the new image (overrides image of newOp)
 * @param {String}	disImage	the new disabled image (overrides that of newOp)
 */
ZmOperation.setOperation =
function(parent, oldOp, newOp, text, image, disImage) {
	var op = parent.getOp(oldOp);
	if (!op) return;

	op.setText(text ? text : ZmMsg[ZmOperation.getProp(newOp, "textKey")]);
	op.setImage(image ? image : ZmOperation.getProp(newOp, "image"));
};

/**
 * Takes a list of operations and removes any who have a corresponding setting that's
 * not set. Also deals with the fact that you don't want a separator or a spacer unless
 * there's stuff on either side of it.
 * 
 * @param	{Array}	list		a list of {ZmOperation} objects
 * @return	{Array}		a list of {ZmOperation} objects
 */
ZmOperation.filterOperations =
function(list) {
	var newList = [];
	if (!(list && list.length)) { return newList; }
	
	// remove disabled operations
	for (var i = 0; i < list.length; i++) {
		var op = list[i];
		if (!op) {
			continue;
		}
		if (appCtxt.checkPrecondition(ZmOperation.PRECONDITION[op])) {
			newList.push(op);
		}
	}
	// reduce multiple consecutive separators to the first one
	var newList1 = [];
	var gotSep = false;
	for (var i = 0; i < newList.length; i++) {
		var op = newList[i];
		if (op == ZmOperation.SEP || op == ZmOperation.SPACER) {
			if (!gotSep) {
				newList1.push(op);
			}
			gotSep = true;
		} else {
			newList1.push(op);
			gotSep = false;
		}
	}
	// remove separator at beginning or end
	if (newList1 && newList1.length) {
		if (newList1[0] == ZmOperation.SEP || newList1[0] == ZmOperation.SPACER) {
			newList1.shift();
		}
		var i = newList1.length - 1;
		if (newList1[i] == ZmOperation.SEP || newList1[i] == ZmOperation.SPACER || newList1[i] == ZmOperation.FILLER) {
			newList1.pop();
		}
	}
	
	return newList1;
};

/**
 * Adds a "New" submenu. Overrides are used because we don't want "New" at the
 * beginning of each label.
 *
 * @param {DwtComposite}		parent		the parent widget
 * @return	{ZmActionMenu}	the menu
 */
ZmOperation.addNewMenu =
function(parent) {
	var list = ZmOperation.NEW_ITEM_OPS;
	list.push(ZmOperation.SEP);
	list = list.concat(ZmOperation.NEW_ORG_OPS);

	var overrides = {};
	for (var i = 0; i < list.length; i++) {
		var op = list[i];
		var htmlElId = parent._htmlElId + "_" + op;
		overrides[op] = {htmlElId: htmlElId};
		var textKey = ZmOperation.NEW_ITEM_KEY[op] || ZmOperation.NEW_ORG_KEY[op];
		if (textKey) {
			overrides[op].textKey = textKey;
		}
	}

	var menu = new ZmActionMenu({parent:parent, menuItems:list, overrides:overrides});
	parent.setMenu(menu);

	return menu;
};

/**
 * Adds a "Search" submenu for searching from/to sender/recipient.
 *
 * @param {DwtComposite}	parent		parent widget (a toolbar or action menu)
 * @return	{ZmActionMenu}	the menu
 */
ZmOperation.addSearchMenu =
function(parent) {
	var list = [ZmOperation.SEARCH, ZmOperation.SEARCH_TO];

	var menu = new ZmActionMenu({parent:parent, menuItems:list});
	parent.setMenu(menu);

	return menu;
};

/**
 * Adds a contact group menu for creating a contacts from the contact list
 * @param {DwtComposite}    parent  parent widget (a toolbar or action menu)
 * @return {ZmActionMenu) the menu
 */
ZmOperation.addContactGroupMenu =
function(parent) {
	var contactGroupMenu = new ZmContactGroupMenu(parent);
	parent.setMenu(contactGroupMenu);
	return contactGroupMenu;
};

/**
 * Adds a "Tag" submenu for tagging items.
 *
 * @param {DwtComposite}	parent		parent widget (a toolbar or action menu)
 * @return	{ZmTagMenu}	the menu
 */
ZmOperation.addTagMenu =
function(parent) {
	var tagMenu = new ZmTagMenu(parent);
	parent.setMenu(tagMenu);
	return tagMenu;
};


/**
* Adds a "Move" submenu for tagging items.
*
* @param {DwtComposite}	parent		parent widget (a toolbar or action menu)
* @return	{ZmTagMenu}	the menu
*/
ZmOperation.addMoveMenu =
function(parent) {
	var moveMenu = new DwtMenu(parent); //this is a dummy menu just so the drop-down would appear
	parent.setMenu(moveMenu);
	return moveMenu;
};

/**
 * Adds a color submenu for choosing tag color.
 *
 * @param {DwtComposite}	parent		parent widget (a toolbar or action menu)
 * @param {boolean} hideNoFill True to hide the no-fill/use-default option.
 * @return	{ZmPopupMenu}	the menu
 */
ZmOperation.addColorMenu =
function(parent, hideNoFill) {
    var menu = new ZmColorMenu({parent:parent,image:"Tag",hideNone:true,hideNoFill:hideNoFill});
    parent.setMenu(menu);
    return menu;
};

/**
 * Gets the tooltip for the operation with the given ID. If the operation has a shortcut associated
 * with it, a shortcut hint is appended to the end of the tooltip.
 *
 * @param {String}	id		the operation ID
 * @param {String}	keyMap	the key map (for resolving shortcut)
 * @param {String}	tooltip	the tooltip override
 * @return	{String}	the tool tip
 */
ZmOperation.getToolTip =
function(id, keyMap, tooltip) {
	var opDesc = ZmOperation._operationDesc[id] || ZmOperation.defineOperation(id);
	tooltip = tooltip || opDesc.tooltip;
	var sc = tooltip && opDesc.shortcut && appCtxt.getShortcutHint(keyMap, opDesc.shortcut);
	return sc ? [tooltip, sc].join("") : tooltip;
};
}
if (AjxPackage.define("zimbraMail.core.ZmMimeTable")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the mime table information utility class.
 * 
 */

/**
 * Creates the mime table class
 * @class
 * This class represents a mime table that contains utility methods for managing mime types.
 * 
 */
ZmMimeTable = function() {
};

// IGNORE means the client will not display these attachment types to the user
ZmMimeTable.APP						= "application";
ZmMimeTable.APP_FLASH				= "application/x-shockwave-flash";
ZmMimeTable.APP_ADOBE_PDF			= "application/pdf";
ZmMimeTable.APP_ADOBE_PS			= "application/postscript";
ZmMimeTable.APP_APPLE_DOUBLE 		= "application/applefile";		// IGNORE
ZmMimeTable.APP_EXE					= "application/exe";
ZmMimeTable.APP_MS_DOWNLOAD			= "application/x-msdownload";
ZmMimeTable.APP_MS_EXCEL			= "application/vnd.ms-excel";
ZmMimeTable.APP_MS_PPT				= "application/vnd.ms-powerpoint";
ZmMimeTable.APP_MS_PROJECT			= "application/vnd.ms-project";
ZmMimeTable.APP_MS_TNEF				= "application/ms-tnef"; 		// IGNORE
ZmMimeTable.APP_MS_TNEF2 			= "application/vnd.ms-tnef"; 	// IGNORE (added per bug 2339)
ZmMimeTable.APP_SIGNATURE           = "application/pkcs7-signature"; // IGNORE (added per bug 69476)
ZmMimeTable.APP_MS_VISIO			= "application/vnd.visio";
ZmMimeTable.APP_MS_WORD				= "application/msword";
ZmMimeTable.APP_OCTET_STREAM		= "application/octet-stream";
ZmMimeTable.APP_OPENXML_DOC			= "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
ZmMimeTable.APP_OPENXML_EXCEL		= "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
ZmMimeTable.APP_OPENXML_PPT			= "application/vnd.openxmlformats-officedocument.presentationml.presentation";
ZmMimeTable.APP_XML     			= "application/xml";
ZmMimeTable.APP_ZIMBRA_DOC			= "application/x-zimbra-doc";
ZmMimeTable.APP_ZIP					= "application/zip";
ZmMimeTable.APP_ZIP2				= "application/x-zip-compressed";
ZmMimeTable.AUDIO					= "audio";
ZmMimeTable.AUDIO_WAV				= "audio/x-wav";
ZmMimeTable.AUDIO_MP3				= "audio/mpeg";
ZmMimeTable.IMG						= "image";
ZmMimeTable.IMG_GIF					= "image/gif";
ZmMimeTable.IMG_BMP					= "image/bmp";
ZmMimeTable.IMG_JPEG				= "image/jpeg";
ZmMimeTable.IMG_PJPEG				= "image/pjpeg";				// bug 23607
ZmMimeTable.IMG_PNG					= "image/png";
ZmMimeTable.IMG_TIFF				= "image/tiff";
ZmMimeTable.MSG_RFC822				= "message/rfc822";
ZmMimeTable.MSG_READ_RECEIPT		= "message/disposition-notification";
ZmMimeTable.MULTI_ALT				= "multipart/alternative"; 		// IGNORE
ZmMimeTable.MULTI_MIXED				= "multipart/mixed"; 			// IGNORE
ZmMimeTable.MULTI_RELATED			= "multipart/related"; 			// IGNORE
ZmMimeTable.MULTI_APPLE_DBL 		= "multipart/appledouble"; 		// IGNORE
ZmMimeTable.MULTI_DIGEST			= "multipart/digest";			// IGNORE
ZmMimeTable.TEXT					= "text";
ZmMimeTable.TEXT_RTF				= "text/enriched";
ZmMimeTable.TEXT_HTML				= "text/html";
ZmMimeTable.TEXT_CAL				= "text/calendar"; 				// IGNORE
ZmMimeTable.TEXT_JAVA				= "text/x-java";
ZmMimeTable.TEXT_X_VCARD			= "text/x-vcard";
ZmMimeTable.TEXT_VCARD				= "text/vcard";
ZmMimeTable.TEXT_DIRECTORY  	    = "text/directory";
ZmMimeTable.TEXT_PLAIN				= "text/plain";
ZmMimeTable.TEXT_XML				= "text/xml";
ZmMimeTable.TEXT_CSV				= "text/csv";
ZmMimeTable.VIDEO					= "video";
ZmMimeTable.VIDEO_WMV				= "video/x-ms-wmv";
ZmMimeTable.XML_ZIMBRA_SHARE		= "xml/x-zimbra-share";

// Formats for text/plain
ZmMimeTable.FORMAT_FLOWED			= "flowed";

ZmMimeTable._icons = {
	doc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABgxJREFUeNpiYMABGEGEZsjk/1glfv78+X/z5s1wQRcXFwYmGMfX15dBSEgIzP7z5y9C4vefPwxGRkYQib9QCZDg+3fvwCpB4N+/vwwAAcSA01XYXASWALkIxIC5ys3NHWj0bwYWmAphYWGGf///gwX/Ai2H6/j58xdc8C/MVeiC//79ZwAIwBcVIwEIwjAGXuEP3Pk7PkxGEttyOT0FO3VIkzRZRrKa0C779gsikTiWO9sZ0IM6ao2sO+zILOUZ8FmMOoCp4H3gjOj4EHg3YUuWztboQO9G0mIUkOOJdAlAORmlMAgDQXQt1p6nhArVUs/WgwX8sWD/vYUEVBCNRZtJjI1UKM5XxNlkd15Ce+XtiVQpPew9wf/HYOEwYfj3925AnHNq23ZlvicJnYJAh9E0TbqKFWa8ASs5DPTKczqrqz+OJq0fcEVRUFVV+idjbH4KJurNgrIsqa5rve6lNAxmLpsF1yhStA1A7KxPWOBtFDyzDMPpdRzfNFsYQR0fvjsgdAnDpWfsTNZsSskTQkxHFZvbhtuzNYOD7LvHRwDWqiAHQRgIruiJhEdwk0SIH5Azn/EPPsgHkHAwHuXi0R/IB7iRUNm2W7YIxSbOgSYFdru7M1NS3HNYjvBnvK7njbekPeHPVW/1uCzjV6AREH9Iz+iVbdu6K0CrmWpjGhi/eQz076WNqsGPw+/nPYwjDEMoyxI6TTOOU56TfJUzaTIj4xaJPYeiKBZbQcYmVUOBQfglqOtaVkBeTzikqalAJjWBwWhhNQEq0JROhsaCEnptcsCSYMKdixXyx2F4WZZJVnz1WLu+YO+s20DM3Du8x1EUQVVVqy3cJwnzk7GLgnSAeDfNTZ3OLtHsUVusFUwVwE6Oz20Q3OM4vnwEoL6KdRqGgaiTOFKqDFEZ+IHCRKWARBcW2uTH+LCiwJyFjS/IkhVYCsLcOTiJE59rNQoSJ1WtVOk93/PduzP7k06eyYtewOxufAAvZjq8dOfZze7/E/Dry3PGOZ8E0jSl6FVqUzOvWEV1XRdJkmxPBZfWjFatdXPzOVsuPfLoaG5o08ciDEO2y7IRuLIakqAsy/Z9QZ0cJiF73O+N4IrAnyJLEAQGs3PM4JhUWBgozWQC1BgfPF21NBFFUTfRjATMjQDjDhZKqlrMBF2pnixRtFhIYmrgOEvkw0WqV6p2MriDcQb6yHQiQFluNxvrRZrBHTNAzWVPDIY+h8yu1msts+FGQRKoJUrdAT7NR3fQqyIzOJGBqhYV2Ew5PGdtpWgCV//5pHExZm0iBPh4fxtIpIPLDL5gVTG5Ypqm7KkopNfYIo5jAly0BM8Avh02EUqT5TnZRDZZ8Pfh8NltFVVVPXiedy9+penvQuK7GybtVqctWGK0E2FcrFY7/P4RoF2r6UkYCKLTpBxIk7aYQFDCQeQmiZjguTGB3yX+LBMPeulVzxx6InhCPKA0wbjuEtruLi2dXeoHxrlAaAlvpjOz781g8O5ShjGkLx78brundGgo8y72wRXsl10zR6Iq8GD/zPsW1rX3tPHfAYx42pX6FmHxdI2ktFRJdrJrr/P5XbPZvNRWBOyQHo1Gq+HhLlamxOqk3YYyO9wRwOPjFRQoY9rUMwiCwqI/Ho/hqNGAzmknF3jswAfRd4CPepYuwabKzZruLt4WwlYgC7g8rTB/Osc5hQoEAZwASdhFUQ5Mp1PwfV/pO73eBVQq7ga7zgcuXivEAabb5FTCdBVe5+GB8wTvC1JItR0m4JHAo3uLrAGdFGJ7Tcd1hRrAAJdXZmYREbcdZzXQVunjkJFCecBRqlLFmBLSBi4NT4mkSDHvTZ2I85FjnYPJ5mhehbWzbhdcxxW0fOLgNuCaRcwXp/zYXZrL/cEAFXE+xwn/CAgSOEiiWKuryK1PEXh6QZKNoUYacOnnsx3Y1g6r1So8r6ctt4htCMYoG5ZSaDtw4SQOwxBs2wbDMFB9nNJYqNcPYfI0gZfZbLXmgZx/BYiYkvsO6CFYq9XW07h84PzoT5hKUEb4YFlW1yyVuNRQ7yrYPq6aKhHw5fKdbUMfW63jc/gL9gktYa1Fdd0eFQAAAABJRU5ErkJggg==",
	exe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABrdJREFUeNpiYMABGEHEWxmV/1glfv78CZf4/ecPw5/fvxlYYAKbN2+Gq3ZwcGRgQtbu4uICpv/8/Qsx6svXr/+/f//OcPDAAQZTUzMGVjZWBoAAYsDpKmwuAksguwjiwl9Al2FxlaOTE8NfoOVM6EaABEEYbBRI+/cf3xkYGRnBgv/+/WcACMAXleMACMMwS2yd+hKYEAtHJ3hyga0S/KVz9yaUIEACQaYMtmM7n5V8jdzOqvIXxMzgY3l365yDUgree3TGYF2WVKlBJALTg7CDQwhC7PsB8zzJrrVGXhR3hpOwf2609mWpbtrkhsTa9SOKlBTidZqYRPEE8hECmwBiIBUwkhKkQHCAiVQbWAjFATwegPgPLAngU/wLmN7//YUExufPnw+wIEuC4oCPjw+e4uzs7RnY2djAiv/9g4QWih/evHmDkmkOASMSrvjff0wNV69eBdPuHh7AyLIFs/ft3QuPFwwNiFzxk+HihQtgtrq6BlwxCKP4gYWVFZypD+zfDxfj5uYCKwTFOiii4aGEHBogZ3BwcDCYmpkhFANVf//27QDj27dv/7Oxs8MV/0NKS8iKQWnp188fjQABWCtjHQRhIAwXMcFBFuAFYITFAd7PByNRR0zQyU03I5G50A3khMPaItjoJaUFws+1/e4vVtyx6Vbkz2Ffz5pySSuGOqvKbMNleTn9JAJG8MSAq+eqaZTSdyymAin2PI8EQfBRGJmrGwAk0xsSnArTNHvkoAGf0BcFHd8DyFQMy7KkZ2EUveoR7Y/3yKEZiNmDcBhG/VLEcSz9CNyC99OyaApnbInueU72STK5RKIwjhkrt/MxKg5p+tUesJIRY2HIp0E9cO6MUYGmYzsO8X1fyhiF604fZqBhFrcs2+gzndQtAv1H/X3n9YTrCb4XxlWL58513fVDAFrMZrVBIIjjExV68WLBvkCKlwZKSHJphLT07DO1r9C3kVjoSXvtAxS91JMHk4tIlKYzJit+7Gqa4MJGDfpbZ2dn5r8OHcgwZC76wmQ3lRD+MdDLF9mZAu1xyCkaPJsOn673sykoinIRpFy+9R+An28YoVTca5p2Nvygdn/rafrYrzVtdNEUdcGZVSfPDakg3/eLc8uyeuFsgE4LbNuGJEmKzuBMXBPcdd1C4HUNIPRBVaH3tWfcKPEGuNF1sQ9WmONPaYZhCCw4Iw545TJDSciHdzjZ8zxAidiy6Ar1JAGc9br8PwgCiKIIZvN5q6oJLWjCqTE49abPSP/wSqZwAFqGi0V9s/GJVtGD2S6DOI45NZlf3YRxoOt67Ro3IPDuOK377nHPx4N3WkBBtNluTw5APlzgAxahiiz/K9k14cwCRZRbyKmmaZbO9TBq0zQt7ntYLkGWFcjzDI+yEF5YgNCNKHFVV46qquVDBCdQN/zoZAS/YX/pS1x3k4lgKfLhO1xtpaoIw/BVkqQV9vJ7w0ElV7WR4FgpMoyfo4C7HY+f6PxPgG6tZSdhKIiOApHCxoQNibCQEllBZCVhI3/kJ4g/RpS4ggoEgiEhrJAdskANCKTXO6OFtvRdEq0naSilTc9t53VmONI4WCpbRaeFv40HXg5V9XUXHriFYOEOF6K42Q0ED9fqOHEKAcUxBByBXwBlgrX0CH5K30OAEgXTSU2d/FT/9sFLDEinIfzbT9AtcU3v2k3Z7kq3djowHo81x5LJpKbG8kp8uwCZ+V8AyoVIJEKbugY2qjhRAeBvmI0V4vgdt2hUcExcpwG9LQCJ1+t1urmba1AnGToi17alUol6wHbEd2WGjyiEtcihQQ1tM4HHQHsMHCpLM+CoQK8Z/KBQKFA56oz4zl88mxAOp5rNpuUCi8UiRAWBbobTvk67TbrFCK1WC/L5PLX/9k1F3frb7TMvPuCkuYzidttYlr+fWvTkBK64jT9J0p6iU9Dr9VQatmJKXD8yc7WARCJBjmvVU5jNZlx6riCETSdVVFkslqbkFaAZoUMzYKbELTWZHcrl8nZ/MBjAcDg0PK9Wq9Gnkt3tiJ+lUiCK4s48mPXTZ37CqJKAQg7aenbEFaCJOSGr0ZNu34A6czYaDTKVQ2E0GsF0+gp5Ho1siYNOFHupVXCuMn+bg8QjkcAjDU68MQlhtOl2u/BuEm1wOn6Ry9G5S+4T/ec+fC6XRDwej+81NYyIM2bQyjdqAvqpVdA3XnS1kGLnrk3FhDhOUlDY0xtYrVb3/OaV7X8gfBRZiKyYJbKb9Yauo8ji2Dmtiatbf5quxGQyacdiscvwT2HmhbiTBOSX+Bofiix3MpnzIvwHfAEfFY7czGOf7AAAAABJRU5ErkJggg==",
	generic: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABulJREFUeNpiYMABGEFEfGLyf6yyP3/+/A/CR44c+f/l69f/Hz58+M8Ik9i8eTNYkaCgIIO+vgEDE7JOFhYWBmVlFYY/f/9CJH7/+QOWMDAwZODg5GT49+8vA0AAMeB0FS4XMYIsRnXhL6DRv1Etf/PmLcOuXTsZ/sIsP3bsGFjw9OlTDHb29mAJRojnfoFVwgT//fvPABCAT2q7ARAEYvfBF04gA+gCuDUDsYQMYMJVegYTooHA9aeX9ME8kp/jOPZtm5IUKgJejNn2l1J6MedseJaCphuDu557d8qo24LEeJgHRu6+TV6yhmAJsAK/eDPLBQDPP2DFWtW6qaqCRqBuEtGQRJh8yC2AGEgFjKQEKRAcYCLVBhZCcQCLB5Af/v79g5mawAn1928GVlZWMPsXkP3vLyQwPn/+fIAFm+IdO3aANahraDBcuXyZwcnZGRhikNBiwqXY1NQUrvjdu3fgoEbRgK4YlIRBivft3cvAz8cP9cd/REyDFPv6+jI8efIERbG9vQNcMYoN2traDB8/fWJ4+fIlVsWgWAdFNNwGGVlZhkMHDzJ8//6d4dmzZ5iKGSCYEeih/6xsbPCg+4eUlpAVg+Lh188fjQABaKuCHARhILjaCwkHvXLkGySa8DM/Yoyv0ItBEw148hdy5ALlYsBOS6EgyEFsQtgWMrvTzk51xz3gDzTx2O+2M815cvCq8GBOfx616/4CAg+WMjD6uRBPmqaf0h4EqYSJAb2dhGw457Xr+75fA2vNlUIAowy6wIix5nkeWZZFjDHiQnq365VW67WcS0cVCbLsC4M+YJgogCFBdAsqxyVwjyL5H5sztU3UsOhloKvsVgzgMGyA0Tgvsf9wadu2DWDlpzzj/QwAqA9Px7pitC2A0bomsDY5MpJgvZcBgI+HQ+0JjuPIwxuruHsb5JyfWwmG5JYkiYyXi6X6PgJcVuXmeZUA4xnHgTwkJYEWTTknpQwy3q3714gLJc+L67qbtwDUWE1Pg0AQ3ZIm1QtQsQc12qR4t9rEJtJErf1h/q3iwfRY4MCf4EJCD3owqUY6b8NXESiLqYmbECBs3uzMzrx5C/uTShbshXWHS2R3LYGQ9rR4TqB7J7v/b6CtDwa8Qn8zvsMwlVrZ1EUW+b7/qijKQ1Nw3peheLM0HV1H3W5LKES2bSc9YBd4XIy1Y7MgHnojnTKgkIKP8J7k43DIjnu9QgOSCDiAILXw3o4k1yEdU1zX5d8bGciC014l4NPplG+lMZnwedZyKW6gChz9wKE9ARCOZzEJhmGWXSsM7ALHPtyOx+yd5oDOVVXNgVd4UBccSJZl8Tq6orn5HlFqIAbXNK0WOPahuAEVGAiCgN/PSQ0jOzCagZd4IMtyUkQX/T5/NudzYfBSD+LTzYtpsh4VDxo8ssQwDEHwEg+w8jsCg1xBWNSuym5GI35wEAGPPdgiuyy3rIIVcxyb5f88iICfnZ602l/R34k8cWHlT7MZaZsPvnpFVX7keRV4EiIysKhixc5BpxH4ev2ZqgrP854lSbqnKxJWkfbZ0kYl92SxaZtBVC51/RHPGwHas4KdhIEo+AhNSGi5ksYDEUQ9aeTilRg+TP0xouEK1QQ4wEmkYJBEE6lawIg7a3fTVtCirYrxJQ2b7oF52919M/NiPslzxH6K9LvjlNGhIz/vwotDWq04RiLimBVp9aL4Laxr5WnjfwJBxNNXqW8YIWwtj9T0yU/33L1lnTDGcKD89AouC1xSR7fZHXaAKMDTAHHjZvr2Nm05Zi7mut0u512TyYSTuXQ6zR8lrnwIXCbwPAs/AT9woUlADvEOc8K0ccf1YEBuHxaeyyLg7socWgIfARdWFv9DtuL7TA9pqZTcKpirVatwxanZbOJM0s7u7mLLZUbhbKHPAh/djSRFz2QyfHuBTRu1Glcww+GQbm9uOQl7C9yblPJTwAW/1R2LzmKrD/AiwCLnA5cZLZ9AmMChAjRN48CFvyjm0JZKJBLSEvQAd8azZc9Au92mVqsVOXBVU6UZPQ+4v2UWKAGAFOCTySSVSqVXm4/JTlyJ3wncLz6UoFtHBNwUUYBwj4vAPf7gCMMogfvHgRKAgwA9ji+BAnTR6TDBuEZ7hQLV63Xq93ryiR649xAH5kLj8ZgqlQoXsIgU2yrwt+LwJ+dUTgA3DGMxcPokcCfQKNhgslIJylWgZ9FD6ZkmNRoNXnTK5bIEh4TQIRpZFgfvtgJCWXEx8nn2yrIkCx14lHp0Ri7ZVur3r8i2Hz13OELXdcrnN9kXikcC3FOJbdvmezwWiwVmh+i9rWez/Hm35IcM3G39eVwJ0zTPVFXdUxxvKyitXcxVogE+nT6hG3qey2UL9BfiBR/sp5wwcmsxAAAAAElFTkSuQmCC",
	image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABo9JREFUeNpiYMABGEFE1VqL/1glfv78+f/WrVtggb///jEoyMszMIE4b9++Zbh58yaDopISWPDPn78QHc+ePfvPx8/PsGf3bqDgHwYbWzsGFpDEn79/GXZs3w43/9+/vwwAAcSA01XYXASWQHYR2FigHXJAB4DtUFNTY4A4+xfD7du3GP4C7WSBqTx69CjDu3fvGOQVFMASYH9s3rwZLAgCDx88ALrqPwNAAL6oIAdAEIZ58Af7wPyB35evyDPkZFxZl0DUiBCykHRd2w0jGZ0YobL+ggD48+q3Z8sYReQBPN2RXTblvIdWuKT5i7EBU9rir7qEMXs3EHiPvq8AFg2UFpKOUkBG7obr5miCyAivzQNdVAEoJ5ccBmEYiJoKWOdI5QA5FOfqhmWOA8qmgNqQmchVAkhVLHkTWf7MvEhtNDWSxpgetRPafx6ko2FCII+kCY85UXlAHWOMgGjv/fSTFexba4vibd+jHx95RfSfw0C1ihsAG1KLl3mmzBSUEp+M0wna2TlXmHeZoFN0jSuANyshzsXphxJXqfAhMJv4o0LX91wDB34zlrACO0tiaVvf4yEAbdWSgyAMRIfPQeQGXkEIJ/BCrjwWpRvizhOIkYXsCYEEF7XTMAWKRaPYhNA29M1Mee8NKe4sX1tYeRz3J4dKWB28T5y58OehLeMXEDQCRYORnlEPdV2nM4tBb8qy7OtgYRRpzglJAN/2IbKccw5VVU1Yb8v4kudwlQ+yCsRAbH8pG+wTtqvoHh2kjKn9XRiqfa1JEJ8FiGS5BIx6pYxNZbEkkU69GWkYtBb8dz/vlYvbms1Y89R4rAEo4ziONSvosL5jGMCK4jZ4BHUDIaY0tdFtCRiMeY+rRts2qUMZ38uSea6nDoNRplob10D+JGA+RyZJYB4EweEpAPVVz9owDEQVYbfdTDrZoUNDCl46pIPntkvzt/qzvJWSQgJebEjTxWBI8RCv3dJB1anRhz+kKAkp9OCIksC705Pu7gn9SSXvOQttLaXN7g5DQzpR8qyBnrzZ/f8AzpV3ixzHOQqEECKFFq8N9mWOelVVvXie93AoOJvLoBaVguR+2e/3OucBuG3mbOhvyxeeCWoAoZpVO2bYAOj1cGgOABaGoXgm2NICb5kmRdoArPHRbhrHMVtHUYR83zdy3pRo/DftNS2KQqyTJOkEr9brGhgh9XlgDEA7oaz58bgFPp/NUJZl8NxTdtBu3VqKXNcVg74J/r5YgNpm/30sl+hrKwyImAUWFOkOFGiBrFWj+gfJSWNJEQfP0pQdNhw6ONBi1Me2FHHwsiyFcjABy1skFYV2B1Cdn6uVALeS9jWKduwAthkMBsgPglbx1F0e6Nt02rkDp0kLWJ7nzPe1s/OLGjgLwOUhvy1Pk8mOrLvlSjNzThGmAV5NLfdQ8M3mW6oKepjPGON76mJ4EML1EddGms/WkPkVzTej0SOsfwRoz1pWEwai6BXcaFRwYzcVqUgjcdOuXEq/rO2HCe1WrBaDBbsQgimRuggW66OWpnODE2fyqHn4qKUXghJluM+Zc87EbJTnhnzU4HfbPYFDN3bchS+u4bjsFgOhc1yD47PaXlDX0cPG/wD8kKeo0HcbRmUtjmra6Cf72/tkcpfP56/ih85gUMftRGRjANPpFOr1+kGCq1arkEqnHcSfqhC+ApjNZtZ3UjLziZpx6xRmskuzrhE0ShHp62gEQirlqlxsBIxulkwmrRsGRKeodI/HYxN/Fwkrs98+hGkVfXWBQrEbR2s4mAHBA6DW7/eh2+1y74bDoRkg1d7C9jgLBZ3/XyOijcRvl8OJLKjZbJqgTJIkE1ivnTIcFeAdt0oRPgBsF5wFrAIOOX2H7HZTxtFxXdettZ4IrcPnlKxXKpV4/sINLi8DGhCxAtj3SGjZjKNO6eW4QjjSc6/nuZ46GMCEcFW8JWIjcOqXvN4X30arfCwW0Gg0IJvNglguc46/EaceVu0ShN8xNXANwjAiBkBbRe50LPaJ0r+iKJBIJECqVMyMUwXAvwbkr4UgbAtRx19UFWRZ9jw7MOuB9SuXCNwk8NBDjDeZmqZBu9XazdbFapWOFnJIFP4C+FpRfUr3d2l4KOLDtxDvuGH4hNN0V8FdoVAo7B0H5XInK9jCan/OUTErMJ/PIZPJQCwWc93HRbEM56L4Izq0YxXnyek+hJ497pFxVvrjVAlVVduCIFzEyf4OAWDtvh1fLj/xNvSxWDy7hL9g372EhOmMs4Y3AAAAAElFTkSuQmCC",
	audio: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABjpJREFUeNpiYMABGEHE+vBN/7HK/vz58z8M79u37/+HDx/+MyEr2Lx5M8P///8Z/vz5ywCX+P3nD4OLiwtE4i9UAiS4Y/t2sEodXT2Gf//+MgAEEANOV+FyESPIJagu/AU0+jfC8mPHjsEF//5FchXINbt27QQLwiVAKt+9e8dgZ28PFvz37z8DQAA+yBgHQBCGoo3xAmKiF9DBFa/PyhFYOYXdpJUWjcYQOkBCPr/v/3YllenlGDfTFIlzhsgYd+n/JDIhBIgxwmAM7NZCIgLOH7uao/celmV9qz5LsPOb+qkeEVUktTjnYJ4mFZbQqSAdiEyJ9OFZTUzKzvkWA1ZohksAMZAKGEkJUiA4wESqDSyE4gASD//Arv8LDBRGbHEAA58+fWLg4ORk+PcXEhifP3/G7SRQPjh48CBcMdgWYFCx4FIsBIphY2OEYnAQ49BgambGIMDPj6L4HzQ+MJz06/dvsKIrV64w7Nu7F0UxhgaQ4tu3bwMV/WN4/vw5JISgisEp9j8DwkkgxW/fvGG4d/cug4WlJYO9vQOqYgYIZgTmqP+sbGyooYHkDOS88Ovnj0aAALRVSw6CMBAd2y5INMAVuIEL2GvYm3gjr+MN2Pg7gRxAt7pkQwjRCHZaBgtEA0aHkJY0ffM6vDclxx3lMIUfx3K9GNGZfw5eEd8x+HO8bRlDAhuBkoHh50K+aZruxbegURTBXSoDFe37QQOYNIfy6p0gyzLYSOGa4QcBnE8n1ZlMYFQczXsniONYjWEYAueiZozxqIxbA0M5LAHVGBkzxjqMyegvYKi9IPr/PF1TZLs1SuW6ruF1AtZzTCg+Ad9vN5CX/KtTKqcWMJvNIUkSGE/GslzccG/rNmiXqC03LIdlWZDnuWLq2I5ek4/t2Jpl2QUuCZ98gHG5XneccbUZyuYx1Xd15YMxAq235nhKCXzwPG/1FID6sltNGIbi+LH0ZlCMbl4WJjjp9W7mzazVJ9uLjeED6EuUXlgo7K7gPlxO1sQ0TZa06sBCaVrK7yQn5+Mf+JdMbtkLnSObFrtHDwvShSbPCujFi931G/DJtA++758E+a7qUD0Pfse9PM/fCCFJVzjry19Kbaru2+Gwd5KLuBTSwXkydvJNmqaifJvgnQxgB8NOJl+HcxnAM0lRFOL9hsrKsiytBpz3QIbHcQzP87llBdDeRffjMURRVJuhGd5iBRiKeMlws4FjV3MywONcB2t+A6WzWVwkJ5EMe6UnrGYUgbZteq4ZymHbzUYTpk04X4Fng+e7HTsEc1gYhooBE9yQBzIc5cknFQLybO9GI1gkCbxTVdEnAyNcuwLVLTJc3VAXODPAIbqq+DSbiR8xsf7a0Ca8chE1sKbwRFcVgyCA5WplCUU9fL//OKqKLMteqMhaoNA6yBqopo0MTzFZ8cZc+zCZLHH8I0C7VrOTMBCEp2k5kaAHaQ8YicBNTISTiQceTXwGn8JXwJNXa6JnMCFBDiQkmAieMKyd1f3pltChtgjGuUBYAt8MMzvffINljDzt4KEF2213AR1qm7wLX7iE3bIrdERUQQt2z1obYV07Txv/HaBIrRfX5xBQ318FImSt0KhpjJ/62ftsBnCzBb/AeDzmgzk2IinTCElBkwkjEg4koIxpGDLzbrfLdXE01JlQEI2LOBiPbME25wCKxyjA6sQ8RFK+ZQ8KcL0zZ+rAaDTiGwgU4FbZF6NYkIErmpFRCpnzlWnVWg2qlSoHctvpKGJFBh4+yzyFnFwOTut1KLquBCAjrqsDZODyIFsHGs0muAFoXUI1c1wn6mTgIu3SrgF9WcM/2LZji1PVAB24uTJz0gIejWq0OKdvU37vI4iDYhE01GTg5vDhpAVc3eMClirOl8GA3/269fv98KxHBG4+d9IDzkTYJShRnKibr7xKga0BPGERLwOOKeH795HpWXybyO2T4BbCvvDc68n3oq5ZKh3CUbmsFTEBOBhDcdKIT14n8OD7MQ1KFafneeC53pJUYWsBZwxoRRyXKjjxYxSXRZ9vRvb3EhUnFXioE+M6plAogGVZZFqLeyD8z4TM8eDAdmzumLr30weuS38hVWI4HD7m8/kz7JxA4ONJG9BPgc/nH7i5e6pUjhvwF+wTCBNICWzuLa8AAAAASUVORK5CYII=",
	presentation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABx1JREFUeNp0jMENgDAMAw2/MgezsG8W6SglD/qIkjQoICQeYMl+OBcDP5oy6rbG51VEIk1EcfQezBzzG1BVWNr8nkpazbC3hlIWmDuujyyTfMoxHKcAYsDpKlwuYgSZj+rCX0Cjf0Ps2Lx5MxiDBG/fvsXwF2Y5CLi5uYNV/vv3HyzBCPHcL4Z9+/YC3f+HwdrGBiwJEIAvKsYBEISBjXHzD8IEk6M7/puP8BDd7NnWQCIxQNou17vjGEfyc2Zty7YPQQCkZMptSVXTMcYGVG8vGOS8J4ilqWcLIVApxeq8LlqdE+9sy5ruR0Gj55st8pwzpXQQg+2xkKlKtqBfXIG3sKl0D4RRgh4BKKWCHIRBILhtsL+wB15ibXiY7+JA30EI9QVcSIw2KcquhSAmmk4g4bDM7s4M7EWzR9KIqd3bgf3zAIG74PyU2DpNCGstcM7pvcTAhvUthvd+YmWh1vrjjdobY+A8juQFqsVq05LjCCEEMYdNavzwc+l1Y02+fHVIM5fM6FjI5lUd0oJSSrjFHCHzse+pkJSKp62LlVJwGga4znNmTrLibZxzz0PXZelCkaWyGLO0PO6XlwC0Vb0OgkAMrkDCQthk0hgeADROGh1ZeSefy8S/ByCyEE2UQQcdWIk/C3g9KXqKRI02acpduLbX+76WGDdnpgU/lvZwXaEr/Nx5lvhEgj+LQOhvBRsB4Yf4nDCN43iqFB0gpH4qjuNwx4S5lAGgMIDrujwI2nvxfR90Xc+xSBmHYchBRkzABQVR3s0OyaqqKgRBwLVqGNC07VvGCM6EvtPPAmCNoygCxoF8z7KsG3ezGZA89FO0pQHK3mI8GgnrBh8HRLIXg6cMFTgmNE2DWr0Oy8UCer0+yIr8kLE4DY6Hg4iiIseb7RZWrP7YP+jxDFZ/z/PgfDpBp9t9cpxm6abEA5Tdfj+5IkC8Yr6XnRTt9Z/cGwVgKkvSzDTNwUUA6qumJ2EgiM7aJiatSYPIgYNRghw8cqgHlA9j5CA/Sn6XFw+EA+LBk5HEeICUCCkXEi41se4s0A+6220xmDjJpk2bvNfOzrx5C3/SySlnYdJ4oWJX3kNB2tHHMwHdudj9fwJ1/7wMqqr+CsQNlO26ZlkvPLwDmU6nj4ZhNLYFZ3MZfXhQplfrMJMhqVK0qU1x4O6qnVMPHNE7NGsFuhIRYGiaBsdU2Pj28NvLOxU0GI/HEXApwQ11gMEYjUaQzWbBcRzQdT2UFiQQpSjRHuCoxLVYLKDT6UC3240ARQlS9AGmq1QqLc0kDWqEJQR+zSZqANu2YTabcY5LPAJ/+CT6AyxF0wyfC/L5vIBgc7JJ/iBY57fNJsznczY2eZspGpvqNgNfIBgRRyEkuGu1Ih36Qc0Vnn5Qt66qVW7Ow+CCPeC1P9Y5gldrNXbafu73peDcMuWBY95fqZMzzQtQFAXqjQaaWhi8DaTgjAC/KE64nno95uL0A917VqlcwmTyKQFf3pDhcNg+yuXu41SR10QycMf5gsLpCWGuwrKsNiGk7pnYgBdy13bQe+57Idc3RyFPhHFWLF7j9UeA9qymJ3Eoil6ckpAwboBEbQ0ZMNGwowm6YMNPU/+LP4INi8kYMi4c3bEQFsTGjx1IjCQan+88ffW1tOU9REeMNyEU2sW5r/fj3HNToZFnj3816HPbb06H9sK8C3/s0mLZPhyRWdCgxbPGh7CuhaeN3w7oSK3rB23i1Pe/AlHVtYmSGho7ce+WdyNOOsl6L0BQ70ADC4WCLzTOA3hgENFldJKXgviaGpggZG3tkOBspVar0c/l5UjgvgOPzMwB8N6PsHQ6TT+4E2E2qn6TKadWlwRyJDF1aFqoQDsDrQOdhp4W5cDr82QeQjpvAxuodrstKCCsXq+L37BcLkeu64rTjYrxTCYTGC7igQfvzbWMNptNHzwM6xtpEBFbrRaInbKAYb5wq3JY3wkWGsdeGKO8N/MbiDPM38Ph0D+dTqcz8cwFd2BtdTUiORUGGnniQRmQmeaAToxn+cSG0STJoAE8RlWV8PAVAzy8MrPm2YBs2xZJ2Ot2qd/vk5xmUBqLxSL9KpXiqwp75fuMWCxwralSpydUKhVa4jNaVFWRUk5SHVeTczAYkOd5MgEmZu2ka8s0xhEiaGizNLVphkqUy+enAFenNAMHECqbW1uiHyS1/IvLSzFFS0Dj8VhcQ9GoVl2xAEhKTj+I4oBT8Np6awOSwG9GI/p3fCziHsC3d55lAJh37lG3e0aHh39ohVcgrNp1wiMKOGOkl8S6wO/uxnR09FcAR7JCv4DEoMa44zhkO7bo5NdXV+JT3tjgSe/MDDzQifGasWtLpVLG7BCnDCkVIZLnzDO+cz7TEZFHvR5Z4u0wY+Cq9BdQJXgVOMlms1WLkykyoLXTW/58QkUCv79/wDb0tFwuufQV7AktkUoIAneoIAAAAABJRU5ErkJggg==",
	html: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAB+JJREFUeNp0jDEOgCAQBFdjISQUvsMSH+RXeQs/uEhB7g4MGK1kiy1msgsMMrXa9rP+ipzzJ1gEwozlBUSEEAKcc/D+wNxgjBHGWqzGdCiqz9WVUm1zEe2wFMUtgBhwugqbi8ASyC6CuPAX0GW/IZZv3rwZLnj79i2Gv0B7wBKsrKxwlffv3wdLgI0CCX7+8hms4C/YVf8ZAALwRQYpDMMwEFxKcKD5hQ95QcBQ2r7ckJyTPxh/wvgUqZaC6CEkOq92pdlLJFejRF7TeCvi5qyOzGe2KSV47xWp0CuloHcOO5EuPkxoH4pYChH+WkrXIeeMbV3/yC2h1ooYI0IIeA6DOi7LjPfn265pCXaSdEQ7aTcWTUxKxYR8PIGfAJRTQQ6CMBDExotXeY9P4Kf9QQ/ihTf0JJ5IbETSQDCY2HV3G2pFjelcO9nOzsxmqVilWIooReoP638ZvHIA7uFHm5a4o7Xu4c3o+/63JMrFYngz2TnvlliSZmzwPihhpZQns8XgQxuGAaSU4Bs6QdM0YK2Fa9fBpW357WwMHOt6H/oda66qKshA3X5xgHdJRVGwJNJMIPIJj0NrjdXYceoUdHApdsMYk+XbnOtBU5mM7Ns4loLqG5Np8jcy7SuEODwFoK0KdhoEgujU9swVrtRDlXIwnNQLFxL5LD/Fz8CTNbEnkjYcwJjUq3DCW3swUvdNmS1F1GB0EsJuNvt2MvPeG1HcUv3O6I/jNb0Z9JZ0z+jP1d7qaVvGbwKOwTRo6LlSn+LbbPQfwMK5rSLAtw9EUURvijHgpEQcx1QUBV2FIftaWZbkTKdkWZYGBj9lPfpKmIhQgTRVgowB7rou09TzPM74McsoS1N+ZDI5YavofACXkaFhGOT7/qdSLBcL3gPovao0CEDH42Oazx8YAyYsWuhssoxZBEohNYZznDqOLgdKkRc5PSn5YhycX1zWwDvwzWbd3WQMHAG+VX0IgoCSJOEz0zS1Na2eVzy99hlXh9OgPdl+YoVuXiNLaq1rXNrNsfVsIFm/5Pnd8GjIl2m7v6T3teVR409y3lrDnxTwvW3b1x8CUF81rQkDQXRrPAilqD1oVahSS3KtBwsRarVSf1f/VcFSvzBgbwHpRcxFEBp68SRihXRn6q67ibF+kEIDy5IE3szOzsx7Q/6kkgPqRSZtdoUQBW8F5Dx258Cb3f83EL69ucIqPObhNbL+gNvzO80iSsCtaDRaORQceRkUr9imV+s8Hj85KkTbwFkxhoIC38kAkM1sNvNwhWEYCA5i2jnUALRsYLRut+v5l8lk0HNQWS+Nxv4GYMICPgDiAVZjz3Q6xT2VTiNApVrF91eq/L0GfOrANE1cQCoiq0HMh8OhJCQVRSEPtRp+azWbGFJ365YMgNfgvaZppFgsei7Utm3UxW5v2UmMXo8OO0vOER4DEHd4aB/fmC1sctoU71gs9sPr9od/iECegIqAywVjIjgzfpFKecDf+n28H1XVSBrvxydEolTBcI3HPM8ty5LizxaEZT6fkwKVMIlkQqDRLc3usV4nZzSDBoMBsUYjBPqkmj4SiUjgnXabjkpLopdK5BRmRwnc5wQsLLquk8tslmcGuxt3nt+Vy5hNbnB2gvC28ldVlYMBeFKQhwAA4LK6kMHxBHDEXXpLNpdzFZHzC7jDDXR2aVz7gi8WX2tVMZlMnug8dU/XSlgxEhG1kc/OneVvePHX+TxW37cA7VnPbxJREB4Cdkl2G+nFtpi1Fpp0FStL4ESiXOzfZb36V/ifKIcab5YG2hBNDITEXggXPNWwvu+xs75d9xdg2mKc9AValu43szPz5vteRn0GYsI4ES8tutvWFuPQSXDuwh9e03rZGzjCZdai9bPWjUxdaz82/ncgjdTaf/+WxOh7q0BY1vJRzQD9VD/7MZ2Sab6j3G1HcFHg3sRBIXvxOgD3HJg5N+cABNjxeEyVSkXODKsAV3fmlRzAhApgGMcwYKrsQTWcRgA8swpTzCy4NSQt6L7gtY1Gg4zNzVTAf48ZS6YQSANYCRvAN5vNyOuZqcDKBwfz2V/8lMpleRgCSfyTGMlhTyGhuSN7NHD/Z6kdAGiAZwNnA3BViQzm+DcRfTwhWFGQxbyW94Y4wzDkKc61YEHn5x2aTCZ0AcVSrJ2dXbKeWBHAPY+SHbh2DxCY0MBM0yTbtlMV5xdBJ9jmbGv2R45nc1myazV5zeXFJV1dffcWnHxerco0C8qATlIN4NH3+33vdxQgQKTtKgPB+39y9AVT8/hQTI5blkWH1qGUc6G+TkWv/3h6SnuC+oD+hB2ZRToAOgMSzPne6/VkCtVEtJA+Se3wqxL9fYXrxhUnSHWncyaBqzqF+WhP+U4MJwsa0gWLOw5r2Mj7er1Oha2t0HY4HAyIqdiuKEpN00Id4OsBuCMCxd9BykBcf7C97UY8TEleoIhZZIFUBLUfjnDnwNFBsfjQ18eZo8+ZbikSOKcKG9IMYr6uGzHAFyjiYI7f29iQnQfFDc6PPt7tduV6dXws7zAcDr1IoiVqeS20HbbbH7z/fb9QkC00m80lAyf/+9wyWz5uVEUnUndOd6Edsj12mXpYO3zxshWSEsnAHYfSFfGys8qzoyN/xJ2IPp74Ph64byeGdoQ8z2QyKw9Z0Tvn3wGuSn8+VWI0Gn3Wdd3OuTvrXQWOnduZzc5Kpf0a/Qv2C+rxFTGs7un2AAAAAElFTkSuQmCC",
	video: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAB2lJREFUeNp0iskNgEAMAw39d0EBPFLNoqWEaPlGOYAsxwvmYcWeAD8MPad5/xQi8go1g6lizMLMIKI+LqXAzC/xkJ8RAfNb5JHUuqK17ZSOQwAx4HYVFheBJZBdBHHhL6AjoK66desWXPD7j+8Mf4F2sqCrBAkyMjJCJP4A3X/79i2Gf///M/z+9YtBXkGRASAAX2SQAiAIRFE3bgxSCDpON/D+RNeoVTnT/xNKLWxABuQ5+p9dJb2yScs8/UIKGTYRNzW31LhCH3vOuXneECSl5MYYcVC/aglXkKGqau4z3PVOzfLeuxMQwcJnYKJghSHYAa1P2o9DpYj9TQNVDFZ0gvqEcLcAlJK9DoIwFIWvBlmVtLMwMfUh5NF8M6a+AosgmHRtSViQBLG3RdKKieGOzbk/PeeDrbXbYqmufL91Q/AvAzeHUbu3oum7BrR2tGZ0XZcvtnLOgVIKaZou4qIoTAZKKbhkmXHL+wMhxJ+sBacoms+a1g2IhnsGCu5VZd5ecx5eA2PMuxkFSZLYDdOPDUKIRYwMYbx1XdsN+iS0KnDBO2oqb2VpJqFYtS2c4xgeTTNjoVmSUk6HMPQmf1jCRjMZLEvDs7++BWCtfHYUhIEwPloSQtaQaNazlj1w4OIz6BP4AL7LvhhZ2TvxxMnNEi/6AoSe/NMpzAA1JIvZJtCmbTrt9Pt9JeIO+r+C/y677Wgw0gPLcK0Op8ey41cKOoaRQYtnFGFRFHvHnlyWJcRx/HKw9WbDmkPongIopQwSYRiC53kmGJmgveOf49GIa6rl9zaZwHeS1HrtEXa7IKx5nj8tXJFyY7TwS9MUtHyZSWN/daqcvxwbXYBxq/0ea3QFtHQaaxgGZqE3QBRF8D6fw6+GPwg+OpfX5LiqF4sl+L7fYd7ACj0nwAlZlsF0Nqu5v3YW5hxXDThp1IUYNx5Br0H7ZbMvj3LKj8e9q2S7TwgHZCDBdV3uVqrcj2jC+XL5EmPBu2ofk3JOeaYaaNxqo5L0womU8vMhAPVV09IwEESHJGih0kBB7KUFG49i8eAlhar/zJ/kMTcR/AEeC6JgD7Wmh7axXiqazmwym9002UpLBQdCcsmb3fl48wb+pJN3xEWPSHbnFoLf7ejwgp13Tnb/34Hj111wHGcrEJ6x+f54IAe3F6fgojzc1MRc/tY7nZ/6tiEygXMzrsSG9olNrdvtwn6lYnZA5vu+kFUk3shUAaeePAgCMZjCMJTDak9wUeagMEREvfTjurCQHSKlH7fbTJ4rISrNAa8AppizcJwg86ZyS5sHpQ54KVmXULK34TAZrXEe3HCDKIp+VS1kH/O52hDKuDQkWRXa4/E4WXIkgD4TDqpVmOJszs6sh8gxJVk0C47NtucV1jmF5qjRABuZYIpKOZMrmbtSjvhJBXwMUAjON7BtWzwgk5wpitIcUFieUlEFJeDs4H00SvR9nAc3JPkT5SOsAWcH09lMbOIAOnhhDqhaREeiAw/jLtXa8wvIkS7FV/IPEaVbc2EweIVmDlw4YO9cir1eD/r9vlib2SaiSuKcZEnAZ5RctGarhUt7TQGPpYN7BL/iOieyOut0DKHJl+JqWOh7sfjKVAVuczeWZV3io1UOaNqo5K1cifEpKieed03fSwHatXqeBIIguglECB+FnY0mAjVqbUGk8Wepv8Uf4G8w2FFoIiUxRg4htmpCgmGdt9zeze59LhoCxkkgx8FdZnZn5t57g5mm1zeX9N4Rm223BIcubdyFExdiu+wKgegy64jts85aUNfWw8b/APJIrW/npz+Cvr9hXDAL26xJP/l3n4Rj9tOe9pvquKFl5A0AcsKTL1Suyw7o0Qs0H0f8tT6SKwDgXzhfqVQUDoB8rg0TBmBjgD+bOmStOGSQ4XAomq2WaELE8VccMsldr0fg5EXREkjCccpFJmC0DaIagun3++rzHiFRl7qJpArD4YPBo3gl8A9rt49EvV5XAImDVUNmkcIthbgMGYh2DI2tkuOCrSoIHVciJSPdZk2EiCiTl8UZ0kinkGadaY4jHbQiuWC6ntL82G/15AAqQ7lcCtUzi0hqShAsgusOgE0h14EGkUJTogOrdhW+AxA08RnkCGOF0Whk7kCwYeGxdK0BwaCsbShkm+i66jNwCnM1aeiZMuK4PTJzCoAzctSATqcWdRK8XPr4M1FS0FKcmk4mwvM89V2VeLDJWeKDSGWVScYZP3iw5nBLEdzKcZa7sfoRc/ODqQM4jhQxz/08rDXJtKAOq+OYP1jyOm53Iax6rRbct1qtGVliOx4471rEuAn6PlIFtkudI2DNnCImPDmT+jiuQXMoFgrqHIjveOyx62SECBukOMvxhZ8mepAAx3GpUvoMUUjmdFwavqh77ZTUmF2veNAoZLRwrZlFcgC6HWJ7i1Ss75T/SbM0QI1VsRJUmeXk1XKMWip2wyxee/39AGazmcpv/CnC7uPQlbpn3cyukrXiSe0wepy+4lz6C0k9GbWxe2phx0W/NeZth+t2fD7/wjT0odE4PBF/wb4BHtFPrN/YdLgAAAAASUVORK5CYII=",
	spreadsheet: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABOFJREFUeNpiYMABGEGEQqHrf6wSP3/+hEv8/vOH4c/v3wwsIM6xY8cY3r59C1ft4ODIwITN/D9//0KM+vL163+Q9j9//oIF//37ywAQQAw4XYXNRWAJZBdBXPgL6DKoqzZv3oyi2s7eHrur/oJcBTIKph0k8Bfsqv8MAAGEM0hwAbDdZkq6eBX9//8fjFHCFj0Y0YGjkxPDf5iT0L0OipB/f/+BQ/Lvv39ghf/+/wP7gQWmiJAN1jY2YGfB4wiXif+BNMQPYN8wAASgnIx1AARhIKqNnyUDkyz8L274TQRMTERbiIQEVOh86T16x9A7Y89JcTT0Okx/GeQ5pAp8iQ8srD/jMYwxOp31aZqUsmhd+A+cB5fmN1w+YlWRcgyf5WKtLZEWIYZVqcJhZqyORJtrQ6lT0AnpDYO2BjGqd+c0IFeTmLoEANstgGA57jyQMmCgMnjQv5uR5CxNIiA9rZKce7CVAKQCUIkBTv9I+fkfEH/58gWRjqhpMCyz/QcmAAwLsBVNuPITNgDKY6D0CbOEhdphDvYNw3/cFujo6DD8BqZz9KAwNTMDOQvhfRCGlj1gF0OcDc0PDPC8gGHBlStXMILIzc2d4fSpU0T5AJbn/0MtJSqI8NbM2MoIWG3wH62iIpQq4JEHD2NYUKBWM9Bak+H7928HGGE2P3v+fD/EkP8oXoSLQXWi0tCwh5v9H85kBpZDioqKDQABxECXnEyjsugCsLAzZAIavp9GjgeXzjQv7Ia+BSxGcpoMLCyUFUmw5iI6+wHDbgbGV69e7efn53cg13BwvQxq8aKXU0AsJCjISFEQ4TMc5hMmWhkOswAj8NErFlBlAypdQRURISAoKMhgYGhIHR9gj2wG6gURDiuQLKBRPkAvuolKpsREKKrLIWwJcXFGjEhGry4FgBEHrJAYPn38CK+DEfUGap3BzMzCwM3DjRJEWJstyMAD2N4GGX769GmCwcPPL8Cgq6eLEkQE4+Df//8k9Lf+o7QoiLIAOcmRaglNLED3AUoqIje1oBqKMFxaSpKR6Q+wqUILw+FBBLTgIC0M//XrN6JV8fTp0wZGRkZ71PYmlA3rc6G3Q5HCG71NBAIqysqOIBogQHtWs9ogEIRHMFVQNGdFqIHmKO3Vi/SYp2r6Zs0TNBffwGsDlRQES6y7VNkfdTfJJtHSuayMIvPt/Ow3sxrpoJphrOslgXHLpqZDa5Z3IcULTEteEZAmzRKYniRXYV2Tp43/AGSap3OprwppxlrQ09qTbSd697XfvwVB8KzfegePNbw9v6GHD43d8BbAoZIDkKYpfNaEbkjiOMZrnud4SHNMK0cxA0Zv2zY8LJccAPJkFgJAxg/N/KlxVVlKfyvHDBm613oIbh9CsuSTDi2SJ1UTACAkeFMBQBredMiyOdAkqExVcVwXd3GnVBU+xrsNZ6/MhABEF3e49Vyt8N8/djvpkbCMuPM5RFHUCaJSGUJkM36RJB7whBoAxBXBBQoRsCNw5UmM5/I9B5SaiRPdCJPPQgC+7+PBW9eJWRFuRs+GaUIYhsy3fD/bqWP0SO4Mk0tcdo90EVfxPE9YVQ6/fzUMA+5rAKdUld5Q4XS0LzCAoijAcRzQNO1skqXO8O4dBybX2qlElmXvlmU96rMZfwKOyPCy/Ea3odvFInyCvyA/oHKrnTBRFkEAAAAASUVORK5CYII=",
	archive: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAAEgBckRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmZJREFUeNp0i8ENgDAMAw2bUIlt2SbfjMAC5dHOUcVtIRXwAj9sy5cAP5rc9m3tn6CU0s0MOWcsIYBXf4GnkWMkK+bnVURwxAhVBesN/NKVUhrZWsUpgBhwugqbi8ASMItv3boFFpCXVwAa/RviojVr1vwH0Z8+ff5/9969/69ev/7PguwqGLC2sUE4Fxn8+/efASAAX1RyAyAIBPfhS0rAYBWG/suwD3kyAwzRoAkO7Gthjt3pSGaQhPPH7yOS1k67rxGOvkbEGG11znhb+kbPQG2iM6vMwh6UYRmZzrqLGfzm9VkKV0pEhnbT2WkgxEjiUWkhigCUk0EOgyAQRcfGegHYktR6C5b1ZD0XGy9iF3XPhk2LEWWgTGqwafgJCSQMfN4foFRVCVKv4VR6Q/0vA8rBj8U3JnVTUkKbdGlbcEuEYYwZdliPgkPUt773xCKtXQFjDKSUYW79p8GTlVJxs1vzAs55sIRe3cc3Wkq5ZAUp6WvXwWxnmKZnWAsh6OH1EZXHOGaUMHUMmnJAz78UNkMcldZ6PTcNoXNfvUQnQ+wl+37dNwForXodBGEgfCJEJ0XfgInVEFcxMvFAPoBvJuogCYMP4K4sdSLiYESucIWKiDF4DIW299v7vkKIO6TDBFqW6fLYoRRaN54HvlbgzyIxwK+CHMzboIRn7Ksoijz1k2IQBBCGYaODmW1Dv9cThgU1pQ1Q6wBxpGkamKZZWcPOL9gTYLfdgmVZMNR1PscJ9VNjo6Bx13W/KgViFG88wiN/mhygwisbjMZjDC29Ge9IHRUdez6X+BTHWgcYVZLtzKiXp559d1UV9LQcEnxLiCQnmIla1xWMscr8wnG48i2+ge/v3zDpQ74NkqT6c0A1ZhfGN9BBlg8viw2KDPO1wXBAdrnE8dXrkPfT+bxO8jKUUxRzuaY8kitRR/HaVZSNYRirpwDUV79vgkAUfhAikhqQDnRpwmDDWllMnWr/M/8sY4emsRNT904OLi5sQGyjvXfw8ICTkzY26UvInSZ878e9e98H/MlN7siF59o7G3ahjgPpQsHzAXrxYff/HRjmTQiGYfwKhO5DfQ/wAdp2u31xHGf2U3DOy4KuEJ9r19WUoaOQ/ypEfd183wdd16XglEnrNF0sFq3OUeh4ngf34/FJB9JDTpJECU7GSgzPy2W3DNI05auMzUgV0kxar9e8hJ1LhBYEgfJAmRCDOI4lDhT3gGSqqltCxsXY5k3wlgyIbGjNJeG+ObILoFumXrGsJlcWULLaSQeyDx7LsqDft/jLWJK6ObYNvZ5ZoUzlGVQI33Whz5zgmzIHRDVnlUgkfKJALAF113DoVr7CcGcWwktUFMoz6GJZlgklaskAu0Vmk8kErgYDHuXbatUYH9XIT2RArSizKIpUM7UBzh1QJGKfP0ynuRQsVYZMYdB/+Q/bdmrgh9LBKwOfiZdoUJRC/jS7pRn5AXa7z6Oq2Gw2c03THqsiq9jva0JL0EKHYyoVTYR2Nxo94fotQLtmk5MwEMXx19DQRQ14AUikwZUVPEFX4C08hXvxWJI0gYU7hEboCcoRcFXDOK+kdDpMP6blwxrfhqSTwP/Nx+v//QaFa3lG9MOC3x1TaodGvO/CBy9QrXjFRMJibUH1wjqL66q8bfxPIA9qbT+9A7W+FxUSYi0ggpLKtZ049rXZADy3QL30DMoKZ+mLlB8SBTIk13UDF14kkOTcmWZg/fMK3yewJcUS8DwvEO2n4M/cBI5+x2I+3wmhvtkwDGi126nCeVohlQD6PMdxTrKV0DSh1UZLFxIokfDw2qP0FmIBetk9/jGbRTad6bnEwuNjhcsocvgs4UjN0CXuGWpIIsk25hC73ds9YSAMBmWRaEQwo0mQXgHsnCzLot62cdSqol/pATBGOhokIpxxxpEyz6USsG37LKW11+tD87opFM5fmZ3kPTAcPgpnfDqZJKKapPYoKQlCTpjAePxWjpjlTEI6AaQ54YEEHsSzixsbO+ymsp5pdY2pRLxwtkuTSAAPZ9od8DGjQX1ZXdPEwrl1UmXqeN4wzfsdkWI4P/5BwF2tJKArEQrnZahS5TBnLJefpVagVlMPKg7/87E3MWIdrO2KoqTW8cFgkGmykt+c2QcyPuNEKJxFfzEqsV6vF7qu91XqEEHC1h5fOKQK9/1vvA11Op2bB/gL8QMgpRmwBzDmaQAAAABJRU5ErkJggg=="
};

ZmMimeTable._table = {};

// only add types which are NOT ignored by the client	
ZmMimeTable._table[ZmMimeTable.APP]					= {desc: ZmMsg.application, image: "ExeDoc", imageLarge: "ExeDoc_48", dataUri: ZmMimeTable._icons.exe, query: "application/*"};
ZmMimeTable._table[ZmMimeTable.APP_FLASH]			= {desc: ZmMsg.swf, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.APP_ADOBE_PDF]		= {desc: ZmMsg.adobePdfDocument, image: "Doc", imageLarge: "Doc_48", dataUri: ZmMimeTable._icons.doc};
ZmMimeTable._table[ZmMimeTable.APP_ADOBE_PS]		= {desc: ZmMsg.adobePsDocument, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.APP_EXE]				= {desc: ZmMsg.application, image: "ExeDoc", imageLarge: "ExeDoc_48", dataUri: ZmMimeTable._icons.exe};
ZmMimeTable._table[ZmMimeTable.APP_MS_DOWNLOAD]		= {desc: ZmMsg.msDownload, image: "ExeDoc", imageLarge: "ExeDoc_48", dataUri: ZmMimeTable._icons.exe};
ZmMimeTable._table[ZmMimeTable.APP_MS_EXCEL]		= {desc: ZmMsg.msExcelDocument, image: "MSExcelDoc", imageLarge: "MSExcelDoc_48", dataUri: ZmMimeTable._icons.spreadsheet, query: "excel"};
ZmMimeTable._table[ZmMimeTable.APP_MS_PPT]			= {desc: ZmMsg.msPPTDocument, image: "MSPowerpointDoc", imageLarge: "MSPowerpointDoc_48", dataUri: ZmMimeTable._icons.presentation, query: "powerpoint"};
ZmMimeTable._table[ZmMimeTable.APP_MS_PROJECT]		= {desc: ZmMsg.msProjectDocument, image: "MSProjectDoc", imageLarge: "MSProjectDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.APP_MS_VISIO]		= {desc: ZmMsg.msVisioDocument, image: "MSVisioDoc", imageLarge: "MSVisioDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.APP_MS_WORD]			= {desc: ZmMsg.msWordDocument, image: "MSWordDoc", imageLarge: "MSWordDoc_48", dataUri: ZmMimeTable._icons.doc, query: "word"};
ZmMimeTable._table[ZmMimeTable.APP_OCTET_STREAM]	= {desc: ZmMsg.unknownBinaryType, image: "UnknownDoc", imageLarge: "UnknownDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.APP_OPENXML_DOC]		= {desc: ZmMsg.msWordDocument, image: "MSWordDoc", imageLarge: "MSWordDoc_48", dataUri: ZmMimeTable._icons.doc};
ZmMimeTable._table[ZmMimeTable.APP_OPENXML_EXCEL]	= {desc: ZmMsg.msExcelDocument, image: "MSExcelDoc", imageLarge: "MSExcelDoc_48", dataUri: ZmMimeTable._icons.spreadsheet};
ZmMimeTable._table[ZmMimeTable.APP_OPENXML_PPT]		= {desc: ZmMsg.msPPTDocument, image: "MSPowerpointDoc", imageLarge: "MSPowerpointDoc_48", dataUri: ZmMimeTable._icons.presentation};
ZmMimeTable._table[ZmMimeTable.APP_XML]			    = {desc: ZmMsg.xmlDocument, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.APP_ZIMBRA_DOC]  	= {desc: ZmMsg.zimbraDocument, image: "Doc", imageLarge: "Doc_48", dataUri: ZmMimeTable._icons.doc};
ZmMimeTable._table[ZmMimeTable.APP_ZIP]				= {desc: ZmMsg.zipFile, image: "ZipDoc", imageLarge: "ZipDoc_48", dataUri: ZmMimeTable._icons.archive};
ZmMimeTable._table[ZmMimeTable.APP_ZIP2]			= {desc: ZmMsg.zipFile, image: "ZipDoc", imageLarge: "ZipDoc_48", dataUri: ZmMimeTable._icons.archive};
ZmMimeTable._table[ZmMimeTable.AUDIO]				= {desc: ZmMsg.audio, image: "AudioDoc", imageLarge: "AudioDoc_48", dataUri: ZmMimeTable._icons.audio};
ZmMimeTable._table[ZmMimeTable.AUDIO_WAV]			= {desc: ZmMsg.waveAudio, image: "AudioDoc", imageLarge: "AudioDoc_48", dataUri: ZmMimeTable._icons.audio};
ZmMimeTable._table[ZmMimeTable.AUDIO_MP3]			= {desc: ZmMsg.mp3Audio, image: "AudioDoc", imageLarge: "AudioDoc_48", dataUri: ZmMimeTable._icons.audio};
ZmMimeTable._table[ZmMimeTable.IMG]					= {desc: ZmMsg.image, image: "ImageDoc", imageLarge: "ImageDoc_48", dataUri: ZmMimeTable._icons.image, query: "image/*"};
ZmMimeTable._table[ZmMimeTable.IMG_BMP]				= {desc: ZmMsg.bmpImage, image: "ImageDoc", imageLarge: "ImageDoc_48", dataUri: ZmMimeTable._icons.image, query: "bmp"};
ZmMimeTable._table[ZmMimeTable.IMG_GIF]				= {desc: ZmMsg.gifImage, image: "ImageDoc", imageLarge: "ImageDoc_48", dataUri: ZmMimeTable._icons.image, query: "gif"};
ZmMimeTable._table[ZmMimeTable.IMG_JPEG]			= {desc: ZmMsg.jpegImage, image: "ImageDoc", imageLarge: "ImageDoc_48", dataUri: ZmMimeTable._icons.image, query: "jpeg"};
ZmMimeTable._table[ZmMimeTable.IMG_PNG]				= {desc: ZmMsg.pngImage, image: "ImageDoc", imageLarge: "ImageDoc_48", dataUri: ZmMimeTable._icons.image, query: "png"};
ZmMimeTable._table[ZmMimeTable.IMG_TIFF]			= {desc: ZmMsg.tiffImage, image: "ImageDoc", imageLarge: "ImageDoc_48", dataUri: ZmMimeTable._icons.image};
ZmMimeTable._table[ZmMimeTable.MSG_RFC822]			= {desc: ZmMsg.mailMessage, image: "MessageDoc", imageLarge: "MessageDoc_48", dataUri: ZmMimeTable._icons.doc};
ZmMimeTable._table[ZmMimeTable.TEXT]				= {desc: ZmMsg.textDocuments, image: "Doc", imageLarge: "Doc_48", dataUri: ZmMimeTable._icons.doc};
ZmMimeTable._table[ZmMimeTable.TEXT_RTF]			= {desc: ZmMsg.enrichedText, image: "Doc", imageLarge: "Doc_48", dataUri: ZmMimeTable._icons.doc};
ZmMimeTable._table[ZmMimeTable.TEXT_HTML]			= {desc: ZmMsg.htmlDocument, image: "HtmlDoc", imageLarge: "HtmlDoc_48", dataUri: ZmMimeTable._icons.html};
ZmMimeTable._table[ZmMimeTable.TEXT_JAVA]			= {desc: ZmMsg.javaSource, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.TEXT_PLAIN]			= {desc: ZmMsg.textFile, image: "Doc", imageLarge: "Doc_48", dataUri: ZmMimeTable._icons.doc, query: "text"};
ZmMimeTable._table[ZmMimeTable.TEXT_XML]			= {desc: ZmMsg.xmlDocument, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.TEXT_CSV]			= {desc: ZmMsg.csvDocument, image: "MSExcelDoc", imageLarge: "MSExcelDoc_48", dataUri: ZmMimeTable._icons.spreadsheet};
ZmMimeTable._table[ZmMimeTable.VIDEO]				= {desc: ZmMsg.video, image: "VideoDoc", imageLarge: "VideoDoc_48", dataUri: ZmMimeTable._icons.video};
ZmMimeTable._table[ZmMimeTable.VIDEO_WMV]			= {desc: ZmMsg.msWMV, image: "VideoDoc", imageLarge: "VideoDoc_48", dataUri: ZmMimeTable._icons.video};
ZmMimeTable._table[ZmMimeTable.TEXT_DIRECTORY]		= {desc: ZmMsg.vCard, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.TEXT_VCARD]			= {desc: ZmMsg.vCard, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};
ZmMimeTable._table[ZmMimeTable.TEXT_X_VCARD]		= {desc: ZmMsg.vCard, image: "GenericDoc", imageLarge: "GenericDoc_48", dataUri: ZmMimeTable._icons.generic};

ZmMimeTable.getInfo =
function(type, createIfUndefined) {
	var entry = ZmMimeTable._table[type];
	if (!entry && createIfUndefined) {
		entry = ZmMimeTable._table[type] = {desc: type, image: "UnknownDoc", imageLarge: "UnknownDoc_48", dataUri: ZmMimeTable._icons.generic};
	}
	if (entry) {
		if (!entry.type) {
			entry.type = type;
		}
	} else {
		// otherwise, check if main category is in table
		var baseType = type.split("/")[0];
		if (baseType) {
			entry = ZmMimeTable._table[baseType];
		}
	}
	return entry;
};

/**
 * Checks if the type is ignored.
 * 
 * @param	{constant}	type		the type
 * @return	{Boolean}	<code>true</code> if the type is ignored
 */
ZmMimeTable.isIgnored = 
function(type) {
	return (type == ZmMimeTable.MULTI_ALT ||
			type == ZmMimeTable.MULTI_MIXED ||
			type == ZmMimeTable.MULTI_RELATED ||
			type == ZmMimeTable.MULTI_APPLE_DBL ||
			type == ZmMimeTable.APP_MS_TNEF ||
			type == ZmMimeTable.APP_MS_TNEF2 ||
            type == ZmMimeTable.APP_SIGNATURE);
};

/**
 * Checks if the type is renderable.
 * 
 * @param	{constant}	type		the type
 * @return	{Boolean}	<code>true</code> if the type is renderable
 */
ZmMimeTable.isRenderable =
function(type, textOnly) {
	return (type === ZmMimeTable.TEXT_HTML ||
			type === ZmMimeTable.TEXT_PLAIN ||
			(!textOnly && ZmMimeTable.isRenderableImage(type)) ||
			(!textOnly && type === ZmMimeTable.APP_ADOBE_PDF));
};

ZmMimeTable.isTextType =
function(type){
    return (type.match(/^text\/.*/) &&
            type != ZmMimeTable.TEXT_HTML &&
            type != ZmMimeTable.TEXT_CAL);  
};

/**
 * Checks if the type is a renderable image.
 * 
 * @param	{constant}	type		the type
 * @return	{Boolean}	<code>true</code> if the type is a renderable image
 */
ZmMimeTable.isRenderableImage =
function(type) {
	return (type == ZmMimeTable.IMG_JPEG ||
			type == ZmMimeTable.IMG_GIF ||
			type == ZmMimeTable.IMG_BMP ||
			type == ZmMimeTable.IMG_PNG);
};

/**
 * Checks if the type has an HTML version.
 * 
 * @param	{constant}	type		the type
 * @return	{Boolean}	<code>true</code> if the type has an HTML version
 */
ZmMimeTable.hasHtmlVersion =
function(type) {
	return (!(ZmMimeTable.isIgnored(type) ||
			type.match(/^text\/plain/) ||
			type.match(/^image/) ||
			type.match(/^audio/) ||
			type.match(/^video/)));
};

ZmMimeTable.isMultiMedia =
function(type){
    return (type.match(/^audio/) ||
			type.match(/^video/));
};

ZmMimeTable.isWebDoc =
function(type) {
    return (type == ZmMimeTable.APP_ZIMBRA_DOC);
};

/**
 * Checks if the type is a vCard.
 * 
 * @param	{constant}	type		the type
 * @return	{Boolean}	<code>true</code> if the type is a vCard
 */
ZmMimeTable.isVcard =
function(type) {
    return (type === ZmMimeTable.TEXT_DIRECTORY || 
    		type === ZmMimeTable.TEXT_X_VCARD || 
    		type === ZmMimeTable.TEXT_VCARD);
};
}

if (AjxPackage.define("zimbraMail.share.model.ZmObjectHandler")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file contains the zimlet object handler base class.
 * 
 */

/**
 * Creates the object handler.
 * @class
 * This class defines the default implementation for a zimlet object handler.
 * <br />
 * <br />
 * To write a zimlet, see {@link ZmZimletBase}. 
 * 
 * @param	{string}	typeName	the type name
 * @param	{string}	className	the class name
 */
ZmObjectHandler = function(typeName, className) {
	if (arguments.length > 0) {
		this.init(typeName, className);
	}
}

ZmObjectHandler.prototype.constructor = ZmObjectHandler;
ZmObjectHandler.prototype.isZmObjectHandler = true;

/**
 * This method is called by the Zimlet framework to initialize the object.
 * 
 * @param	{string}	typeName	the type name
 * @param	{string}	className	the class name; if <code>null</code>, "Object" will be used
 */
ZmObjectHandler.prototype.init =
function(typeName, className) {
	this._typeName = typeName;
	this._className = className ? className : "Object";
	this.name = this.toString();
};

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
ZmObjectHandler.prototype.toString = 
function() {
	// If you can find a cleaner way to get the name of 
	// a sub-class without hard coding each instance
	// in a toString() method feel free to change.
	if(!this._toString) {
		var ctor = "" + this.constructor;
		ctor = ctor.substring(0,ctor.indexOf("("));
		this._toString = ctor.substring("function ".length);
	}
	return this._toString;
};

ZmObjectHandler.prototype.getEnabled =	function() {
	return true;
};


/**
 * Gets the type name.
 * 
 * @return	{string}		the type name
 */
ZmObjectHandler.prototype.getTypeName =
function() {
	return this._typeName;
};

/**
 * Gets the class name for a given object.
 * 
 * @param	{Object}		obj			the object
 * @param	{Object}		context		the content
 * @param	{string}		spanId		ID of the SPAN
 *
 * @return	{string}		the class name
 */
ZmObjectHandler.prototype.getClassName =
function(obj, context, spanId) {
	return this._className;
};

/**
 * Gets the hovered class name for the given object.
 * 
 * @param	{Object}		obj			the object
 * @param	{Object}		context		the content
 * @param	{string}		spanId		ID of hovered SPAN
 *
 * @return	{string}		the hovered class name
 */
ZmObjectHandler.prototype.getHoveredClassName =
function(obj, context, spanId) {
	var cname = this.getClassName(obj, context, spanId);
	if (this._cachedClassNameForHovered !== cname) {
		this._cachedClassNameForHovered = cname;
		this._classNameHovered = cname + "-" + DwtCssStyle.HOVER;
	}
	return this._classNameHovered;
};

/**
 * Gets the active class name for a given object.
 * 
 * @param	{Object}		obj		the object
 * @param	{Object}		context		the content
 * @param	{string}		spanId		ID of the SPAN
 *
 * @return	{string}		the active class name
 */
ZmObjectHandler.prototype.getActiveClassName =
function(obj, context, spanId) {
	var cname = this.getClassName(obj, context, spanId);
	if (this._cachedClassNameForActive !== cname) {
		this._cachedClassNameForActive = cname;
		this._classNameActive = cname + "-" + DwtCssStyle.ACTIVE;
	}
	return this._classNameActive;
};

/**
 * @private
 */
ZmObjectHandler.prototype.findObject =
function(content, startIndex, objectMgr) {
	if (startIndex === 0) {
		this._lastMatch = null;
		this._noMatch = false;
	}
	if (this._noMatch) {return null;}
	if (this._lastMatch && this._lastMatch.index >= startIndex) {
		return this._lastMatch;
	}
	this._lastMatch = this.match(content, startIndex, objectMgr);
	this._noMatch = (this._lastMatch === null);
	return this._lastMatch;
};


/**
 * This method is used to match content for a zimlet. Zimlet implementations should
 * override this method. Usage should return a non-null result in the format of
 * <code>String.match</code> if text on the line matched the handler regular expression.
 * 
 * <pre>
 * var result = handler.match(line);
 * result[0] // should be matched string
 * result.index // should be location within line match occurred
 * </pre>
 * 
 * Handlers can also set result.context which will be passed back to
 * them during the various method calls ({@link #getToolTipText}, etc). Handlers should set
 * regex.lastIndex to startIndex and then use <code>regex.exec(content)</code>. Handlers should
 * also use the "g" option when constructing their regex.
 */
ZmObjectHandler.prototype.match =
function(content, startIndex) {
	return null;
};

/**
 * Generates content inside the <code>&lt;span&gt;</code> tag.
 * 
 * @return	{number}	the content index
 * @private
 * */
ZmObjectHandler.prototype._getHtmlContent =
function(html, idx, obj, context, spanId) {
	html[idx++] = AjxStringUtil.htmlEncode(obj, true);
	return idx;
};

/**
 * Generates the <code>&lt;span&gt;</code> tag.
 * 
 * @return	{number}	the content index
 * @private
 */
ZmObjectHandler.prototype.generateSpan = 
function(html, idx, obj, spanId, context, options) {
	html[idx++] = "<span class='";
	html[idx++] = this.getClassName(obj);
	html[idx++] = "' role='link' id='";
	html[idx++] = spanId;
	html[idx++] = "'>";
	idx = this._getHtmlContent(html, idx, obj, context, spanId, options);
	html[idx++] = "</span>";
	return idx;
};

/**
 * Checks if the handler has tool tip text.
 * 
 * @param		{Object}	obj			the object
 * @param		{Object}	context		the context
 * @return		<code>true</code> if the handler has tool tip text; <code>false</code> otherwise
 */
ZmObjectHandler.prototype.hasToolTipText =
function(obj, context) {
	return true;
};

/**
 * Gets the handler tool tip text.
 * 
 * @param		{Object}	obj			the object
 * @param		{Object}	context		the context
 * @return		{string}	the handler has tool tip text
 */
ZmObjectHandler.prototype.getToolTipText =
function(obj, context) {
	return AjxStringUtil.htmlEncode(obj);
};

/**
 * Populates the handler tool tip text.
 * 
 * @param		{Object}	obj			the object
 * @param		{Object}	context		the context
 */
ZmObjectHandler.prototype.populateToolTip =
function(obj, context) {
};

/**
 * Gets the action menu.
 * 
 * @param		{Object}	obj			the object
 * @param		{string}	span		the span element
 * @param		{Object}	context		the context
 * @return		{ZmActionMenu}	the action menu
 * 
 * @private
 */
ZmObjectHandler.prototype.getActionMenu =
function(obj, span, context) {
	return null;
};

/**
 * This method is called by the Zimlet framework when the object is selected.
 * 
 * @param		{Object}	obj			the object
 * @param		{string}	span		the span element
 * @param		{Object}	ev			the event
 * @param		{Object}	context		the context
 * @see		#clicked
 */
ZmObjectHandler.prototype.selected =
function(obj, span, ev, context) {
	return this.clicked(span, obj, context, ev);
};

/**
 * This method is called by the Zimlet framework when the object is clicked.
 * 
 * @param		{Object}	obj			the object
 * @param		{string}	span		the span element
 * @param		{Object}	ev			the event
 * @param		{Object}	context		the context
 */
ZmObjectHandler.prototype.clicked =
function(span, obj, context, ev) {
};

/**
 * This method is called when the object is hovered-over.
 * 
 * @private
 */
ZmObjectHandler.prototype.hoverOver = function(object, context, x, y) {

	var tooltip = this.getToolTipText(object, context) || '',
		content, callback;

	if (typeof(tooltip) === "string") {
		content = tooltip;
	}
	else if (tooltip.isAjxCallback || AjxUtil.isFunction(tooltip)) {
		callback = tooltip;
	}
	else if (typeof(tooltip) === "object") {
		content = tooltip.content;
		callback = tooltip.callback;
	}

	if (!content && callback && tooltip.loading) {
		content = AjxMsg.loading;
	}

	if (content) {
		this._showTooltip(object, context, x, y, content);
	}

	if (callback) {
		var callback1 = new AjxCallback(this, this._showTooltip, [ object, context, x, y ]);
		AjxTimedAction.scheduleAction(new AjxTimedAction(null, function() {
			callback.run(callback1);
		}), 0);
	}
};

ZmObjectHandler.prototype._showTooltip = function(object, context, x, y, content) {
	var shell = DwtShell.getShell(window);
	var tooltip = shell.getToolTip();
	tooltip.setContent(content);
	tooltip.popup(x, y);
	// TODO: call below is odd; not sure if it's used much, appears to be for two-step tooltips (eg a map)
	this.populateToolTip(object, context);
};

/**
 * This method is called when the handler is hovered-out.
 * 
 * @private
 */
ZmObjectHandler.prototype.hoverOut = function(object, context) {
	var shell = DwtShell.getShell(window);
	var tooltip = shell.getToolTip();
	tooltip.popdown();
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmObjectManager")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the object manager.
 * 
 */

/**
 * Creates an object manager.
 * @class
 * This class is used to high-light objects within a given view.
 * 
 * @author Kevin Henrikson
 *
 * @param {DwtComposite}	view			the view this manager is going to high-light for
 * @param {AjxCallback}	selectCallback  the callback triggered when user clicks on high-light object (provide if you want to do something before the clicked on object opens its corresponding view)
 * @param {Boolean}	skipHandlers 	<code>true</code> to avoid adding the standard handlers
 */
ZmObjectManager = function(view, selectCallback, skipHandlers) {

	this._selectCallback = selectCallback;
	this._uuid = Dwt.getNextId();
	this._objectIdPrefix = "OBJ_PREFIX_";
	this._objectHandlers = {};

	// don't include when looking for objects. only used to provide tool tips for images
	if (appCtxt.get(ZmSetting.MAIL_ENABLED) && window["ZmImageAttachmentObjectHandler"]) {
		this._imageAttachmentHandler = new ZmImageAttachmentObjectHandler();
	}

	// create handlers (see registerHandler below)
	if (!skipHandlers) {
        this.initialized = false;
        this._addAutoHandlers();
	} else {
        this.initialized = true;
    }

    this.sortHandlers();
	this.reset();
	this.setView(view);
};

ZmObjectManager._TOOLTIP_DELAY = 275;

// Define common types for quicker object matching.
ZmObjectManager.EMAIL = "email";
ZmObjectManager.URL = "url";
ZmObjectManager.PHONE = "phone";
ZmObjectManager.DATE = "date";
ZmObjectManager.ADDRESS = "address";

// Allows callers to pass in a current date
ZmObjectManager.ATTR_CURRENT_DATE = "currentDate";

ZmObjectManager._autohandlers = [];

/**
 * Registers the handler.
 * 
 * @param	{Object}	obj		the object
 * @param	{constant}	type	the type
 * @param	{constant}	priority	the priority
 */
ZmObjectManager.registerHandler =
function(obj, type, priority) {
	if (typeof obj == "string") {
		obj = eval(obj);
	}
	var c = ZmObjectManager._autohandlers;
	if (!obj.__registered) {
		var id = c.push(obj);
		var i = id - 1;
		if(type) {
			c[i].useType = type;
		}
		if(priority) {
			c[i].usePrio = priority;
		}
		obj.__registered = true;
	}
};

/**
 * @private
 */
ZmObjectManager.unregisterHandler =
function(obj) {
	if (typeof obj == "string") {
		obj = eval(obj);
	}
 	var c = ZmObjectManager._autohandlers, i;
	for (i = c.length; --i >= 0;) {
		if (c[i] === obj) {
			c.splice(i, 1);
			break;
		}
	}
};

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmObjectManager.prototype.toString =
function() {
	return "ZmObjectManager";
};

/**
 * Gets the handlers.
 * 
 * @return	{Array}	an array of {@link ZmObjectHandler} objects
 */
ZmObjectManager.prototype.getHandlers =
function() {
	if (!this.initialized) {
		var zimletMgr = appCtxt.getZimletMgr();
		if (zimletMgr.isLoaded()) {
			this.initialized = true;
			var zimlets = zimletMgr.getContentZimlets();
			for (var i = 0; i < zimlets.length; i++) {
				this.addHandler(zimlets[i], zimlets[i].type, zimlets[i].prio);
			}
		}
	}
	return this._objectHandlers;
};

/**
 * Adds the handler.
 * 
 * @param	{ZmObjectHandler}	h		the handler
 * @param	{constant}			type	the type
 * @param	{constant}		priority	the priority
 */
ZmObjectManager.prototype.addHandler =
function(h, type, priority) {
	type = type || (h.getTypeName() ? h.getTypeName() : "none");
	priority = priority ? priority : -1;
	h._prio = priority;
	//DBG.println(AjxDebug.DBG3, "addHandler " + h + " type: " + type + " prio: " + priority);
	var oh = this.getHandlers();
	if (!oh[type]) {oh[type] = [];}
	oh[type].push(h);
};

/**
 * Removes the handler.
 * 
 * @param	{ZmObjectHandler}	h		the handler
 * @param	{constant}			type	the type
 */
ZmObjectManager.prototype.removeHandler =
function(h, type) {
	type = type || (h.getTypeName() ? h.getTypeName() : "none");
	var oh = this.getHandlers();
	if (oh[type]) {
		for (var i = 0, count = oh[type].length; i < count; i++) {
			if (oh[type][i] == h) {
				oh[type].splice(i, 1);
				break;
			}
		}
	}
};

/**
 * Sorts the handlers.
 * 
 */
ZmObjectManager.prototype.sortHandlers =
function() {
	this._allObjectHandlers = [];
    var objectHandlers = this.getHandlers();
    for (var type in objectHandlers) {
		// Object handlers grouped by Type
		objectHandlers[type].sort(ZmObjectManager.__byPriority);

		// Copy each array to a single array of all Object Handlers
		for (var k = 0; k < objectHandlers[type].length; k++) {
			this._allObjectHandlers.push(objectHandlers[type][k]);
		}
	}
	this._allObjectHandlers.sort(ZmObjectManager.__byPriority);
};

/**
 * @private
 */
ZmObjectManager.prototype._addAutoHandlers =
function() {
	var c = ZmObjectManager._autohandlers, i, obj, prio;
	for (i = 0; i < c.length; ++i) {
		obj = c[i];
		var	handler = obj;
		var type = obj.TYPE;
		if (!(obj.isZmObjectHandler)) {
			handler = new obj();
		}
		if (obj.useType) {
			type = obj.useType;
		}
		if (obj.usePrio) {
			prio = obj.usePrio;
		}
		this.addHandler(handler, type, prio);
	}
};

/**
 * Resets the objects.
 * 
 */
ZmObjectManager.prototype.reset =
function() {
	this._objects = {};
};

/**
 * Sets the view.
 * 
 * @param	{DwtComposite}		view		the view
 */
ZmObjectManager.prototype.setView =
function(view) {
	if (view != null && appCtxt.getZimletMgr().isLoaded()) {
	    view.addListener(DwtEvent.ONMOUSEOVER, new AjxListener(this, this._mouseOverListener));
	    view.addListener(DwtEvent.ONMOUSEOUT, new AjxListener(this, this._mouseOutListener));
	    view.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
	    view.addListener(DwtEvent.ONMOUSEUP, new AjxListener(this, this._mouseUpListener));
	    view.addListener(DwtEvent.ONMOUSEMOVE, new AjxListener(this, this._mouseMoveListener));
		view.addListener(DwtEvent.ONCONTEXTMENU, new AjxListener(this, this._rightClickListener));
		this._hoverOverListener = new AjxListener(this, this._handleHoverOver);
	    this._hoverOutListener = new AjxListener(this, this._handleHoverOut);
	}
	this._view = view;
};

ZmObjectManager.prototype.getView = function() {
	return this._view;
};

/**
 * Gets the count of objects.
 * 
 * @return	{int}	the count
 */
ZmObjectManager.prototype.objectsCount =
function() {
	return (appCtxt.zimletsPresent()) ? appCtxt.getZimletMgr().getContentZimlets().length : 0;
};

/**
 * Gets the image attachment handler.
 * 
 * @return	{ZmImageAttachmentObjectHandler}	the handler
 */
ZmObjectManager.prototype.getImageAttachmentHandler =
function() {
	return this._imageAttachmentHandler;
};

/**
 * @private
 */
ZmObjectManager.prototype._getAjxEmailAddress =
function(obj){
    if(appCtxt.isChildWindow && obj.isAjxEmailAddress){ //Making sure child window knows its type AjxEmailAddress
        obj = AjxEmailAddress.copy(obj);
    }
    return obj;
};

/**
 * Finds objects.
 * 
 * @param	{String}	content		the content
 * @param	{Boolean}	htmlEncode	<code>true</code> to HTML encode the content
 * @param	{constant}	type		the type
 * @param	{Boolean}	isTextMsg	<code>true</code> if is text msg
 * @param	{hash}		options		arbitrary options to pass to handler
 *
 * @return	{String}	the object
 */
ZmObjectManager.prototype.findObjects =
function(content, htmlEncode, type, isTextMsg, options) {
	if  (!content) {return "";}
	var html = [];
	var idx = 0;

	var maxIndex = content.length;
	var lastIndex = 0;

    var objectHandlers = this.getHandlers();
    while (true) {
		var lowestResult = null;
		var lowestIndex = maxIndex;
		var lowestHandler = null;

		// if given a type, just go thru the handler defined for that type.
		// otherwise, go thru every handler we have. Regardless, ask each handler
		// to find us a match >= to lastIndex. Handlers that didn't match last
		// time will simply return, handlers that matched last time that we didn't
		// use (because we found a closer match) will simply return that match again.
		//
		// when we are done, we take the handler with the lowest index.
		var i;
		var handlers;
		var chunk;
		var result = null;
		if (type) {
			//DBG.println(AjxDebug.DBG3, "findObjects type [" + type + "]");
			handlers = objectHandlers[type];
			if (handlers) {
				for (i = 0; i < handlers.length; i++) {
					//DBG.println(AjxDebug.DBG3, "findObjects by TYPE (" + handlers[i] + ")");
					result = handlers[i].findObject(content, lastIndex, this);
					// No match keep trying.
					if(!result) {continue;}
					// Got a match let's handle it.
					if (result.index >= lowestIndex) {break;}
					lowestResult = result;
					lowestIndex = result.index;
					lowestHandler = handlers[i];
				}
			}
			// If it's an email address just handle it and return the result.
			if (type == "email" || content instanceof AjxEmailAddress) {
				if (lowestHandler) {
                    content = this._getAjxEmailAddress(content);
					this.generateSpan(lowestHandler, html, idx, content, lowestResult, options);
				} else {
					html[idx++] = AjxStringUtil.htmlEncode(content.toString());
				}
				return html.join("");
			}
		} else {
			for (var j = 0; j < this._allObjectHandlers.length; j++) {
				var handler = this._allObjectHandlers[j];
				//DBG.println(AjxDebug.DBG3, "findObjects trying (" + handler + ")");
				result = handler.findObject(content, lastIndex, this);
				if (result && result.index < lowestIndex) {
					lowestResult = result;
					lowestIndex = result.index;
					lowestHandler = handler;
				}
			}
		}

		if (!lowestResult) {
			// all done
			// do last chunk
			chunk = content.substring(lastIndex, maxIndex);
			if (htmlEncode) {
				html[idx++] = AjxStringUtil.htmlEncode(chunk, !!isTextMsg);
			} else {
				html[idx++] = chunk;
			}
			break;
		}

		//  add anything before the match
		if (lowestIndex > lastIndex) {
			chunk = content.substring(lastIndex, lowestIndex);
			if (htmlEncode) {
				html[idx++] = AjxStringUtil.htmlEncode(chunk, !!isTextMsg);
			} else {
				html[idx++] = chunk;
			}
		}

		// add the match
		if(lowestHandler) {
			idx = this.generateSpan(lowestHandler, html, idx, lowestResult[0], lowestResult.context);
		} else {
			html[idx++] = lowestResult[0];
		}

		// update the index
		lastIndex = lowestResult.index + (lowestResult.matchLength || lowestResult[0].length);
	}

	return html.join("");
};


/**
 * Added this customized method for the sake of ZmMailMsgView performance.
 * 
 * TODO: Integrate this method to findObjectsInNode()
 * 
 * @private
 */
ZmObjectManager.prototype.processObjectsInNode = function(doc, node){

    var objectManager = this;
	doc = doc || node.ownerDocument;
    var tmpdiv = doc.createElement("div");

    var recurse = function(node, handlers) {
		var tmp, i, val, next;
		switch (node.nodeType) {
		    case 1:	// ELEMENT_NODE
			node.normalize();
			tmp = node.tagName.toLowerCase();

			if (next == null) {
				if (/^(img|a)$/.test(tmp)) {
                    var href;
                    try {
                        // IE can throw an "Invalid Argument" error depending on value of href
                        // e.g: http://0:0:0:0:0:0:0:1%0:7070/service/soap/ContactActionRequest:1331608015326:9c4f5868c5b0b4f2
                        href = node.href;
                    }
                    catch(e) {
                        //do nothing
                    }

                    var isMailToLink = tmp === "a" && ZmMailMsgView._MAILTO_RE.test(href),
                        isUrlLink = tmp === "a" && ZmMailMsgView._URL_RE.test(href);

                    if ((isMailToLink || isUrlLink) && node.target){
						// tricky.
						var txt = isMailToLink ? href :RegExp.$1 ;
						tmp = doc.createElement("div");
						tmp.innerHTML = objectManager.findObjects(AjxStringUtil.trim(txt));
						tmp = tmp.firstChild;
						if (tmp.nodeType == 3 /* Node.TEXT_NODE */) {
							// probably no objects were found.  A warning would be OK here
							// since the regexps guarantee that objects _should_ be found.
							return tmp.nextSibling;
						}
						// here, tmp is an object span, but it
						// contains the URL (href) instead of
						// the original link text.
						node.parentNode.insertBefore(tmp, node); // add it to DOM
						tmp.innerHTML = "";
						tmp.appendChild(node); // we have the original link now
						return tmp.nextSibling;	// move on
					}
					handlers = false;
				}
			} else {
				// consider processed
				node = next;
			}

			// bug 28264: the only workaround possible seems to be
			// to remove textIndent styles that have a negative value:
			if (parseFloat(node.style.textIndent) < 0) {
				node.style.textIndent = "";
			}
            for (i = node.firstChild; i; i = recurse(i, handlers)) {}
			return node.nextSibling;

		    case 3:	// TEXT_NODE
		    case 4:	// CDATA_SECTION_NODE (just in case)
			// generate ObjectHandler-s
			if (handlers && /[^\s\xA0]/.test(node.data)) try {
 				var a = null, b = null;

				if (!AjxEnv.isIE) {
					// this block of code is supposed to free the object handlers from
					// dealing with whitespace.  However, IE sometimes crashes here, for
					// reasons that weren't possible to determine--hence we avoid this
					// step for IE.  (bug #5345)
					var results = /^[\s\xA0]+/.exec(node.data);
					if (results) {
						a = node;
						node = node.splitText(results[0].length);
					}
					results = /[\s\xA0]+$/.exec(node.data);
					if (results)
						b = node.splitText(node.data.length - results[0].length);
				}

				tmp = tmpdiv;
				var code = objectManager.findObjects(node.data, true, null, false);
				var disembowel = false;
				if (AjxEnv.isIE) {
					// Bug #6481, #4498: innerHTML in IE massacrates whitespace
					//            unless it sees a <pre> in the code.
					tmp.innerHTML = [ "<pre>", code, "</pre>" ].join("");
					disembowel = true;
				} else {
					tmp.innerHTML = code;
				}

				if (a)
					tmp.insertBefore(a, tmp.firstChild);
				if (b)
					tmp.appendChild(b);

				a = node.parentNode;
				if (disembowel)
					tmp = tmp.firstChild;
				while (tmp.firstChild)
					a.insertBefore(tmp.firstChild, node);
				tmp = node.nextSibling;
				a.removeChild(node);
				return tmp;
			} catch(ex) {};
		}
		return node.nextSibling;
	};

    // Parse through the DOM directly and find objects.
	if (node && node.childNodes && node.childNodes.length) {
		for (var i = 0; i < node.childNodes.length; i++){
			recurse(node.childNodes[i], true);
		}
	}
};

/**
 * @private
 */
ZmObjectManager.prototype.findObjectsInNode =
function(node, re_discard, re_allow, callbacks) {
	var objectManager = this, doc = node.ownerDocument, tmpdiv = doc.createElement("div");

	if (!re_discard)
		re_discard = /^(script|link|object|iframe|applet)$/i;

	// This inner function does the actual work.  BEWARE that it return-s
	// in various places, not only at the end.
	var recurse = function(node, handlers) {
		var tmp, i, val, next;
		switch (node.nodeType) {
		    case 1:	// ELEMENT_NODE
			node.normalize();
			tmp = node.tagName.toLowerCase();
			if (callbacks && callbacks.foreachElement) {
				next = callbacks.foreachElement(node, tmp, re_discard, re_allow);
			}
			if (next == null) {
				if (/^(img|a)$/.test(tmp)) {
					if (tmp == "a" && node.target
					    && (ZmMailMsgView._URL_RE.test(node.href)
						|| ZmMailMsgView._MAILTO_RE.test(node.href)))
					{
						// tricky.
						var txt = RegExp.$1;
						tmp = doc.createElement("div");
						tmp.innerHTML = objectManager.findObjects(AjxStringUtil.trim(RegExp.$1));
						tmp = tmp.firstChild;
						if (tmp.nodeType == 3 /* Node.TEXT_NODE */) {
							// probably no objects were found.  A warning would be OK here
							// since the regexps guarantee that objects _should_ be found.
							return tmp.nextSibling;
						}
						// here, tmp is an object span, but it
						// contains the URL (href) instead of
						// the original link text.
						node.parentNode.insertBefore(tmp, node); // add it to DOM
						tmp.innerHTML = "";
						tmp.appendChild(node); // we have the original link now
						return tmp.nextSibling;	// move on
					}
					handlers = false;
				} else if (re_discard.test(tmp) || (re_allow && !re_allow.test(tmp))) {
					tmp = node.nextSibling;
					node.parentNode.removeChild(node);
					return tmp;
				}
			} else {
				// consider processed
				node = next;
			}

			if (AjxEnv.isIE) {
				// strips expression()-s, bwuahahaha!
				// granted, they get lost on the server-side anyway, but assuming some get through...
				// the line below exterminates them.
				node.style.cssText = node.style.cssText;
			}

			for (i = node.firstChild; i; i = recurse(i, handlers)) {}
			return node.nextSibling;

		    case 3:	// TEXT_NODE
		    case 4:	// CDATA_SECTION_NODE (just in case)
			// generate ObjectHandler-s
			if (handlers && /[^\s\xA0]/.test(node.data)) try {
 				var a = null, b = null;

				if (!AjxEnv.isIE) {
					// this block of code is supposed to free the object handlers from
					// dealing with whitespace.  However, IE sometimes crashes here, for
					// reasons that weren't possible to determine--hence we avoid this
					// step for IE.  (bug #5345)
					var results = /^[\s\xA0]+/.exec(node.data);
					if (results) {
						a = node;
						node = node.splitText(results[0].length);
					}
					results = /[\s\xA0]+$/.exec(node.data);
					if (results)
						b = node.splitText(node.data.length - results[0].length);
				}

				tmp = tmpdiv;
				var code = objectManager.findObjects(node.data, true, null, false);
				var disembowel = false;
				if (AjxEnv.isIE) {
					// Bug #6481, #4498: innerHTML in IE massacrates whitespace
					//            unless it sees a <pre> in the code.
					tmp.innerHTML = [ "<pre>", code, "</pre>" ].join("");
					disembowel = true;
				} else {
					tmp.innerHTML = code;
				}

				if (a)
					tmp.insertBefore(a, tmp.firstChild);
				if (b)
					tmp.appendChild(b);

				a = node.parentNode;
				if (disembowel)
					tmp = tmp.firstChild;
				while (tmp.firstChild)
					a.insertBefore(tmp.firstChild, node);
				tmp = node.nextSibling;
				a.removeChild(node);
				return tmp;
			} catch(ex) {};
		}
		return node.nextSibling;
	};
	var df = doc.createDocumentFragment();
	while (node.firstChild) {
		df.appendChild(node.firstChild); // NODE now out of the displayable DOM
		recurse(df.lastChild, true, this);	 // parse tree and findObjects()
	}
	node.appendChild(df);	// put nodes back in the document
};

/**
 * Sets handler attribute.
 * 
 * @param	{String}	type		the type
 * @param	{String}	name		the attribute name
 * @param	{Object}	value		the value
 */
ZmObjectManager.prototype.setHandlerAttr =
function(type, name, value) {
    var handlers = this.getHandlers()[type];
	if (handlers) {
		for (var i = 0; i < handlers.length; i++) {
			handlers[i][name] = value;
		}
	}
};

/**
 * Generates the span.
 * 
 * @private
 */
ZmObjectManager.prototype.generateSpan =
function(handler, html, idx, obj, context, options) {
	var id = this._objectIdPrefix + Dwt.getNextId();
    if (handler && handler.name) {
        id = id + "_" + handler.name;
    }
	this._objects[id] = {object: obj, handler: handler, id: id, context: context };
	return handler.generateSpan(html, idx, obj, id, context, options);
};

/**
 * @private
 */
ZmObjectManager.prototype._findObjectSpan =
function(e) {
	while (e && (!e.id || e.id.indexOf(this._objectIdPrefix) !== 0)) {
		e = e.parentNode;
	}
	return e;
};

/**
 * @private
 */
ZmObjectManager.prototype._mouseOverListener =
function(ev) {
	var span = this._findObjectSpan(ev.target);
	if (!span) {return false;}
	var object = this._objects[span.id];
	if (!object) {return false;}

	span.className = object.handler.getHoveredClassName(object.object, object.context, span.id);
	if (object.handler.hasToolTipText()) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		if ((!manager.isHovering() || manager.getHoverObject() != object) && !DwtMenu.menuShowing()) {
			manager.reset();
			manager.setHoverOverDelay(ZmObjectManager._TOOLTIP_DELAY);
			manager.setHoverObject(object);
			manager.setHoverOverData(object);
			manager.setHoverOverListener(this._hoverOverListener);
			manager.hoverOver(ev.docX, ev.docY);
			ev.hoverStarted = true;
		}
	}

	ev._returnValue = true;
	ev._dontCallPreventDefault = true;
	return false;
};

/**
 * @private
 */
ZmObjectManager.prototype._mouseOutListener =
function(ev) {
	var span = this._findObjectSpan(ev.target);
	var object = span ? this._objects[span.id] : null;

	if (object) {
		span.className = object.handler.getClassName(object.object, object.context, span.id);
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		manager.setHoverOutDelay(150);
		manager.setHoverOutData(object);
		manager.setHoverOutListener(this._hoverOutListener);
		manager.hoverOut();
	}

	return false;
};

/**
 * @private
 */
ZmObjectManager.prototype._mouseMoveListener =
function(ev) {
	ev._returnValue = true;
	ev._dontCallPreventDefault = true;
	ev._stopPropagation = true;
	var span = this._findObjectSpan(ev.target);
	var object = span ? this._objects[span.id] : null;

	if (object) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		if (!manager.isHovering()) {
			// NOTE: mouseOver already init'd hover settings
			manager.hoverOver(ev.docX, ev.docY);
		}
	}

	return false;
};

/**
 * @private
 */
ZmObjectManager.prototype._rightClickListener =
function(ev) {
	ev.button = DwtMouseEvent.RIGHT;
	return this._mouseDownListener(ev);
};

/**
 * @private
 */
ZmObjectManager.prototype._mouseDownListener =
function(ev) {

	// "authoritative" means a previous listener doesn't want propagation to get reset
	if (!ev._authoritative) {
		ev._dontCallPreventDefault = true;
		ev._returnValue = true;
		ev._stopPropagation = false;
	}

	var span = this._findObjectSpan(ev.target);
	if (!span) {
		return true;
	}
	var object = this._objects[span.id];
	if (!object) {
		return true;
	}

	ev._stopPropagation = true;

	var shell = DwtShell.getShell(window);
	var manager = shell.getHoverMgr();
	manager.setHoverOutDelay(0);
	manager.setHoverOutData(object);
	manager.setHoverOutListener(this._hoverOutListener);
	manager.hoverOut();

	span.className = object.handler.getActiveClassName(object.object, object.context, span.id);
	if (ev.button == DwtMouseEvent.RIGHT) {
		var menu = object.handler.getActionMenu(object.object, span, object.context, ev);
		if (menu) {
			menu.popup(0, ev.docX, ev.docY);
			// if we have an action menu, don't let the browser show its context menu too
			ev._dontCallPreventDefault = false;
			ev._returnValue = false;
			ev._stopPropagation = true;
			return true;
		}
	} else if (ev.button == DwtMouseEvent.LEFT) {
		if (this._selectCallback) {
			this._selectCallback.run();
		}
		object.handler.selected(object.object, span, ev, object.context);
		return true;
	}
	return false;
};

/**
 * @private
 */
ZmObjectManager.prototype._mouseUpListener =
function(ev) {
	ev._returnValue = true;
	ev._dontCallPreventDefault = true;
	ev._stopPropagation = true;
	var span = this._findObjectSpan(ev.target);
	if (!span) {return false;}
	var object = this._objects[span.id];
	if (!object) {return false;}

	span.className = object.handler.getHoveredClassName(object.object, object.context, span.id);
	return false;
};

/**
 * @private
 */
ZmObjectManager.prototype._handleHoverOver =
function(event) {
	if (!(event && event.object)) { return; }

	var span = this._findObjectSpan(event.target);
	var handler = event.object.handler;
	var object = event.object.object;
	var context = event.object.context;
	var id = event.object.id;
	var x = event.x;
	var y = event.y;

	handler.hoverOver(object, context, x, y, span, id);
};

/**
 * @private
 */
ZmObjectManager.prototype._handleHoverOut =
function(event) {
	if (!(event && event.object)) { return; }

	var span = this._findObjectSpan(event.target);
	var handler = event.object.handler;
	var object = event.object.object;
	var context = event.object.context;
	var id = event.object.id;

	handler.hoverOut(object, context, span, id);
};

// Private static functions

/**
 * @private
 */
ZmObjectManager.__byPriority =
function(a, b) {
	return (b._prio < a._prio) - (a._prio < b._prio);
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmSettings")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the settings class.
 */

/**
 * Creates a collection of settings with default values. If no app context is given,
 * then this is a skeletal, non-live version of settings which can provide default
 * settings and parse SOAP settings.
 * @class
 * This class is a collection of various sorts of settings: config values, preferences,
 * and COS features. Each setting has an ID which can be used to retrieve it.
 *
 * @author Conrad Damon
 *
 * @param {Boolean}	noInit	if <code>true</code>, skip initialization
 *
 * @extends		ZmModel
 */
ZmSettings = function(noInit) {

	ZmModel.call(this, ZmEvent.S_SETTINGS);

	this._settings = {};	// settings by ID
	this._nameToId = {};	// map to get from server setting name to setting ID

	this.getInfoResponse = null; // Cached GetInfoResponse for lazy creation of identities, etc.
	this._handleImplicitChange = new AjxListener(this, this._implicitChangeListener);

	if (!noInit) {
        this.initialize();
	}
};

ZmSettings.prototype = new ZmModel;
ZmSettings.prototype.constructor = ZmSettings;

ZmSettings.BASE64_TO_NORMAL_RATIO = 1.34;

/**
 * Creates a new setting and adds it to the settings.
 *
 * @param {String}		id			the unique ID of the setting
 * @param {Hash}	params		a hash of parameters
 * @param {String}	params.name			the name of the pref or attr on the server
 * @param {constant}	params.type		config, pref, or COS
 * @param {constant}	params.dataType	string, int, or boolean (defaults to string)
 * @param {Object}	params.defaultValue	the default value
 */
ZmSettings.prototype.registerSetting =
function(id, params) {
	ZmSetting[id] = id;
	var setting = this._settings[id] = new ZmSetting(id, params);
	if (params.name) {
		this._nameToId[params.name] = id;
	}
	if (params.isImplicit) {
		setting.addChangeListener(this._handleImplicitChange);
	}
	return setting;
};

/**
 * Returns a string representation of the object.
 *
 * @return		{String}		a string representation of the object
 */
ZmSettings.prototype.toString =
function() {
	return "ZmSettings";
};

/**
 * Initializes the settings.
 *
 */
ZmSettings.prototype.initialize =
function() {
	this._initialize();
	this._setDefaults();
	this.userSettingsLoaded = false;

	// set listeners for settings
	var listener = new AjxListener(this, this._changeListener);
	if (!appCtxt.multiAccounts) {
		this.getSetting(ZmSetting.QUOTA_USED).addChangeListener(listener);
	}
	this.getSetting(ZmSetting.POLLING_INTERVAL).addChangeListener(listener);
	this.getSetting(ZmSetting.SKIN_NAME).addChangeListener(listener);
	this.getSetting(ZmSetting.SHOW_SELECTION_CHECKBOX).addChangeListener(listener);
	this.getSetting(ZmSetting.LOCALE_NAME).addChangeListener(listener);
	this.getSetting(ZmSetting.FONT_NAME).addChangeListener(listener);
	this.getSetting(ZmSetting.FONT_SIZE).addChangeListener(listener);
	this.getSetting(ZmSetting.SHORTCUTS).addChangeListener(listener);
	this.getSetting(ZmSetting.CHILD_ACCTS_VISIBLE).addChangeListener(listener);
	this.getSetting(ZmSetting.ATTACHMENTS_BLOCKED).addChangeListener(listener);
	this.getSetting(ZmSetting.CHAT_PLAY_SOUND).addChangeListener(listener);
	this.getSetting(ZmSetting.CHAT_ENABLED).addChangeListener(listener);


	if (appCtxt.isOffline) {
		this.getSetting(ZmSetting.OFFLINE_IS_MAILTO_HANDLER).addChangeListener(listener);
        this.getSetting(ZmSetting.OFFLINE_BACKUP_ACCOUNT_ID).addChangeListener(listener);
        this.getSetting(ZmSetting.OFFLINE_BACKUP_INTERVAL).addChangeListener(listener);
        this.getSetting(ZmSetting.OFFLINE_BACKUP_PATH).addChangeListener(listener);
        this.getSetting(ZmSetting.OFFLINE_BACKUP_KEEP).addChangeListener(listener);
        this.getSetting(ZmSetting.OFFLINE_UPDATE_NOTIFY).addChangeListener(listener);
	}
};

/**
 * Gets the value of the given setting.
 *
 * @param {String}	id		the ID of the setting
 * @param	{String}	key		the key
 * @return	{Object}	the value or <code>null</code> for none
 */
ZmSettings.prototype.get =
function(id, key) {
	return (id && this._settings[id]) ? this._settings[id].getValue(key) : null;
};

/**
 * Sets the value of the given setting.
 *
 * @param {String}	id		the ID of the setting
 * @param {Object}	value			the new value for the setting
 * @param {String}	key 			optional key for use by hash table data type
 * @param {Boolean}	setDefault		if <code>true</code>, also set the default value
 * @param {Boolean}	skipNotify		if <code>true</code>, do not notify listeners
 * @param {Boolean}	skipImplicit		if <code>true</code>, do not check for change to implicit pref
 */
ZmSettings.prototype.set = function(id, value, key, setDefault, skipNotify, skipImplicit) {
	if (id && this._settings[id]) {
		this._settings[id].setValue(value, key, setDefault, skipNotify, skipImplicit);
	}
	else {
		DBG.println(AjxDebug.DBG1, "ZmSettings.set: ID missing (value = " + value);
	}
};

/**
 * Gets the setting.
 *
 * @param {String}	id		the ID of the setting
 * @return	{ZmSetting}	the setting
 */
ZmSettings.prototype.getSetting =
function(id) {
	return this._settings[id];
};

/**
 * Populates settings values.
 *
 * @param {Hash}	list		a hash of preference or attribute values
 */
ZmSettings.prototype.createFromJs =
function(list, setDefault, skipNotify, skipImplicit) {
    // default skipImplicit value is true
    skipImplicit = skipImplicit == null || skipImplicit; 

	for (var i in list) {
		var val = list[i];
		var setting = this._settings[this._nameToId[i]];
		if (setting) {
			if (setting.dataType == ZmSetting.D_HASH) {
				var pairs = val.split(",");
				var value = {};
				for (var j = 0; j < pairs.length; j++) {
					var fields = pairs[j].split(":");
					value[fields[0]] = fields[1];
				}
				val = value;
			}
			setting.setValue(val, null, setDefault, skipNotify, skipImplicit);
			if (ZmSetting.IS_IMPLICIT[setting.id]) {
				setting.origValue = setting.copyValue();
			}
		} else {
			DBG.println(AjxDebug.DBG3, "*** Unrecognized setting: " + i);
		}
	}
};

/**
 * Gets the setting that is associated with the given server-side setting, if any.
 *
 * @param {String}	name	the server-side setting name (for example, "zimbraFeatureContactsEnabled")
 * @return	{String}	the setting id
 */
ZmSettings.prototype.getSettingByName =
function(name) {
	return this._nameToId[name];
};

/**
 * Checks if the given ID was received from the server. Use this method
 * to determine whether this ID is supported by a ZCS server. Currently used by
 * ZDesktop since it can "talk" to both v5 and v6 ZCS.
 *
 * @param {String}	id	the setting ID
 * @return	{Boolean}	<code>true</code> if the attribute is supported
 */
ZmSettings.prototype.attrExists =
function(id) {
	var name = this.getSetting(id).name;
	return (this.getInfoResponse.prefs._attrs[name] ||
			this.getInfoResponse.attrs._attrs[name]);
};

/**
 * Retrieves the preferences, COS settings, and metadata for the current user.
 * All the data gets stored into the settings collection.
 *
 * @param {AjxCallback}	callback 			the callback to run after response is received
 * @param {AjxCallback}	errorCallback 	the callback to run error is received
 * @param {String}	accountName		the name of account to load settings for
 * @param {Object}	response			the pre-determined JSON response object
 * @param {ZmBatchCommand}	batchCommand		set if part of a batch request
 */
ZmSettings.prototype.loadUserSettings =
function(callback, errorCallback, accountName, response, batchCommand) {
	var args = [callback, accountName];

	var soapDoc = AjxSoapDoc.create("GetInfoRequest", "urn:zimbraAccount");
	soapDoc.setMethodAttribute("rights", "createDistList"); //not sure when this is called, but let's add it anyway. (on login it's called from within launchZCS.JSP calling GetInfoJSONTag.java
	var respCallback = this._handleResponseLoadUserSettings.bind(this, args);
	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, respCallback);
	}
	else {
		var params = {
			soapDoc: (response ? null : soapDoc),
			accountName: accountName,
			asyncMode: true,
			callback: respCallback,
			errorCallback: errorCallback,
			response: response
		};
		appCtxt.getAppController().sendRequest(params);
	}
};

/**
 * @private
 */
ZmSettings.prototype._handleResponseLoadUserSettings =
function(callback, accountName, result) {
    this.setUserSettings(result.getResponse().GetInfoResponse, accountName);
    this.userSettingsLoaded = true;
    if (callback) {
        callback.run(result);
    }
};

/**
 * Sets the user settings.
 *
 * @param {hash}    params
 * @param {object}  params.info             The GetInfoResponse object.
 * @param {string}  [params.accountName]    The name of the account.
 * @param {boolean} [params.setDefault]     Set default value
 * @param {boolean} [params.skipNotify]     Skip change notification
 * @param {boolean} [params.skipImplicit]   Skip implicit changes
 * @param {boolean} [params.preInit]        Only init base settings for startup
 */
ZmSettings.prototype.setUserSettings = function(params) {

    params = Dwt.getParams(arguments, ["info", "accountName", "setDefault", "skipNotify", "skipImplicit", "preInit"]);

    var info = this.getInfoResponse = params.info;

	appCtxt.createDistListAllowed = false;
	appCtxt.createDistListAllowedDomains = [];
	appCtxt.createDistListAllowedDomainsMap = {};
	var rightTargets = info.rights && info.rights.targets;
	if (rightTargets) {
		for (var i = 0; i < rightTargets.length; i++) {
			var target = rightTargets[i];
			if (target.right == "createDistList") {
				if (target.target[0].type == "domain") {
					appCtxt.createDistListAllowed = true;
					appCtxt.createDistListAllowedDomains.push(target.target[0].name);
					appCtxt.createDistListAllowedDomainsMap[target.target[0].name] = true;
					break;
				}
			}

		}
	}

	// For delegated admin who can see prefs but not mail, we still need to register the mail settings so
	// they can be created and set below in createFromJs().
	if (this.get(ZmSetting.ADMIN_DELEGATED)) {
		if (!this.get(ZmSetting.ADMIN_MAIL_ENABLED) && this.get(ZmSetting.ADMIN_PREFERENCES_ENABLED)) {
			(new ZmMailApp()).enableMailPrefs();
		}
	}

	// Voice feature
    this.set(ZmSetting.VOICE_ENABLED, this._hasVoiceFeature(), null, false, true);

    var accountName = params.accountName;
    var setDefault = params.preInit ? false : params.setDefault;
    var skipNotify = params.preInit ? true : params.skipNotify;
    var skipImplicit = params.preInit ? true : params.skipImplicit;

    var settings = [
        ZmSetting.ADMIN_DELEGATED,          info.adminDelegated,
        ZmSetting.MESSAGE_SIZE_LIMIT,    this._base64toNormalSize(info.attSizeLimit),
        ZmSetting.CHANGE_PASSWORD_URL,      info.changePasswordURL,
        ZmSetting.DOCUMENT_SIZE_LIMIT,      this._base64toNormalSize(info.docSizeLimit),
        ZmSetting.LAST_ACCESS,              info.accessed,
        ZmSetting.LICENSE_STATUS,           info.license && info.license.status,
        ZmSetting.PREVIOUS_SESSION,         info.prevSession,
        ZmSetting.PUBLIC_URL,               info.publicURL,
		ZmSetting.ADMIN_URL,                info.adminURL,
        ZmSetting.QUOTA_USED,               info.used,
        ZmSetting.RECENT_MESSAGES,          info.recent,
        ZmSetting.REST_URL,                 info.rest,
        ZmSetting.USERNAME,                 info.name,
		ZmSetting.EMAIL_VALIDATION_REGEX, 	info.zimbraMailAddressValidationRegex,
		ZmSetting.DISABLE_SENSITIVE_ZIMLETS_IN_MIXED_MODE, 	(info.domainSettings && info.domainSettings.zimbraZimletDataSensitiveInMixedModeDisabled ? info.domainSettings.zimbraZimletDataSensitiveInMixedModeDisabled : "FALSE")
    ];
    for (var i = 0; i < settings.length; i += 2) {
        var value = settings[i+1];
        if (value != null) {
            this.set(settings[i], value, null, setDefault, skipNotify, skipImplicit);
        }
    }

    // features and other settings
    if (info.attrs && info.attrs._attrs) {
        this.createFromJs(info.attrs._attrs, setDefault, skipNotify, skipImplicit);
    }

	// By default, everything but mail is enabled for delegated admin. Require an additional setting to allow admin to view mail.
	if (this.get(ZmSetting.ADMIN_DELEGATED)) {
		this.set(ZmSetting.MAIL_ENABLED, this.get(ZmSetting.ADMIN_MAIL_ENABLED), setDefault, skipNotify, skipImplicit);
		var enableMailPrefs = this.get(ZmSetting.MAIL_ENABLED) || (this.get(ZmSetting.ADMIN_DELEGATED) && this.get(ZmSetting.ADMIN_PREFERENCES_ENABLED));
		this.set(ZmSetting.MAIL_PREFERENCES_ENABLED, enableMailPrefs, setDefault, skipNotify, skipImplicit);
		// Disable other areas where mail could be exposed to a prefs-only admin
		if (this.get(ZmSetting.MAIL_PREFERENCES_ENABLED) && !this.get(ZmSetting.MAIL__ENABLED)) {
			this.set(ZmSetting.MAIL_FORWARDING_ENABLED, false, setDefault, skipNotify, skipImplicit);
			this.set(ZmSetting.FILTERS_MAIL_FORWARDING_ENABLED, false, setDefault, skipNotify, skipImplicit);
			this.set(ZmSetting.NOTIF_FEATURE_ENABLED, false, setDefault, skipNotify, skipImplicit);
		}
	}

	// Server may provide us with SSO-enabled URL for Community integration (integration URL with OAuth signature)
	if (info.communityURL) {
		this.set(ZmSetting.SOCIAL_EXTERNAL_URL, info.communityURL, null, setDefault, skipNotify);
	}

	if (params.preInit) {
	    return;
    }

    // preferences
    if (info.prefs && info.prefs._attrs) {
        this.createFromJs(info.prefs._attrs, setDefault, skipNotify, skipImplicit);
    }

    // accounts
	var setting;
	if (!accountName) {
		// NOTE: only the main account can have children
		appCtxt.accountList.createAccounts(this, info);

		// for offline, find out whether this client supports prism-specific features
		if (appCtxt.isOffline) {
			if (AjxEnv.isPrism && window.platform) {
				this.set(ZmSetting.OFFLINE_SUPPORTS_MAILTO, true, null, setDefault, skipNotify, skipImplicit);
				this.set(ZmSetting.OFFLINE_SUPPORTS_DOCK_UPDATE, true, null, setDefault, skipNotify, skipImplicit);
			}

			// bug #45804 - sharing always enabled for offline
			appCtxt.set(ZmSetting.SHARING_ENABLED, true, null, setDefault, skipNotify);
		}
	}

	// handle settings whose values may depend on other settings
	setting = this._settings[ZmSetting.REPLY_TO_ADDRESS];
	if (setting) {
		setting.defaultValue = this.get(ZmSetting.USERNAME);
	}
	if (this.get(ZmSetting.FORCE_CAL_OFF)) {
		this.set(ZmSetting.CALENDAR_ENABLED, false, null, setDefault, skipNotify, skipImplicit);
	}

	if (!this.get(ZmSetting.OPTIONS_ENABLED)) {
		this.set(ZmSetting.FILTERS_ENABLED, false, null, setDefault, skipNotify, skipImplicit);
	}

	// load zimlets *only* for the main account
	if (!accountName) {
		if (info.zimlets && info.zimlets.zimlet) {
            if (this.get(ZmSetting.ZIMLETS_SYNCHRONOUS)) {
                var action = new AjxTimedAction(this, this._beginLoadZimlets, [info.zimlets.zimlet, info.props.prop, true]);
                AjxTimedAction.scheduleAction(action, 0);
            } else {
                var listener = new AjxListener(this, this._beginLoadZimlets, [info.zimlets.zimlet, info.props.prop, false]);
                appCtxt.getAppController().addListener(ZmAppEvent.POST_STARTUP, listener);
            }
		} else {
			appCtxt.allZimletsLoaded();
		}
	}

	var value = appCtxt.get(ZmSetting.REPLY_INCLUDE_ORIG);
	if (value) {
		var list = ZmMailApp.INC_MAP[value];
		appCtxt.set(ZmSetting.REPLY_INCLUDE_WHAT, list[0], null, setDefault, skipNotify);
		appCtxt.set(ZmSetting.REPLY_USE_PREFIX, list[1], null, setDefault, skipNotify);
		appCtxt.set(ZmSetting.REPLY_INCLUDE_HEADERS, list[2], null, setDefault, skipNotify);
	}

	var value = appCtxt.get(ZmSetting.FORWARD_INCLUDE_ORIG);
	if (value) {
		var list = ZmMailApp.INC_MAP[value];
		appCtxt.set(ZmSetting.FORWARD_INCLUDE_WHAT, list[0], null, setDefault, skipNotify);
		appCtxt.set(ZmSetting.FORWARD_USE_PREFIX, list[1], null, setDefault, skipNotify);
		appCtxt.set(ZmSetting.FORWARD_INCLUDE_HEADERS, list[2], null, setDefault, skipNotify);
	}

    // Populate Sort Order Defaults
    var sortPref =  ZmSettings.DEFAULT_SORT_PREF;
    sortPref[ZmId.VIEW_CONVLIST]			= ZmSearch.DATE_DESC;
    sortPref[ZmId.VIEW_CONV]				= ZmSearch.DATE_DESC;
    sortPref[ZmId.VIEW_TRAD]				= ZmSearch.DATE_DESC;
    sortPref[ZmId.VIEW_CONTACT_SRC]			= ZmSearch.NAME_ASC;
    sortPref[ZmId.VIEW_CONTACT_TGT]			= ZmSearch.NAME_ASC;
    sortPref[ZmId.VIEW_CONTACT_SIMPLE]		= ZmSearch.NAME_ASC;
    sortPref[ZmId.VIEW_CAL]					= ZmSearch.DATE_ASC;
    sortPref[ZmId.VIEW_TASKLIST]			= ZmSearch.DUE_DATE_ASC;
    sortPref[ZmId.VIEW_BRIEFCASE_DETAIL]	= ZmSearch.SUBJ_ASC;

    var sortOrderSetting = this._settings[ZmSetting.SORTING_PREF];
    if (sortOrderSetting) {
        // Populate empty sort pref's with defaultValues
        for (var pref in sortPref){
            if (!sortOrderSetting.getValue(pref)){
                sortOrderSetting.setValue(sortPref[pref], pref, false, true);
            }
        }

        // Explicitly Set defaultValue
        sortOrderSetting.defaultValue = AjxUtil.hashCopy(sortPref);
    }
	
	DwtControl.useBrowserTooltips = this.get(ZmSetting.BROWSER_TOOLTIPS_ENABLED);

	this._updateUserFontPrefsRule();
};


ZmSettings.prototype._base64toNormalSize =
function(base64) {
	if (!base64 || base64 === -1) { //-1 is unlimited
		return base64;
	}
	return base64 / ZmSettings.BASE64_TO_NORMAL_RATIO;
};


/**
 * @private
 */
ZmSettings.prototype._beginLoadZimlets =
function(zimlet, prop, sync) {
	var zimletsCallback = new AjxCallback(this, this._loadZimletPackage, [zimlet, prop, sync]);
	AjxDispatcher.require(["Startup2"], false, zimletsCallback);
};

ZmSettings.prototype._loadZimletPackage =
function(zimlet, prop, sync) {
	var zimletsCallback = new AjxCallback(this, this._loadZimlets, [zimlet, prop, sync]);
	AjxDispatcher.require("Zimlet", false, zimletsCallback);
};

/**
 * @private
 */
ZmSettings.prototype._loadZimlets =
function(allZimlets, props, sync) {

	allZimlets = allZimlets || [];
	this.registerSetting("ZIMLETS",		{type:ZmSetting.T_CONFIG, defaultValue:allZimlets, isGlobal:true});
	this.registerSetting("USER_PROPS",	{type:ZmSetting.T_CONFIG, defaultValue:props});

	var zimlets = this._getCheckedZimlets(allZimlets);

	DBG.println(AjxDebug.DBG1, "Zimlets - Loading " + zimlets.length + " Zimlets");
	var zimletMgr = appCtxt.getZimletMgr();
	zimletMgr.loadZimlets(zimlets, props, null, null, sync);

	if (zimlets && zimlets.length) {
		var activeApp = appCtxt.getCurrentApp();
		if (activeApp) {
			var overview;
			if (appCtxt.multiAccounts) {
				var containerId = activeApp.getOverviewContainer().containerId;
				var zimletLabel = ZmOrganizer.LABEL[ZmOrganizer.ZIMLET];
				var overviewId = [containerId, zimletLabel].join("_");
				overview = appCtxt.getOverviewController().getOverview(overviewId);
			} else {
				overview = activeApp.getOverview();
			}
		}

		// update overview tree
		if (overview) {
			overview.setTreeView(ZmOrganizer.ZIMLET);

			// HACK: for multi-account, hide the zimlet section if no panel zimlets
			if (appCtxt.multiAccounts && zimletMgr.getPanelZimlets().length == 0) {
				activeApp.getOverviewContainer().removeZimletSection();
			}
		}

		// create global portlets
		if (appCtxt.get(ZmSetting.PORTAL_ENABLED)) {
			var portletMgr = appCtxt.getApp(ZmApp.PORTAL).getPortletMgr();
			var portletIds = portletMgr.createPortlets(true);
		}
	}
};

/**
 * Filters a list of zimlets, returned ones that are checked.
 *
 * @param zimlets			[array]		list of zimlet objects
 *
 * @private
 */
ZmSettings.prototype._getCheckedZimlets =
function(allZimlets) {

	var zimlets = [];
	for (var i = 0; i < allZimlets.length; i++) {
		var zimletObj = allZimlets[i];
		if (zimletObj.zimletContext[0].presence != "disabled") {
			zimlets.push(zimletObj);
		}
	}

	return zimlets;
};

/**
 * Loads the preference data.
 *
 * @param	{AjxCallback}	callback		the callback
 */
ZmSettings.prototype.loadPreferenceData =
function(callback) {
	// force main account (in case multi-account) since locale/skins are global
	var command = new ZmBatchCommand(null, appCtxt.accountList.mainAccount.name);

	var skinDoc = AjxSoapDoc.create("GetAvailableSkinsRequest", "urn:zimbraAccount");
	var skinCallback = new AjxCallback(this, this._handleResponseLoadAvailableSkins);
	command.addNewRequestParams(skinDoc, skinCallback);

	var localeDoc = AjxSoapDoc.create("GetAvailableLocalesRequest", "urn:zimbraAccount");
	var localeCallback = new AjxCallback(this, this._handleResponseGetAllLocales);
	command.addNewRequestParams(localeDoc, localeCallback);

	var csvFormatsDoc = AjxSoapDoc.create("GetAvailableCsvFormatsRequest", "urn:zimbraAccount");
	var csvFormatsCallback = new AjxCallback(this, this._handleResponseGetAvailableCsvFormats);
	command.addNewRequestParams(csvFormatsDoc, csvFormatsCallback);

	command.run(callback);
};

/**
 * @private
 */
ZmSettings.prototype._handleResponseLoadAvailableSkins =
function(result) {
	var resp = result.getResponse().GetAvailableSkinsResponse;
	var skins = resp.skin;
	if (skins && skins.length) {
		var setting = appCtxt.accountList.mainAccount.settings.getSetting(ZmSetting.AVAILABLE_SKINS);
		for (var i = 0; i < skins.length; i++) {
			// always save available skins on the main account (in case multi-account)
			setting.setValue(skins[i].name);
		}
	}
};

/**
 * @private
 */
ZmSettings.prototype._handleResponseGetAllLocales =
function(response) {
	var locales = response._data.GetAvailableLocalesResponse.locale;
	if (locales && locales.length) {
		for (var i = 0, count = locales.length; i < count; i++) {
			var locale = locales[i];
			// bug: 38038
			locale.id = locale.id.replace(/^in/,"id");
			ZmLocale.create(locale.id, locale.name, ZmMsg["localeName_" + locale.id] || locale.localName);
		}
        if (locales.length === 1) {
            //Fix for bug# 80762 - Set the value to always true in case of only one language/locale present
            this.set(ZmSetting.LOCALE_CHANGE_ENABLED, true);
        }
        else {
            this.set(ZmSetting.LOCALE_CHANGE_ENABLED, ZmLocale.hasChoices());
        }
	}
};

/**
 * @private
 */
ZmSettings.prototype._handleResponseGetAvailableCsvFormats =
function(result){
	var formats = result.getResponse().GetAvailableCsvFormatsResponse.csv;
	if (formats && formats.length) {
		var setting = appCtxt.accountList.mainAccount.settings.getSetting(ZmSetting.AVAILABLE_CSVFORMATS);
		for (var i = 0; i < formats.length; i++) {
			setting.setValue(formats[i].name);
		}
	}
};

/**
 * Saves one or more settings.
 *
 * @param {Array}		list			a list of {ZmSetting} objects
 * @param {AjxCallback}	callback		the callback to run after response is received
 * @param {ZmBatchCommand}	batchCommand	the batch command
 * @param {ZmZimbraAccount}	account		the account to save under
 * @param {boolean}			isImplicit	if true, we are saving implicit settings
 */
ZmSettings.prototype.save =
function(list, callback, batchCommand, account, isImplicit) {
	if (!(list && list.length)) { return; }

	var acct = account || appCtxt.getActiveAccount();
	var soapDoc = AjxSoapDoc.create("ModifyPrefsRequest", "urn:zimbraAccount");
	var gotOne = false;
	var metaData = [], done = {}, setting;
	for (var i = 0; i < list.length; i++) {
		setting = list[i];
        if (done[setting.id]) { continue; }
		if (setting.type == ZmSetting.T_METADATA) {
			metaData.push(setting);
			// update the local meta data
			acct.metaData.update(setting.section, setting.name, setting.getValue());
			continue;
		} else if (setting.type != ZmSetting.T_PREF) {
			DBG.println(AjxDebug.DBG1, "*** Attempt to modify non-pref: " + setting.id + " / " + setting.name);
			continue;
		}
		if (!setting.name) {
			DBG.println(AjxDebug.DBG2, "Modify internal pref: " + setting.id);
			continue;
		}
		if (setting.dataType == ZmSetting.D_LIST) {
			// LDAP supports multi-valued attrs, so don't serialize list
			var value = setting.getValue();
			if (value && value.length) {
				for (var j = 0; j < value.length; j++) {
					var node = soapDoc.set("pref", value[j]);
					node.setAttribute("name", setting.name);
				}
			} else {
				var node = soapDoc.set("pref", "");
				node.setAttribute("name", setting.name);
			}
		} else {
			var value = setting.getValue(null, true);
			var node = soapDoc.set("pref", value);
			node.setAttribute("name", setting.name);
		}

        done[setting.id] = true;
		gotOne = true;
	}

    // bug: 50668 if the setting is implicit and global, use main Account
    if(appCtxt.isOffline && ZmSetting.IS_IMPLICIT[setting.id] && ZmSetting.IS_GLOBAL[setting.id]) {
        acct = appCtxt.accountList.mainAccount;
    }

	if (metaData.length > 0) {
		var metaDataCallback = new AjxCallback(this, this._handleResponseSaveMetaData, [metaData]);
		var sections = [ZmSetting.M_IMPLICIT, ZmSetting.M_OFFLINE];
		acct.metaData.save(sections, metaDataCallback);
	}

	if (gotOne) {
		var respCallback;
		if (callback || batchCommand) {
			respCallback = new AjxCallback(this, this._handleResponseSave, [list, callback]);
		}
		if (batchCommand) {
			batchCommand.addNewRequestParams(soapDoc, respCallback);
		} else {
			appCtxt.getAppController().sendRequest({soapDoc:soapDoc, asyncMode:true, callback:respCallback,
			 										accountName:acct.name, noBusyOverlay:isImplicit});
		}
	}
};

/**
 * @private
 */
ZmSettings.prototype._handleResponseSaveMetaData =
function(list, result) {
	for (var i = 0; i < list.length; i++) {
		var setting = list[i];
		if (!ZmSetting.IS_IMPLICIT[setting.id]) {
			setting.origValue = setting.copyValue();
			setting._notify(ZmEvent.E_MODIFY);
		}
	}
};

/**
 * @private
 */
ZmSettings.prototype._handleResponseSave =
function(list, callback, result) {
	var resp = result.getResponse();
	if (resp.ModifyPrefsResponse != null) {
		// notify each changed setting's listeners
		for (var i = 0; i < list.length; i++) {
			var setting = list[i];
			setting.origValue = setting.copyValue();
			if (!ZmSetting.IS_IMPLICIT[setting.id]) {
				setting._notify(ZmEvent.E_MODIFY);
			}
		}
		// notify any listeners on the settings as a whole
		this._notify(ZmEvent.E_MODIFY, {settings:list});
	}

	if (callback) {
		callback.run(result);
	}
};

ZmSettings.DEFAULT_SORT_PREF = {};

/**
 * Set defaults which are determined dynamically (which can't be set in static code).
 *
 * @private
 */
ZmSettings.prototype._setDefaults =
function() {

	var value = AjxUtil.formatUrl({host:location.hostname, path:"/service/soap/", qsReset:true});
	this.set(ZmSetting.CSFE_SERVER_URI, value, null, false, true);

	// CSFE_MSG_FETCHER_URI
	value = AjxUtil.formatUrl({host:location.hostname, path:"/service/home/~/", qsReset:true, qsArgs:{auth:"co"}});
	this.set(ZmSetting.CSFE_MSG_FETCHER_URI, value, null, false, true);

	// CSFE_UPLOAD_URI
	value = AjxUtil.formatUrl({host:location.hostname, path:"/service/upload", qsReset:true, qsArgs:{lbfums:""}});
	this.set(ZmSetting.CSFE_UPLOAD_URI, value, null, false, true);

	// CSFE_ATTACHMENT_UPLOAD_URI
	value = AjxUtil.formatUrl({host:location.hostname, path:"/service/upload", qsReset:true});
	this.set(ZmSetting.CSFE_ATTACHMENT_UPLOAD_URI, value, null, false, true);

	// CSFE EXPORT URI
	value = AjxUtil.formatUrl({host:location.hostname, path:"/service/home/~/", qsReset:true, qsArgs:{auth:"co", id:"{0}", fmt:"csv"}});
	this.set(ZmSetting.CSFE_EXPORT_URI, value, null, false, true);

	var h = location.hostname;
	var isDev = ((h.indexOf(".zimbra.com") != -1) || (window.appDevMode && (/\.local$/.test(h) || (!appCtxt.isOffline && h == "localhost"))));
	this.set(ZmSetting.IS_DEV_SERVER, isDev);
	if (isDev || window.isScriptErrorOn) {
		this.set(ZmSetting.SHOW_SCRIPT_ERRORS, true, null, false, true);
	}

	this.setReportScriptErrorsSettings(AjxException, ZmController.handleScriptError);
};

ZmSettings.prototype.persistImplicitSortPrefs =
function(id){
    return ZmSettings.DEFAULT_SORT_PREF[id];
};

/**
 * sets AjxException static attributes. This is extracted so it can be called from ZmNewwindow as well.
 * this is since the child window gets its own AjxException variable.
 *
 * @param AjxExceptionClassVar
 * @param handler
 */
ZmSettings.prototype.setReportScriptErrorsSettings =
function(AjxExceptionClassVar, handler) {
	// script error reporting
	var rse = AjxExceptionClassVar.reportScriptErrors = this._settings[ZmSetting.SHOW_SCRIPT_ERRORS].getValue();
	if (rse) {
		AjxExceptionClassVar.setScriptErrorHandler(handler);
	}

};

/**
 * Loads the standard settings and their default values.
 *
 * @private
 */
ZmSettings.prototype._initialize =
function() {
	// CONFIG SETTINGS
    this.registerSetting("ADMIN_DELEGATED",                 {type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("AC_TIMER_INTERVAL",				{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_INT, defaultValue:300});
	this.registerSetting("ASYNC_MODE",						{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("BRANCH",							{type:ZmSetting.T_CONFIG, defaultValue:"JUDASPRIEST"});

	// next 3 are replaced during deployment
	this.registerSetting("CLIENT_DATETIME",					{type:ZmSetting.T_CONFIG, defaultValue:"20161025-0504"});
	this.registerSetting("CLIENT_RELEASE",					{type:ZmSetting.T_CONFIG, defaultValue:"20161025045328"});
	this.registerSetting("CLIENT_VERSION",					{type:ZmSetting.T_CONFIG, defaultValue:"8.7.1_GA_1670"});
	this.registerSetting("CONFIG_PATH",						{type:ZmSetting.T_CONFIG, defaultValue:appContextPath + "/js/zimbraMail/config"});
	this.registerSetting("CSFE_EXPORT_URI",					{type:ZmSetting.T_CONFIG});
	this.registerSetting("CSFE_MSG_FETCHER_URI",			{type:ZmSetting.T_CONFIG});
	this.registerSetting("CSFE_SERVER_URI",					{type:ZmSetting.T_CONFIG});
	this.registerSetting("CSFE_UPLOAD_URI",					{type:ZmSetting.T_CONFIG});
	this.registerSetting("CSFE_ATTACHMENT_UPLOAD_URI",		{type:ZmSetting.T_CONFIG});
	this.registerSetting("DEV",								{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("FORCE_CAL_OFF",					{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("HELP_URI",						{name:"zimbraHelpAdvancedURL", type:ZmSetting.T_CONFIG, defaultValue:appContextPath + ZmMsg.helpURI});
	this.registerSetting("HTTP_PORT",						{type:ZmSetting.T_CONFIG, defaultValue:ZmSetting.HTTP_DEFAULT_PORT});
	this.registerSetting("HTTPS_PORT",						{type:ZmSetting.T_CONFIG, defaultValue:ZmSetting.HTTPS_DEFAULT_PORT});
	this.registerSetting("INSTANT_NOTIFY_INTERVAL",			{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_INT, defaultValue:500}); // milliseconds
	this.registerSetting("INSTANT_NOTIFY_TIMEOUT",			{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_INT, defaultValue:300}); // seconds
	this.registerSetting("IS_DEV_SERVER",					{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("LOG_REQUEST",						{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("LOGO_URI",						{type:ZmSetting.T_CONFIG, defaultValue:null});
	this.registerSetting("PROTOCOL_MODE",					{type:ZmSetting.T_CONFIG, defaultValue:ZmSetting.PROTO_HTTP});
	this.registerSetting("SERVER_VERSION",					{type:ZmSetting.T_CONFIG});
	this.registerSetting("SHOW_SCRIPT_ERRORS",				{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("TIMEOUT",							{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_INT, defaultValue:30}); // seconds
	this.registerSetting("USE_XML",							{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("SMIME_HELP_URI",						{type:ZmSetting.T_CONFIG, defaultValue:appContextPath + ZmMsg.smimeHelpURI});

	// DOMAIN SETTINGS
	this.registerSetting("CHANGE_PASSWORD_URL",				{type:ZmSetting.T_CONFIG});
	this.registerSetting("PUBLIC_URL",						{type:ZmSetting.T_CONFIG});
	this.registerSetting("ADMIN_URL",						{type:ZmSetting.T_CONFIG});
	this.registerSetting("DISABLE_SENSITIVE_ZIMLETS_IN_MIXED_MODE",		{type:ZmSetting.T_CONFIG});

	// COS SETTINGS - APPS
	this.registerSetting("BRIEFCASE_ENABLED",				{name:"zimbraFeatureBriefcasesEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("ATTACHMENTS_BLOCKED",				{name:"zimbraAttachmentsBlocked", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("CALENDAR_ENABLED",				{name:"zimbraFeatureCalendarEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("CALENDAR_UPSELL_ENABLED",			{name:"zimbraFeatureCalendarUpsellEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("CALENDAR_UPSELL_URL",				{name:"zimbraFeatureCalendarUpsellURL", type:ZmSetting.T_COS});
	this.registerSetting("CONTACTS_ENABLED",				{name:"zimbraFeatureContactsEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("CONTACTS_UPSELL_ENABLED",			{name:"zimbraFeatureContactsUpsellEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("CONTACTS_UPSELL_URL",				{name:"zimbraFeatureContactsUpsellURL", type:ZmSetting.T_COS});
	this.registerSetting("IMPORT_ENABLED",					{name:"zimbraFeatureImportFolderEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("EXPORT_ENABLED",					{name:"zimbraFeatureExportFolderEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    this.registerSetting("MAIL_ENABLED",					{name:"zimbraFeatureMailEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    this.registerSetting("EXTERNAL_USER_MAIL_ADDRESS",		{name:"zimbraExternalUserMailAddress", type:ZmSetting.T_COS, dataType:ZmSetting.D_STRING});
    this.registerSetting("ADMIN_MAIL_ENABLED",				{name:"zimbraFeatureAdminMailEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    this.registerSetting("ADMIN_PREFERENCES_ENABLED",		{name:"zimbraFeatureAdminPreferencesEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("MAIL_UPSELL_ENABLED",				{name:"zimbraFeatureMailUpsellEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("MAIL_UPSELL_URL",					{name:"zimbraFeatureMailUpsellURL", type:ZmSetting.T_COS});
	this.registerSetting("OPTIONS_ENABLED",					{name:"zimbraFeatureOptionsEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("PORTAL_ENABLED",					{name:"zimbraFeaturePortalEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("SOCIAL_ENABLED",					{name:"zimbraFeatureSocialEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("SOCIAL_EXTERNAL_ENABLED",			{name:"zimbraFeatureSocialExternalEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("SOCIAL_EXTERNAL_URL",				{name:"zimbraFeatureSocialExternalURL", type:ZmSetting.T_COS});
	this.registerSetting("SOCIAL_NAME",				        {name:"zimbraFeatureSocialName", type:ZmSetting.T_COS, defaultValue:ZmMsg.communityName});
	this.registerSetting("TASKS_ENABLED",					{name:"zimbraFeatureTasksEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("VOICE_ENABLED",					{name:"zimbraFeatureVoiceEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("VOICE_UPSELL_ENABLED",			{name:"zimbraFeatureVoiceUpsellEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("VOICE_UPSELL_URL",				{name:"zimbraFeatureVoiceUpsellURL", type:ZmSetting.T_COS});
	this.registerSetting("DLS_FOLDER_ENABLED",				{name:"zimbraFeatureDistributionListFolderEnabled", type: ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue: true});

	// COS SETTINGS
    this.registerSetting("ATTACHMENTS_VIEW_IN_HTML_ONLY",	{name:"zimbraAttachmentsViewInHtmlOnly", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("AVAILABLE_SKINS",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST, isGlobal:true});
	this.registerSetting("AVAILABLE_CSVFORMATS",			{type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST, isGlobal:true});
	this.registerSetting("CHANGE_PASSWORD_ENABLED",			{name:"zimbraFeatureChangePasswordEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("DISPLAY_NAME",					{name:"displayName", type:ZmSetting.T_COS});
	this.registerSetting("DUMPSTER_ENABLED",				{name:"zimbraDumpsterEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("ERROR_REPORT_URL",				{name:"zimbraErrorReportUrl", type:ZmSetting.T_COS, dataType:ZmSetting.D_STRING});
	this.registerSetting("EXPORT_MAX_DAYS",					{name:"zimbraExportMaxDays", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:0});
	this.registerSetting("FILTER_BATCH_SIZE",               {name:"zimbraFilterBatchSize", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue: 10000});
    this.registerSetting("FLAGGING_ENABLED",				{name:"zimbraFeatureFlaggingEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("FOLDERS_EXPANDED",				{name:"zimbraPrefFoldersExpanded", type:ZmSetting.T_METADATA, dataType: ZmSetting.D_HASH, isImplicit:true, section:ZmSetting.M_IMPLICIT});
	this.registerSetting("FOLDER_TREE_OPEN",				{name:"zimbraPrefFolderTreeOpen", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isImplicit:true});
	this.registerSetting("FOLDER_TREE_SASH_WIDTH",          {name:"zimbraPrefFolderTreeSash", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_INT, isImplicit:true, section:ZmSetting.M_IMPLICIT});
	this.registerSetting("GAL_AUTOCOMPLETE_ENABLED",		{name:"zimbraFeatureGalAutoCompleteEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN,	defaultValue:false});
	this.registerSetting("GAL_ENABLED",						{name:"zimbraFeatureGalEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN,	defaultValue:true});
	this.registerSetting("GROUP_CALENDAR_ENABLED",			{name:"zimbraFeatureGroupCalendarEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("HTML_COMPOSE_ENABLED",			{name:"zimbraFeatureHtmlComposeEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("IDLE_SESSION_TIMEOUT",			{name:"zimbraMailIdleSessionTimeout", type:ZmSetting.T_COS, dataType:ZmSetting.D_LDAP_TIME, defaultValue:0});
	this.registerSetting("IMAP_ACCOUNTS_ENABLED",			{name:"zimbraFeatureImapDataSourceEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("IMPORT_ON_LOGIN_ENABLED",			{name:"zimbraDataSourceImportOnLogin", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("INSTANT_NOTIFY",					{name:"zimbraFeatureInstantNotify", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("LOCALE_CHANGE_ENABLED",			{name:"zimbraFeatureLocaleChangeEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("LOCALES",							{type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST});
	this.registerSetting("LOGIN_URL",						{name:"zimbraWebClientLoginURL", type:ZmSetting.T_COS});
	this.registerSetting("LOGOUT_URL",						{name:"zimbraWebClientLogoutURL", type:ZmSetting.T_COS});
	this.registerSetting("MIN_POLLING_INTERVAL",			{name:"zimbraMailMinPollingInterval", type:ZmSetting.T_COS, dataType:ZmSetting.D_LDAP_TIME, defaultValue:120});
	this.registerSetting("MOBILE_SYNC_ENABLED",				{name:"zimbraFeatureMobileSyncEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("MOBILE_POLICY_ENABLED",			{name:"zimbraFeatureMobilePolicyEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("POP_ACCOUNTS_ENABLED",			{name:"zimbraFeaturePop3DataSourceEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("PORTAL_NAME",						{name:"zimbraPortalName", type:ZmSetting.T_COS, defaultValue:"example"});
	this.registerSetting("PRIORITY_INBOX_ENABLED",          {name:"zimbraFeaturePriorityInboxEnabled", type:ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("PWD_MAX_LENGTH",					{name:"zimbraPasswordMaxLength", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:64});
	this.registerSetting("PWD_MIN_LENGTH",					{name:"zimbraPasswordMinLength", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:6});
	this.registerSetting("QUOTA",							{name:"zimbraMailQuota", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:0});
	this.registerSetting("SAVED_SEARCHES_ENABLED",			{name:"zimbraFeatureSavedSearchesEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("SEARCH_TREE_OPEN",				{name:"zimbraPrefSearchTreeOpen", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isImplicit:true});
	this.registerSetting("SHARING_ENABLED",					{name:"zimbraFeatureSharingEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SHARING_PUBLIC_ENABLED",			{name:"zimbraPublicSharingEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SHARING_EXTERNAL_ENABLED",		{name:"zimbraExternalSharingEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SHORTCUT_ALIASES_ENABLED",		{name:"zimbraFeatureShortcutAliasesEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SHOW_OFFLINE_LINK",				{name:"zimbraWebClientShowOfflineLink", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SIGNATURES_ENABLED",				{name:"zimbraFeatureSignaturesEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SKIN_CHANGE_ENABLED",				{name:"zimbraFeatureSkinChangeEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    this.registerSetting("SOCIAL_FILTERS_ENABLED",          {name:"zimbraFeatureSocialFiltersEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST, isImplicit: true, section:ZmSetting.M_IMPLICIT});
	this.registerSetting("SPAM_ENABLED",					{name:"zimbraFeatureAntispamEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("TAG_TREE_OPEN",					{name:"zimbraPrefTagTreeOpen", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isImplicit:true});
	this.registerSetting("TAGGING_ENABLED",					{name:"zimbraFeatureTaggingEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("VIEW_ATTACHMENT_AS_HTML",			{name:"zimbraFeatureViewInHtmlEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("EXPAND_DL_ENABLED",				{name:"zimbraFeatureDistributionListExpandMembersEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("FORCE_CLEAR_COOKIES",				{name:"zimbraForceClearCookies", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("WEBCLIENT_OFFLINE_ENABLED",		{name:"zimbraFeatureWebClientOfflineAccessEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SPELL_DICTIONARY",                                {name:"zimbraPrefSpellDictionary", type:ZmSetting.T_COS, defaultValue:""});
	this.registerSetting("TWO_FACTOR_AUTH_AVAILABLE",	    {name:"zimbraFeatureTwoFactorAuthAvailable", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("TWO_FACTOR_AUTH_REQUIRED",	    {name:"zimbraFeatureTwoFactorAuthRequired", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("TRUSTED_DEVICES_ENABLED",         {name:"zimbraFeatureTrustedDevicesEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("APP_PASSWORDS_ENABLED",	        {name:"zimbraFeatureAppSpecificPasswordsEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});

	// user metadata (included with COS since the user can't change them)
	this.registerSetting("LICENSE_STATUS",					{type:ZmSetting.T_COS, defaultValue:ZmSetting.LICENSE_GOOD});
	this.registerSetting("QUOTA_USED",						{type:ZmSetting.T_COS, dataType:ZmSetting.D_INT});    
	this.registerSetting("USERID",							{name:"zimbraId", type:ZmSetting.T_COS});
	this.registerSetting("USERNAME",						{type:ZmSetting.T_COS});
	this.registerSetting("CN",								{name:"cn", type:ZmSetting.T_COS});
	this.registerSetting("LAST_ACCESS",						{type:ZmSetting.T_COS, dataType:ZmSetting.D_INT});
	this.registerSetting("PREVIOUS_SESSION",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_INT});
	this.registerSetting("RECENT_MESSAGES",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_INT});
	this.registerSetting("REST_URL",						{name:"rest" , type:ZmSetting.T_COS});
	this.registerSetting("IS_ADMIN",						{name:"zimbraIsAdminAccount", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue: false});
	this.registerSetting("IS_EXTERNAL",						{name:"zimbraIsExternalVirtualAccount", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue: false});
	this.registerSetting("IS_DELEGATED_ADMIN",				{name:"zimbraIsDelegatedAdminAccount", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue: false});
    this.registerSetting("MESSAGE_SIZE_LIMIT",              {type:ZmSetting.T_COS, dataType:ZmSetting.D_INT});
    this.registerSetting("DOCUMENT_SIZE_LIMIT",             {type:ZmSetting.T_COS, dataType:ZmSetting.D_INT});

	// CLIENT SIDE FEATURE SUPPORT
	this.registerSetting("ATTACHMENT_ENABLED",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("ATT_VIEW_ENABLED",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("BROWSER_TOOLTIPS_ENABLED",		{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("EVAL_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("FEED_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("HELP_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("HISTORY_SUPPORT_ENABLED",			{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:("onhashchange" in window)});
	this.registerSetting("NOTES_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("PRINT_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SEARCH_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SHORTCUT_LIST_ENABLED",			{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("OFFLINE_ENABLED",					{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:appCtxt.isOffline});
	this.registerSetting("SPELL_CHECK_ENABLED",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:!appCtxt.isOffline && (!AjxEnv.isSafari || AjxEnv.isSafari3up || AjxEnv.isChrome)});
	this.registerSetting("SPELL_CHECK_ADD_WORD_ENABLED",	{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:!AjxEnv.isSafari || AjxEnv.isSafari3up || AjxEnv.isChrome});

	//SETTINGS SET AT DOMAIN LEVEL
	this.registerSetting("EMAIL_VALIDATION_REGEX",			{name:"zimbraMailAddressValidationRegex", type:ZmSetting.T_DOMAIN, dataType:ZmSetting.D_LIST});
	this.registerSetting("SUPPORTED_HELPS",					{name:"zimbraWebClientSupportedHelps", type:ZmSetting.T_DOMAIN, dataType:ZmSetting.D_LIST});

	// USER PREFERENCES (mutable)

	// general preferences
	this.registerSetting("ACCOUNTS",						{type: ZmSetting.T_PREF, dataType: ZmSetting.D_HASH});
	this.registerSetting("TWO_FACTOR_AUTH_ENABLED",	        {name:"zimbraTwoFactorAuthEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("ACCOUNT_TREE_OPEN",				{name:"zimbraPrefAccountTreeOpen", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isImplicit:true});
	this.registerSetting("CHILD_ACCTS_VISIBLE",				{name:"zimbraPrefChildVisibleAccount", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LIST});
	this.registerSetting("CLIENT_TYPE",						{name:"zimbraPrefClientType", type:ZmSetting.T_PREF, defaultValue:ZmSetting.CLIENT_ADVANCED});
	this.registerSetting("COMPOSE_AS_FORMAT",				{name:"zimbraPrefComposeFormat", type:ZmSetting.T_PREF, defaultValue:ZmSetting.COMPOSE_HTML, isGlobal:true});
	this.registerSetting("COMPOSE_INIT_FONT_COLOR",			{name:"zimbraPrefHtmlEditorDefaultFontColor", type:ZmSetting.T_PREF, defaultValue:ZmSetting.COMPOSE_FONT_COLOR, isGlobal:true});
	this.registerSetting("COMPOSE_INIT_FONT_FAMILY",		{name:"zimbraPrefHtmlEditorDefaultFontFamily", type:ZmSetting.T_PREF, defaultValue:ZmSetting.COMPOSE_FONT_FAM, isGlobal:true});
	this.registerSetting("COMPOSE_INIT_FONT_SIZE",			{name:"zimbraPrefHtmlEditorDefaultFontSize", type:ZmSetting.T_PREF, defaultValue:ZmSetting.COMPOSE_FONT_SIZE, isGlobal:true});
    this.registerSetting("COMPOSE_INIT_DIRECTION",			{name:"zimbraPrefComposeDirection", type:ZmSetting.T_PREF, defaultValue:ZmSetting.LTR, isGlobal:true});
    this.registerSetting("SHOW_COMPOSE_DIRECTION_BUTTONS",	{name:"zimbraPrefShowComposeDirection", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("DEFAULT_TIMEZONE",				{name:"zimbraPrefTimeZoneId", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:AjxTimezone.getServerId(AjxTimezone.DEFAULT), isGlobal:true});
    this.registerSetting("WEBCLIENT_OFFLINE_BROWSER_KEY",	{name:"zimbraPrefWebClientOfflineBrowserKey", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, isImplicit:true});
    this.registerSetting("DEFAULT_PRINTFONTSIZE",	    	{name:"zimbraPrefDefaultPrintFontSize", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmSetting.PRINT_FONT_SIZE, isGlobal:true});
	this.registerSetting("GROUPBY_HASH",                    {type: ZmSetting.T_PREF, dataType:ZmSetting.D_HASH});
	this.registerSetting("GROUPBY_LIST",                    {name:"zimbraPrefGroupByList", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_HASH, isImplicit:true, section:ZmSetting.M_IMPLICIT});
    this.registerSetting("FILTERS",							{type: ZmSetting.T_PREF, dataType: ZmSetting.D_HASH});
	this.registerSetting("FONT_NAME",						{name:"zimbraPrefFont", type:ZmSetting.T_PREF, defaultValue: ZmSetting.FONT_SYSTEM, isGlobal:true});
	this.registerSetting("FONT_SIZE",						{name:"zimbraPrefFontSize", type:ZmSetting.T_PREF, defaultValue: ZmSetting.FONT_SIZE_NORMAL, isGlobal:true});
	this.registerSetting("IDENTITIES",						{type: ZmSetting.T_PREF, dataType: ZmSetting.D_HASH});
	this.registerSetting("INITIALLY_SEARCH_GAL",			{name:"zimbraPrefGalSearchEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("LIST_VIEW_COLUMNS",				{name:"zimbraPrefListViewColumns", type:ZmSetting.T_PREF, dataType:ZmSetting.D_HASH, isImplicit:true});
	this.registerSetting("LOCALE_NAME",						{name:"zimbraPrefLocale", type:ZmSetting.T_PREF, defaultValue:appRequestLocaleId, isGlobal:true});
	this.registerSetting("SHOW_SELECTION_CHECKBOX",			{name:"zimbraPrefShowSelectionCheckbox", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	// PAGE_SIZE: number of items to fetch for virtual paging; also used for number of msgs in one page of a conv
	this.registerSetting("PAGE_SIZE",						{name: "zimbraPrefItemsPerVirtualPage", type:ZmSetting.T_PREF, dataType:ZmSetting.D_INT, defaultValue:50, isGlobal:true});
	this.registerSetting("PASSWORD",						{type:ZmSetting.T_PREF, dataType:ZmSetting.D_NONE});
	this.registerSetting("POLLING_INTERVAL",				{name:"zimbraPrefMailPollingInterval", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LDAP_TIME, defaultValue:300});
	this.registerSetting("POLLING_INTERVAL_ENABLED",		{name:"zimbraFeatureMailPollingIntervalPreferenceEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("SEARCH_INCLUDES_SHARED",			{name:"zimbraPrefIncludeSharedItemsInSearch", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("SEARCH_INCLUDES_SPAM",			{name:"zimbraPrefIncludeSpamInSearch", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("SEARCH_INCLUDES_TRASH",			{name:"zimbraPrefIncludeTrashInSearch", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("SHORT_ADDRESS",					{name:"zimbraPrefShortEmailAddress", type:ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: true});
	this.registerSetting("SHORTCUTS",						{name:"zimbraPrefShortcuts", type:ZmSetting.T_PREF});
	this.registerSetting("SHOW_SEARCH_STRING",				{name:"zimbraPrefShowSearchString", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("SIGNATURES",						{type: ZmSetting.T_PREF, dataType: ZmSetting.D_HASH});
	this.registerSetting("SIGNATURES_MAX",					{name:"zimbraSignatureMaxNumEntries", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:20});
	this.registerSetting("SIGNATURES_MIN",					{name:"zimbraSignatureMinNumEntries", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:1});
	this.registerSetting("SKIN_NAME",						{name:"zimbraPrefSkin", type:ZmSetting.T_PREF, defaultValue:"skin", isGlobal:true});
	this.registerSetting("SORTING_PREF",					{name:"zimbraPrefSortOrder", type:ZmSetting.T_PREF, dataType:ZmSetting.D_HASH, isImplicit:true, isGlobal:true, dontSaveDefault: true});
	this.registerSetting("USE_KEYBOARD_SHORTCUTS",			{name:"zimbraPrefUseKeyboardShortcuts", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("VIEW_AS_HTML",					{name:"zimbraPrefMessageViewHtmlPreferred", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("VOICE_ACCOUNTS",					{type: ZmSetting.T_PREF, dataType: ZmSetting.D_HASH});
	this.registerSetting("WARN_ON_EXIT",					{name:"zimbraPrefWarnOnExit", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});

	this._registerOfflineSettings();
	this._registerZimletsSettings();

	// need to do this before loadUserSettings(), and zimlet settings are not tied to an app where it would normally be done
	this.registerSetting("ZIMLET_TREE_OPEN",				{name:"zimbraPrefZimletTreeOpen", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isImplicit:true});
	
	//shared settings
	this.registerSetting("MAIL_ALIASES",					{name:"zimbraMailAlias", type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST});
	this.registerSetting("ALLOW_FROM_ADDRESSES",			{name:"zimbraAllowFromAddress", type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST});

	// Internal pref to control display of mail-related preferences. The only time it will be false is for a delegated admin with zimbraFeatureAdminMailEnabled and
	// zimbraFeatureAdminPreferencesEnabled set to FALSE.
	this.registerSetting("MAIL_PREFERENCES_ENABLED",	    {type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});

	//chat settings
	this.registerSetting("CHAT_PLAY_SOUND",					{name:"zimbraPrefChatPlaySound", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	this.registerSetting("CHAT_FEATURE_ENABLED",				{name:"zimbraFeatureChatEnabled", type: ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	this.registerSetting("CHAT_ENABLED",				{name:"zimbraPrefChatEnabled", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});

	ZmApp.runAppFunction("registerSettings", this);
};

/**
 * @private
 */
ZmSettings.prototype._registerZimletsSettings =
function() {
	// zimlet-specific
	this.registerSetting("CHECKED_ZIMLETS_ENABLED",			{name:"zimbraFeatureManageZimlets", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	this.registerSetting("CHECKED_ZIMLETS",					{name:"zimbraPrefZimlets", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LIST, isGlobal:true});
    this.registerSetting("MANDATORY_ZIMLETS",		        {name:"zimbraZimletMandatoryZimlets", type:ZmSetting.T_COS, dataType:ZmSetting.D_LIST});
    this.registerSetting("ZIMLETS_SYNCHRONOUS",		        {name:"zimbraZimletLoadSynchronously", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});

};

/**
 * @private
 */
ZmSettings.prototype._registerOfflineSettings =
function() {
	if (!appCtxt.isOffline) { return; }

	// offline-specific
	this.registerSetting("OFFLINE_ACCOUNT_FLAVOR",			{name:"offlineAccountFlavor", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING});
	this.registerSetting("OFFLINE_COMPOSE_ENABLED",			{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("OFFLINE_DEBUG_TRACE",				{type:ZmSetting.T_CONFIG, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	this.registerSetting("OFFLINE_IS_MAILTO_HANDLER",		{name:"zimbraPrefMailtoHandlerEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("OFFLINE_REMOTE_SERVER_URI",		{name:"offlineRemoteServerUri", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING});
	this.registerSetting("OFFLINE_REPORT_EMAIL",			{type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:"zdesktop-report@zimbra.com", isGlobal:true});
	this.registerSetting("OFFLINE_SHOW_ALL_MAILBOXES",		{name:"offlineShowAllMailboxes", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, section:ZmSetting.M_OFFLINE, isGlobal:true});
	this.registerSetting("OFFLINE_ALL_MAILBOXES_TREE_OPEN",	{name:"offlineAllMailboxesTreeOpen", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, section:ZmSetting.M_OFFLINE, isGlobal:true, isImplicit:true});
	this.registerSetting("OFFLINE_NOTIFY_NEWMAIL_ON_INBOX",	{name:"offlineNotifyNewMailOnInbox", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, section:ZmSetting.M_OFFLINE, isGlobal:true});
	this.registerSetting("OFFLINE_SAVED_SEARCHES_TREE_OPEN",{name:"offlineSavedSearchesTreeOpen", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, section:ZmSetting.M_OFFLINE, isGlobal:true, isImplicit:true});
	this.registerSetting("OFFLINE_SMTP_ENABLED",			{name:"zimbraDataSourceSmtpEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	this.registerSetting("OFFLINE_SUPPORTS_MAILTO",			{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("OFFLINE_SUPPORTS_DOCK_UPDATE",	{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	this.registerSetting("OFFLINE_WEBAPP_URI",				{name:"offlineWebappUri", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING});
    this.registerSetting("OFFLINE_BACKUP_INTERVAL",	        {name:"zimbraPrefOfflineBackupInterval", type:ZmSetting.T_PREF, dataType:ZmSetting.D_INT, defaultValue:0, isGlobal:true});
    this.registerSetting("OFFLINE_BACKUP_PATH",	            {name:"zimbraPrefOfflineBackupPath", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, isGlobal:true});
    this.registerSetting("OFFLINE_BACKUP_KEEP",	            {name:"zimbraPrefOfflineBackupKeep", type:ZmSetting.T_PREF, dataType:ZmSetting.D_INT, isGlobal:true});
    this.registerSetting("OFFLINE_BACKUP_ACCOUNT_ID",       {name:"zimbraPrefOfflineBackupAccountId", type:ZmSetting.T_PREF, dataType:ZmSetting.D_INT, isGlobal:true});
    this.registerSetting("OFFLINE_BACKUP_RESTORE",          {name:"zimbraPrefOfflineBackupRestore", dataType:ZmSetting.D_INT, isGlobal:true});
    this.registerSetting("OFFLINE_BACKUP_NOW_BUTTON",       {name:"zimbraPrefOfflineBackupAccount", dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
    this.registerSetting("OFFLINE_ZIMLET_SYNC_ACCOUNT_ID",  {name:"zimbraPrefOfflineZimletSyncAccountId", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, isGlobal:true});
	this.registerSetting("OFFLINE_WEBAPP_URI",				{name:"offlineWebappUri", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING});

	// reset the help URI to zimbra.com for offline
	this.registerSetting("HELP_URI",						{type:ZmSetting.T_CONFIG, defaultValue:"https://www.zimbra.com/desktop7/"});
//	// make default false for DUMPSTER_ENABLED. shouldn't be necessary since GetInfoResponse includes zimbraDumpsterEnabled:"FALSE", but can't find why settings is not read correctly
	this.registerSetting("DUMPSTER_ENABLED",				{name:"zimbraDumpsterEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    this.registerSetting("OFFLINE_UPDATE_NOTIFY",			{name:"zimbraPrefOfflineUpdateChannel", type: ZmSetting.T_PREF, dataType: ZmSetting.D_STRING, isGlobal:true});
};

/**
 * @private
 */
ZmSettings.prototype._changeListener =
function(ev) {

	if (ev.type !== ZmEvent.S_SETTING) {
		return;
	}

	var id = ev.source.id,
		value = ev.source.getValue();

	if (id === ZmSetting.QUOTA_USED) {
		appCtxt.getAppController().setUserInfo();
	}
	else if (id === ZmSetting.POLLING_INTERVAL) {
		appCtxt.getAppController().setPollInterval();
	}
	else if (id === ZmSetting.SKIN_NAME) {
		this._showConfirmDialog(ZmMsg.skinChangeRestart, this._refreshBrowserCallback.bind(this));
	}
	else if (id === ZmSetting.SHOW_SELECTION_CHECKBOX) {
		this._showConfirmDialog(value ? ZmMsg.checkboxChangeRestartShow : ZmMsg.checkboxChangeRestartHide, this._refreshBrowserCallback.bind(this));
	}
	else if (id === ZmSetting.FONT_NAME || id === ZmSetting.FONT_SIZE) {
		this._showConfirmDialog(ZmMsg.fontChangeRestart, this._refreshBrowserCallback.bind(this));
	}
	else if (id === ZmSetting.LOCALE_NAME) {
		// bug: 29786
		if (appCtxt.isOffline && AjxEnv.isPrism) {
			try {
				netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
				var prefs = Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefBranch);
				if (prefs) {
					var newLocale = appCtxt.get(ZmSetting.LOCALE_NAME).replace("_", "-");
					prefs.setCharPref("general.useragent.locale", newLocale);
					prefs.setCharPref("intl.accept_languages", newLocale);
				}
			} catch (ex) {
				// do nothing for now
			}
		}
		this._showConfirmDialog(ZmMsg.localeChangeRestart, this._refreshBrowserCallback.bind(this));
	}
	else if (id === ZmSetting.CHILD_ACCTS_VISIBLE) {
		this._showConfirmDialog(ZmMsg.accountChangeRestart, this._refreshBrowserCallback.bind(this));
	}
	else if (appCtxt.isOffline && id === ZmSetting.OFFLINE_IS_MAILTO_HANDLER) {
		appCtxt.getAppController().registerMailtoHandler(true, ev.source.getValue());
	}
	else if (appCtxt.isOffline && id === ZmSetting.OFFLINE_UPDATE_NOTIFY) {
		appCtxt.getAppController()._offlineUpdateChannelPref(ev.source.getValue());
	}
    else if (id === ZmSetting.CHAT_ENABLED || id === ZmSetting.CHAT_PLAY_SOUND || (id === ZmSetting.CHAT_PLAY_SOUND && id === ZmSetting.CHAT_ENABLED)) {
		this._showConfirmDialog(ZmMsg.chatFeatureChangeRestart, this._refreshBrowserCallback.bind(this));
	}
};

// Shows a confirm dialog that asks the user if they want to reload ZCS to show the change they just made
ZmSettings.prototype._showConfirmDialog = function(text, callback, style) {

	var confirmDialog = appCtxt.getYesNoMsgDialog();
	confirmDialog.reset();
	confirmDialog.registerCallback(DwtDialog.YES_BUTTON, callback);
	confirmDialog.setMessage(text, style || DwtMessageDialog.WARNING_STYLE);
	confirmDialog.popup();
};

ZmSettings.prototype._implicitChangeListener =
function(ev) {
	if (!appCtxt.get(ZmSetting.OPTIONS_ENABLED)) {
		return;
	}
	if (ev.type != ZmEvent.S_SETTING) { return; }
	var id = ev.source.id;
	var setting = this.getSetting(id);
	if (id == ZmSetting.FOLDERS_EXPANDED && window.duringExpandAll) {
		if (!window.afterExpandAllCallback) {
			window.afterExpandAllCallback = this.save.bind(this, [setting], null, null, appCtxt.getActiveAccount(), true);
		}
		return;
	}
	if (ZmSetting.IS_IMPLICIT[id] && setting) {
        if (id === ZmSetting.WEBCLIENT_OFFLINE_BROWSER_KEY) {
            var callback = this._offlineSettingsSaveCallback.bind(this, setting);
        }
		else {
			//Once implicit preference is saved, reload the application cache to get the latest changes
			var callback = appCtxt.reloadAppCache.bind(appCtxt, false);
		}
		this.save([setting], callback, null, appCtxt.getActiveAccount(), true);
	}
};

/**
 * @private
 */
ZmSettings.prototype._refreshBrowserCallback =
function(args) {
	appCtxt.getYesNoMsgDialog().popdown();
	window.onbeforeunload = ZmZimbraMail.getConfirmExitMethod();
	var url = AjxUtil.formatUrl({qsArgs : args});
	window.location.replace(url);
};

// Adds/replaces a CSS rule that comprises user font prefs
ZmSettings.prototype._updateUserFontPrefsRule =
function() {
	if (this._userFontPrefsRuleIndex != null) {
		DwtCssStyle.removeRule(document.styleSheets[0], this._userFontPrefsRuleIndex);
	}
	var selector = "." + ZmSetting.USER_FONT_CLASS;
	var declaration = "font-family:" + appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_FAMILY) + ";" +
					  "font-size:" + appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_SIZE) + ";" +
					  "color:" + appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_COLOR) + ";";
	this._userFontPrefsRuleIndex = DwtCssStyle.addRule(document.styleSheets[0], selector, declaration);
};

// Check license to see if voice feature is allowed
// License block format:
//
//  <license status="OK">
//    <attr name="SMIME">FALSE</attr>
//    <attr name="VOICE">TRUE</attr>
//  </license>

ZmSettings.prototype._hasVoiceFeature = function() {

    var info = this.getInfoResponse;
    var license = info && info.license;
    var status = license && license.status;

    if (!license || !license.attr) {
        return false;
    }

    // License not installed or not activated or expired
    if (ZmSetting.LICENSE_MSG[status]) {
        return false;
    }

    // check for VOICE license attribute

    for (var i = 0; license && i < license.attr.length; i++) {
        var attr = license.attr[i];

        if (attr.name == "VOICE") {
            return attr._content == "TRUE";
        }
    }

    return false;
};

/**
 * @private
 */
ZmSettings.prototype._offlineSettingsSaveCallback =
function(setting) {
	var offlineBrowserKey = setting.getValue();
	var localOfflineBrowserKey = localStorage.getItem(ZmSetting.WEBCLIENT_OFFLINE_BROWSER_KEY);
	if (offlineBrowserKey && offlineBrowserKey.indexOf(localOfflineBrowserKey) !== -1) {
		this._showConfirmDialog(ZmMsg.offlineChangeRestart, this._refreshBrowserCallback.bind(this));
    }
    else {
        ZmOffline.deleteOfflineData();
        appCtxt.initWebOffline();// To reset the property isWebClientOfflineSupported
	    //delete outbox folder
	    var outboxFolder = appCtxt.getById(ZmFolder.ID_OUTBOX);
	    if (outboxFolder) {
		    outboxFolder.notifyDelete();
	    }
    }
	//Always reload appcache whenever offline setting is enabled/disabled. Appcache will be updated/emptied depending upon the setting.
	appCtxt.reloadAppCache(true);
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmMetaData")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines classes for the storage/retrieval of generic user data.
 */

/**
 * Stores generic data to the server via <code>&lt;Set[Mailbox|Custom]MetadataRequest&gt;</code> and
 * <code>&lt;Get[Mailbox|Custom]MetadataRequest&gt;</code>.
 * @class
 * This class provides a general way to store per-user data using arbitrary
 * key/value pairs. NOTE: the server does not support modifying data so if there
 * are any changes, *all* the data must be re-set per section. Data can be
 * written on the mailbox or on an individual mailbox item. If the constructor
 * receives an itemId, then data will be retrieved/written via [Get|Set]CustomMetadataRequest.
 * <br/>
 * <br/>
 * The section data is mapped into {@link ZmSettings} (based on the key name) to allow
 * for easy access. When creating/setting a *new* key/value, naming conventions
 * should be followed as defined by prefs in {@link ZmSettings}. For example, if adding
 * a new key called "foo", the name for the key should be "zimbraPrefFoo" and
 * should be added to the list of settings in {@link ZmSettings} with type set to
 * ZmSetting.T_METADATA
 *
 * @param {ZmAccount}	account		Optional. The account this meta data belongs to
 * @param {String}	itemId		Optional.  If specified, (custom) meta data will be saved on the item
 *
 * @author Parag Shah
 */
ZmMetaData = function(account, itemId) {

	this._sections = {};
	this._account = account;
	this._itemId = itemId;
};

ZmMetaData.prototype.constructor = ZmMetaData;


// Consts

ZmMetaData.NAMESPACE		= "zwc";


// Public Methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmMetaData.prototype.toString =
function() {
	return "ZmMetaData";
};

/**
 * Saves the given section and corresponding key/value pair to the server.
 *
 * @param {String}	section		the name of the section to save
 * @param {Object}	data			the list of key/value pairs
 * @param {ZmBatchCommand}	batchCommand	if part of a batch command
 * @param {AjxCallback}	callback		the callback to trigger on successful save
 * @param {AjxCallback}	errorCallback	the error callback to trigger on error
 * @param {Boolean} sensitive if <code>true</code>, attempt to use secure conn to protect data
 */
ZmMetaData.prototype.set =
function(section, data, batchCommand, callback, errorCallback, sensitive) {
	var soapDoc;
	if (this._itemId) {
		soapDoc = AjxSoapDoc.create("SetCustomMetadataRequest", "urn:zimbraMail");
		soapDoc.getMethod().setAttribute("id", this._itemId);
	} else {
		soapDoc = AjxSoapDoc.create("SetMailboxMetadataRequest", "urn:zimbraMail");
	}
	var metaNode = soapDoc.set("meta");
	metaNode.setAttribute("section", [ZmMetaData.NAMESPACE, section].join(":"));

	for (var i in data) {
		var d = data[i];

		// serialize if we're dealing with an object
		if (AjxUtil.isObject(d)) {
			d = ZmSetting.serialize(d, ZmSetting.D_HASH);
		}
		var a = soapDoc.set("a", d, metaNode);
		a.setAttribute("n", i);
	}

	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, callback, errorCallback);
	}
	else {
		var params = {
			soapDoc: soapDoc,
			asyncMode: true,
			callback: callback,
			errorCallback: errorCallback,
			accountName: (this._account ? this._account.name : null),
			sensitive: sensitive
		};

		appCtxt.getAppController().sendRequest(params);
	}
};

/**
 * Fetches the given section name from the server unless its already been
 * fetched (and therefore cached)
 *
 * @param {String}	section		section of meta data to fetch
 * @param {ZmBatchCommand}	batchCommand	if part of a separate batch command
 * @param {AjxCallback}	callback		the callback to trigger once meta data is fetched
 * @param {AjxCallback}	errorCallback	the error callback to trigger on error
 */
ZmMetaData.prototype.get =
function(section, batchCommand, callback, errorCallback) {
	var command = batchCommand || (new ZmBatchCommand());
	var sectionName = [ZmMetaData.NAMESPACE, section].join(":");

	var cachedSection = this._sections[sectionName];

	// if not yet cached, go fetch it
	if (!cachedSection) {
		var soapDoc;
		if (this._itemId) {
			soapDoc = AjxSoapDoc.create("GetCustomMetadataRequest", "urn:zimbraMail");
			soapDoc.getMethod().setAttribute("id", this._itemId);
		} else {
			soapDoc = AjxSoapDoc.create("GetMailboxMetadataRequest", "urn:zimbraMail");
		}
		var metaNode = soapDoc.set("meta");
		metaNode.setAttribute("section", sectionName);

		command.addNewRequestParams(soapDoc);

		if (!batchCommand) {
			command.run(callback, errorCallback);
		}
	}
	else {
		if (callback) {
			callback.run(cachedSection);
		} else {
			return cachedSection;
		}
	}
};

/**
 * Loads meta data from the server
 *
 * @param {Array}		sections	the sections to load
 * @param {AjxCallback}	callback	the callback
 * @param {ZmBatchCommand}		batchCommand if part of batch command
 */
ZmMetaData.prototype.load =
function(sections, callback, batchCommand) {
	if (!sections) { return; }
	if (!(sections instanceof Array)) { sections = [sections]; }

	var command = batchCommand || (new ZmBatchCommand());
	for (var i = 0; i < sections.length; i++) {
		if (sections[i] == ZmSetting.M_OFFLINE && !appCtxt.isOffline) { continue; }
		this.get(sections[i], command);
	}

	if (!batchCommand) {
		if (command.size() > 0) {
			var respCallback = new AjxCallback(this, this._handleLoad, [callback]);
			var offlineCallback = this._handleOfflineLoad.bind(this, respCallback);
			command.run(respCallback, null, offlineCallback);
		}
	} else {
		if (callback) {
			callback.run(this._sections);
		}
	}
};

/**
 * @private
 */
ZmMetaData.prototype._handleLoad =
function(callback, result) {
	this._sections = {};

	var br = result.getResponse().BatchResponse;
	if (br) {
		var metaDataResp = (this._itemId != null) ? br.GetCustomMetadataResponse : br.GetMailboxMetadataResponse;
		if (metaDataResp && metaDataResp.length) {
			if (ZmOffline.isOnlineMode()) {
				localStorage.setItem("MetadataResponse", JSON.stringify(br));
			}
			for (var i = 0; i < metaDataResp.length; i++) {
				var data = metaDataResp[i].meta[0];
				this._sections[data.section] = data._attrs;
			}
		}
	}

	if (callback) {
		callback.run(this._sections);
	}
};

/**
 * @private
 */
ZmMetaData.prototype._handleOfflineLoad =
function(callback) {
	var result = localStorage.getItem("MetadataResponse");
	if (result) {
		var csfeResult = new ZmCsfeResult({BatchResponse : JSON.parse(result)});
		callback.run(csfeResult);
	}
};

/**
 * Modifies the given section with new key/value pairs
 *
 * @param {Array}			section			the section to modify
 * @param {Object}			data			the list of key/value pairs
 * @param {ZmBatchCommand}	batchCommand	Optional. the batch command the request should be a part of
 * @param {AjxCallback}		callback		the callback called on successful modify
 * @param {AjxCallback}		errorCallback	the error callback to trigger on error
 */
ZmMetaData.prototype.modify =
function(section, data, batchCommand, callback, errorCallback) {
	var soapDoc = AjxSoapDoc.create("ModifyMailboxMetadataRequest", "urn:zimbraMail");
	var metaNode = soapDoc.set("meta");
	metaNode.setAttribute("section", [ZmMetaData.NAMESPACE, section].join(":"));

	for (var i in data) {
		var a = soapDoc.set("a", data[i], metaNode);
		a.setAttribute("n", i);
	}

	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, callback, errorCallback);
	}
	else {
		var params = {
			soapDoc: soapDoc,
			asyncMode: true,
			callback: callback,
			errorCallback: errorCallback,
			accountName: (this._account ? this._account.name : null)
		};

		appCtxt.getAppController().sendRequest(params);
	}
};

/**
 * Saves all data within the given section out to the server. If section is not
 * provided, all sections are saved.
 *
 * @param {Array}		sections		the sections to save
 * @param {AjxCallback}	callback		the callback called on successful save
 * @param {ZmBatchCommand}	batchCommand		the batch command the request should be a part of
 */
ZmMetaData.prototype.save =
function(sections, callback, batchCommand) {
	if (!sections) { return; }
	if (!(sections instanceof Array)) { sections = [sections]; }

	var acct = this._account ? this._account.name : null;
	var command = batchCommand || (new ZmBatchCommand(null, acct));

	for (var i = 0; i < sections.length; i++) {
		var s = sections[i];
		var sectionName = [ZmMetaData.NAMESPACE, s].join(":");
		var sectionData = this._sections[sectionName];
		if (sectionData) {
			this.set(s, sectionData, command);
		}
	}

	if (!batchCommand) {
		if (command.size() > 0) {
			command.run(callback);
		}
	} else {
		if (callback) {
			callback.run();
		}
	}
};

/**
 * Updates the local section cache with the given key/value pair.
 *
 * @param {String}	section	the section to update
 * @param {String}	key		the key to update
 * @param {String}	value		the new value
 */
ZmMetaData.prototype.update =
function(section, key, value) {
	var sectionName = [ZmMetaData.NAMESPACE, section].join(":");
	var sectionObj = this._sections[sectionName];
	if (!sectionObj) {
		sectionObj = this._sections[sectionName] = {};
	}
	sectionObj[key] = value;
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmKeyMap")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the key map.
 */

/**
 * Creates a key map for the ZCS application.
 * @class
 * This class maps keys to actions for the ZCS application. There is a global key map
 * with bindings that apply to any key not handled by the current controller; these
 * global bindings apply across applications (mail, contacts, etc). Key bindings that
 * are context-dependent are tied to a particular controller. If that controller has
 * control, then those bindings will be used.
 * <br/>
 * <br/>
 * Bindings are passed in via the <code>ZmKeys</code> object, which is populated from a properties
 * file. The identifiers used in the properties file must match those used here.
 * 
 * @author Ross Dargahi
 * @author Conrad Damon
 * 
 * @extends		DwtKeyMap
 */
ZmKeyMap = function() {
	
	ZmKeyMap._setPreconditions();
	DwtKeyMap.call(this);
	this._load(this._map, ZmKeys);
};

ZmKeyMap.prototype = new DwtKeyMap(true);
ZmKeyMap.prototype.constructor = ZmKeyMap;

ZmKeyMap.prototype.isZmKeyMap = true;
ZmKeyMap.prototype.toString = function() { return "ZmKeyMap"; };


// Map names (must match those in the key properties file ZmKeys.properties)
ZmKeyMap.MAP_ADDRESS			= "address";
ZmKeyMap.MAP_BRIEFCASE			= "briefcase";
ZmKeyMap.MAP_CALENDAR			= "calendar";
ZmKeyMap.MAP_CALL				= "call";
ZmKeyMap.MAP_COMPOSE			= "compose";
ZmKeyMap.MAP_CONTACTS			= "contacts";
ZmKeyMap.MAP_CONVERSATION		= "conversation";
ZmKeyMap.MAP_CONVERSATION_LIST	= "conversationList";
ZmKeyMap.MAP_DL_ADDRESS_LIST	= "dlAddressList";
ZmKeyMap.MAP_EDIT_APPOINTMENT	= "editAppointment";
ZmKeyMap.MAP_EDIT_CONTACT		= "editContact";
ZmKeyMap.MAP_EDIT_TASK			= "editTask";
ZmKeyMap.MAP_GLOBAL				= "global";
ZmKeyMap.MAP_MAIL				= "mail";
ZmKeyMap.MAP_MESSAGE			= "message";
ZmKeyMap.MAP_QUICK_REPLY		= "quickReply";
ZmKeyMap.MAP_OPTIONS			= "options";
ZmKeyMap.MAP_TASKS				= "tasks";
ZmKeyMap.MAP_VIEW_APPOINTMENT	= "viewAppointment";
ZmKeyMap.MAP_VOICEMAIL			= "voicemail";

// Action codes
ZmKeyMap.ADDRESS_PICKER			= "AddressPicker";
ZmKeyMap.ADD_EXTERNAL_CALENDAR	= "AddExternalCalendar";
ZmKeyMap.ATTACHMENT				= "Attachment";
ZmKeyMap.CAL_DAY_VIEW			= "DayView";
ZmKeyMap.CAL_FB_VIEW			= "FBView";
ZmKeyMap.CAL_LIST_VIEW			= "CalListView";
ZmKeyMap.CAL_MONTH_VIEW			= "MonthView";
ZmKeyMap.CAL_WEEK_VIEW			= "WeekView";
ZmKeyMap.CAL_WORK_WEEK_VIEW		= "WorkWeekView";
ZmKeyMap.CALL_MANAGER       	= "CallManager";
ZmKeyMap.CANCEL					= "Cancel";
ZmKeyMap.COLLAPSE				= "Collapse";
ZmKeyMap.COLLAPSE_ALL			= "CollapseAll";
ZmKeyMap.DEL					= "Delete";
ZmKeyMap.SHIFT_DEL				= "ShiftDelete";
ZmKeyMap.DOWNLOAD           	= "Download";
ZmKeyMap.EDIT					= "Edit";
ZmKeyMap.EXPAND					= "Expand";
ZmKeyMap.EXPAND_ALL				= "ExpandAll";
ZmKeyMap.FIRST_UNREAD			= "FirstUnread";
ZmKeyMap.FIRST_UNREAD_MSG		= "FirstUnreadMsg";
ZmKeyMap.FLAG					= "Flag";
ZmKeyMap.FOCUS_CONTENT_PANE		= "FocusContentPane";
ZmKeyMap.FOCUS_SEARCH_BOX		= "FocusSearchBox";
ZmKeyMap.FOCUS_TOOLBAR			= "FocusToolbar";
ZmKeyMap.FORWARD				= "Forward";
ZmKeyMap.GET_MAIL				= "GetMail";
ZmKeyMap.GOTO_BRIEFCASE			= "GoToBriefcase";
ZmKeyMap.GOTO_CALENDAR			= "GoToCalendar";
ZmKeyMap.GOTO_CONTACTS			= "GoToContacts";
ZmKeyMap.GOTO_DRAFTS			= "GoToDrafts";
ZmKeyMap.GOTO_JUNK				= "GoToJunk";
ZmKeyMap.GOTO_INBOX				= "GoToInbox";
ZmKeyMap.GOTO_MAIL				= "GoToMail";
ZmKeyMap.GOTO_OPTIONS			= "GoToOptions";
ZmKeyMap.GOTO_SENT				= "GoToSent";
ZmKeyMap.GOTO_TASKS				= "GoToTasks";
ZmKeyMap.GOTO_TRASH				= "GoToTrash";
ZmKeyMap.GOTO_VOICE				= "GoToVoice";
ZmKeyMap.HTML_FORMAT			= "HtmlFormat";
ZmKeyMap.KEEP_READING			= "KeepReading";
ZmKeyMap.LAST_UNREAD			= "LastUnread";
ZmKeyMap.LAST_UNREAD_MSG		= "LastUnreadMsg";
ZmKeyMap.MARK_COMPLETE			= "MarkComplete";
ZmKeyMap.MARK_HEARD				= "MarkHeard";
ZmKeyMap.MARK_READ				= "MarkRead";
ZmKeyMap.MARK_UNCOMPLETE		= "MarkUncomplete";
ZmKeyMap.MARK_UNHEARD			= "MarkUnheard";
ZmKeyMap.MARK_UNREAD			= "MarkUnread";
ZmKeyMap.MOVE					= "Move";
ZmKeyMap.MOVE_TO_INBOX			= "MoveToInbox";
ZmKeyMap.MOVE_TO_JUNK			= "MoveToJunk";
ZmKeyMap.MOVE_TO_TRASH			= "MoveToTrash";
ZmKeyMap.MUTE_UNMUTE_CONV	    = "MuteUnmuteConv";
ZmKeyMap.NEW					= "New";
ZmKeyMap.NEW_APPT				= "NewAppointment";
ZmKeyMap.NEW_BRIEFCASE			= "NewBriefcase";
ZmKeyMap.NEW_CALENDAR			= "NewCalendar";
ZmKeyMap.NEW_CONTACT			= "NewContact";
ZmKeyMap.NEW_DOC    			= "NewDocument";
ZmKeyMap.NEW_FILE				= "NewFile";
ZmKeyMap.NEW_FOLDER				= "NewFolder";
ZmKeyMap.NEW_MESSAGE			= "NewMessage";
ZmKeyMap.NEW_MESSAGE_WIN		= "NewMessageWindow";
ZmKeyMap.NEW_SEARCH				= "NewSearch";
ZmKeyMap.NEW_TAG				= "NewTag";
ZmKeyMap.NEW_TASK				= "NewTask";
ZmKeyMap.NEW_WINDOW				= "NewWindow";
ZmKeyMap.NEXT_APPT				= "NextAppointment";
ZmKeyMap.NEXT_CONV				= "NextConversation";
ZmKeyMap.NEXT_DAY				= "NextDay";
ZmKeyMap.NEXT_MSG				= "NextMessage";
ZmKeyMap.NEXT_PAGE				= "NextPage";
ZmKeyMap.NEXT_UNREAD			= "NextUnread";
ZmKeyMap.NEXT_UNREAD_MSG		= "NextUnreadMsg";
ZmKeyMap.PLAY					= "Play";
ZmKeyMap.PRESENCE_MENU			= "PresenceMenu";
ZmKeyMap.PREV_APPT				= "PreviousAppointment";
ZmKeyMap.PREV_CONV				= "PreviousConversation";
ZmKeyMap.PREV_DAY				= "PreviousDay";
ZmKeyMap.PREV_MSG				= "PreviousMessage";
ZmKeyMap.PREV_PAGE				= "PreviousPage";
ZmKeyMap.PREV_UNREAD			= "PreviousUnread";
ZmKeyMap.PREV_UNREAD_MSG		= "PreviousUnreadMsg";
ZmKeyMap.PRINT					= "Print";
ZmKeyMap.PRINT_ALL				= "PrintAll";
ZmKeyMap.QUICK_ADD				= "QuickAdd";
ZmKeyMap.QUICK_REMINDER 	    = "QuickReminder";
ZmKeyMap.READING_PANE_BOTTOM	= "ReadingPaneAtBottom";
ZmKeyMap.READING_PANE_OFF		= "ReadingPaneOff";
ZmKeyMap.READING_PANE_RIGHT		= "ReadingPaneOnRight";
ZmKeyMap.REFRESH				= "Refresh";
ZmKeyMap.REPLY					= "Reply";
ZmKeyMap.REPLY_ALL				= "ReplyAll";
ZmKeyMap.SAVE					= "Save";
ZmKeyMap.SAVED_SEARCH			= "SavedSearch";
ZmKeyMap.SELECT_ALL				= "SelectAll";
ZmKeyMap.SEND					= "Send";
ZmKeyMap.SHORTCUTS				= "Shortcuts";
ZmKeyMap.SHOW_FRAGMENT			= "ShowFragment";
ZmKeyMap.SPAM					= "Spam";
ZmKeyMap.SPELLCHECK				= "Spellcheck";
ZmKeyMap.TAG					= "Tag";
ZmKeyMap.TODAY					= "Today";
ZmKeyMap.TOGGLE					= "Toggle";
ZmKeyMap.UNTAG					= "Untag";
ZmKeyMap.VIEW_BY_CONV			= "ViewByConversation";
ZmKeyMap.VIEW_BY_MSG			= "ViewByMessage";
ZmKeyMap.VISIT					= "Visit";
ZmKeyMap.VISIT_TAG				= "VisitTag";

// HTML entities (used to display keys)
ZmKeyMap.ENTITY = {};
ZmKeyMap.ENTITY[DwtKeyMap.ARROW_LEFT]	= "&larr;"
ZmKeyMap.ENTITY[DwtKeyMap.ARROW_RIGHT]	= "&rarr;"
ZmKeyMap.ENTITY[DwtKeyMap.ARROW_UP]		= "&uarr;"
ZmKeyMap.ENTITY[DwtKeyMap.ARROW_DOWN]	= "&darr;"
ZmKeyMap.ENTITY['"'] = "&quot;"
ZmKeyMap.ENTITY['&'] = "&amp;"
ZmKeyMap.ENTITY['<'] = "&lt;"
ZmKeyMap.ENTITY['>'] = "&gt;"
ZmKeyMap.ENTITY[DwtKeyMap.COMMA]		= ",";
ZmKeyMap.ENTITY[DwtKeyMap.SEMICOLON]	= ";";
ZmKeyMap.ENTITY[DwtKeyMap.BACKSLASH] 	= "\\";

// preconditions for maps
ZmKeyMap.MAP_PRECONDITION = {};

// preconditions for specific shortcuts
ZmKeyMap.ACTION_PRECONDITION = {};

ZmKeyMap._setPreconditions =
function() {
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_COMPOSE]				= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_MAIL]				= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_CONVERSATION_LIST]	= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_CONVERSATION]		= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_DL_ADDRESS_LIST]		= ZmSetting.CONTACTS_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_MESSAGE]				= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_CONTACTS]			= ZmSetting.CONTACTS_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_EDIT_CONTACT]		= ZmSetting.CONTACTS_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_CALENDAR]			= ZmSetting.CALENDAR_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_EDIT_APPOINTMENT]	= ZmSetting.CALENDAR_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_OPTIONS]				= ZmSetting.OPTIONS_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_BRIEFCASE]			= ZmSetting.BRIEFCASE_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_TASKS]				= ZmSetting.TASKS_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_EDIT_TASK]			= ZmSetting.TASKS_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_VOICEMAIL]			= ZmSetting.VOICE_ENABLED;
	ZmKeyMap.MAP_PRECONDITION[ZmKeyMap.MAP_CALL]				= ZmSetting.VOICE_ENABLED;
	
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL] = {};
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.FOCUS_SEARCH_BOX]	= ZmSetting.SEARCH_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_BRIEFCASE]		= ZmSetting.BRIEFCASE_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_CALENDAR]		= ZmSetting.CALENDAR_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_CONTACTS]		= ZmSetting.CONTACTS_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_MAIL]			= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_OPTIONS]		= ZmSetting.OPTIONS_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_TASKS]			= ZmSetting.TASKS_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.GOTO_VOICE]			= ZmSetting.VOICE_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_APPT]			= ZmSetting.CALENDAR_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_BRIEFCASEITEM]	= ZmSetting.BRIEFCASE_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_CALENDAR]		= ZmSetting.CALENDAR_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_CONTACT]			= ZmSetting.CONTACTS_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_FILE]			= ZmSetting.BRIEFCASE_ENABLED;
    ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_DOC]				= ZmSetting.DOCS_ENABLED;    
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_FOLDER]			= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_MESSAGE]			= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_MESSAGE_WIN]		= ZmSetting.MAIL_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_TAG]				= ZmSetting.TAGGING_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.NEW_TASK]			= ZmSetting.TASKS_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.SAVED_SEARCH]		= ZmSetting.SAVED_SEARCHES_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.TAG]					= ZmSetting.TAGGING_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_GLOBAL][ZmKeyMap.UNTAG]				= ZmSetting.TAGGING_ENABLED;

	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_COMPOSE] = {};
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_COMPOSE][ZmKeyMap.ADDRESS_PICKER]		= ZmSetting.CONTACTS_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_COMPOSE][ZmKeyMap.HTML_FORMAT]		= ZmSetting.HTML_COMPOSE_ENABLED;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_COMPOSE][ZmKeyMap.NEW_WINDOW]			= ZmSetting.NEW_WINDOW_COMPOSE;
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_COMPOSE][ZmKeyMap.SAVE]				= ZmSetting.SAVE_DRAFT_ENABLED;

	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_EDIT_APPOINTMENT] = {};
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_EDIT_APPOINTMENT][ZmKeyMap.HTML_FORMAT]	= ZmSetting.HTML_COMPOSE_ENABLED;

    ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_CALENDAR] = {};
	ZmKeyMap.ACTION_PRECONDITION[ZmKeyMap.MAP_CALENDAR][ZmKeyMap.CAL_FB_VIEW]		= ZmSetting.FREE_BUSY_VIEW_ENABLED;
};

/**
 * Checks if this map is valid. A map may have a precondition,
 * which is either a setting that must be true, or a function that returns
 * true.
 *
 * @param {String}	mapName	the name of map
 * @return	{Boolean}	<code>true</code> if the map is valid
 * 
 * @private
 */
ZmKeyMap.prototype._checkMap = function(mapName) {

	var result = this._checkedMap[mapName] = appCtxt.checkPrecondition(ZmKeyMap.MAP_PRECONDITION[mapName]);
	return result;
};

/**
 * Checks if this action is valid. A map or an action may have a precondition,
 * which is either a setting that must be true, or a function that returns
 * true.
 *
 * @param {String} mapName	the name of map
 * @param {String} action	the action to check
 * @return	{Boolean}	<code>true</code> if the action is valid
 * 
 * @private
 */
ZmKeyMap.prototype._checkAction = function(mapName, action) {

	if (this._checkedMap[mapName] === false || (!this._checkedMap[mapName] && !this._checkMap(mapName))) {
		return false;
	}

	var mapPre = ZmKeyMap.ACTION_PRECONDITION[mapName];
	return appCtxt.checkPrecondition(mapPre && mapPre[action]);
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmTimezone")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the timezone class.
 */

/**
 * Creates a timezone
 * @class
 * This class represents a timezone.
 * 
 */
ZmTimezone = function() {}

// Static methods

/**
 * Gets the default timezone.
 * 
 * @return	{AjxTimezone}	the timezone
 */
ZmTimezone.getDefault =
function() {
	var shell = DwtShell.getShell(window);
	var serverId = appCtxt.get(ZmSetting.DEFAULT_TIMEZONE);
	return (serverId) ? AjxTimezone.getClientId(serverId) : AjxTimezone.DEFAULT;
};

/**
 * Gets the default rule.
 * 
 * @return	{String}	the rule
 */
ZmTimezone.getDefaultRule =
function() {
	return AjxTimezone.getRule(ZmTimezone.getDefault());
};

/**
 * This function mirrors the <code>AjxSoapDoc#set</code> method
 * to add a timezone element at the specific place within the
 * given SOAP document. The added element takes the form of the
 * <code>&lt;tz></code> element as defined for <code>&lt;SearchRequest&gt;</code>.
 *
 * @param {object|AjxSoapDoc}	request			the JSON request object or SOAP document
 * @param {String}	timezoneClientId	the client identifier
 * @param {Node}	parentNode		(optional) the parent node at which to add
 * @param {Boolean}	skipKnownTimezone	(optional) if <code>true</code>, does not add the "tz" element if it's one of the known set
 */
ZmTimezone.set =
function(request, timezoneClientId, parentNode, skipKnownTimezone) {
	var timezone = AjxTimezone.getRule(timezoneClientId);
	if (!timezone) { return; }

	if (timezone.autoDetected || !skipKnownTimezone) {
		if (request instanceof AjxSoapDoc) {
			ZmTimezone._setSoap(request, timezoneClientId, parentNode, timezone);
		} else {
			ZmTimezone._setJson(request, timezoneClientId, timezone);
		}
	}
};

/**
 * @private
 */
ZmTimezone._setSoap =
function(soapDoc, timezoneClientId, parentNode, timezone) {
	var tz = soapDoc.set("tz", null, parentNode);
	var id = AjxTimezone.getServerId(timezoneClientId);
	tz.setAttribute("id", id);
	if (timezone.autoDetected) {
		tz.setAttribute("stdoff", timezone.standard.offset);
		if (timezone.daylight) {
			tz.setAttribute("dayoff", timezone.daylight.offset);
            var enames = [ "standard", "daylight" ];
            var pnames = [ "mon", "mday", "week", "wkday", "hour", "min", "sec" ];
            for (var i = 0; i < enames.length; i++) {
                var ename = enames[i];
                var onset = timezone[ename];
                
                var el = soapDoc.set(ename, null, tz);
                for (var j = 0; j < pnames.length; j++) {
                    var pname = pnames[j];
                    if (pname in onset) {
                        el.setAttribute(pname, onset[pname]);
                    }
                }
            }
        }
	}
};

/**
 * @private
 */
ZmTimezone._setJson =
function(request, timezoneClientId, timezone) {
	var id = AjxTimezone.getServerId(timezoneClientId);
	var tz = request.tz = {id:id};
	if (timezone.autoDetected) {
		tz.stdoff = timezone.standard.offset;
		if (timezone.daylight) {
			tz.dayoff = timezone.daylight.offset;
            var enames = [ "standard", "daylight" ];
            var pnames = [ "mon", "mday", "week", "wkday", "hour", "min", "sec" ];
            for (var i = 0; i < enames.length; i++) {
                var ename = enames[i];
                var onset = timezone[ename];
                tz[ename] = {};
                for (var j = 0; j < pnames.length; j++) {
                    var pname = pnames[j];
                    if (pname in onset) {
                    	tz[ename][pname] = onset[pname];
                    }
                }
            }
        }
	}
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmItem")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines an item.
 */

/**
 * Creates an item.
 * @class
 * An item is a piece of data that may contain user content. Most items are taggable. Currently,
 * the following things are items: conversation, message, attachment, appointment, and contact.
 * <br/>
 * <br/>
 * An item typically appears in the context of a containing list. Its event handling
 * is generally handled by the list so we avoid having the same listeners on each item. If we
 * create a context where an item stands alone outside a list context, then the item will have
 * its own listeners and do its own notification handling.
 *
 * @author Conrad Damon
 * 
 * @param {constant}	type		type of object (conv, msg, etc)
 * @param {int}			id			the unique id
 * @param {ZmList}		list		a list that contains this item
 * @param {Boolean}		noCache		if <code>true</code>, do not cache this item
 * 
 * @extends		ZmModel
 */
ZmItem = function(type, id, list, noCache) {

	if (arguments.length == 0) { return; }
	ZmModel.call(this, type);

	this.type = type;
	this.id = id;
	this.list = list;
	this._list = {};

    // number of views using this item
    this.refCount = 0;

	this.tags = [];
	this.tagHash = {};
	this.folderId = 0;

	// make sure the cached item knows which lists it is in, even if those other lists
	// have separate instances of this item - propagate view IDs from currently cached item
	var curItem = appCtxt.getById(id);
	if (curItem) {
		this._list = AjxUtil.hashCopy(curItem._list);
        if (!list) {
            // No list specified, preserve the previous list
            this.list = curItem.list;
        }
	}
	if (list) {
		this._list[list.id] = true;
	}
	
	if (id && !noCache) {
		appCtxt.cacheSet(id, this);
	}
};

ZmItem.prototype = new ZmModel;
ZmItem.prototype.constructor = ZmItem;

ZmItem.prototype.isZmItem = true;
ZmItem.prototype.toString = function() { return "ZmItem"; };


ZmItem.APP 				= {};	// App responsible for item
ZmItem.MSG_KEY 			= {};	// Type names
ZmItem.ICON 			= {};	// Representative icons
ZmItem.RESULTS_LIST 	= {};	// Function for creating search results list

// fields that can be part of a displayed item
ZmItem.F_ACCOUNT		= ZmId.FLD_ACCOUNT;
ZmItem.F_ATTACHMENT		= ZmId.FLD_ATTACHMENT;
ZmItem.F_CAPACITY		= ZmId.FLD_CAPACITY;
ZmItem.F_COMPANY		= ZmId.FLD_COMPANY;
ZmItem.F_DATE			= ZmId.FLD_DATE;
ZmItem.F_DEPARTMENT		= ZmId.FLD_DEPARTMENT;
ZmItem.F_EMAIL			= ZmId.FLD_EMAIL;
ZmItem.F_EXPAND			= ZmId.FLD_EXPAND;
ZmItem.F_FILE_TYPE		= ZmId.FLD_FILE_TYPE;
ZmItem.F_FLAG			= ZmId.FLD_FLAG;
ZmItem.F_FOLDER			= ZmId.FLD_FOLDER;
ZmItem.F_FRAGMENT		= ZmId.FLD_FRAGMENT;
ZmItem.F_FROM			= ZmId.FLD_FROM;
ZmItem.F_HOME_PHONE		= ZmId.FLD_HOME_PHONE;
ZmItem.F_ID				= ZmId.FLD_ID;
ZmItem.F_INDEX			= ZmId.FLD_INDEX;
ZmItem.F_ITEM_ROW		= ZmId.FLD_ITEM_ROW;
ZmItem.F_ITEM_ROW_3PANE	= ZmId.FLD_ITEM_ROW_3PANE;
ZmItem.F_LOCATION		= ZmId.FLD_LOCATION;
ZmItem.F_NAME			= ZmId.FLD_NAME;
ZmItem.F_NOTES			= ZmId.FLD_NOTES;
ZmItem.F_PARTICIPANT	= ZmId.FLD_PARTICIPANT;
ZmItem.F_PCOMPLETE		= ZmId.FLD_PCOMPLETE;
ZmItem.F_PRIORITY		= ZmId.FLD_PRIORITY;
ZmItem.F_RECURRENCE		= ZmId.FLD_RECURRENCE;
ZmItem.F_SELECTION		= ZmId.FLD_SELECTION;
ZmItem.F_SELECTION_CELL	= ZmId.FLD_SELECTION_CELL;
ZmItem.F_SIZE			= ZmId.FLD_SIZE;
ZmItem.F_SORTED_BY		= ZmId.FLD_SORTED_BY;	// placeholder for 3-pane view
ZmItem.F_STATUS			= ZmId.FLD_STATUS;
ZmItem.F_READ			= ZmId.FLD_READ;
ZmItem.F_MUTE			= ZmId.FLD_MUTE;
ZmItem.F_SUBJECT		= ZmId.FLD_SUBJECT;
ZmItem.F_TAG			= ZmId.FLD_TAG;
ZmItem.F_TAG_CELL		= ZmId.FLD_TAG_CELL;
ZmItem.F_TO             = ZmId.FLD_TO;
ZmItem.F_TYPE			= ZmId.FLD_TYPE;
ZmItem.F_VERSION        = ZmId.FLD_VERSION;
ZmItem.F_WORK_PHONE		= ZmId.FLD_WORK_PHONE;
ZmItem.F_LOCK           = ZmId.FLD_LOCK;
ZmItem.F_MSG_PRIORITY   = ZmId.FLD_MSG_PRIORITY;
ZmItem.F_APP_PASSCODE_CREATED = ZmId.FLD_CREATED;
ZmItem.F_APP_PASSCODE_LAST_USED = ZmId.FLD_LAST_USED;

// Action requests for different items
ZmItem.SOAP_CMD = {};

// Item fields (for modify events)
ZmItem.TAGS_FIELD = 1;

// Item flags
ZmItem.FLAG_ATTACH				= "a";
ZmItem.FLAG_FLAGGED				= "f";
ZmItem.FLAG_FORWARDED			= "w";
ZmItem.FLAG_ISDRAFT 			= "d";
ZmItem.FLAG_ISSCHEDULED 		= "c";
ZmItem.FLAG_ISSENT				= "s";
ZmItem.FLAG_READ_RECEIPT_SENT	= "n";
ZmItem.FLAG_REPLIED				= "r";
ZmItem.FLAG_UNREAD				= "u";
ZmItem.FLAG_MUTE				= "(";
ZmItem.FLAG_LOW_PRIORITY		= "?";
ZmItem.FLAG_HIGH_PRIORITY		= "!";
ZmItem.FLAG_PRIORITY            = "+"; //msg prioritization
ZmItem.FLAG_NOTE                = "t"; //specially for notes
ZmItem.FLAG_OFFLINE_CREATED     = "o";

ZmItem.ALL_FLAGS = [
	ZmItem.FLAG_FLAGGED,
	ZmItem.FLAG_ATTACH,
	ZmItem.FLAG_UNREAD,
	ZmItem.FLAG_MUTE,
	ZmItem.FLAG_REPLIED,
	ZmItem.FLAG_FORWARDED,
	ZmItem.FLAG_ISSENT,
	ZmItem.FLAG_READ_RECEIPT_SENT,
	ZmItem.FLAG_ISDRAFT,
	ZmItem.FLAG_ISSCHEDULED,
	ZmItem.FLAG_HIGH_PRIORITY,
	ZmItem.FLAG_LOW_PRIORITY,
	ZmItem.FLAG_PRIORITY,
    ZmItem.FLAG_NOTE,
    ZmItem.FLAG_OFFLINE_CREATED
];

// Map flag to item property
ZmItem.FLAG_PROP = {};
ZmItem.FLAG_PROP[ZmItem.FLAG_ATTACH]			= "hasAttach";
ZmItem.FLAG_PROP[ZmItem.FLAG_FLAGGED]			= "isFlagged";
ZmItem.FLAG_PROP[ZmItem.FLAG_FORWARDED]			= "isForwarded";
ZmItem.FLAG_PROP[ZmItem.FLAG_ISDRAFT] 			= "isDraft";
ZmItem.FLAG_PROP[ZmItem.FLAG_ISSCHEDULED] 		= "isScheduled";
ZmItem.FLAG_PROP[ZmItem.FLAG_ISSENT]			= "isSent";
ZmItem.FLAG_PROP[ZmItem.FLAG_READ_RECEIPT_SENT]	= "readReceiptSent";
ZmItem.FLAG_PROP[ZmItem.FLAG_REPLIED]			= "isReplied";
ZmItem.FLAG_PROP[ZmItem.FLAG_UNREAD]			= "isUnread";
ZmItem.FLAG_PROP[ZmItem.FLAG_MUTE]			    = "isMute";
ZmItem.FLAG_PROP[ZmItem.FLAG_LOW_PRIORITY]		= "isLowPriority";
ZmItem.FLAG_PROP[ZmItem.FLAG_HIGH_PRIORITY]		= "isHighPriority";
ZmItem.FLAG_PROP[ZmItem.FLAG_PRIORITY]          = "isPriority";
ZmItem.FLAG_PROP[ZmItem.FLAG_NOTE]              = "isNote";
ZmItem.FLAG_PROP[ZmItem.FLAG_OFFLINE_CREATED]   = "isOfflineCreated";

// DnD actions this item is allowed

/**
 * Defines the "move" action.
 * 
 * @see		#getDefaultDndAction
 */
ZmItem.DND_ACTION_MOVE = 1 << 0;
/**
 * Defines the "copy" action.
 * 
 * @see		#getDefaultDndAction
 */
ZmItem.DND_ACTION_COPY = 1 << 1;
/**
 * Defines the "move & copy" action.
 * 
 * @see		#getDefaultDndAction
 */
ZmItem.DND_ACTION_BOTH = ZmItem.DND_ACTION_MOVE | ZmItem.DND_ACTION_COPY;

/**
 * Defines the notes separator which is used by items
 * (such as calendar or share invites) that have notes.
 * 
 */
ZmItem.NOTES_SEPARATOR			= "*~*~*~*~*~*~*~*~*~*";

/**
 * Registers an item and stores information about the given item type.
 *
 * @param {constant}	item		the item type
 * @param	{Hash}	params			a hash of parameters
 * @param {constant}	params.app			the app that handles this item type
 * @param {String}		params.nameKey		the message key for item name
 * @param {String}		params.icon			the name of item icon class
 * @param {String}		params.soapCmd		the SOAP command for acting on this item
 * @param {String}		params.itemClass	the name of class that represents this item
 * @param {String}		params.node			the SOAP response node for this item
 * @param {constant}	params.organizer	the associated organizer
 * @param {String}		params.searchType	the associated type in SearchRequest
 * @param {function}	params.resultsList	the function that returns a {@link ZmList} for holding search results of this type
 */
ZmItem.registerItem =
function(item, params) {
	if (params.app)				{ ZmItem.APP[item]					= params.app; }
	if (params.nameKey)			{ ZmItem.MSG_KEY[item]				= params.nameKey; }
	if (params.icon)			{ ZmItem.ICON[item]					= params.icon; }
	if (params.soapCmd)			{ ZmItem.SOAP_CMD[item]				= params.soapCmd; }
	if (params.itemClass)		{ ZmList.ITEM_CLASS[item]			= params.itemClass; }
	if (params.node)			{ ZmList.NODE[item]					= params.node; }
	if (params.organizer)		{ ZmOrganizer.ITEM_ORGANIZER[item]	= params.organizer; }
	if (params.searchType)		{ ZmSearch.TYPE[item]				= params.searchType; }
	if (params.resultsList)		{ ZmItem.RESULTS_LIST[item]			= params.resultsList; }

	if (params.node) {
		ZmList.ITEM_TYPE[params.node] = item;
	}

	if (params.dropTargets) {
		if (!ZmApp.DROP_TARGETS[params.app]) {
			ZmApp.DROP_TARGETS[params.app] = {};
		}
		ZmApp.DROP_TARGETS[params.app][item] = params.dropTargets;
	}
};

/**
* Gets an item id by taking a normalized id (or an item id) and returning the item id.
* 
* @param	{String}	id		the normalized id
* @return	{String}	the item id
*/
ZmItem.getItemId =
function(id) {
	if (!id) {
		return id;
	}
	if (!ZmItem.SHORT_ID_RE) {
		var shell = DwtShell.getShell(window);
		ZmItem.SHORT_ID_RE = new RegExp(appCtxt.get(ZmSetting.USERID) + ':', "gi");
	}
	return id.replace(ZmItem.SHORT_ID_RE, '');
};

// abstract methods
/**
 * Creates an item.
 * 
 * @param	{Hash}	args		the arguments
 */
ZmItem.prototype.create = function(args) {};
/**
 * Modifies an item.
 * 
 * @param	{Hash}	mods		the arguments
 */
ZmItem.prototype.modify = function(mods) {};

/**
 * Gets the item by id.
 *
 * @param {String}	id		an item id
 * @return	{ZmItem}	the item
 */
ZmItem.prototype.getById =
function(id) {
	if (id == this.id) {
		return this;
	}
};

ZmItem.prototype.getAccount =
function() {
	if (!this.account) {
		var account;

		if (this.folderId) {
			var ac = window.parentAppCtxt || window.appCtxt;
			var folder = ac.getById(this.folderId);
			account = folder && folder.getAccount();
		}

		if (!account) {
			var parsed = ZmOrganizer.parseId(this.id);
			account = parsed && parsed.account;
		}
		this.account = account;
	}
	return this.account;
};

/**
 * Clears the item.
 * 
 */
ZmItem.prototype.clear = function() {

    // only clear data if no views are using this item
    if (this.refCount <= 1) {
        this._evtMgr.removeAll(ZmEvent.L_MODIFY);
        if (this.tags.length) {
            for (var i = 0; i < this.tags.length; i++) {
                this.tags[i] = null;
            }
            this.tags = [];
        }
        for (var i in this.tagHash) {
            this.tagHash[i] = null;
        }
        this.tagHash = {};
    }

    this.refCount--;
};

/**
 * Caches the item.
 * 
 * @return	{Boolean}	<code>true</code> if the item is placed into cache; <code>false</code> otherwise
 */
ZmItem.prototype.cache =
function(){
  if (this.id) {
      appCtxt.cacheSet(this.id, this);
      return true;
  }
  return false;  
};

/**
 * Checks if the item has a given tag.
 * 
 * @param {String}		tagName		tag name
 * @return	{Boolean}	<code>true</code> is this item has the given tag.
 */
ZmItem.prototype.hasTag =
function(tagName) {
	return (this.tagHash[tagName] == true);
};

/**
 * is it possible to add a tag to this item?
 * @param tagName
 * @returns {boolean}
 */
ZmItem.prototype.canAddTag =
function(tagName) {
	return !this.hasTag(tagName);
};


/**
* Gets the folder id that contains this item, if available.
* 
* @return	{String}	the folder id or <code>null</code> for none
*/
ZmItem.prototype.getFolderId =
function() {
	return this.folderId;
};

/**
 * @deprecated
 * Use getRestUrl
 * 
 * @private
 * @see		#getRestUrl
 */
ZmItem.prototype.getUrl =
function() {
	return this.getRestUrl();
};

/**
 * Gets the rest url for this item.
 * 
 * @return	{String}	the url
 */
ZmItem.prototype.getRestUrl =
function() {
	// return REST URL as seen by server
	if (this.restUrl) {
		return this.restUrl;
	}

	// if server doesn't tell us what URL to use, do our best to generate
	var organizerType = ZmOrganizer.ITEM_ORGANIZER[this.type];
	var organizer = appCtxt.getById(this.folderId);
	var url = organizer
		? ([organizer.getRestUrl(), "/", AjxStringUtil.urlComponentEncode(this.name)].join(""))
		: null;

	DBG.println(AjxDebug.DBG3, "NO REST URL FROM SERVER. GENERATED URL: " + url);

	return url;
};

/**
* Gets the appropriate tag image info for this item.
* 
* @return	{String}	the tag image info
*/
ZmItem.prototype.getTagImageInfo =
function() {
	return this.getTagImageFromNames(this.getVisibleTags());
};

/**
 * @deprecated
 * */
ZmItem.prototype.getTagImageFromIds =
function(tagIds) {
	var tagImageInfo;

	if (!tagIds || tagIds.length == 0) {
		tagImageInfo = "Blank_16";
	} else if (tagIds.length == 1) {
        tagImageInfo = this.getTagImage(tagIds[0]);
	} else {
		tagImageInfo = "TagStack";
	}

	return tagImageInfo;
};

ZmItem.prototype.getVisibleTags =
function() {
    if(!appCtxt.get(ZmSetting.TAGGING_ENABLED)){
        return [];
    }
    return this.tags;
	//todo - do we need anything from this?
//    var searchAll = appCtxt.getSearchController().searchAllAccounts;
//    if (!searchAll && this.isShared()) {
//        return [];
//    } else {
//        return this.tags;
//    }
};

ZmItem.prototype.getTagImageFromNames =
function(tags) {

	if (!tags || tags.length == 0) {
		return "Blank_16";
	}
	if (tags.length == 1) {
        return this.getTagImage(tags[0]);
	} 

	return "TagStack";
};


ZmItem.prototype.getTagImage =
function(tagName) {
	//todo - I don't think we need the qualified/normalized/whatever id anymore.
//	var tagFullId = (!this.getAccount().isMain)
//		? ([this.getAccount().id, tagName].join(":"))
//		: (ZmOrganizer.getSystemId(tagName));
	var tagList = appCtxt.getAccountTagList(this);

	var tag = tagList.getByNameOrRemote(tagName);
    return tag ? tag.getIconWithColor() : "Blank_16";
};

/**
* Gets the default action to use when dragging this item. This method
* is meant to be overloaded for items that are read-only and can only be copied.
*
* @param {Boolean}		forceCopy		If set, default DnD action is a copy
* @return	{Object}	the action
*/
ZmItem.prototype.getDefaultDndAction =
function(forceCopy) {
	return (this.isReadOnly() || forceCopy)
		? ZmItem.DND_ACTION_COPY
		: ZmItem.DND_ACTION_MOVE;
};

/**
* Checks if this item is read-only. This method should be
* overloaded by the derived object to determine what "read-only" means.
* 
* @return	{Boolean}	the read-only status
*/
ZmItem.prototype.isReadOnly =
function() {
	return false;
};

/**
 * Checks if this item is shared.
 * 
 * @return	{Boolean}	<code>true</code> if this item is shared (remote)
 */
ZmItem.prototype.isShared =
function() {
	if (this._isShared == null) {
		if (this.id === -1) {
			this._isShared = false;
		} else {
			this._isShared = appCtxt.isRemoteId(this.id);
		}
	}
	return this._isShared;
};

// Notification handling

// For delete and modify notifications, we first apply the notification to this item. Then we
// see if the item is a member of any other lists. If so, we have those other copies of this
// item handle the notification as well. Each will notify through the list that created it.

ZmItem.prototype.notifyDelete =
function() {
	this._notifyDelete();
	for (var listId in this._list) {
		var list = appCtxt.getById(listId);
		if (!list || (this.list && listId == this.list.id)) { continue; }
		var ctlr = list.controller;
		if (!ctlr || ctlr.inactive || (ctlr.getList().id != listId)) { continue; }
		var doppleganger = list.getById(this.id);
		if (doppleganger) {
			doppleganger._notifyDelete();
		}
	}
};

ZmItem.prototype._notifyDelete =
function() {
	this.deleteLocal();
	if (this.list) {
		this.list.deleteLocal([this]);
	}
	this._notify(ZmEvent.E_DELETE);
};

ZmItem.prototype.notifyModify =
function(obj, batchMode) {
	this._notifyModify(obj, batchMode);
	for (var listId in this._list) {
		var list = listId ? appCtxt.getById(listId) : null;
		if (!list || (this.list && (listId == this.list.id))) { continue; }
		var ctlr = list.controller;
		if (!ctlr || ctlr.inactive || (ctlr.getList().id != listId)) { continue; }
		var doppleganger = list.getById(this.id);
		if (doppleganger) {
			doppleganger._notifyModify(obj, batchMode);
		}
	}
};

/**
 * Handles a modification notification.
 *
 * @param {Object}	obj			the item with the changed attributes/content
 * @param {boolean}	batchMode	if true, return event type and don't notify
 */
ZmItem.prototype._notifyModify =
function(obj, batchMode) {
	// empty string is meaningful here, it means no tags
	if (obj.tn != null) {
		this._parseTagNames(obj.tn);
		this._notify(ZmEvent.E_TAGS);
	}
	// empty string is meaningful here, it means no flags
	if (obj.f != null) {
		var flags = this._getFlags();
		var origFlags = {};
		for (var i = 0; i < flags.length; i++) {
			origFlags[flags[i]] = this[ZmItem.FLAG_PROP[flags[i]]];
		}
		this._parseFlags(obj.f);
		var changedFlags = [];
		for (var i = 0; i < flags.length; i++) {
			var on = this[ZmItem.FLAG_PROP[flags[i]]];
			if (origFlags[flags[i]] != on) {
				changedFlags.push(flags[i]);
			}
		}
		if (changedFlags.length) {
			this._notify(ZmEvent.E_FLAGS, {flags: changedFlags});
		}
	}
	if (obj.l != null && obj.l != this.folderId) {
		var details = {oldFolderId:this.folderId};
		this.moveLocal(obj.l);
		if (this.list) {
			this.list.moveLocal([this], obj.l);
		}
		if (batchMode) {
			delete obj.l;			// folder has been handled
			return ZmEvent.E_MOVE;
		} else {
			this._notify(ZmEvent.E_MOVE, details);
		}
	}
};

// Local change handling

/**
 * Applies the given flag change to this item by setting a boolean property.
 *
 * @param {constant}	flag	the flag that changed
 * @param {Boolean}	on		<code>true</code> if the flag is now set
 */
ZmItem.prototype.flagLocal =
function(flag, on) {
	this[ZmItem.FLAG_PROP[flag]] = on;
};

/**
 * Sets the given flag change to this item. Both the flags string and the
 * flag properties are affected.
 *
 * @param {constant}	flag	the flag that changed
 * @param {Boolean}	on	<code>true</code> if the flag is now set
 *
 * @return	{String}		the new flags string
 */
ZmItem.prototype.setFlag =
function(flag, on) {
	this.flagLocal(flag, on);
	var flags = this.flags || "";
	if (on && flags.indexOf(flag) == -1) {
		flags = flags + flag;
	} else if (!on && flags.indexOf(flag) != -1) {
		flags = flags.replace(flag, "");
	}
	this.flags = flags;

	return flags;
};

/**
 * Adds or removes the given tag for this item.
 *
 * @param {Object}		tag		tag name
 * @param {Boolean}		doTag		<code>true</code> if tag is being added; <code>false</code> if it is being removed
 * @return	{Boolean}	<code>true</code> to notify
 */
ZmItem.prototype.tagLocal =
function(tag, doTag) {
	var bNotify = false;
	if (doTag) {
		if (!this.tagHash[tag]) {
			bNotify = true;
			this.tags.push(tag);
			this.tagHash[tag] = true;
		}
	} else {
		for (var i = 0; i < this.tags.length; i++) {
			if (this.tags[i] == tag) {
				this.tags.splice(i, 1);
				delete this.tagHash[tag];
				bNotify = true;
				break;
			}
		}
	}
	
	return bNotify;
};

/**
 * Removes all tags.
 * 
 */
ZmItem.prototype.removeAllTagsLocal =
function() {
	this.tags = [];
	for (var i in this.tagHash) {
		delete this.tagHash[i];
	}
};

/**
 * Deletes local, in case an item wants to do something while being deleted.
 */
ZmItem.prototype.deleteLocal = function() {};

/**
 * Moves the item.
 * 
 * @param	{String}	folderId
 * @param	{AjxCallback}	callback		the callback
 * @param	{AjxCallback}	errorCallback	the callback on error
 * @return	{Object}		the result of the move
 */
ZmItem.prototype.move =
function(folderId, callback, errorCallback) {
	return ZmItem.move(this.id, folderId, callback, errorCallback);
};

/**
 * Moves the item.
 * 
 * @return	{Object}		the result of the move
 */
ZmItem.move =
function(itemId, folderId, callback, errorCallback, accountName) {
	var json = {
		ItemActionRequest: {
			_jsns: "urn:zimbraMail",
			action: {
				id:	itemId instanceof Array ? itemId.join() : itemId,
				op:	"move",
				l:	folderId
			}
		}
	};

	var params = {
		jsonObj:		json,
		asyncMode:		Boolean(callback),
		callback:		callback,
		errorCallback:	errorCallback,
		accountName:	accountName
	};
	return appCtxt.getAppController().sendRequest(params);
};

/**
 * Updates the folder for this item.
 *
 * @param {String}		folderId		the new folder ID
 */
ZmItem.prototype.moveLocal =
function(folderId) {
	this.folderId = folderId;
};

/**
 * Takes a comma-separated list of tag IDs and applies the tags to this item.
 * 
 * @private
 */
ZmItem.prototype._parseTags =
function(str) {	
	this.tags = [];
	this.tagHash = {};
	if (str && str.length) {
		var tags = str.split(",");
		for (var i = 0; i < tags.length; i++) {
			var tagId = Number(tags[i]);
			if (tagId >= ZmOrganizer.FIRST_USER_ID[ZmOrganizer.TAG])
				this.tagLocal(tagId, true);
		}
	}
};

/**
 * Takes a comma-separated list of tag names and applies the tags to this item.
 *
 * @private
 */
ZmItem.prototype._parseTagNames =
function(str) {
	this.tags = [];
	this.tagHash = {};
	if (!str || !str.length) {
		return;
	}
	
	// server escapes comma with backslash
	str = str.replace(/\\,/g, "\u001D");
	var tags = str.split(",");
	
	for (var i = 0; i < tags.length; i++) {
		var tagName = tags[i].replace("\u001D", ",");
		this.tagLocal(tagName, true);
	}
};

/**
 * Takes a string of flag chars and applies them to this item.
 * 
 * @private
 */
ZmItem.prototype._parseFlags =
function(str) {
	this.flags = str;
	for (var i = 0; i < ZmItem.ALL_FLAGS.length; i++) {
		var flag = ZmItem.ALL_FLAGS[i];
		var on = (str && (str.indexOf(flag) != -1)) ? true : false;
		this.flagLocal(flag, on);
	}
};

// Listener notification

/**
 * Notify the list as well as this item.
 * 
 * @private
 */
ZmItem.prototype._notify =
function(event, details) {
	this._doNotify(event, details);
};

ZmItem.prototype._setupNotify =
function() {
    this._doNotify();
}

ZmItem.prototype._doNotify =
function(event, details) {
	if (this._evt) {
		this._evt.item = this;
		if (event != null) {
			ZmModel.prototype._notify.call(this, event, details);
		}
	} else {
		var idText = "";
		if (this.type && this.id) {
			idText = ": item = " + this.type + "(" + this.id + ")";
		}
		DBG.println(AjxDebug.DBG1, "ZmItem._doNotify, missing _evt" + idText);
	}
    if (this.list) {
        this.list._evt.item = this;
        this.list._evt.items = [this];
        if (event != null) {
            if (details) {
                details.items = [this];
            } else {
                details = {items: [this]};
            }
            this.list._notify(event, details);
        }
    }
};

/**
 * Returns a list of flags that apply to this type of item.
 * 
 * @private
 */
ZmItem.prototype._getFlags =
function() {
	return [ZmItem.FLAG_FLAGGED, ZmItem.FLAG_ATTACH];
};

/**
 * Rename the item.
 *
 * @param	{String}	newName
 * @param	{AjxCallback}	callback		the callback
 * @param	{AjxCallback}	errorCallback	the callback on error
 * @return	{Object}		the result of the move
 */
ZmItem.prototype.rename =
function(newName, callback, errorCallback) {
	return ZmItem.rename(this.id, newName, callback, errorCallback);
};

/**
 * Rename the item.
 *
 * @return	{Object}		the result of the move
 */
ZmItem.rename =
function(itemId, newName, callback, errorCallback, accountName) {
    var json = {
		ItemActionRequest: {
			_jsns: "urn:zimbraMail",
			action: {
				id:	itemId instanceof Array ? itemId[0] : itemId,
				op:	"rename",
				name:	newName
			}
		}
	};	

	var params = {
		jsonObj:		json,
		asyncMode:		Boolean(callback),
		callback:		callback,
		errorCallback:	errorCallback,
		accountName:	accountName
	};
	return appCtxt.getAppController().sendRequest(params);
};

ZmItem.prototype.getSortedTags =
function() {
	var numTags = this.tags && this.tags.length;
	if (numTags) {
		var tagList = appCtxt.getAccountTagList(this);
		var ta = [];
		for (var i = 0; i < numTags; i++) {
			var tag = tagList.getByNameOrRemote(this.tags[i]);
			//tag could be missing if this was called when deleting a whole tag (not just untagging one message). So this makes sure we don't have a null item.
			if (!tag) {
				continue;
			}
			ta.push(tag);
		}
		ta.sort(ZmTag.sortCompare);
		return ta;
	}
	return null;
};

}
if (AjxPackage.define("zimbraMail.share.model.ZmOrganizer")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines an organizer.
 */

/**
* Creates an empty organizer.
* @class
* This class represents an "organizer", which is something used to classify or contain
* items. So far, that's either a tag or a folder. Tags and folders are represented as
* a tree structure, though tags are flat and have only one level below the root. Folders
* can be nested.
*
* @author Conrad Damon
*
* @param	{Hash}	params		a hash of parameters
* @param {constant}	params.type		the organizer type
* @param {int}		params.id			the numeric ID
* @param {String}	params.name		the name
* @param {ZmOrganizer}	params.parent		the parent organizer
* @param {ZmTree}	params.tree		the tree model that contains this organizer
* @param {constant}	params.color		the color for this organizer
* @param {String}	params.rgb		the color for this organizer, as HTML RGB value
* @param {Boolean}	params.link		<code>true</code> if this organizer is shared
* @param {Boolean}	params.broken		<code>true</code> if this link is broken
* @param {int}	params.numUnread	the number of unread items for this organizer
* @param {int}	params.numTotal	the number of items for this organizer
* @param {Boolean}	params.noTooltip	do not show tooltip 
* @param {int}	params.sizeTotal	the total size of organizer's items
* @param {String}	params.url		the URL for this organizer's feed
* @param {String}	params.owner		the owner for this organizer
* @param {String}	params.oname		the owner's name for this organizer
* @param {String}	params.zid		the Zimbra ID of owner, if remote folder
* @param {String}	params.rid		the remote ID of organizer, if remote folder
* @param {String}	params.restUrl	the REST URL of this organizer.
* @param {String}	params.newOp		the name of operation run by button in overview header
* @param {ZmZimbraAccount}	params.account	the account this organizer belongs to
*/
ZmOrganizer = function(params) {

	if (arguments.length == 0) { return; }

	this.type = params.type;
	var id = this.id = params.id;
	this.nId = ZmOrganizer.normalizeId(id);
	this.name = ZmFolder.MSG_KEY[this.nId] ? ZmMsg[ZmFolder.MSG_KEY[this.nId]] : params.name;
	this._systemName = this.nId < 256 && params.name;
	this.parent = params.parent;
	this.tree = params.tree;
	this.numUnread = params.numUnread || 0;
	this.numTotal = params.numTotal || 0;
	this.noTooltip = params.noTooltip;
	this.sizeTotal = params.sizeTotal || 0;
	this.url = params.url;
	this.owner = params.owner;
	this.oname = params.oname;
	this.link = params.link || (Boolean(params.zid)) || (this.parent && this.parent.link);
	this.isMountpoint = params.link;
	this.zid = params.zid;
	this.rid = params.rid;
	this.restUrl = params.restUrl;
	this.account = params.account;
    this.perm = params.perm;
	this.noSuchFolder = params.broken; // Is this a link to some folder that ain't there.
	this._isAdmin = this._isReadOnly = this._hasPrivateAccess = null;
    this.retentionPolicy = params.retentionPolicy;
	this.webOfflineSyncDays = params.webOfflineSyncDays;

	this.color =
        params.color ||
        (this.parent && this.parent.color) ||
        ZmOrganizer.ORG_COLOR[id] ||
        ZmOrganizer.ORG_COLOR[this.nId] ||
        ZmOrganizer.DEFAULT_COLOR[this.type] ||
        ZmOrganizer.C_NONE
    ;
	this.isColorCustom = params.rgb != null; //set so we know if the user chose a custom color (to distiguish from basic color or none
	this.rgb =
        params.rgb ||
        ZmOrganizer.COLOR_VALUES[this.color] ||
        ZmOrganizer.COLOR_VALUES[ZmOrganizer.ORG_DEFAULT_COLOR]
    ;

	if (appCtxt.isOffline && !this.account && this.id == this.nId) {
		this.account = appCtxt.accountList.mainAccount;
	}

	if (id && params.tree) {
		appCtxt.cacheSet(id, this);
		if (this.link) {
			// also store under ID that items use for parent folder ("l" attribute in node)
			appCtxt.cacheSet([this.zid, this.rid].join(":"), this);
		}
	}

	this.children = new AjxVector();
};

ZmOrganizer.prototype.isZmOrganizer = true;
ZmOrganizer.prototype.toString = function() { return "ZmOrganizer"; };

// global organizer types
ZmOrganizer.TAG					= ZmEvent.S_TAG;
ZmOrganizer.SEARCH				= ZmEvent.S_SEARCH;
ZmOrganizer.SHARE               = ZmEvent.S_SHARE;
ZmOrganizer.MOUNTPOINT			= ZmEvent.S_MOUNTPOINT;
ZmOrganizer.ZIMLET				= ZmEvent.S_ZIMLET;

// folder IDs defined in com.zimbra.cs.mailbox.Mailbox
// Note: since these are defined as Numbers, and IDs come into our system as Strings,
// we need to use == for comparisons (instead of ===, which will fail)
ZmOrganizer.ID_ROOT				= 1;
ZmOrganizer.ID_INBOX			= 2;
ZmOrganizer.ID_TRASH			= 3;
ZmOrganizer.ID_SPAM				= 4;
ZmOrganizer.ID_ADDRBOOK			= 7;
ZmOrganizer.ID_CALENDAR			= 10;
ZmOrganizer.ID_AUTO_ADDED 		= 13;
ZmOrganizer.ID_CHATS			= 14;
ZmOrganizer.ID_TASKS			= 15;
ZmOrganizer.ID_BRIEFCASE		= 16;
ZmOrganizer.ID_ALL_MAILBOXES	= 249; 
ZmOrganizer.ID_NOTIFICATION_MP	= 250;
ZmOrganizer.ID_SYNC_FAILURES	= 252;		// offline only
ZmOrganizer.ID_OUTBOX    		= 254;		// offline only
ZmOrganizer.ID_ZIMLET			= -1000;	// zimlets need a range.  start from -1000 incrementing up.
ZmOrganizer.ID_ATTACHMENTS		= -17;		// Attachments View
ZmOrganizer.ID_DLS				= -18;

// fields that can be part of a displayed organizer
ZmOrganizer.F_NAME				= "name";
ZmOrganizer.F_UNREAD			= "unread";
ZmOrganizer.F_TOTAL				= "total";
ZmOrganizer.F_SIZE				= "size";
ZmOrganizer.F_COLOR				= "color";
ZmOrganizer.F_RGB				= "rgb";
ZmOrganizer.F_QUERY				= "query";
ZmOrganizer.F_SHARES			= "shares";
ZmOrganizer.F_FLAGS				= "flags";
ZmOrganizer.F_REST_URL			= "rest";
ZmOrganizer.F_PERMS				= "perms";
ZmOrganizer.F_RNAME				= "rname";	// remote name

// server representation of org flags
ZmOrganizer.FLAG_CHECKED			= "#";
ZmOrganizer.FLAG_DISALLOW_SUBFOLDER	= "o";
ZmOrganizer.FLAG_EXCLUDE_FREE_BUSY	= "b";
ZmOrganizer.FLAG_IMAP_SUBSCRIBED	= "*";
ZmOrganizer.FLAG_OFFLINE_GLOBAL		= "g";
ZmOrganizer.FLAG_OFFLINE_SYNCABLE	= "y";
ZmOrganizer.FLAG_OFFLINE_SYNCING	= "~";
ZmOrganizer.ALL_FLAGS = [
	ZmOrganizer.FLAG_CHECKED,
	ZmOrganizer.FLAG_IMAP_SUBSCRIBED,
	ZmOrganizer.FLAG_EXCLUDE_FREE_BUSY,
	ZmOrganizer.FLAG_DISALLOW_SUBFOLDER,
	ZmOrganizer.FLAG_OFFLINE_GLOBAL,
	ZmOrganizer.FLAG_OFFLINE_SYNCABLE,
	ZmOrganizer.FLAG_OFFLINE_SYNCING
];

// org property for each flag
ZmOrganizer.FLAG_PROP = {};
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_CHECKED]				= "isChecked";
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_IMAP_SUBSCRIBED]		= "imapSubscribed";
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_EXCLUDE_FREE_BUSY]	= "excludeFreeBusy";
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_DISALLOW_SUBFOLDER]	= "disallowSubFolder";
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_OFFLINE_GLOBAL]		= "isOfflineGlobalSearch";
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_OFFLINE_SYNCABLE]	= "isOfflineSyncable";
ZmOrganizer.FLAG_PROP[ZmOrganizer.FLAG_OFFLINE_SYNCING]		= "isOfflineSyncing";

// Following chars invalid in organizer names: " : / [anything less than " "]
ZmOrganizer.VALID_NAME_CHARS = "[^\\x00-\\x1F\\x7F:\\/\\\"]";
ZmOrganizer.VALID_PATH_CHARS = "[^\\x00-\\x1F\\x7F:\\\"]"; // forward slash is OK in path
ZmOrganizer.VALID_NAME_RE = new RegExp('^' + ZmOrganizer.VALID_NAME_CHARS + '+$');

ZmOrganizer.MAX_NAME_LENGTH			= 128;	// max allowed by server
ZmOrganizer.MAX_DISPLAY_NAME_LENGTH	= 30;	// max we will show

// color constants (server stores a number)
ZmOrganizer.C_NONE				= 0;
ZmOrganizer.C_BLUE				= 1;
ZmOrganizer.C_CYAN				= 2;
ZmOrganizer.C_GREEN				= 3;
ZmOrganizer.C_PURPLE			= 4;
ZmOrganizer.C_RED				= 5;
ZmOrganizer.C_YELLOW			= 6;
ZmOrganizer.C_PINK				= 7;
ZmOrganizer.C_GRAY				= 8;
ZmOrganizer.C_ORANGE			= 9;
ZmOrganizer.MAX_COLOR			= ZmOrganizer.C_ORANGE;
ZmOrganizer.ORG_DEFAULT_COLOR 	= ZmOrganizer.C_GRAY;

ZmOrganizer.COLOR_VALUES = [
	null,
	ZmMsg.colorBlue,
	ZmMsg.colorCyan,
	ZmMsg.colorGreen,
	ZmMsg.colorPurple,
	ZmMsg.colorRed,
	ZmMsg.colorYellow,
	ZmMsg.colorPink,
	ZmMsg.colorGray,
	ZmMsg.colorOrange
];

// color names
ZmOrganizer.COLOR_TEXT = {};
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_NONE]		= ZmMsg.none;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_ORANGE]	= ZmMsg.orange;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_BLUE]		= ZmMsg.blue;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_CYAN]		= ZmMsg.cyan;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_GREEN]		= ZmMsg.green;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_PURPLE]	= ZmMsg.purple;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_RED]		= ZmMsg.red;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_YELLOW]	= ZmMsg.yellow;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_PINK]		= ZmMsg.pink;
ZmOrganizer.COLOR_TEXT[ZmOrganizer.C_GRAY]		= ZmMsg.gray;

// list of colors and text for populating a color select menu
ZmOrganizer.COLORS = [];
ZmOrganizer.COLOR_CHOICES = [];
(function() {
	for (var i = 0; i <= ZmOrganizer.MAX_COLOR; i++) {
		var color = ZmOrganizer.COLOR_TEXT[i];
		ZmOrganizer.COLORS.push(color);
		ZmOrganizer.COLOR_CHOICES.push( { value:i, label:color } );
	}
})();


ZmOrganizer.MSG_KEY 		= {};		// keys for org names
ZmOrganizer.ROOT_MSG_KEY	= {};		// key for name of root (used as tree header)
ZmOrganizer.ITEM_ORGANIZER 	= {};		// primary organizer for item types
ZmOrganizer.DEFAULT_FOLDER 	= {};		// default folder for org type
ZmOrganizer.SOAP_CMD 		= {};		// SOAP command for modifying an org
ZmOrganizer.FIRST_USER_ID 	= {};		// lowest valid user ID for an org type
ZmOrganizer.PRECONDITION 	= {};		// setting that this org type depends on
ZmOrganizer.HAS_COLOR 		= {};		// whether an org uses colors
ZmOrganizer.DEFAULT_COLOR 	= {};		// default color for each org type
ZmOrganizer.ORG_COLOR 		= {};		// color overrides by ID
ZmOrganizer.APP 			= {};		// App responsible for organizer
ZmOrganizer.ORG_CLASS 		= {};		// constructor for organizer
ZmOrganizer.ORG_PACKAGE 	= {};		// package required to construct organizer
ZmOrganizer.CREATE_FUNC 	= {};		// function that creates this organizer
ZmOrganizer.LABEL 			= {};		// msg key for text for tree view header item
ZmOrganizer.ITEMS_KEY 		= {};		// msg key for text describing contents
ZmOrganizer.TREE_TYPE 		= {};		// type of server data tree that contains this type of organizer
ZmOrganizer.VIEWS 			= {};		// views by org type
ZmOrganizer.VIEW_HASH		= {};		// view hash by org type
ZmOrganizer.TYPE 			= {};		// types by view (reverse map of above)
ZmOrganizer.FOLDER_KEY 		= {};		// keys for label "[org] folder"
ZmOrganizer.MOUNT_KEY 		= {};		// keys for label "mount [org]"
ZmOrganizer.DEFERRABLE 		= {};		// creation can be deferred to app launch
ZmOrganizer.PATH_IN_NAME	= {};		// if true, provide full path when asked for name
ZmOrganizer.OPEN_SETTING	= {};		// setting that controls whether the tree view is open
ZmOrganizer.NEW_OP			= {};		// name of operation for new button in tree header (optional)
ZmOrganizer.DISPLAY_ORDER	= {};		// sort number to determine order of tree view (optional)
ZmOrganizer.HIDE_EMPTY		= {};		// if true, hide tree header if tree is empty
ZmOrganizer.SHAREABLE 		= {};		// allow share or not

ZmOrganizer.APP2ORGANIZER	= {};		// organizer types, keyed by app name
ZmOrganizer.APP2ORGANIZER_R = {};		// app names, keyed by app organizer type

// allowed permission bits
ZmOrganizer.PERM_READ		= "r";
ZmOrganizer.PERM_WRITE		= "w";
ZmOrganizer.PERM_INSERT		= "i";
ZmOrganizer.PERM_DELETE		= "d";
ZmOrganizer.PERM_ADMIN		= "a";
ZmOrganizer.PERM_WORKFLOW	= "x";
ZmOrganizer.PERM_PRIVATE	= "p";

// Retention Policy Elements - Keep or Purge
ZmOrganizer.RETENTION_KEEP  = "keep";
ZmOrganizer.RETENTION_PURGE = "purge";

// Abstract methods

/**
 * Stores information about the given organizer type.
 * 
 * @param {constant}	org				the organizer type
 * @param {Hash}	params			a hash of parameters
 * @param	{constant}	app				the app that handles this org type
 * @param	{String}	nameKey			the msg key for org name
 * @param	{constant}	precondition		the setting that this org type depends on
 * @param	{int}	defaultFolder		the folder ID of default folder for this org
 * @param	{String}	soapCmd			the SOAP command for acting on this org
 * @param	{int}	firstUserId		the minimum ID for a user instance of this org
 * @param	{String}	orgClass			the name of constructor for this org
 * @param	{String}	orgPackage		the name of smallest package with org class
 * @param	{String}	treeController	the name of associated tree controller
 * @param	{String}	labelKey			the msg key for label in overview
 * @param	{String}	itemsKey			the msg key for text describing contents
 * @param	{Boolean}	hasColor			<code>true</code> if org has color associated with it
 * @param	{constant}	defaultColor		the default color for org in overview
 * @param	{Array}	orgColor			the color override by ID (in pairs)
 * @param	{constant}	treeType			the type of data tree (from server) that contains this org
 * @param	{String}	views				the associated folder views (JSON)
 * @param	{String}	folderKey			the msg key for folder props dialog
 * @param	{String}	mountKey			the msg key for folder mount dialog
 * @param	{String}	createFunc		the name of function for creating this org
 * @param	{String}	compareFunc		the name of function for comparing instances of this org
 * @param	{Boolean}	deferrable		if <code>true</code>, creation can be deferred to app launch
 * @param	{Boolean}	pathInName		if <code>true</code>, provide full path when asked for name
 * @param	{constant}	openSetting		the setting that controls whether the tree view is open
 * @param	{int}	displayOrder		the number that is used when sorting the display of trees. (Lower number means higher display.)
 * @param	{Boolean}	hideEmpty			if <code>true</code>, hide tree header if tree is empty
 */
ZmOrganizer.registerOrg =
function(org, params) {
	if (params.nameKey)			{ ZmOrganizer.MSG_KEY[org]				= params.nameKey; }
	if (params.app)				{
		ZmOrganizer.APP[org] = params.app;
		if (!ZmOrganizer.APP2ORGANIZER[params.app]) {
			ZmOrganizer.APP2ORGANIZER[params.app] = [];
		}
		ZmOrganizer.APP2ORGANIZER[params.app].push(org);
        ZmOrganizer.APP2ORGANIZER_R[org] = params.app;
	}
	if (params.defaultFolder)	{ ZmOrganizer.DEFAULT_FOLDER[org]		= params.defaultFolder; }
	if (params.precondition)	{ ZmOrganizer.PRECONDITION[org]			= params.precondition; }
	if (params.soapCmd)			{ ZmOrganizer.SOAP_CMD[org]				= params.soapCmd; }
	if (params.firstUserId)		{ ZmOrganizer.FIRST_USER_ID[org]		= params.firstUserId; }
	if (params.orgClass)		{ ZmOrganizer.ORG_CLASS[org]			= params.orgClass; }
	if (params.orgPackage)		{ ZmOrganizer.ORG_PACKAGE[org]			= params.orgPackage; }
	if (params.labelKey)		{ ZmOrganizer.LABEL[org]				= params.labelKey; }
	if (params.itemsKey)		{ ZmOrganizer.ITEMS_KEY[org]			= params.itemsKey; }
	if (params.hasColor)		{ ZmOrganizer.HAS_COLOR[org]			= params.hasColor; }
	if (params.views)			{ ZmOrganizer.VIEWS[org]				= params.views; }
	if (params.folderKey)		{ ZmOrganizer.FOLDER_KEY[org]			= params.folderKey; }
	if (params.mountKey)		{ ZmOrganizer.MOUNT_KEY[org]			= params.mountKey; }
	if (params.deferrable)		{ ZmOrganizer.DEFERRABLE[org]			= params.deferrable; }
	if (params.pathInName)		{ ZmOrganizer.PATH_IN_NAME[org]			= params.pathInName; }
	if (params.openSetting)		{ ZmOrganizer.OPEN_SETTING[org]			= params.openSetting; }
	if (params.newOp)			{ ZmOrganizer.NEW_OP[org]				= params.newOp; }
	if (params.displayOrder)	{ ZmOrganizer.DISPLAY_ORDER[org]		= params.displayOrder; }
	if (params.hideEmpty)		{ ZmOrganizer.HIDE_EMPTY[org]			= params.hideEmpty; }
	ZmOrganizer.SHAREABLE[org]	= !params.disableShare; 

	if (!appCtxt.isChildWindow || params.childWindow ) {
		if (params.compareFunc)		{ ZmTreeView.COMPARE_FUNC[org]			= params.compareFunc; }
		if (params.treeController)	{ ZmOverviewController.CONTROLLER[org]	= params.treeController; }
	}

	ZmOrganizer.TREE_TYPE[org] = params.treeType || org; // default to own type
	ZmOrganizer.CREATE_FUNC[org] = params.createFunc || "ZmOrganizer.create";

	if (params.views) {
		ZmOrganizer.VIEW_HASH[org] = AjxUtil.arrayAsHash(ZmOrganizer.VIEWS[org]);
	}

	if (params.hasColor) {
		ZmOrganizer.DEFAULT_COLOR[org] = (params.defaultColor != null)
			? params.defaultColor
			: ZmOrganizer.ORG_DEFAULT_COLOR;
	}

	if (params.orgColor) {
		for (var id in params.orgColor) {
			ZmOrganizer.ORG_COLOR[id] = params.orgColor[id];
		}
	}

	if (params.dropTargets) {
		if (!ZmApp.DROP_TARGETS[params.app]) {
			ZmApp.DROP_TARGETS[params.app] = {};
		}
		ZmApp.DROP_TARGETS[params.app][org] = params.dropTargets;
	}
};

ZmOrganizer.sortCompare = function(organizerA, organizerB) {};

/**
 * nulls value that is the default color for the type.
 * @param value
 */
ZmOrganizer.getColorValue =
function(value, type) {
	// no need to save color if missing or default
	if (value == ZmOrganizer.DEFAULT_COLOR[type]) {
		return null;
	}

	return value;
};

/**
 * Creates an organizer via <code>&lt;CreateFolderRequest&gt;</code>. Attribute pairs can
 * be passed in and will become attributes of the folder node in the request.
 * 
 * @param {Hash}	params	a hash of parameters
 */
ZmOrganizer.create =
function(params) {
	var jsonObj = {CreateFolderRequest:{_jsns:"urn:zimbraMail"}};
	var folder = jsonObj.CreateFolderRequest.folder = {};
	var errorCallback = params.errorCallback || new AjxCallback(null, ZmOrganizer._handleErrorCreate, params);
	var type = params.type;

	// set attributes
	params.view = params.view || ZmOrganizer.VIEWS[type] ? ZmOrganizer.VIEWS[type][0] : null;
	for (var i in params) {
		if (i == "type" || i == "errorCallback" || i == "account") { continue; }

		var value = params[i];
		if (value) {
			folder[i] = value;
		}
	}
	//adding support to asyncMode == false didn't eventually help me, but why not keep it?
	var asyncMode = params.asyncMode === undefined ? true : params.asyncMode; //default is true

	return appCtxt.getAppController().sendRequest({
		jsonObj: jsonObj,
		asyncMode: asyncMode,
		accountName: (params.account && params.account.name),
		callback: params.callback,
		callbackAfterNotifications: params.callbackAfterNotifications, 
		errorCallback: errorCallback
	});
};

/**
 * @private
 */
ZmOrganizer._handleErrorCreate =
function(params, ex) {
	if (!params.url && !params.name) { return false; }
	
	var msg;
	if (params.name && (ex.code == ZmCsfeException.MAIL_ALREADY_EXISTS)) {
		var type = appCtxt.getFolderTree(appCtxt.getActiveAccount()).getFolderTypeByName(params.name);
        msg = AjxMessageFormat.format(ZmMsg.errorAlreadyExists, [params.name, type.toLowerCase()]);
	} else if (params.url) {
		var errorMsg = (ex.code == ZmCsfeException.SVC_RESOURCE_UNREACHABLE) ? ZmMsg.feedUnreachable : ZmMsg.feedInvalid;
		msg = AjxMessageFormat.format(errorMsg, params.url);
	}

	if (msg) {
		ZmOrganizer._showErrorMsg(msg);
		return true;
	}

	return false;
};

/**
 * @private
 */
ZmOrganizer._showErrorMsg =
function(msg) {
	var msgDialog = appCtxt.getMsgDialog();
	msgDialog.reset();
	msgDialog.setMessage(AjxStringUtil.htmlEncode(msg), DwtMessageDialog.CRITICAL_STYLE);
	msgDialog.popup();
};

/**
 * Gets the folder.
 * 
 * @param	{String}	id		the folder id
 * @param	{AjxCallback}	callback	the callback
 * @param	{ZmBatchCommand}	batchCmd	the batch command or <code>null</code> for none
 */
ZmOrganizer.getFolder =
function(id, callback, batchCmd) {
	var jsonObj = {GetFolderRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.GetFolderRequest;
	request.folder = {l:id};
	var respCallback = new AjxCallback(null, ZmOrganizer._handleResponseGetFolder, [callback]);
	if (batchCmd) {
		batchCmd.addRequestParams(jsonObj, respCallback);
	} else {
		appCtxt.getRequestMgr().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
	}
};

/**
 * @private
 */
ZmOrganizer._handleResponseGetFolder =
function(callback, result) {
	var resp = result.getResponse().GetFolderResponse;
	var folderObj = (resp && resp.folder && resp.folder[0]) ||
					(resp && resp.link && resp.link[0]);
	var folder;
	if (folderObj) {
		folder = appCtxt.getById(folderObj.id);
		if (folder) {
			folder.clearShares();
			folder._setSharesFromJs(folderObj);
		} else {
			var parent = appCtxt.getById(folderObj.l);
			folder = ZmFolderTree.createFromJs(parent, folderObj, appCtxt.getFolderTree(), "folder");
		}
	}
	if (callback) {
		callback.run(folder);
	}
};

/**
 * Gets the folder.
 * 
 * @param	{AjxCallback}	callback	the callback
 * @param	{ZmBatchCommand}	batchCmd	the batch command or <code>null</code> for none
 */
ZmOrganizer.prototype.getFolder =
function(callback, batchCmd) {
	ZmOrganizer.getFolder(this.id, callback, batchCmd);
};


// Static methods

/**
 * Gets the view name by organizer type.
 * 
 * @param	{String}	organizerType		the organizer type
 * @return	{String}	the view
 */
ZmOrganizer.getViewName =
function(organizerType) {
	return ZmOrganizer.VIEWS[organizerType][0];
};

/**
 * Checks an organizer (folder or tag) offlineSyncInterval for validity.
 *
 * @param {String}	value		offlineSyncInterval
 * @return	{String}	<code>null</code> if the offlineSyncInterval is valid or an error message if the name is invalid
 */
ZmOrganizer.checkWebOfflineSyncDays =
function(value) {
    if (isNaN(value)) {	return ZmMsg.invalidFolderSyncInterval; }
    var interval = parseInt(value);
	if (interval < 0 ||  interval > 30) {
		return ZmMsg.invalidFolderSyncInterval;
	}
	return null;
};

/**
 * Checks an organizer (folder or tag) name for validity.
 *
 * @param {String}	name		an organizer name
 * @return	{String}	<code>null</code> if the name is valid or an error message if the name is invalid
 */
ZmOrganizer.checkName =
function(name) {
	if (name.length == 0) {	return ZmMsg.nameEmpty; }

	if (name.length > ZmOrganizer.MAX_NAME_LENGTH) {
		return AjxMessageFormat.format(ZmMsg.nameTooLong, ZmOrganizer.MAX_NAME_LENGTH);
	}

	if (!ZmOrganizer.VALID_NAME_RE.test(name)) {
		return AjxMessageFormat.format(ZmMsg.errorInvalidName, AjxStringUtil.htmlEncode(name));
	}

	return null;
};

/**
 * Checks a URL (a folder or calendar feed, for example) for validity.
 *
 * @param {String}	url	a URL
 * @return	{String}	<code>null</code> if valid or an error message
 */
ZmOrganizer.checkUrl =
function(url) {
	// TODO: be friendly and prepend "http://" when it's missing
	if (!url.match(/^[a-zA-Z]+:\/\/.*$/i)) {
		return ZmMsg.errorUrlMissing;
	}

	return null;
};

/**
 * @private
 */
ZmOrganizer.checkSortArgs =
function(orgA, orgB) {
	if (!orgA && !orgB) return 0;
	if (orgA && !orgB) return 1;
	if (!orgA && orgB) return -1;
	return null;
};

/**
 * @private
 */
ZmOrganizer.checkColor =
function(color) {
	return ((color != null) && (color >= 0 && color <= ZmOrganizer.MAX_COLOR))
		? color : ZmOrganizer.ORG_DEFAULT_COLOR;
};

/**
 * Gets the system ID for the given system ID and account. Unless this
 * is a child account, the system ID is returned unchanged. For child
 * accounts, the ID consists of the account ID and the local ID.
 * 
 * @param {int}	id		the ID of a system organizer
 * @param {ZmZimbraAccount}	account	the account
 * @param {Boolean}		force		<code>true</code> to generate the fully qualified ID even if this is the main account
 * @return	{String}	the ID
 */
ZmOrganizer.getSystemId =
function(id, account, force) {
	account = account || appCtxt.getActiveAccount();
	if ((account && !account.isMain) || force) {
		return ((typeof(id) == "string") && (id.indexOf(":") != -1) || !id)
			? id : ([account.id, id].join(":"));
	}
	return id;
};

/**
 * Normalizes the id by stripping the account ID portion from a system ID for a child account, which
 * can then be used to check against known system IDs. Any non-system ID is
 * returned unchanged (if type is provided).
 *
 * @param {String}	id	ID of an organizer
 * @param {constant}	type	the type of organizer
 * @return	{String}	the resulting id
 */
ZmOrganizer.normalizeId =
function(id, type) {
	if (typeof(id) != "string") { return id; }
	var idx = id.indexOf(":");
	var localId = (idx == -1) ? id : id.substr(idx + 1);
	return (type && (localId >= ZmOrganizer.FIRST_USER_ID[type])) ? id : localId;
};

/**
 * Parses an id into an object with fields for account and normalized id
 *
 * @param {String}	id		the ID of an organizer
 * @param {Object}	result	an optional object in which the result is stored
 * @return	{Object}	the resulting ID
 */
ZmOrganizer.parseId =
function(id, result) {
	var ac = window.parentAppCtxt || window.appCtxt;

	result = result || {};
	if (id == null) { return result; }
	var idx = (typeof id == "string") ? id.indexOf(":") : -1;
	if (idx == -1) {
		result.account = ac.accountList.mainAccount;
		result.id = id;
	} else {
		result.acctId = id.substring(0, idx);
		result.account = ac.accountList.getAccount(result.acctId);
		result.id = id.substr(idx + 1);
	}
	return result;
};

// Public methods

/**
* Gets the name of this organizer.
*
* @param {Boolean}	showUnread		<code>true</code> to display the number of unread items (in parens)
* @param {int}	maxLength		the length (in chars) to truncate the name to
* @param {Boolean}	noMarkup		if <code>true</code>, don't return any HTML
* @param {Boolean}	useSystemName	if <code>true</code>, don't use translated version of name
* @return	{String}	the name
*/
ZmOrganizer.prototype.getName = 
function(showUnread, maxLength, noMarkup, useSystemName, useOwnerName, defaultRootType) {
	if (this.nId == ZmFolder.ID_ROOT) {
		var type = defaultRootType || this.type;
		return (ZmOrganizer.LABEL[type])
			? ZmMsg[ZmOrganizer.LABEL[type]] : "";
	}
	var name = (useSystemName && this._systemName) || (useOwnerName && this.oname) || this.name || "";
	if (ZmOrganizer.PATH_IN_NAME[this.type] && this.path) {
		name = [this.path, name].join("/");
	}
	name = (maxLength && name.length > maxLength)
		? name.substring(0, maxLength - 3) + "..." : name;
	return this._markupName(name, showUnread, noMarkup);
};

/**
* Gets the full path as a string.
*
* @param {Boolean}	includeRoot		<code>true</code> to include root name at the beginning of the path
* @param {Boolean}	showUnread		<code>true</code> to display the number of unread items (in parens)
* @param {int}	maxLength		the length (in chars) to truncate the name to
* @param {Boolean}	noMarkup		if <code>true</code>, do not return any HTML
* @param {Boolean}	useSystemName	if <code>true</code>, use untranslated version of system folder names
* @return	{String}	the path
*/
ZmOrganizer.prototype.getPath = 
function(includeRoot, showUnread, maxLength, noMarkup, useSystemName, useOwnerName) {
	var parent = this.parent;
	var path = this.getName(showUnread, maxLength, noMarkup, useSystemName, useOwnerName);
	while (parent && ((parent.nId != ZmOrganizer.ID_ROOT) || includeRoot)) {
		path = parent.getName(showUnread, maxLength, noMarkup, useSystemName, useOwnerName) + ZmFolder.SEP + path;
		parent = parent.parent;
	}

	return path;
};

/**
 * Gets the tooltip. The tooltip shows number of unread items, total messages and the total size.
 *
 * @param {Boolean}	force		if <code>true</code>, don't use cached tooltip
 * @return	{String}	the tooltip
 */
ZmOrganizer.prototype.getToolTip =
function(force) {
	if (this.noTooltip) {
		return null;
	}
    if (!this._tooltip || force) {
		var itemText = this._getItemsText();
		var unreadLabel = this._getUnreadLabel();
		var subs = {name:this.name, itemText:itemText, numTotal:this.numTotal, sizeTotal:this.sizeTotal, numUnread:this.numUnread, unreadLabel:unreadLabel};
		this._tooltip = AjxTemplate.expand("share.App#FolderTooltip", subs);
	}
	return this._tooltip;
};

/**
 * Gets the full path, suitable for use in search expressions.
 *
 * @return	{String}	the path
 */
ZmOrganizer.prototype.getSearchPath =
function(useOwnerName) {
	return (this.nId != ZmOrganizer.ID_ROOT)
		? this.getPath(null, null, null, true, true, useOwnerName) : "/";
};

/**
 * Gets the URL.
 * 
 * @return	{String}	the URL
 * 
 * @deprecated use {@link getRestUrl}
 */
ZmOrganizer.prototype.getUrl =
function() {
	return this.getRestUrl();
};

/**
 * Gets the sync URL.
 * 
 * @return		{String}	the URL
 */
ZmOrganizer.prototype.getSyncUrl =
function() {
	return url;
};

/**
 * Gets the remote ID.
 * 
 * @return	{String}	the ID
 */
ZmOrganizer.prototype.getRemoteId =
function() {
	if (!this._remoteId) {
		this._remoteId = (this.isRemote() && this.zid && this.rid)
			? (this.zid + ":" + this.rid)
			: this.id;
	}
	return this._remoteId;
};


/**
 * Gets the REST URL.
 * 
 * @return	{String}	the URL
 */
ZmOrganizer.prototype.getRestUrl =
function(noRemote) {

	var restUrl = appCtxt.get(ZmSetting.REST_URL);
	if (restUrl && (!this.isRemote() || noRemote)) { //for remote - this does not work. either use this.restUrl (if set, which is for shared folder, but not for sub-folders) or call _generateRestUrl which seems to work for subfodlers of shared as well.
		var path = AjxStringUtil.urlEncode(this.getSearchPath()).replace("#","%23").replace(";", "%3B"); // User may type in a # in a folder name, but that's not ok for our urls
		// return REST URL as seen by the GetInfoResponse
		return ([restUrl, "/", path].join(""));
	}

	// return REST URL as seen by server - this is the remote (isRemote() true) case - shared folder.
	if (this.restUrl) {
		return this.restUrl;
	}

	// if server doesn't tell us what URL to use, do our best to generate
	var url = this._generateRestUrl();
	DBG.println(AjxDebug.DBG3, "NO REST URL FROM SERVER. GENERATED URL: " + url);

	return url;
};

/**
 * Gets the OWNER'S REST URL,used to fetch resturl of shared folders.
 *
 * @return	{String}	the URL
 */
ZmOrganizer.prototype.getOwnerRestUrl =
function(){
  var restUrl=this.restUrl;
  var path = AjxStringUtil.urlEncode(this.oname).replace("#","%23");

  // return REST URL as seen by the GetInfoResponse
  return ([restUrl, "/", path].join(""));
};

ZmOrganizer.prototype._generateRestUrl =
function() {
	var loc = document.location;
	var uname = appCtxt.get(ZmSetting.USERNAME);
	var host = loc.host;
	var m = uname.match(/^(.*)@(.*)$/);

	host = (m && m[2]) || host;

	// REVISIT: What about port? For now assume other host uses same port
	if (loc.port && loc.port != 80) {
		host = host + ":" + loc.port;
	}

	var path = AjxStringUtil.urlEncode(this.getSearchPath()).replace("#","%23"); // User may type in a # in a folder name, but that's not ok for our urls
		
	return [
		loc.protocol, "//", host, "/service/user/", uname, "/",	path
	].join("");
};

/**
 * Gets the account.
 * 
 * @return	{ZmZimbraAccount}	the account
 */
ZmOrganizer.prototype.getAccount =
function() {
	if (appCtxt.multiAccounts) {
		if (!this.account) {
			this.account = ZmOrganizer.parseId(this.id).account;
		}
		// bug 46364:
		// still no account?! Must be remote organizer, keep checking parent
		if (!this.account) {
			var parent = this.parent;
			while (parent && !this.account) {
				this.account = parent.getAccount();
				parent = parent.parent;
			}
		}
		return this.account;
	}

	return (this.account || appCtxt.accountList.mainAccount);
};

/**
 * Gets the shares.
 * 
 * @return	{Array}	an array of shares
 */
ZmOrganizer.prototype.getShares =
function() {
	return this.shares;
};

/**
 * Adds the share.
 * 
 * @param	{Object}	share		the share to add
 */
ZmOrganizer.prototype.addShare =
function(share) {
	this.shares = this.shares || [];
	this.shares.push(share);

	var curAcct = appCtxt.getActiveAccount();
	var curZid = curAcct && curAcct.id;
	var shareId = share.grantee && share.grantee.id;
	if (shareId && (shareId == curZid)) {
		this._mainShare = share;
	}
};

/**
 * Clears all shares.
 * 
 */
ZmOrganizer.prototype.clearShares =
function() {
	if (this.shares && this.shares.length) {
		for (var i = 0; i < this.shares.length; i++) {
			this.shares[i] = null;
		}
	}
	this.shares = null;
	this._mainShare = null;
};

/**
 * Gets the share granted to the current user.
 * 
 * @return	{String}	the main share
 */
ZmOrganizer.prototype.getMainShare =
function() {
	if (!this._mainShare) {
		var curAcct = appCtxt.getActiveAccount();
		var curZid = curAcct && curAcct.id;
		if (curZid && this.shares && this.shares.length) {
			for (var i = 0; i < this.shares.length; i++) {
				var share = this.shares[i];
				var id = share && share.grantee && share.grantee.id;
				if (id && id == curZid) {
					this._mainShare = share;
					break;
				}
			}
		}
	}
	return this._mainShare;
};

/**
 * Checks if the organizer supports sharing.
 * 
 * @return	{Boolean}	<code>true</code> if the organizer supports sharing
 */
ZmOrganizer.prototype.supportsSharing =
function() {
	// overload per organizer type
	return true;
};

/**
 * Checks if the organizer supports pulbic access.
 * 
 * @return	{Boolean}	<code>true</code> if the organizer supports public access
 */
ZmOrganizer.prototype.supportsPublicAccess =
function() {
	// overload per organizer type
	return true;
};

/**
 * Checks if the organizer supports private permission.
 * 
 * @return	{Boolean}	<code>true</code> if the organizer supports private permission
 */
ZmOrganizer.prototype.supportsPrivatePermission =
function() {
	// overload per organizer type
	return false;
};

/**
 * Gets the icon.
 * 
 * @return	{String}	the icon
 */
ZmOrganizer.prototype.getIcon = function() {};

/**
 * Gets the color of the organizer
 *
 * @return	{String}	the color
 */
ZmOrganizer.prototype.getColor =
function() {
    return this.rgb || ZmOrganizer.COLOR_VALUES[this.color];
}


/**
 * Gets the icon with color
 * 
 * @return	{String}	the icon
 */
ZmOrganizer.prototype.getIconWithColor =
function() {
	var icon = this.getIcon() || "";
	var color = this.getColor();
	return color ? [icon,color].join(",color=") : icon;
};

// Actions

/**
 * Renames the organizer.
 * 
 * @param	{String}	name		the name
 * @param	{AjxCallback}	callback		the callback
 * @param	{AjxCallback}	errorCallback		the error callback
 * @param	{ZmBatchCommand}	batchCmd		the batch command
 */
ZmOrganizer.prototype.rename =
function(name, callback, errorCallback, batchCmd) {
	if (name == this.name) { return; }
	var params = {
		action: "rename",
		attrs: {name: name},
		callback: callback,
		errorCallback: errorCallback,
		batchCmd: batchCmd
	};
	this._organizerAction(params);
};

/**
 * Sets the web offline sync interval.
 *
 * @param	{String}	        interval		the web offline sync interval
 * @param	{AjxCallback}	    callback		the callback
 * @param	{AjxCallback}	    errorCallback   the error callback
 * @param   {ZmBatchCommand}    batchCmd        optional batch command
 */
ZmOrganizer.prototype.setOfflineSyncInterval =
function(interval, callback, errorCallback, batchCmd) {
	if (this.webOfflineSyncDays == interval) { return; }

	this._organizerAction({action: "webofflinesyncdays", attrs: {numDays: interval}, callback: callback,
                           errorCallback: errorCallback, batchCmd: batchCmd});
};

/**
 * Sets the color.
 * 
 * @param	{String}	        color		    the color
 * @param	{AjxCallback}	    callback		the callback
 * @param	{AjxCallback}	    errorCallback   the error callback
 * @param   {ZmBatchCommand}    batchCmd        optional batch command
 */
ZmOrganizer.prototype.setColor =
function(color, callback, errorCallback, batchCmd) {
	var color = ZmOrganizer.checkColor(color);
	if (!this.isColorChanged(color)) { return; }

	this._organizerAction({action: "color", attrs: {color: color}, callback: callback,
                           errorCallback: errorCallback, batchCmd: batchCmd});
};

/**
 * Sets the RGB color.
 * 
 * @param	{Object}	        rgb		        the rgb
 * @param	{AjxCallback}	    callback		the callback
 * @param	{AjxCallback}	    errorCallback	the error callback
 * @param   {ZmBatchCommand}    batchCmd        optional batch command
 */
ZmOrganizer.prototype.setRGB = function(rgb, callback, errorCallback, batchCmd) {
	if (!this.isColorChanged(rgb)) { return; }
	this._organizerAction({action: "color", attrs: {rgb: rgb}, callback: callback,
                           errorCallback: errorCallback, batchCmd: batchCmd});
};


ZmOrganizer.prototype.getRetentionPolicy =
function(policyElement) {
    var policy = null;
    if (this.retentionPolicy && this.retentionPolicy[0] && this.retentionPolicy[0][policyElement] &&
        this.retentionPolicy[0][policyElement][0]       && this.retentionPolicy[0][policyElement][0].policy &&
        this.retentionPolicy[0][policyElement][0].policy[0]) {
        policy = this.retentionPolicy[0][policyElement][0].policy[0];
    }
    return policy;
}

ZmOrganizer.prototype.getRetentionPolicyLifetimeMsec =
function(policy) {
    if (policy) {
        // Apply the keep (retention) period
        var lifetime = policy.lifetime;
        var amount = parseInt(lifetime);
        // Intervals taken from DateUtil.java.
        var interval = lifetime.slice(lifetime.length-1);
        var lifetimeMsec = 0;
        switch (interval) {
            case  "d": lifetimeMsec = amount * AjxDateUtil.MSEC_PER_DAY;    break;
            case  "h": lifetimeMsec = amount * AjxDateUtil.MSEC_PER_HOUR;   break;
            case  "m": lifetimeMsec = amount * AjxDateUtil.MSEC_PER_MINUTE; break;
            case  "s": lifetimeMsec = amount * 1000; break;
            case "ms": lifetimeMsec = amount;  break;
            default  : lifetimeMsec = amount * 1000; break;
        }
    }
    return lifetimeMsec;
}

/**
 * Sets the Retention Policy.
 *
 * @param	{Object}	        retentionPolicy     the new retention policy
 * @param	{AjxCallback}	    callback		    the callback
 * @param	{AjxCallback}	    errorCallback	    the error callback
 * @param   {ZmBatchCommand}    batchCmd            optional batch command
 */
ZmOrganizer.prototype.setRetentionPolicy = function(newRetentionPolicy, callback, errorCallback, batchCmd) {
    var keepPolicy  = this.getRetentionPolicy(ZmOrganizer.RETENTION_KEEP);
    var purgePolicy = this.getRetentionPolicy(ZmOrganizer.RETENTION_PURGE);
    if (!this.policiesDiffer(keepPolicy,  newRetentionPolicy.keep) &&
        !this.policiesDiffer(purgePolicy, newRetentionPolicy.purge)) {
        // No updated policy specified or no changes.
        return;
    }

	var cmd = ZmOrganizer.SOAP_CMD[this.type] + "Request";
	var request = {
		_jsns: "urn:zimbraMail",
		action : {
			op: "retentionpolicy",
			id: this.id,
			retentionPolicy: {
				keep: {},
				purge: {}
			}
		}
	};
	var jsonObj = {};
	jsonObj[cmd] = request;

	var retentionNode = request.action.retentionPolicy;

    if (newRetentionPolicy.keep) {
        this._addPolicy(retentionNode.keep, newRetentionPolicy.keep);
    }
    if (newRetentionPolicy.purge) {
        this._addPolicy(retentionNode.purge, newRetentionPolicy.purge);
    }

	if (batchCmd) {
        batchCmd.addRequestParams(jsonObj, callback, errorCallback);
 	}
	else {
		var accountName;
		if (appCtxt.multiAccounts) {
			accountName = (this.account)
				? this.account.name : appCtxt.accountList.mainAccount.name;
		}
		appCtxt.getAppController().sendRequest({
			jsonObj:       jsonObj,
			asyncMode:     true,
			accountName:   accountName,
			callback:      callback,
			errorCallback: errorCallback
		});
	}

};

ZmOrganizer.prototype.policiesDiffer =
function(policyA, policyB) {
    var differ = false;
    if ((policyA && !policyB) || (!policyA && policyB)) {
        differ = true;
    } else if (policyA) {
        // Old and new specified
        if (policyA.type != policyB.type) {
            differ = true;
        } else {
            if (policyA.type == "user") {
                differ = policyA.lifetime != policyB.lifetime;
            } else {
                // System policy
                differ = policyA.id != policyB.id;
            }
        }
    }
    return differ;
}

ZmOrganizer.prototype._addPolicy =
function(node, policy) {
	var policyNode = node.policy = {};
	for (var attr in policy) {
		if (AjxEnv.isIE) {
			policy[attr] += ""; //To string
		}

		policyNode[attr] = policy[attr];
	}
};

/**
 * Returns color number b/w 0-9 for a given color code
 *
 * @param	{String}	color	The color (usually in #43eded format
 * @return {int} Returns 0-9 for a standard color and returns -1 for custom color
 */
ZmOrganizer.getStandardColorNumber =
function(color) {
	if (String(color).match(/^#/)) {
		var len = ZmOrganizer.COLOR_VALUES.length;
		for(var i =0; i < len; i++) {
			var currentVal = ZmOrganizer.COLOR_VALUES[i];
			if(currentVal && currentVal == color) {
				return i;
			}
		}
	} else if(color <= 9 && color >= 0) {
		return color;
	}
	return -1;
};

/**
 * Returns true if the color is changed
 *
 * @param	{String/int}	color	The color (usually in #rgb format or numeric color code
 * @return {Boolean} Returns true if the color is changed
 */
ZmOrganizer.prototype.isColorChanged =
function(color) {
    var isNewColorCustom = ZmOrganizer.getStandardColorNumber(color) === -1,
        isPrevColorCustom = this.isColorCustom;
    if ((isNewColorCustom && !isPrevColorCustom) ||
        (!isNewColorCustom && isPrevColorCustom) ) {
        //Custom changed to standard or standard changed to custom
        return true;
    }
    else if (isNewColorCustom && isPrevColorCustom) {
        //If both are custom colors check the rgb codes
        return color != this.rgb;
    }
    else if (!isNewColorCustom && !isPrevColorCustom){
        //If both are standard check the numeric color codes
        return color != this.color;
    }
    //default fallback
    return false;
};

/**
 * Updates the folder. Although it is possible to use this method to change just about any folder
 * attribute, it should only be used to set multiple attributes at once since it
 * has extra overhead on the server.
 *
 * @param {Hash}	attrs		the attributes
 */
ZmOrganizer.prototype.update =
function(attrs) {
	this._organizerAction({action: "update", attrs: attrs});
};

/**
 * Assigns the organizer a new parent, moving it within its tree.
 *
 * @param {ZmOrganizer}	newParent		the new parent of this organizer
 * @param {boolean}		noUndo			if true, action is not undoable
 */
ZmOrganizer.prototype.move =
function(newParent, noUndo, batchCmd) {

	var newId = (newParent.nId > 0)
		? newParent.id
		: ZmOrganizer.getSystemId(ZmOrganizer.ID_ROOT);

	if ((newId == this.id || newId == this.parent.id) ||
		(this.type == ZmOrganizer.FOLDER && (ZmOrganizer.normalizeId(newId, this.type) == ZmFolder.ID_SPAM)) ||
		(newParent.isChildOf(this)))
	{
		return;
	}
	var params = {};
	params.batchCmd = batchCmd;
	params.actionTextKey = 'actionMoveOrganizer';
	params.orgName = this.getName(false, false, true, false, false, this.type);
	if (newId == ZmOrganizer.ID_TRASH) {
		params.actionArg = ZmMsg.trash;
		params.action = "trash";
		params.noUndo = noUndo;
	}
	else {
		if (newParent.account && newParent.account.isLocal()) {
			newId = [ZmAccount.LOCAL_ACCOUNT_ID, newId].join(":");
		}
		params.actionArg = newParent.getName(false, false, true, false, false, this.type);
		params.action = "move";
		params.attrs = {l: newId};
		params.noUndo = noUndo;
	}
	this._organizerAction(params);
};

/**
 * Deletes an organizer. If it's a folder, the server deletes any contents and/or
 * subfolders. If the organizer is "Trash" or "Spam", the server deletes and re-creates the
 * folder. In that case, we do not bother to remove it from the UI (and we ignore
 * creates on system folders).
 *
 */
ZmOrganizer.prototype._delete =
function(batchCmd) {
	DBG.println(AjxDebug.DBG1, "deleting: " + AjxStringUtil.htmlEncode(this.name) + ", ID: " + this.id);
	var isEmptyOp = ((this.type == ZmOrganizer.FOLDER || this.type == ZmOrganizer.ADDRBOOK || this.type == ZmOrganizer.BRIEFCASE) &&
					 (this.nId == ZmFolder.ID_SPAM || this.nId == ZmFolder.ID_TRASH));
	// make sure we're not deleting a system object (unless we're emptying SPAM or TRASH)
	if (this.isSystem() && !isEmptyOp) return;

	var action = isEmptyOp ? "empty" : "delete";
	this._organizerAction({action: action, batchCmd: batchCmd});
};

/**
 * Empties the organizer.
 *
 * @param	{Boolean}	doRecursive		<code>true</code> to recursively empty the organizer
 * @param	{ZmBatchCommand}	batchCmd	the batch command
 * @param	{Object}	callback
 * @param	{number}	timeout		the timeout(in seconds)
 * @param	{AjxCallback}	errorCallback		the callback to run after timeout
 * @param	{Boolean}	noBusyOverlay		if <code>true</code>, do not show busy overlay
 */
ZmOrganizer.prototype.empty =
function(doRecursive, batchCmd, callback, timeout, errorCallback, noBusyOverlay) {
	doRecursive = doRecursive || false;

	var isEmptyOp = ((this.type == ZmOrganizer.FOLDER || this.type == ZmOrganizer.ADDRBOOK) &&
					 (this.nId == ZmFolder.ID_SPAM ||
					  this.nId == ZmFolder.ID_TRASH ||
					  this.nId == ZmFolder.ID_CHATS ||
					  this.nId == ZmOrganizer.ID_SYNC_FAILURES));

	// make sure we're not emptying a system object (unless it's SPAM/TRASH/SYNCFAILURES)
	if (this.isSystem() && !isEmptyOp) { return; }

	var params = {
		action: "empty",
		batchCmd: batchCmd,
		callback: callback,
		timeout: timeout,
		errorCallback: errorCallback,
		noBusyOverlay: noBusyOverlay
	};
	params.attrs = (this.nId == ZmFolder.ID_TRASH)
		? {recursive:true}
		: {recursive:doRecursive};

	if (this.isRemote()) {
		params.id = this.getRemoteId();
	}

	this._organizerAction(params);
};

/**
 * Marks all items as "read".
 *
 * @param	{ZmBatchCommand}	batchCmd	the batch command
 */
ZmOrganizer.prototype.markAllRead =
function(batchCmd) {
	var id = this.isRemote() ? this.getRemoteId() : null;
	this._organizerAction({action: "read", id: id, attrs: {l: this.id}, batchCmd:batchCmd});
};

/**
 * Synchronizes the organizer.
 *
 */
ZmOrganizer.prototype.sync =
function() {
	this._organizerAction({action: "sync"});
};

// Notification handling

/**
 * Handles delete notification.
 *
 */
ZmOrganizer.prototype.notifyDelete =
function() {
	// select next reasonable organizer if the currently selected organizer is
	// the one being deleted or is a descendent of the one being deleted
	var tc = appCtxt.getOverviewController().getTreeController(this.type);
	var treeView = tc && tc.getTreeView(appCtxt.getCurrentApp().getOverviewId());

	// treeview returns array of organizers for checkbox style trees
	var organizers = treeView && treeView.getSelected();
	if (organizers) {
		if (!(organizers instanceof Array)) organizers = [organizers];
		for (var i = 0; i <  organizers.length; i++) {
			var organizer = organizers[i];
			if (organizer && (organizer == this || organizer.isChildOf(this))) {
				var folderId = this.parent.id;
				if (this.parent.nId == ZmOrganizer.ID_ROOT) {
					folderId = ZmOrganizer.getSystemId(this.getDefaultFolderId());
				}
				var skipNotify = false;
				treeView.setSelected(folderId, skipNotify);
			}
		}
	}

	// perform actual delete
	this.deleteLocal();
	this._notify(ZmEvent.E_DELETE);
};

/**
 * Handles create notification.
 */
ZmOrganizer.prototype.notifyCreate = function() {};

/**
* Handles modifications to fields that organizers have in general. Note that
* the notification object may contain multiple notifications.
*
* @param {Object}	obj		a "modified" notification
* @param {Hash}	details	the event details
*/
ZmOrganizer.prototype.notifyModify =
function(obj, details) {
	var doNotify = false;
	var details = details || {};
	var fields = {};
	if (obj.name != null && (this.name != obj.name || this.id != obj.id)) {
		if (obj.id == this.id) {
			details.oldName = this.name;
			this.name = obj.name;
			fields[ZmOrganizer.F_NAME] = true;
			this.parent.children.sort(eval(ZmTreeView.COMPARE_FUNC[this.type]));
		} else {
			// rename of a remote folder
			details.newName = obj.name;
			fields[ZmOrganizer.F_RNAME] = true;
		}
		doNotify = true;
	}
	if (obj.u != null && this.numUnread != obj.u) {
		this.numUnread = obj.u;
		fields[ZmOrganizer.F_UNREAD] = true;
		doNotify = true;
	}
	if (obj.n != null && this.numTotal != obj.n) {
		this.numTotal = obj.n;
		fields[ZmOrganizer.F_TOTAL] = true;
		doNotify = true;
	}
	if (obj.s != null && this.sizeTotal != obj.s) {
		this.sizeTotal = obj.s;
		fields[ZmOrganizer.F_SIZE] = true;
		doNotify = true;
	}
	if ((obj.rgb != null || obj.color != null) && !obj._isRemote) {
        var color = obj.color || obj.rgb;
		if (this.isColorChanged(color)) {
			this.isColorCustom = obj.rgb != null;
			this.color = obj.color;
            this.rgb = obj.rgb || ZmOrganizer.COLOR_VALUES[color];
			fields[ZmOrganizer.F_COLOR] = true;
            fields[ZmOrganizer.F_RGB] = true;
		}
		doNotify = true;
	}
	if (obj.f != null && !obj._isRemote) {
		var oflags = this._setFlags().split("").sort().join("");
		var nflags = obj.f.split("").sort().join("");
		if (oflags != nflags) {
			this._parseFlags(obj.f);
			fields[ZmOrganizer.F_FLAGS] = true;
			doNotify = true;
		}
	}
	if (obj.rest != null && this.restUrl != obj.rest && !obj._isRemote) {
		this.restUrl = obj.rest;
		fields[ZmOrganizer.F_REST_URL] = true;
		doNotify = true;
	}
	// if shares changed, do wholesale replace
	if (obj.acl) {
		this.clearShares();
		if (obj.acl.grant && obj.acl.grant.length) {
			AjxDispatcher.require("Share");
			for (var i = 0; i < obj.acl.grant.length; i++) {
				share = ZmShare.createFromJs(this, obj.acl.grant[i]);
				this.addShare(share);
			}
		}
		fields[ZmOrganizer.F_SHARES] = true;
		doNotify = true;
	}
	if (obj.perm && obj._isRemote) {
		fields[ZmOrganizer.F_PERMS] = true;
		doNotify = true;

		// clear acl-related flags so they are recalculated
		this._isAdmin = this._isReadOnly = this._hasPrivateAccess = null;
	}
    if (obj.retentionPolicy) {
        // Only displayed in a modal dialog - no need to doNotify
        if (obj.retentionPolicy[0].keep || obj.retentionPolicy[0].purge) {
            this.retentionPolicy = obj.retentionPolicy;
        } else {
            this.retentionPolicy = null;
        }
    }
	if (obj.hasOwnProperty("webOfflineSyncDays")) {
		this.webOfflineSyncDays = obj.webOfflineSyncDays;
	}

	// Send out composite MODIFY change event
	if (doNotify) {
		details.fields = fields;
		this._notify(ZmEvent.E_MODIFY, details);
	}

	if (this.parent && obj.l != null && obj.l != this.parent.id) {
		var newParent = this._getNewParent(obj.l);
		if (newParent) {
			this.reparent(newParent);
			this._notify(ZmEvent.E_MOVE);
			// could be moving search between Folders and Searches - make sure
			// it has the correct tree
			this.tree = newParent.tree;
		}
	}
};

// Local change handling

/**
 * Deletes the organizer (local). Cleans up a deleted organizer:
 *
 * <ul>
 * <li>remove from parent's list of children</li>
 * <li>remove from item cache</li>
 * <li>perform above two steps for each child</li>
 * <li>clear list of children</li>
 * </ul>
 *
 */
ZmOrganizer.prototype.deleteLocal =
function() {
	this.parent.children.remove(this);
	var a = this.children.getArray();
	var sz = this.children.size();
	for (var i = 0; i < sz; i++) {
		var org = a[i];
		if (org) { org.deleteLocal(); }
	}
	this.children.removeAll();
};

/**
 * Checks if the organizer has a child with the given name.
 *
 * @param {String}	name		the name of the organizer to look for
 * @return	{Boolean}	<code>true</code> if the organizer has a child
 */
ZmOrganizer.prototype.hasChild =
function(name) {
	return (this.getChild(name) != null);
};

/**
* Gets the child with the given name
*
* @param {String}	name		the name of the organizer to look for
* @return	{String}	the name of the child or <code>null</code> if no child has the name
*/
ZmOrganizer.prototype.getChild =
function(name) {
	name = name ? name.toLowerCase() : "";
	var a = this.children.getArray();
	var sz = this.children.size();
	for (var i = 0; i < sz; i++) {
		if (a[i] && a[i].name && (a[i].name.toLowerCase() == name)) {
			return a[i];
		}
	}

	return null;
};

/**
* Gets the child with the given path
*
* @param {String}	path		the path of the organizer to look for
* @return	{String}	the child or <code>null</code> if no child has the path
*/
ZmOrganizer.prototype.getChildByPath =
function(path) {
	// get starting organizer
	var organizer = this;
	if (path.match(/^\//)) {
		while (organizer.nId != ZmOrganizer.ID_ROOT) {
			organizer = organizer.parent;
		}
		path = path.substr(1);
	}

	// if no path, return current organizer
	if (path.length == 0) return organizer;

	// walk descendent axis to find organizer specified by path
	var parts = path.split('/');
	var i = 0;
	while (i < parts.length) {
		var part = parts[i++];
		var child = organizer.getChild(part);
		if (child == null) {
			return null;
		}
		organizer = child;
	}
	return organizer;
};

/**
 * Changes the parent of this organizer. Note that the new parent passed
 * in may be <code>null</code>, which makes this organizer an orphan.
 *
 * @param {ZmOrganizer}	newParent		the new parent
 */
ZmOrganizer.prototype.reparent =
function(newParent) {
	if (this.parent) {
		this.parent.children.remove(this);
	}
	if (newParent) {
		newParent.children.add(this);
	}
	this.parent = newParent;
};

/**
 * Gets the organizer with the given ID, searching recursively through
 * child organizers. The preferred method for getting an organizer by ID
 * is to use <code>appCtxt.getById()</code>.
 *
 * @param {String}	id		the ID to search for
 * @return	{ZmOrganizer}	the organizer or <code>null</code> if not found
 */
ZmOrganizer.prototype.getById =
function(id) {
	if (this.link && id && typeof(id) == "string") {
		var ids = id.split(":");
		if (this.zid == ids[0] && this.rid == ids[1])
			return this;
	}

	if (this.id == id || this.nId == id) {
		return this;
	}

	var organizer;
	var a = this.children.getArray();
	var sz = this.children.size();
	for (var i = 0; i < sz; i++) {
		if (organizer = a[i].getById(id)) {
			return organizer;
		}
	}
	return null;
};

/**
 * Gets the first organizer found with the given name, starting from the root.
 *
 * @param {String}	name		the name to search for
 * @return	{ZmOrganizer}	the organizer
 */
ZmOrganizer.prototype.getByName =
function(name, skipImap) {
	return this._getByName(name.toLowerCase(), skipImap);
};

/**
 * Gets a list of organizers with the given type.
 *
 * @param {constant}	type			the desired organizer type
 * @return	{Array}	an array of {ZmOrganizer} objects
 */
ZmOrganizer.prototype.getByType =
function(type) {
	var list = [];
	this._getByType(type, list);
	return list;
};

/**
 * @private
 */
ZmOrganizer.prototype._getByType =
function(type, list) {
	if (this.type == type) {
		list.push(this);
	}
	var a = this.children.getArray();
	for (var i = 0; i < a.length; i++) {
		if (a[i]) {
			a[i]._getByType(type, list);
		}
	}
};

/**
 * Gets the organizer with the given path.
 *
 * @param {String}	path			the path to search for
 * @param {Boolean}	useSystemName	if <code>true</code>, use untranslated version of system folder names
 * @return	{ZmOrganizer}	the organizer
 */
ZmOrganizer.prototype.getByPath =
function(path, useSystemName) {
	return this._getByPath(path.toLowerCase(), useSystemName);
};

/**
 * Test the path of this folder and then descendants against the given path, case insensitively.
 *
 * @private
 */
ZmOrganizer.prototype._getByPath =
function(path, useSystemName) {
	if (this.nId == ZmFolder.ID_TAGS) { return null; }

	if (path == this.getPath(false, false, null, true, useSystemName).toLowerCase()) {
		return this;
	}

	var a = this.children.getArray();
	for (var i = 0; i < a.length; i++) {
		var organizer = a[i]._getByPath(path, useSystemName);
		if (organizer) {
			return organizer;
		}
	}
	return null;
};

/**
 * Gets the number of children of this organizer.
 *
 * @return	{int}	the size
 */
ZmOrganizer.prototype.size =
function() {
	return this.children.size();
};

/**
 * Checks if the given organizer is a descendant of this one.
 *
 * @param {ZmOrganizer}	organizer		a possible descendant of ours
 * @return	{Boolean}	<code>if the given organizer is a descendant; <code>false</code> otherwise
 */
ZmOrganizer.prototype.isChildOf =
function (organizer) {
	var parent = this.parent;
	while (parent) {
		if (parent == organizer) {
			return true;
		}
		parent = parent.parent;
	}
	return false;
};

/**
 * Gets the organizer with the given ID (looks in this organizer tree).
 *
 * @param {int}	parentId	the ID of the organizer to find
 * @return	{ZmOrganizer}	the organizer
 *
 * @private
 */
ZmOrganizer.prototype._getNewParent =
function(parentId) {
	return appCtxt.getById(parentId);
};

/**
 * Checks if the organizer with the given ID is under this organizer.
 *
 * @param	{String}	id		the ID
 * @return	{Boolean}	<code>true</code> if the organizer is under this organizer
 */
ZmOrganizer.prototype.isUnder =
function(id) {
	id = id.toString();
	if (this.nId == id || (this.isRemote() && this.rid == id)) { return true; }

	var parent = this.parent;
	while (parent && parent.nId != ZmOrganizer.ID_ROOT) {
		if (parent.nId == id) {
			return true;
		}
		parent = parent.parent;
	}
	return false;
};

/**
 * Checks if this organizer is in "Trash".
 *
 * @return	{Boolean}	<code>true</code> if in "Trash"
 */
ZmOrganizer.prototype.isInTrash =
function() {
	return this.isUnder(ZmOrganizer.ID_TRASH);
};

/**
 * Checks if permissions are allowed.
 *
 * @return	{Boolean}	<code>true</code> if permissions are allowed
 */
ZmOrganizer.prototype.isPermAllowed =
function(perm) {
	if (this.perm) {
		var positivePerms = this.perm.replace(/-./g, "");
		return (positivePerms.indexOf(perm) != -1);
	}
	return false;
};

/**
 * Checks if the organizer is read-only.
 *
 * @return	{Boolean}	<code>true</code> if read-only
 */
ZmOrganizer.prototype.isReadOnly =
function() {
	if (this._isReadOnly == null) {
		var share = this.getMainShare();
		this._isReadOnly = (share != null)
			? (this.isRemote() && !share.isWrite())
			: (this.isRemote() && this.isPermAllowed(ZmOrganizer.PERM_READ) && !this.isPermAllowed(ZmOrganizer.PERM_WRITE));
	}
	return this._isReadOnly;
};

/**
 * Checks if admin.
 *
 * @return	{Boolean}	<code>true</code> if this organizer is admin
 */
ZmOrganizer.prototype.isAdmin =
function() {
	if (this._isAdmin == null) {
		var share = this.getMainShare();
		this._isAdmin = (share != null)
			? (this.isRemote() && share.isAdmin())
			: (this.isRemote() && this.isPermAllowed(ZmOrganizer.PERM_ADMIN));
	}
	return this._isAdmin;
};

/**
 * Checks if the organizer has private access.
 *
 * @return	{Boolean}	<code>true</code> if has private access
 */
ZmOrganizer.prototype.hasPrivateAccess =
function() {
	if (this._hasPrivateAccess == null) {
		var share = this.getMainShare();
		this._hasPrivateAccess = (share != null)
			? (this.isRemote() && share.hasPrivateAccess())
			: (this.isRemote() && this.isPermAllowed(ZmOrganizer.PERM_PRIVATE));
	}
	return this._hasPrivateAccess;
};

/**
 * Checks if the organizer is "remote". That applies to mountpoints (links),
 * the folders they represent, and any subfolders we know about.
 *
 * @return	{Boolean}	<code>true</code> if the organizer is "remote"
 */
ZmOrganizer.prototype.isRemote =
function() {
	if (this._isRemote == null) {
		if (this.zid != null) {
			this._isRemote = true;
		} else {
			if (appCtxt.multiAccounts) {
				var account = this.account;
				var parsed = ZmOrganizer.parseId(this.id);

				if (!account) {
					if (parsed.account && parsed.account.isMain) {
						this._isRemote = false;
						return this._isRemote;
					} else {
						account = appCtxt.getActiveAccount();
					}
				}
				this._isRemote = Boolean(!parsed.account || (parsed.account && (parsed.account != account)));
			} else {
				var id = String(this.id);
				this._isRemote = ((id.indexOf(":") != -1) && (id.indexOf(appCtxt.getActiveAccount().id) != 0));
			}
		}
	}
	return this._isRemote;
};

ZmOrganizer.prototype.isRemoteRoot = function() {
	return this.isRemote() && (this.rid == ZmOrganizer.ID_ROOT);
}

/**
 * Checks if the organizer is a system tag or folder.
 *
 * @return	{Boolean}	<code>true</code> if system tag or folder
 */
ZmOrganizer.prototype.isSystem =
function () {
	return (this.nId < ZmOrganizer.FIRST_USER_ID[this.type]);
};

ZmOrganizer.prototype.isDefault =
function () {
	return this.nId == this.getDefaultFolderId();
};

ZmOrganizer.prototype.getDefaultFolderId =
function() {
	return ZmOrganizer.DEFAULT_FOLDER[this.type];
};

ZmOrganizer.prototype.isTrash =
function () {
	return this.nId == ZmFolder.ID_TRASH;
};


/**
 * Checks if the organizer gets its contents from an external feed.
 *
 * @return	{Boolean}	<code>true</code>  if from external feed
 */
ZmOrganizer.prototype.isFeed =
function () {
	return Boolean(this.url);
};

/** Returns true if organizer has feeds. */
ZmOrganizer.prototype.hasFeeds = function() { return false; };

/**
 * Checks if this folder maps to a datasource. If type is given, returns
 * true if folder maps to a datasource *and* is of the given type.
 *
 * @param	{constant}	type			the type (see {@link ZmAccount.TYPE_POP} or {@link ZmAccount.TYPE_IMAP})
 * @param	{Boolean}	checkParent		if <code>true</code>, walk-up the parent chain
 * @return	{Boolean}	<code>true</code> if this folder maps to a datasource
 */
ZmOrganizer.prototype.isDataSource =
function(type, checkParent) {
	var dss = this.getDataSources(type, checkParent);
	return (dss && dss.length > 0);
};

/**
 * Gets the data sources this folder maps to. If type is given,
 * returns non-null result only if folder maps to datasource(s) *and* is of the
 * given type.
 *
 * @param	{constant}	type			the type (see {@link ZmAccount.TYPE_POP} or {@link ZmAccount.TYPE_IMAP})
 * @param	{Boolean}	checkParent		if <code>true</code>, walk-up the parent chain
 * @return	{Array}	the data sources this folder maps to or <code>null</code> for none
 */
ZmOrganizer.prototype.getDataSources =
function(type, checkParent) {
	if (!appCtxt.get(ZmSetting.MAIL_ENABLED)) { return null; }

	var dsc = appCtxt.getDataSourceCollection();
	var dataSources = dsc.getByFolderId(this.nId, type);

	if (dataSources.length == 0) {
		return (checkParent && this.parent)
			? this.parent.getDataSources(type, checkParent)
			: null;
	}

	return dataSources;
};

/**
 * Gets the owner.
 *
 * @return	{String}	the owner
 */
ZmOrganizer.prototype.getOwner =
function() {
	return this.owner || (this.parent && this.parent.getOwner()) || appCtxt.get(ZmSetting.USERNAME);
};

/**
 * Gets the sort index.
 *
 * @return	{int}	the sort index
 */
ZmOrganizer.getSortIndex =
function(child, sortFunction) {
	if (!(child && child.parent && sortFunction)) { return null; }
	var children = child.parent.children.getArray();
	for (var i = 0; i < children.length; i++) {
		var test = sortFunction(child, children[i]);
		if (test == -1) {
			return i;
		}
	}
	return i;
};

/**
 * Sends a request to the server. Note that it's done asynchronously, but
 * there is no callback given. Hence, an organizer action is the last thing
 * done before returning to the event loop. The result of the action is
 * handled via notifications.
 *
 * @param {String}	action		the operation to perform
 * @param {Hash}	attrs		a hash of additional attributes to set in the request
 * @param {ZmBatchCommand}	batchCmd	the batch command that contains this request
 *
 * @private
 */
ZmOrganizer.prototype._organizerAction =
function(params) {

	var cmd = ZmOrganizer.SOAP_CMD[this.type] + "Request";
	var request = {
		_jsns: "urn:zimbraMail",
		action : {
			op: params.action,
			id: params.id || this.id
		}
	};
	var jsonObj = {};
	jsonObj[cmd] = request;

	for (var attr in params.attrs) {
		if (AjxEnv.isIE) {
			params.attrs[attr] += ""; //To string
		}
		request.action[attr] = params.attrs[attr];
	}
	var actionController = appCtxt.getActionController();
	actionController.dismiss();
	var actionLogItem = (!params.noUndo && actionController && actionController.actionPerformed({op: params.action, id: params.id || this.id, attrs: params.attrs})) || null;
	var respCallback = new AjxCallback(this, this._handleResponseOrganizerAction, [params, actionLogItem]);
	if (params.batchCmd) {
        params.batchCmd.addRequestParams(jsonObj, respCallback, params.errorCallback);
 	}
	else {
		var accountName;
		if (appCtxt.multiAccounts) {
			accountName = (this.account)
				? this.account.name : appCtxt.accountList.mainAccount.name;
		}
		appCtxt.getAppController().sendRequest({
			jsonObj: jsonObj,
			asyncMode: true,
			accountName: accountName,
			callback: respCallback,
			errorCallback: params.errorCallback,
			timeout: params.timeout,
			noBusyOverlay: params.noBusyOverlay
		});
	}
};

/**
 * @private
 */
ZmOrganizer.prototype._handleResponseOrganizerAction =
function(params, actionLogItem, result) {

	if (actionLogItem) {
		actionLogItem.setComplete();
	}
	if (params.callback) {
		params.callback.run(result);
	}
	if (params.actionTextKey) {
		var actionController = appCtxt.getActionController();
		var summary = ZmOrganizer.getActionSummary({
			actionTextKey:  params.actionTextKey,
			numItems:       params.numItems || 1,
			type:           this.type,
			orgName:        params.orgName,
			actionArg:      params.actionArg
		});
		var undoLink = actionLogItem && actionController && actionController.getUndoLink(actionLogItem);
		if (undoLink && actionController) {
			actionController.onPopup();
			appCtxt.setStatusMsg({msg: summary+undoLink, transitions: actionController.getStatusTransitions()});
		} else {
			appCtxt.setStatusMsg(summary);
		}
	}
};

/**
 * Returns a string describing an action, intended for display as toast to tell the
 * user what they just did.
 *
 * @param   {Object}        params          hash of params:
 *          {String}        type            organizer type (ZmOrganizer.*)
 *          {String}        actionTextKey   ZmMsg key for text string describing action
 *          {String}        orgName         name of the organizer that was affected
 *          {String}        actionArg       (optional) additional argument
 *
 * @return {String}     action summary
 */
ZmOrganizer.getActionSummary =
function(params) {

	var type = params.type,
		typeKey = ZmOrganizer.FOLDER_KEY[type],
		typeText = ZmMsg[typeKey],
		capKey = AjxStringUtil.capitalize(typeKey),
		alternateKey = params.actionTextKey + capKey,
		text = ZmMsg[alternateKey] || ZmMsg[params.actionTextKey],
		orgName = AjxStringUtil.htmlEncode(params.orgName),
		arg = AjxStringUtil.htmlEncode(params.actionArg);

	return AjxMessageFormat.format(text, [ typeText, orgName, arg ]);
};

/**
 * Test the name of this organizer and then descendants against the given name, case insensitively.
 * 
 * @private
 */
ZmOrganizer.prototype._getByName =
function(name, skipImap) {
	if (this.name && name == this.name.toLowerCase()) {
		return this;
	}

	var organizer;
	var a = this.children.getArray();
	var sz = this.children.size();
	for (var i = 0; i < sz; i++) {
		if (organizer = a[i]._getByName(name, skipImap)) {
			if (skipImap && organizer.isDataSource(ZmAccount.TYPE_IMAP, true)) {
				continue;
			}
			return organizer;
		}
	}
	return null;
};

/**
 * Takes a string of flag chars and applies them to this organizer.
 * 
 * @private
 */
ZmOrganizer.prototype._parseFlags =
function(str) {
	for (var i = 0; i < ZmOrganizer.ALL_FLAGS.length; i++) {
		var flag = ZmOrganizer.ALL_FLAGS[i];
		this[ZmOrganizer.FLAG_PROP[flag]] = (Boolean(str && (str.indexOf(flag) != -1)));
	}
};

/**
 * Converts this organizer's flag-related props into a string of flag chars.
 * 
 * @private
 */
ZmOrganizer.prototype._setFlags =
function() {
	var flags = "";
	for (var i = 0; i < ZmOrganizer.ALL_FLAGS.length; i++) {
		var flag = ZmOrganizer.ALL_FLAGS[i];
		var prop = ZmOrganizer.FLAG_PROP[flag];
		if (this[prop]) {
			flags = flags + flag;
		}
	}
	return flags;
};

/**
 * Adds a change listener.
 * 
 * @param	{AjxListener}	the listener
 */
ZmOrganizer.prototype.addChangeListener =
function(listener) {
	this.tree.addChangeListener(listener);
};

/**
 * Removes a change listener.
 * 
 * @param	{AjxListener}	the listener
 */
ZmOrganizer.prototype.removeChangeListener =
function(listener) {
	this.tree.removeChangeListener(listener);
};

/**
 * @private
 */
ZmOrganizer.prototype._setSharesFromJs =
function(obj) {

	// a folder object will have an acl with grants if this user has
	// shared it, or if it has been shared to this user with admin rights
	if (obj.acl && obj.acl.grant && obj.acl.grant.length > 0) {
		AjxDispatcher.require("Share");
		for (var i = 0; i < obj.acl.grant.length; i++) {
			var grant = obj.acl.grant[i];
			this.addShare(ZmShare.createFromJs(this, grant));
		}
	}
};

/**
 * Handle notifications through the tree.
 * 
 * @private
 */
ZmOrganizer.prototype._notify =
function(event, details) {

	if (details) {
		details.organizers = [this];
	} else {
		details = {organizers: [this]};
	}
	this.tree._evt.type = this.type;	// all folder types are in a single tree
	this.tree._notify(event, details);
};

/**
 * Gets a marked-up version of the name.
 *
 * @param {String}	name			the name to mark up
 * @param {Boolean}	showUnread		if <code>true</code>, display the number of unread items (in parens)
 * @param {Boolean}	noMarkup		if <code>true</code>, do not return any HTML
 * 
 * @private
 */
ZmOrganizer.prototype._markupName = 
function(name, showUnread, noMarkup) {
	if (!noMarkup) {
		name = AjxStringUtil.htmlEncode(name, true);
	}
	if (showUnread && this.hasUnreadDescendent()) {
		if (this.numUnread > 0) {
            name = AjxMessageFormat.format(ZmMsg.folderUnread, [name, this.numUnread]);
		}
		if (!noMarkup) {
			name = ["<span style='font-weight:bold'>", name, "</span>"].join("");
		}
	}
	if (this.noSuchFolder && !noMarkup) {
		name = ["<del>", name, "</del>"].join("");
	}
	return name;
};

/**
 * @private
 */
ZmOrganizer.prototype._getItemsText =
function() {
	var result = ZmMsg[ZmOrganizer.ITEMS_KEY[this.type]];
	if (!result || this.isTrash()) {
		result = ZmMsg.items;
	}
	return result;
};

ZmOrganizer.prototype._getUnreadLabel = 
function() {
	return ZmMsg.unread;	
};

/**
 * Returns true if any descendent folders have unread messages.
 *
 * @returns {boolean}   true if any descendent folders have unread messages
 */
ZmOrganizer.prototype.hasUnreadDescendent = function() {

	if (this.numUnread > 0) {
		return true;
	}

	var a = this.children.getArray(),
		sz = this.children.size();

	for (var i = 0; i < sz; i++) {
		if (a[i].hasUnreadDescendent()) {
			return true;
		}
	}

	return false;
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmFolder")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines a folder.
 *
 */

/**
 * Creates a folder.
 * @class
 * This class represents a folder, which may contain mail. At some point, folders may be
 * able to contain contacts and/or appointments.
 *
 * @author Conrad Damon
 *
 * @param	{Hash}	params		a hash of parameters
 * @param {int}	params.id		the numeric ID
 * @param {String}	params.name		the name
 * @param {ZmOrganizer}	params.parent	the parent folder
 * @param {ZmTree}	params.tree		the tree model that contains this folder
 * @param {int}	params.numUnread	the number of unread items for this folder
 * @param {int}	params.numTotal		the number of items for this folder
 * @param {int}	params.sizeTotal	the total size of folder's items
 * @param {String}	params.url		the URL for this folder's feed
 * @param {String}	params.owner	the Owner for this organizer
 * @param {String}	params.oname	the Owner's name for this organizer, if remote folder
 * @param {String}	params.zid		the Zimbra ID of owner, if remote folder
 * @param {String}	params.rid		the Remote ID of organizer, if remote folder
 * @param {String}	params.restUrl	the REST URL of this organizer
 * 
 * @extends		ZmOrganizer
 */
ZmFolder = function(params) {
	if (arguments.length == 0) { return; }
	params.type = params.type || ZmOrganizer.FOLDER;
	ZmOrganizer.call(this, params);
};

ZmFolder.prototype = new ZmOrganizer;
ZmFolder.prototype.constructor = ZmFolder;

ZmFolder.prototype.isZmFolder = true;
ZmFolder.prototype.toString = function() { return "ZmFolder"; };


// needed to construct USER_ROOT if mail disabled
ZmOrganizer.ORG_CLASS[ZmId.ORG_FOLDER] = "ZmFolder";

ZmFolder.SEP 									= "/";							// path separator

// system folders (see Mailbox.java in ZimbraServer for positive int consts)
// Note: since these are defined as Numbers, and IDs come into our system as Strings,
// we need to use == for comparisons (instead of ===, which will fail)
ZmFolder.ID_LOAD_FOLDERS						= -3;							// special "Load remaining folders" placeholder
ZmFolder.ID_OTHER								= -2;							// used for tcon value (see below)
ZmFolder.ID_SEP									= -1;							// separator
ZmFolder.ID_ROOT								= ZmOrganizer.ID_ROOT;
ZmFolder.ID_INBOX								= ZmOrganizer.ID_INBOX;
ZmFolder.ID_TRASH								= ZmOrganizer.ID_TRASH;
ZmFolder.ID_SPAM								= ZmOrganizer.ID_SPAM;
ZmFolder.ID_SENT								= 5;
ZmFolder.ID_DRAFTS								= 6;
ZmFolder.ID_CONTACTS							= ZmOrganizer.ID_ADDRBOOK;
ZmFolder.ID_AUTO_ADDED							= ZmOrganizer.ID_AUTO_ADDED;
ZmFolder.ID_TAGS	 							= 8;
ZmFolder.ID_TASKS								= ZmOrganizer.ID_TASKS;
ZmFolder.ID_SYNC_FAILURES						= ZmOrganizer.ID_SYNC_FAILURES;
ZmFolder.ID_OUTBOX	 							= ZmOrganizer.ID_OUTBOX;
ZmFolder.ID_CHATS	 							= ZmOrganizer.ID_CHATS;
ZmFolder.ID_ATTACHMENTS                         = ZmOrganizer.ID_ATTACHMENTS;
ZmFolder.ID_DLS									= ZmOrganizer.ID_DLS;

// system folder names
ZmFolder.MSG_KEY = {};
ZmFolder.MSG_KEY[ZmFolder.ID_INBOX]				= "inbox";
ZmFolder.MSG_KEY[ZmFolder.ID_TRASH]				= "trash";
ZmFolder.MSG_KEY[ZmFolder.ID_SPAM]				= "junk";
ZmFolder.MSG_KEY[ZmFolder.ID_SENT]				= "sent";
ZmFolder.MSG_KEY[ZmFolder.ID_DRAFTS]			= "drafts";
ZmFolder.MSG_KEY[ZmFolder.ID_CONTACTS]			= "contacts";
ZmFolder.MSG_KEY[ZmFolder.ID_AUTO_ADDED]		= "emailedContacts";
ZmFolder.MSG_KEY[ZmFolder.ID_TASKS]				= "tasks";
ZmFolder.MSG_KEY[ZmFolder.ID_TAGS]				= "tags";
ZmFolder.MSG_KEY[ZmOrganizer.ID_CALENDAR]		= "calendar";
ZmFolder.MSG_KEY[ZmOrganizer.ID_BRIEFCASE]		= "briefcase";
ZmFolder.MSG_KEY[ZmOrganizer.ID_CHATS]			= "chats";
ZmFolder.MSG_KEY[ZmOrganizer.ID_ALL_MAILBOXES]	= "allMailboxes";
ZmFolder.MSG_KEY[ZmFolder.ID_OUTBOX]			= "outbox";
ZmFolder.MSG_KEY[ZmFolder.ID_SYNC_FAILURES]		= "errorReports";
ZmFolder.MSG_KEY[ZmFolder.ID_ATTACHMENTS]       = "attachments";

// system folder icons
ZmFolder.ICON = {};
ZmFolder.ICON[ZmFolder.ID_INBOX]				= "Inbox";
ZmFolder.ICON[ZmFolder.ID_TRASH]				= "Trash";
ZmFolder.ICON[ZmFolder.ID_SPAM]					= "SpamFolder";
ZmFolder.ICON[ZmFolder.ID_SENT]					= "SentFolder";
ZmFolder.ICON[ZmFolder.ID_SYNC_FAILURES]		= "SendReceive";
ZmFolder.ICON[ZmFolder.ID_OUTBOX]				= "Outbox";
ZmFolder.ICON[ZmFolder.ID_DRAFTS]				= "DraftFolder";
ZmFolder.ICON[ZmFolder.ID_CHATS]				= "ChatFolder";
ZmFolder.ICON[ZmFolder.ID_LOAD_FOLDERS]			= "Plus";
ZmFolder.ICON[ZmFolder.ID_ATTACHMENTS]          = "Attachment";

// name to use within the query language
ZmFolder.QUERY_NAME = {};
ZmFolder.QUERY_NAME[ZmFolder.ID_INBOX]			= "inbox";
ZmFolder.QUERY_NAME[ZmFolder.ID_TRASH]			= "trash";
ZmFolder.QUERY_NAME[ZmFolder.ID_SPAM]			= "junk";
ZmFolder.QUERY_NAME[ZmFolder.ID_SENT]			= "sent";
ZmFolder.QUERY_NAME[ZmFolder.ID_OUTBOX]			= "outbox";
ZmFolder.QUERY_NAME[ZmFolder.ID_DRAFTS]			= "drafts";
ZmFolder.QUERY_NAME[ZmOrganizer.ID_CALENDAR]	= "calendar";
ZmFolder.QUERY_NAME[ZmFolder.ID_CONTACTS]		= "contacts";
ZmFolder.QUERY_NAME[ZmFolder.ID_TASKS]			= "tasks";
ZmFolder.QUERY_NAME[ZmFolder.ID_AUTO_ADDED]		= "Emailed Contacts";
ZmFolder.QUERY_NAME[ZmOrganizer.ID_BRIEFCASE]	= "briefcase";
ZmFolder.QUERY_NAME[ZmFolder.ID_CHATS]			= "chats";
ZmFolder.QUERY_NAME[ZmFolder.ID_SYNC_FAILURES]	= "Error Reports";

ZmFolder.QUERY_ID = AjxUtil.valueHash(ZmFolder.QUERY_NAME);

// order within the overview panel
ZmFolder.SORT_ORDER = {};
ZmFolder.SORT_ORDER[ZmFolder.ID_INBOX]			= 1;
ZmFolder.SORT_ORDER[ZmFolder.ID_CHATS]			= 2;
ZmFolder.SORT_ORDER[ZmFolder.ID_SENT]			= 3;
ZmFolder.SORT_ORDER[ZmFolder.ID_DRAFTS]			= 4;
ZmFolder.SORT_ORDER[ZmFolder.ID_SPAM]			= 5;
ZmFolder.SORT_ORDER[ZmFolder.ID_OUTBOX]			= 6;
ZmFolder.SORT_ORDER[ZmFolder.ID_TRASH]			= 7;
ZmFolder.SORT_ORDER[ZmFolder.ID_SYNC_FAILURES]	= 8;
ZmFolder.SORT_ORDER[ZmFolder.ID_SEP]			= 9;
ZmFolder.SORT_ORDER[ZmFolder.ID_ATTACHMENTS]    = 99; // Last

// character codes for "tcon" attribute in conv action request, which controls
// which folders are affected
ZmFolder.TCON_CODE = {};
ZmFolder.TCON_CODE[ZmFolder.ID_TRASH]			= "t";
ZmFolder.TCON_CODE[ZmFolder.ID_SYNC_FAILURES]	= "o";
ZmFolder.TCON_CODE[ZmFolder.ID_SPAM]			= "j";
ZmFolder.TCON_CODE[ZmFolder.ID_SENT]			= "s";
ZmFolder.TCON_CODE[ZmFolder.ID_DRAFTS]			= "d";
ZmFolder.TCON_CODE[ZmFolder.ID_OTHER]			= "o";

// folders that look like mail folders that we don't want to show
ZmFolder.HIDE_ID = {};
ZmFolder.HIDE_ID[ZmOrganizer.ID_CHATS]				= true;
ZmFolder.HIDE_ID[ZmOrganizer.ID_NOTIFICATION_MP]	= true;

// Hide folders migrated from Outlook mailbox
ZmFolder.HIDE_NAME = {};
//ZmFolder.HIDE_NAME["Journal"]		= true;
//ZmFolder.HIDE_NAME["Notes"]		= true;
//ZmFolder.HIDE_NAME["Outbox"]		= true;
//ZmFolder.HIDE_NAME["Tasks"]		= true;

// folders that contain mail from me instead of to me
ZmFolder.OUTBOUND = [ZmFolder.ID_SENT, ZmFolder.ID_OUTBOX, ZmFolder.ID_DRAFTS];

// The extra-special, visible but untouchable outlook folder
ZmFolder.SYNC_ISSUES 							= "Sync Issues";

// map name to ID
ZmFolder.QUERY_ID = {};
(function() {
	for (var i in ZmFolder.QUERY_NAME) {
		ZmFolder.QUERY_ID[ZmFolder.QUERY_NAME[i]] = i;
	}
})();

/**
 * Comparison function for folders. Intended for use on a list of user folders
 * through a call to <code>Array.sort()</code>.
 *
 * @param {ZmFolder}	folderA		a folder
 * @param {ZmFolder}	folderB		a folder
 * @param {Boolean}		nonMail		this is sorting non mail tree.
 * @return	{int} 0 if the folders match
 */
ZmFolder.sortCompare =
function(folderA, folderB, nonMail) {
	var check = ZmOrganizer.checkSortArgs(folderA, folderB);
	if (check != null) { return check; }

	// offline client wants POP folders above all else *unless* we are POP'ing into Inbox
	if (appCtxt.isOffline) {
		if (folderA.isDataSource(ZmAccount.TYPE_POP)) {
			if (folderA.id == ZmFolder.ID_INBOX) return -1;
			if (folderB.isDataSource(ZmAccount.TYPE_POP)) {
				if (folderA.name.toLowerCase() > folderB.name.toLowerCase()) { return 1; }
				if (folderA.name.toLowerCase() < folderB.name.toLowerCase()) { return -1; }
				return 0;
			}
			return -1;
		} else if (folderB.isDataSource(ZmAccount.TYPE_POP)) {
			return 1;
		}
	}

	if (ZmFolder.SORT_ORDER[folderA.nId] && ZmFolder.SORT_ORDER[folderB.nId]) {
		return (ZmFolder.SORT_ORDER[folderA.nId] - ZmFolder.SORT_ORDER[folderB.nId]);
	}

	// links (shared folders or mailboxes) appear after personal folders
	if (folderA.link !== folderB.link) {
		return folderA.link ? 1 : -1;
	}

	if (nonMail) {
		//for nonp-mail apps, trash last of all things
		if (folderA.isTrash()) {
			return 1;
		}
		if (folderB.isTrash()) {
			return -1;
		}
		//system before non-system (except for trash)
		if (folderA.isSystem() && !folderB.isSystem()) {
			return -1;
		}
		if (!folderA.isSystem() && folderB.isSystem()) {
			return 1;
		}
		if (folderA.isSystem() && folderB.isSystem()) {
			//for 2 system folders, the default one is first, and the rest ordered alphabetically (again except for trash that appears after the user folders)
			if (folderA.isDefault()) {
				return -1;
			}
			if (folderB.isDefault()) {
				return 1;
			}
			//the other cases will be sorted by name below. Either 2 system or 2 user folders.
		}
	}
	else {
		if (!ZmFolder.SORT_ORDER[folderA.nId] && ZmFolder.SORT_ORDER[folderB.nId]) { return 1; }
		if (ZmFolder.SORT_ORDER[folderA.nId] && !ZmFolder.SORT_ORDER[folderB.nId]) { return -1; }
	}

	if (folderA.name.toLowerCase() > folderB.name.toLowerCase()) { return 1; }
	if (folderA.name.toLowerCase() < folderB.name.toLowerCase()) { return -1; }
	return 0;
};


ZmFolder.sortCompareNonMail =
function(folderA, folderB) {
	return ZmFolder.sortCompare(folderA, folderB, true);
};

/**
 * Compares the folders by path.
 * 
 * @param {ZmFolder}	folderA		a folder
 * @param {ZmFolder}	folderB		a folder
 * @return	{int} 0 if the folders match
 */
ZmFolder.sortComparePath =
function(folderA, folderB) {

	var pathA = folderA && folderA.getPath(false, false, null, true, true);
	var pathB = folderB && folderB.getPath(false, false, null, true, true);
	var check = ZmOrganizer.checkSortArgs(pathA, pathB);
	if (check != null) { return check; }

	if (ZmFolder.SORT_ORDER[folderA.nId] && ZmFolder.SORT_ORDER[folderB.nId]) {
		return (ZmFolder.SORT_ORDER[folderA.nId] - ZmFolder.SORT_ORDER[folderB.nId]);
	}
	if (!ZmFolder.SORT_ORDER[folderA.nId] && ZmFolder.SORT_ORDER[folderB.nId]) { return 1; }
	if (ZmFolder.SORT_ORDER[folderA.nId] && !ZmFolder.SORT_ORDER[folderB.nId]) { return -1; }
	if (pathA.toLowerCase() > pathB.toLowerCase()) { return 1; }
	if (pathA.toLowerCase() < pathB.toLowerCase()) { return -1; }
	return 0;
};

/**
 * Checks a folder name for validity. Note: that a name, rather than a path, is checked.
 *
 * @param {String}	name		the folder name
 * @param {ZmFolder}	parent		the parent folder
 * @return	{String} an error message if the name is invalid; <code>null</code>if the name is valid. 
 */
ZmFolder.checkName =
function(name, parent) {
	var error = ZmOrganizer.checkName(name);
	if (error) { return error; }

	// make sure path isn't same as a system folder
	parent = parent || appCtxt.getFolderTree().root;
	if (parent && (parent.id == ZmFolder.ID_ROOT)) {
		var lname = name.toLowerCase();
		for (var id in ZmFolder.MSG_KEY) {
			var sysname = ZmMsg[ZmFolder.MSG_KEY[id]];
			if (sysname && (lname == sysname.toLowerCase())) {
				return ZmMsg.folderNameReserved;
			}
		}
		/*if (lname == ZmFolder.SYNC_ISSUES.toLowerCase()) {
			return ZmMsg.folderNameReserved;
		}*/
	}

	return null;
};

/**
 * Gets the "well-known" ID for a given folder name.
 * 
 * @param	{String}	folderName	the folder name
 * @return	{String}	the id or <code>null</code> if not found
 */
ZmFolder.getIdForName =
function(folderName) {
	var name = folderName.toLowerCase();
	for (var i in ZmFolder.MSG_KEY) {
		if (ZmFolder.MSG_KEY[i] == name) {
			return i;
		}
	}
	return null;
};

/**
 * Moves a folder. A user can move a folder to "Trash" even if there is already a folder in "Trash" with the
 * same name. A new name will be generated for this folder and a rename is performed before the move.
 * 
 * @param	{ZmFolder}	newParent		the new parent
 * @param	{boolean}	noUndo			true if the action should not be undoable
 * @param	{String}	actionText		optional custom action text to display as summary
 */
ZmFolder.prototype.move =
function(newParent, noUndo, actionText, batchCmd) {
	var origName = this.name;
	var name = this.name;
	while (newParent.hasChild(name)) {
		name = name + "_";
	}
	if (origName != name) {
		this.rename(name);
	}
	ZmOrganizer.prototype.move.call(this, newParent, noUndo, batchCmd);
};

/**
 * Sends <code>&lt;FolderActionRequest&gt;</code> to turn sync'ing on/off for IMAP folders. Currently,
 * this is only used by Offline/ZDesktop client
 *
 * @param {Boolean}	syncIt		the flag indicating whether to sync this folder
 * @param {AjxCallback}	callback		the callback to call once server request is successful
 * @param {AjxCallback}	errorCallback	the callback to call if server returns error
 */
ZmFolder.prototype.toggleSyncOffline =
function(callback, errorCallback) {
	if (!this.isOfflineSyncable) { return; }

	var op = this.isOfflineSyncing ? "!syncon" : "syncon";
	var soapDoc = AjxSoapDoc.create("FolderActionRequest", "urn:zimbraMail");
	var actionNode = soapDoc.set("action");
	actionNode.setAttribute("op", op);
	actionNode.setAttribute("id", this.id);

	var params = {
		soapDoc: soapDoc,
		asyncMode: true,
		callback: callback,
		errorCallback: errorCallback
	};
	appCtxt.getAppController().sendRequest(params);
};

/**
 * Checks folders recursively for feeds.
 * 
 * @return	{Boolean}	<code>true</code> for feeds
 */
ZmFolder.prototype.hasFeeds =
function() {
	if (this.type != ZmOrganizer.FOLDER) { return false; }

	var a = this.children.getArray();
	var sz = this.children.size();
	for (var i = 0; i < sz; i++) {
		if (a[i].isFeed()) {
			return true;
		}
		if (a[i].children && a[i].children.size() > 0) {
			return (a[i].hasFeeds && a[i].hasFeeds());
		}
	}
	return false;
};

/**
 * Checks if the folder has search.
 * 
 * @param	{String}	id	not used
 * @return	{Boolean}	<code>true</code> if has search
 */
ZmFolder.prototype.hasSearch =
function(id) {
	if (this.type == ZmOrganizer.SEARCH) { return true; }

	var a = this.children.getArray();
	var sz = this.children.size();
	for (var i = 0; i < sz; i++) {
		if (a[i].hasSearch()) {
			return true;
		}
	}

	return false;
};

/**
 * Checks if the folder supports public access. Override this method if you dont want a folder to be accessed publicly
 * 
 * @return	{Boolean}	always returns <code>true</code>
 */
ZmFolder.prototype.supportsPublicAccess =
function() {
	return true;
};

/**
 * Handles the creation of a folder or search folder. This folder is the parent
 * of the newly created folder. A folder may hold a folder or search folder,
 * and a search folder may hold another search folder.
 *
 * @param {Object}	obj				a JS folder object from the notification
 * @param {String}	elementType		the type of containing JSON element
 * @param {Boolean}	skipNotify		<code>true</code> if notifying client should be ignored
 */
ZmFolder.prototype.notifyCreate =
function(obj, elementType, skipNotify) {
	// ignore creates of system folders
	var nId = ZmOrganizer.normalizeId(obj.id);
	if (this.isSystem() && nId < ZmOrganizer.FIRST_USER_ID[this.type]) { return; }

	var account = ZmOrganizer.parseId(obj.id).account;
	var folder = ZmFolderTree.createFromJs(this, obj, this.tree, elementType, null, account);
	if (folder) {
		var index = ZmOrganizer.getSortIndex(folder, eval(ZmTreeView.COMPARE_FUNC[this.type]));
		this.children.add(folder, index);

		if (!skipNotify) {
			folder._notify(ZmEvent.E_CREATE);
		}
	}
};

/**
 * Provide some extra info in the change event about the former state
 * of the folder. Note that we null out the field after setting up the
 * change event, so the notification isn't also sent when the parent
 * class's method is called.
 *
 * @param {Object}	obj	a "modified" notification
 */
ZmFolder.prototype.notifyModify =
function(obj) {
	var details = {};
	var fields = {};
	var doNotify = false;
	if (obj.name != null && this.name != obj.name && obj.id == this.id) {
		details.oldPath = this.getPath();
		this.name = obj.name;
		fields[ZmOrganizer.F_NAME] = true;
		this.parent.children.sort(eval(ZmTreeView.COMPARE_FUNC[this.type]));
		doNotify = true;
		obj.name = null;
	}
	if (doNotify) {
		details.fields = fields;
		this._notify(ZmEvent.E_MODIFY, details);
	}

	if (obj.l != null && (!this.parent || (obj.l != this.parent.id))) {
		var newParent = this._getNewParent(obj.l);
		if (newParent) {
			details.oldPath = this.getPath();
			this.reparent(newParent);
			this._notify(ZmEvent.E_MOVE, details);
			obj.l = null;
		}
	}

	ZmOrganizer.prototype.notifyModify.apply(this, [obj]);
};

/**
 * Creates a query.
 * 
 * @param	{Boolean}	pathOnly	<code>true</code> if to use the path only
 * @return	{String}	the query
 */
ZmFolder.prototype.createQuery =
function(pathOnly) {
	if (!this.isRemote() && this.isSystem()) {
		var qName = ZmFolder.QUERY_NAME[this.nId] || this.getName(false, null, true, true) || this.name;
		// put quotes around folder names that consist of multiple words or have special characters.
		var quote = /^\w+$/.test(qName) ? "" : "\"";
		return pathOnly
			? qName
			: ("in:" + quote + qName + quote);
	}

	var path = this.isSystem() ? ZmFolder.QUERY_NAME[this.nId] : this.name;
	var f = this.parent;
	while (f && (f.nId != ZmFolder.ID_ROOT) && f.name.length) {
		var name = (f.isSystem() && ZmFolder.QUERY_NAME[f.nId]) || f.name;
		path = name + "/" + path;
		f = f.parent;
	}
	path = '"' + path + '"';
	return pathOnly ? path : ("in:" + path);
};

/**
 * Gets the name.
 * 
 * @param	{Boolean}	 showUnread		<code>true</code> to show unread
 * @param	{int}		maxLength		the max length
 * @param	{Boolean}	noMarkup		<code>true</code> to not include markup
 * @param	{Boolean}	useSystemName	<code>true</code> to use the system name
 * 
 * @return	{String}	the name
 */
ZmFolder.prototype.getName =
function(showUnread, maxLength, noMarkup, useSystemName) {
	if (this.nId == ZmFolder.ID_DRAFTS ||
		this.nId == ZmFolder.ID_OUTBOX ||
		this.rid == ZmFolder.ID_DRAFTS)
	{
		var name = (useSystemName && this._systemName) ? this._systemName : this.name;
		if (showUnread && this.numTotal > 0) {
			name = AjxMessageFormat.format(ZmMsg.folderUnread, [name, this.numTotal]);
			if (!noMarkup) {
				name = ["<span style='font-weight:bold'>", name, "</span>"].join("");
			}
		}
		return name;
	}
	else {
		return ZmOrganizer.prototype.getName.apply(this, arguments);
	}
};

/**
 * Gets the icon.
 * 
 * @return	{String}	the icon
 */
ZmFolder.prototype.getIcon =
function() {
	if (this.nId == ZmOrganizer.ID_ROOT)			{ return null; }
	if (ZmFolder.ICON[this.nId])					{ return ZmFolder.ICON[this.nId]; }
	if (this.isFeed())								{ return "RSS"; }
	if (this.isRemote())							{ return "SharedMailFolder"; }
	if (this.isDataSource(ZmAccount.TYPE_POP))		{ return "POPAccount"; }

	// make a "best-effort" to map imap folders to a well-known icon
	// (parent will be the root imap folder)
	var mappedId = this.getSystemEquivalentFolderId();
	if (mappedId) {
		return ZmFolder.ICON[mappedId] || "Folder";
	}

	return "Folder";
};

ZmFolder.prototype.getSystemEquivalentFolderId =
function() {
	if (this.parent && this.parent.isDataSource(ZmAccount.TYPE_IMAP)) {
		return ZmFolder.getIdForName(this.name);
	}
	return null;
};

ZmFolder.prototype.isSystemEquivalent =
function() {
	return this.getSystemEquivalentFolderId() != null;
};

ZmFolder.prototype.mayContainFolderFromAccount =
function(otherAccount) {
	var thisAccount = this.getAccount();
	if (thisAccount == otherAccount) {
		return true;
	}
	return thisAccount.isLocal(); // can only move to local

};

/**
 * Returns true if the given object(s) may be placed in this folder.
 *
 * If the object is a folder, check that:
 * <ul>
 * <li>We are not the immediate parent of the folder</li>
 * <li>We are not a child of the folder</li>
 * <li>We are not Spam or Drafts</li>
 * <li>We don't already have a child with the folder's name (unless we are in Trash)</li>
 * <li>We are not moving it into a folder of a different type</li>
 * <li>We are not moving a folder into itself</li>
 * </ul>
 *
 * If the object is an item or a list or items, check that:
 * <ul>
 * <li>We are not the Folders container</li>
 * <li>We are not a search folder</li>
 * <li>The items aren't already in this folder</li>
 * <li>A contact can only be moved to Trash</li>
 * <li> A draft can be moved to Trash or Drafts</li>
 * <li>Non-drafts cannot be moved to Drafts</li>
 * </ul>
 *
 * @param {Object}	what		the object(s) to possibly move into this folder (item or organizer)
 * @param {constant}	folderType	the contextual folder type (for tree view root items)
 * @param {boolean}	ignoreExisting  Set to true if checks for item presence in the folder should be skipped (e.g. when recovering deleted items)
 */
ZmFolder.prototype.mayContain =
function(what, folderType, ignoreExisting) {

	if (!what) {
		return true;
	}
	if (this.isFeed() /*|| this.isSyncIssuesFolder()*/) {
		return false;
	}
	// placeholder for showing a large number of folders
	if (this.id == ZmFolder.ID_LOAD_FOLDERS) {
		return false;
	}

	var thisType = folderType || this.type;
	var invalid = false;
	if (what instanceof ZmFolder) {
        invalid = ((what.parent === this && !ignoreExisting) || this.isChildOf(what) || this.nId == ZmFolder.ID_DRAFTS || this.nId == ZmFolder.ID_SPAM ||
				   (!this.isInTrash() && this.hasChild(what.name) && !ignoreExisting) ||
	               (what.type !== thisType && this.nId != ZmFolder.ID_TRASH) ||
				   (what.id === this.id) ||
				   (this.disallowSubFolder) ||
				   (appCtxt.multiAccounts && !this.mayContainFolderFromAccount(what.getAccount())) || // cannot move folders across accounts, unless the target is local
                   (this.isRemote() && !this._remoteMoveOk(what)) ||
				   (what.isRemote() && !this._remoteMoveOk(what)));				// a remote folder can be DnD but not its children
    } else {
		// An item or an array of items is being moved
		var items = AjxUtil.toArray(what);
		var item = items[0];

        // container can only have folders/searches or calendars
		if ((this.nId == ZmOrganizer.ID_ROOT && (what.type !== ZmOrganizer.CALENDAR)) ||
             // nothing can be moved to outbox/sync failures folders
			 this.nId == ZmOrganizer.ID_OUTBOX ||
			 this.nId == ZmOrganizer.ID_SYNC_FAILURES)
		{
			invalid = true;
		} else if (thisType === ZmOrganizer.SEARCH) {
			invalid = true;														// can't drop items into saved searches
		} else if (item && (item.type === ZmItem.CONTACT) && item.isGal) {
			invalid = true;
		} else if (item && (item.type === ZmItem.CONV) && item.list && item.list.search && (item.list.search.folderId === this.id)) {
			invalid = true;														// convs which are a result of a search for this folder
		} else {																// checks that need to be done for each item
			for (var i = 0; i < items.length; i++) {
				var childItem = items[i];
				if (!childItem) {
					invalid = true;
					break;
				}
				if (Dwt.instanceOf(childItem, "ZmBriefcaseFolderItem")) {
                     if (childItem.folder && childItem.folder.isRemote() && !childItem.folder.rid) {
                        invalid = true;
                        break;
                     }
                } else if (item.type === ZmItem.MSG && childItem.isDraft && (this.nId != ZmFolder.ID_TRASH && this.nId != ZmFolder.ID_DRAFTS && this.rid != ZmFolder.ID_DRAFTS)) {
					// can move drafts only into Trash or Drafts
					invalid = true;
					break;
				} else if ((this.nId == ZmFolder.ID_DRAFTS || this.rid == ZmFolder.ID_DRAFTS) && !childItem.isDraft)	{
					// only drafts can be moved into Drafts
					invalid = true;
					break;
				}
			}
			// items in the "Sync Failures" folder cannot be dragged out
			if (appCtxt.isOffline && !invalid) {
				// bug: 41531 - don't allow items to be moved into exchange
				// account when moving across accounts
				var acct = this.getAccount();
				if (acct && item.getAccount() != acct &&
					(acct.type === ZmAccount.TYPE_MSE ||
					 acct.type === ZmAccount.TYPE_EXCHANGE))
				{
					invalid = true;
				}
				else {
					var cs = appCtxt.getCurrentSearch();
					var folder = cs && appCtxt.getById(cs.folderId);
					if (folder && folder.nId == ZmOrganizer.ID_SYNC_FAILURES) {
						invalid = true;
					}
				}
			}

			// bug #42890 - disable moving to shared folders across accounts
			// until server bug is fixed
			if (appCtxt.multiAccounts && this.isRemote() &&
				what.getAccount && this.getAccount().id != what.getAccount().id)
			{
				invalid = true;
			}

			// can't move items to folder they're already in; we're okay if we
			// have one item from another folder
			if (!invalid && !ignoreExisting) {
				if (item && item.folderId) {
					invalid = true;
					for (var i = 0; i < items.length; i++) {
						if (items[i].folderId != this.id) {
							invalid = false;
							break;
						}
					}
				}
			}
		}
		if (!invalid && this.link) {
			invalid = this.isReadOnly();										// cannot drop anything onto a read-only item
		}
	}
	return !invalid;
};

/**
 * Checks if this is the sync issues folder.
 * 
 * @return	{Boolean}	<code>true</code> if the folder is the one dealing with Outlook sync issues
 */

//Bug#68799 Removing special handling of the folder named "Sync Issues"

/*ZmFolder.prototype.isSyncIssuesFolder =
function() {
	return (this.name == ZmFolder.SYNC_ISSUES);
};*/

/**
 * Checks if this folder required hard delete.
 * 
 * @return	{Boolean}	<code>true</code> if deleting items w/in this folder should be hard deleted.
 */
ZmFolder.prototype.isHardDelete =
function() {
	return (this.isInTrash() || this.isInSpam() || (appCtxt.isOffline && this.isUnder(ZmOrganizer.ID_SYNC_FAILURES)));
};

/**
 * Checks if this folder is in spam folder.
 * 
 * @return	{Boolean}	<code>true</code> if in spam
 */
ZmFolder.prototype.isInSpam =
function(){
	return this.isUnder(ZmFolder.ID_SPAM);
};

/**
 *
 * @param {ZmFolder}	folder  the source folder
 * 
 * @return {Boolean}	<code>true/code> if the given remote folder can be moved into this remote folder.
 * The source and the target folder must belong to the same account. The source
 * must have delete permission and the target must have insert permission.
 * 
 * @private
 */
ZmFolder.prototype._remoteMoveOk =
function(folder) {
	if (!this.isRemote() && folder.isMountpoint && folder.rid) { return true; }
	if (!this.link || !folder.link || this.getOwner() !== folder.getOwner()) { return false; }
	if (!this._folderActionOk(this, "isInsert")) {
		return false;
	}
	return this._folderActionOk(folder, "isDelete");
};

ZmFolder.prototype._folderActionOk =
function(folder, func) {
	var share = folder.shares && folder.shares[0];
	if (!share) {
		//if shares is not set, default to readOnly.
		return !folder.isReadOnly();
	}
	return share[func]();
};
/**
 * Returns true if this folder is for outbound mail.
 */
ZmFolder.prototype.isOutbound =
function() {
	for (var i = 0; i < ZmFolder.OUTBOUND.length; i++) {
		if (this.isUnder(ZmFolder.OUTBOUND[i])) {
			return true;
		}
	}
	return false;
};


/**
 * Sets the Global Mark Read flag.  When the user sets this flag, read flags are global for all
 * shared instances of the folder. When not set, each user accessing the shared folder will maintain
 * their own read/unread flag.
 *
 * @param	{Object}	        globalMarkRead		the globalMarkRead boolean flag
 * @param	{AjxCallback}	    callback		    the callback
 * @param	{AjxCallback}	    errorCallback		the error callback
 * @param   {ZmBatchCommand}    batchCmd            optional batch command
 */
ZmOrganizer.prototype.setGlobalMarkRead = function(globalMarkRead, callback, errorCallback, batchCmd) {
	if (this.globalMarkRead == globalMarkRead) { return; }
    // TODO: Bug 59559, awaiting server side implementation (Bug 24567)
    // TODO: - For ZmFolderPropsDialog and ZmSharePropsDialog:
    // TODO:     Make sure that the attrName is indeed globalMarkRead - used in the dialogs
    // TODO:     Make the globalMarkRead labels and controls visible.
    // TODO: - Uncomment this once the server call is ready, make sure action/attrs are correct
	//this._organizerAction({action: "globalMarkRead", attrs: {globalMarkRead: globalMarkRead}, callback: callback,
    //                       errorCallback: errorCallback, batchCmd: batchCmd});
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmSearch")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * The file defines a search class.
 * 
 */

/**
 * Creates a new search with the given properties.
 * @class
 * This class represents a search to be performed on the server. It has properties for
 * the different search parameters that may be used. It can be used for a regular search,
 * or to search within a conversation. The results are returned via a callback.
 *
 * @param {Hash}		params		a hash of parameters
 * @param   {String}	params.query					the query string
 * @param	{String}	params.queryHint				the query string that gets appended to the query but not something the user needs to know about
 * @param	{AjxVector}	params.types					the item types to search for
 * @param	{Boolean}	params.forceTypes				use the types we pass, do not override (in case of mail) to the current user's view pref (MSG vs. CONV).
 * @param	{constant}	params.sortBy					the sort order
 * @param	{int}		params.offset					the starting point within result set
 * @param	{int}		params.limit					the number of results to return
 * @param	{Boolean}	params.getHtml					if <code>true</code>, return HTML part for inlined msg
 * @param	{constant}	params.contactSource			where to search for contacts (GAL or personal)
 * @param	{Boolean}	params.isGalAutocompleteSearch	if <code>true</code>, autocomplete against GAL
 * @param	{constant}	params.galType					the type of GAL autocomplete (account or resource)
 * @param	{constant}	params.autocompleteType			the type of autocomplete (account or resource or all)
 * @param	{int}		params.lastId					the ID of last item displayed (for pagination)
 * @param	{String}	params.lastSortVal				the value of sort field for above item
 * @param	{Boolean}	params.fetch					if <code>true</code>, fetch first hit message
 * @param	{int}		params.searchId					the ID of owning search folder (if any)
 * @param	{Array}		params.conds					the list of search conditions (<code><SearchCalendarResourcesRequest></code>)
 * @param	{Array}		params.attrs					the list of attributes to return (<code><SearchCalendarResourcesRequest></code>)
 * @param	{String}	params.field					the field to search within (instead of default)
 * @param	{Object}	params.soapInfo					the object with method, namespace, response, and additional attribute fields for creating soap doc
 * @param	{Object}	params.response					the canned JSON response (no request will be made)
 * @param	{Array}		params.folders					the list of folders for autocomplete
 * @param	{Array}		params.allowableTaskStatus		the list of task status types to return (assuming one of the values for "types" is "task")
 * @param	{String}	params.accountName				the account name to run this search against
 * @param	{Boolean}	params.idsOnly					if <code>true</code>, response returns item IDs only
 * @param   {Boolean}   params.inDumpster               if <code>true</code>, search in the dumpster
 * @param	{string}	params.origin					indicates what initiated the search
 * @param	{boolean}	params.isEmpty					if true, return empty response without sending a request
 */
ZmSearch = function(params) {

	params = params || {};
	for (var p in params) {
		this[p] = params[p];
	}
	this.galType					= this.galType || ZmSearch.GAL_ACCOUNT;
	this.join						= this.join || ZmSearch.JOIN_AND;

	if (this.query || this.queryHint) {
		// only parse regular searches
		if (!this.isGalSearch && !this.isAutocompleteSearch &&
			!this.isGalAutocompleteSearch && !this.isCalResSearch) {
			
			var pq = this.parsedQuery = new ZmParsedQuery(this.query || this.queryHint);
			this._setProperties();
			var sortTerm = pq.getTerm("sort");
			if (sortTerm) {
				this.sortBy = sortTerm.arg;
			}
		}
	}

	this.isGalSearch = false;
	this.isCalResSearch = false;

	if (ZmSearch._mailEnabled == null) {
		ZmSearch._mailEnabled = appCtxt.get(ZmSetting.MAIL_ENABLED);
		if (ZmSearch._mailEnabled) {
			AjxDispatcher.require("MailCore");
		}
	}

	if (params.checkTypes) {
		var types = AjxUtil.toArray(this.types);
		var enabledTypes = [];
		for (var i = 0; i < types.length; i++) {
			var type = types[i];
			var app = ZmItem.APP[type];
			if (appCtxt.get(ZmApp.SETTING[app])) {
				enabledTypes.push(type);
			}
		}
		this.types = AjxVector.fromArray(enabledTypes);
	}
};

ZmSearch.prototype.isZmSearch = true;
ZmSearch.prototype.toString = function() { return "ZmSearch"; };

// Search types
ZmSearch.TYPE = {};
ZmSearch.TYPE_ANY = "any";

ZmSearch.GAL_ACCOUNT	= "account";
ZmSearch.GAL_RESOURCE	= "resource";
ZmSearch.GAL_ALL		= "";

ZmSearch.JOIN_AND	= 1;
ZmSearch.JOIN_OR	= 2;

ZmSearch.TYPE_MAP = {};

ZmSearch.DEFAULT_LIMIT = DwtListView.DEFAULT_LIMIT;

// Sort By
ZmSearch.DATE_DESC 		= "dateDesc";
ZmSearch.DATE_ASC 		= "dateAsc";
ZmSearch.SUBJ_DESC 		= "subjDesc";
ZmSearch.SUBJ_ASC 		= "subjAsc";
ZmSearch.NAME_DESC 		= "nameDesc";
ZmSearch.NAME_ASC 		= "nameAsc";
ZmSearch.SIZE_DESC 		= "sizeDesc";
ZmSearch.SIZE_ASC 		= "sizeAsc";
ZmSearch.RCPT_ASC       = "rcptAsc";
ZmSearch.RCPT_DESC      = "rcptDesc";
ZmSearch.ATTACH_ASC     = "attachAsc"
ZmSearch.ATTACH_DESC    = "attachDesc"
ZmSearch.FLAG_ASC       = "flagAsc";
ZmSearch.FLAG_DESC      = "flagDesc";
ZmSearch.MUTE_ASC       = "muteAsc";
ZmSearch.MUTE_DESC      = "muteDesc";
ZmSearch.READ_ASC       = "readAsc";
ZmSearch.READ_DESC      = "readDesc";
ZmSearch.PRIORITY_ASC   = "priorityAsc";
ZmSearch.PRIORITY_DESC  = "priorityDesc";
ZmSearch.SCORE_DESC 	= "scoreDesc";
ZmSearch.DURATION_DESC	= "durDesc";
ZmSearch.DURATION_ASC	= "durAsc";
ZmSearch.STATUS_DESC	= "taskStatusDesc";
ZmSearch.STATUS_ASC		= "taskStatusAsc";
ZmSearch.PCOMPLETE_DESC	= "taskPercCompletedDesc";
ZmSearch.PCOMPLETE_ASC	= "taskPercCompletedAsc";
ZmSearch.DUE_DATE_DESC	= "taskDueDesc";
ZmSearch.DUE_DATE_ASC	= "taskDueAsc";



ZmSearch.prototype.execute =
function(params) {
	if (params.batchCmd || this.soapInfo) {
		return this._executeSoap(params);
	} else {
		return this._executeJson(params);
	}
};

/**
 * Creates a SOAP request that represents this search and sends it to the server.
 *
 * @param {Hash}	params		a hash of parameters
 * @param {AjxCallback}	params.callback		the callback to run when response is received
 * @param {AjxCallback}	params.errorCallback	the callback to run if there is an exception
 * @param {ZmBatchCommand}	params.batchCmd		the batch command that contains this request
 * @param {int}	params.timeout		the timeout value (in seconds)
 * @param {Boolean}	params.noBusyOverlay	if <code>true</code>, don't use the busy overlay
 * 
 * @private
 */
ZmSearch.prototype._executeSoap =
function(params) {

	this.isGalSearch = (this.contactSource && (this.contactSource == ZmId.SEARCH_GAL));
	this.isCalResSearch = (!this.contactSource && this.conds != null);
    if (appCtxt.isOffline && this.isCalResSearch) {
        this.isCalResSearch =  appCtxt.isZDOnline();
    }
	if (this.isEmpty) {
		this._handleResponseExecute(params.callback);
		return null;
	}

	var soapDoc;
	if (!this.response) {
		if (this.isGalSearch) {
			// DEPRECATED: Use JSON version
			soapDoc = AjxSoapDoc.create("SearchGalRequest", "urn:zimbraAccount");
			var method = soapDoc.getMethod();
			if (this.galType) {
				method.setAttribute("type", this.galType);
			}
			soapDoc.set("name", this.query);
			var searchFilterEl = soapDoc.set("searchFilter");
			if (this.conds && this.conds.length) {
				var condsEl = soapDoc.set("conds", null, searchFilterEl);
				this._applySoapCond(this.conds, soapDoc, condsEl);
			}
		} else if (this.isAutocompleteSearch) {
			soapDoc = AjxSoapDoc.create("AutoCompleteRequest", "urn:zimbraMail");
			var method = soapDoc.getMethod();
			if (this.limit) {
				method.setAttribute("limit", this.limit);
			}
			soapDoc.set("name", this.query);
		} else if (this.isGalAutocompleteSearch) {
			soapDoc = AjxSoapDoc.create("AutoCompleteGalRequest", "urn:zimbraAccount");
			var method = soapDoc.getMethod();
			method.setAttribute("limit", this._getLimit());
			if (this.galType) {
				method.setAttribute("type", this.galType);
			}
			soapDoc.set("name", this.query);
		} else if (this.isCalResSearch) {
			soapDoc = AjxSoapDoc.create("SearchCalendarResourcesRequest", "urn:zimbraAccount");
			var method = soapDoc.getMethod();
			if (this.attrs) {
				var attrs = [].concat(this.attrs);
				AjxUtil.arrayRemove(attrs, "fullName");
				method.setAttribute("attrs", attrs.join(","));
			}
			var searchFilterEl = soapDoc.set("searchFilter");
			if (this.conds && this.conds.length) {
				var condsEl = soapDoc.set("conds", null, searchFilterEl);
				this._applySoapCond(this.conds, soapDoc, condsEl);
			}
		} else {
			if (this.soapInfo) {
				soapDoc = AjxSoapDoc.create(this.soapInfo.method, this.soapInfo.namespace);
				// Pass along any extra soap data. (Voice searches use this to pass user identification.)
				for (var nodeName in this.soapInfo.additional) {
					var node = soapDoc.set(nodeName);
					var attrs = this.soapInfo.additional[nodeName];
					for (var attr in attrs) {
						node.setAttribute(attr, attrs[attr]);
					}
				}
			} else {
				soapDoc = AjxSoapDoc.create("SearchRequest", "urn:zimbraMail");
			}
			var method = this._getStandardMethod(soapDoc);
			if (this.types) {
				var a = this.types.getArray();
				if (a.length) {
					var typeStr = [];
					for (var i = 0; i < a.length; i++) {
						typeStr.push(ZmSearch.TYPE[a[i]]);
					}
					method.setAttribute("types", typeStr.join(","));
					if (this.types.contains(ZmItem.MSG) || this.types.contains(ZmItem.CONV)) {
						// special handling for showing participants ("To" instead of "From")
						var folder = this.folderId && appCtxt.getById(this.folderId);
						method.setAttribute("recip", (folder && folder.isOutbound()) ? "1" : "0");
					}
					if (this.types.contains(ZmItem.CONV)) {
						// get ID/folder for every msg in each conv result
						method.setAttribute("fullConversation", 1);
					}
					// if we're prefetching the first hit message, also mark it as read
					if (this.fetch) {

						method.setAttribute("fetch", ( this.fetch == "all" ) ? "all" : "1");
						// and set the html flag if we want the html version
						if (this.getHtml) {
							method.setAttribute("html", "1");
						}
					}
					if (this.markRead) {
						method.setAttribute("read", "1");
					}
				}
			}
			if (this.inDumpster) {
				method.setAttribute("inDumpster", "1");
			}
		}
	}

	var soapMethod = this._getStandardMethod(soapDoc);
	soapMethod.setAttribute("needExp", 1);

	var respCallback = this._handleResponseExecute.bind(this, params.callback);

	if (params.batchCmd) {
		params.batchCmd.addRequestParams(soapDoc, respCallback);
	} else {
		return appCtxt.getAppController().sendRequest({soapDoc:soapDoc, asyncMode:true, callback:respCallback,
													   errorCallback:params.errorCallback,
													   timeout:params.timeout, noBusyOverlay:params.noBusyOverlay,
													   response:this.response});
	}
};

/**
 * Creates a JSON request that represents this search and sends it to the server.
 *
 * @param {Hash}	params		a hash of parameters
 * @param {AjxCallback}	params.callback		the callback to run when response is received
 * @param {AjxCallback}	params.errorCallback	the callback to run if there is an exception
 * @param {ZmBatchCommand}	params.batchCmd		the batch command that contains this request
 * @param {int}	params.timeout		the timeout value (in seconds)
 * @param {Boolean}	params.noBusyOverlay	if <code>true</code>, don't use the busy overlay
 * 
 * @private
 */
ZmSearch.prototype._executeJson =
function(params) {

	this.isGalSearch = (this.contactSource && (this.contactSource == ZmId.SEARCH_GAL));
	this.isCalResSearch = (!this.contactSource && this.conds != null);
    if (appCtxt.isOffline && this.isCalResSearch) {
        this.isCalResSearch = appCtxt.isZDOnline();
    }
	if (this.isEmpty) {
		this._handleResponseExecute(params.callback);
		return null;
	}

	var jsonObj, request, soapDoc;
	if (!this.response) {
		if (this.isGalSearch) {
			request = {
				_jsns:"urn:zimbraAccount",
				needIsOwner: "1",
				needIsMember: "directOnly"
			};
			jsonObj = {SearchGalRequest: request};
			if (this.galType) {
				request.type = this.galType;
			}
			request.name = this.query;

			// bug #36188 - add offset/limit for paging support
			request.offset = this.offset = (this.offset || 0);
			request.limit = this._getLimit();

			// bug 15878: see same in ZmSearch.prototype._getStandardMethodJson
			request.locale = { _content: AjxEnv.DEFAULT_LOCALE };

			if (this.lastId) { // add lastSortVal and lastId for cursor-based paging
				request.cursor = {id:this.lastId, sortVal:(this.lastSortVal || "")};
			}
			if (this.sortBy) {
				request.sortBy = this.sortBy;
			}
			if (this.conds && this.conds.length) {
				request.searchFilter = {conds:{}};
				request.searchFilter.conds = ZmSearch.prototype._applyJsonCond(this.conds, request);
			}
		} else if (this.isAutocompleteSearch) {
			jsonObj = {AutoCompleteRequest:{_jsns:"urn:zimbraMail"}};
			request = jsonObj.AutoCompleteRequest;
			if (this.limit) {
				request.limit = this.limit;
			}
			request.name = {_content:this.query};
			if (params.autocompleteType) {
				request.t = params.autocompleteType;
			}
		} else if (this.isGalAutocompleteSearch) {
			jsonObj = {AutoCompleteGalRequest:{_jsns:"urn:zimbraAccount"}};
			request = jsonObj.AutoCompleteGalRequest;
			request.limit = this._getLimit();
			request.name = this.query;
			if (this.galType) {
				request.type = this.galType;
			}
		} else if (this.isCalResSearch) {
			jsonObj = {SearchCalendarResourcesRequest:{_jsns:"urn:zimbraAccount"}};
			request = jsonObj.SearchCalendarResourcesRequest;
			if (this.attrs) {
				var attrs = [].concat(this.attrs);
				request.attrs = attrs.join(",");
			}
            request.offset = this.offset = (this.offset || 0);
            request.limit = this._getLimit();
			if (this.conds && this.conds.length) {
				request.searchFilter = {conds:{}};
				request.searchFilter.conds = ZmSearch.prototype._applyJsonCond(this.conds, request);
			}
		} else {
			if (this.soapInfo) {
				soapDoc = AjxSoapDoc.create(this.soapInfo.method, this.soapInfo.namespace);
				// Pass along any extra soap data. (Voice searches use this to pass user identification.)
				for (var nodeName in this.soapInfo.additional) {
					var node = soapDoc.set(nodeName);
					var attrs = this.soapInfo.additional[nodeName];
					for (var attr in attrs) {
						node.setAttribute(attr, attrs[attr]);
					}
				}
			} else {
				jsonObj = {SearchRequest:{_jsns:"urn:zimbraMail"}};
				request = jsonObj.SearchRequest;
			}
			this._getStandardMethodJson(request);
			if (this.types) {
				var a = this.types.getArray();
				if (a.length) {
					var typeStr = [];
					for (var i = 0; i < a.length; i++) {
						typeStr.push(ZmSearch.TYPE[a[i]]);
					}
					request.types = typeStr.join(",");

					if (this.types.contains(ZmItem.MSG) || this.types.contains(ZmItem.CONV)) {
						// special handling for showing participants ("To" instead of "From")
						var folder = this.folderId && appCtxt.getById(this.folderId);
						request.recip = (folder && folder.isOutbound()) ? "2" : "0";
					}

					if (this.types.contains(ZmItem.CONV)) {
						// get ID/folder for every msg in each conv result
						request.fullConversation = 1;
					}

					// if we're prefetching the first hit message, also mark it as read
					if (this.fetch) {
                        request.fetch = ( this.fetch == "all" ) ? "all" : 1;
						// and set the html flag if we want the html version
						if (this.getHtml) {
							request.html = 1;
						}
					}

					if (this.markRead) {
						request.read = 1;
					}

                    if (this.headers) {
                        for (var hdr in this.headers) {
                            if (!request.header) { request.header = []; }
                            request.header.push({n: this.headers[hdr]});
                        }
                    }

					if (a.length == 1 && a[0] == ZmItem.TASK && this.allowableTaskStatus) {
						request.allowableTaskStatus = this.allowableTaskStatus;
					}
                }
            }
			if (this.inDumpster) {
				request.inDumpster = 1;
			}
        }
    }

	if (request) {
		request.needExp = 1;
	}


	var respCallback = this._handleResponseExecute.bind(this, params.callback);

	if (params.batchCmd) {
		params.batchCmd.addRequestParams(soapDoc, respCallback);
	} else {
		var searchParams = {
			jsonObj:jsonObj,
			soapDoc:soapDoc,
			asyncMode:true,
			callback:respCallback,
			errorCallback:params.errorCallback,
            offlineCallback:params.offlineCallback,
			timeout:params.timeout,
            offlineCache:params.offlineCache,
			noBusyOverlay:params.noBusyOverlay,
			response:this.response,
			accountName:this.accountName,
            offlineRequest:params.offlineRequest
		};
		return appCtxt.getAppController().sendRequest(searchParams);
	}
};

ZmSearch.prototype._applySoapCond =
function(inConds, soapDoc, condsEl, or) {
	if (or || this.join == ZmSearch.JOIN_OR) {
		condsEl.setAttribute("or", 1);
	}
	for (var i = 0; i < inConds.length; i++) {
		var c = inConds[i];
		if (AjxUtil.isArray(c)) {
			var subCondsEl = soapDoc.set("conds", null, condsEl);
			this._applySoapCond(c, soapDoc, subCondsEl, true);
		} else if (c.attr=="fullName" && c.op=="has") {
			var nameEl = soapDoc.set("name", c.value);
		} else {
			var condEl = soapDoc.set("cond", null, condsEl);
			condEl.setAttribute("attr", c.attr);
			condEl.setAttribute("op", c.op);
			condEl.setAttribute("value", c.value);
		}
	}
};

ZmSearch.prototype._applyJsonCond =
function(inConds, request, or) {
	var outConds = {};
	if (or || this.join == ZmSearch.JOIN_OR) {
		outConds.or = 1;
	}

	for (var i = 0; i < inConds.length; i++) {
		var c = inConds[i];
		if (AjxUtil.isArray(c)) {
			if (!outConds.conds)
				outConds.conds = [];
			outConds.conds.push(this._applyJsonCond(c, request, true));
		} else if (c.attr=="fullName" && c.op=="has") {
			request.name = {_content: c.value};
		} else {
			if (!outConds.cond)
				outConds.cond = [];
			outConds.cond.push({attr:c.attr, op:c.op, value:c.value});
		}
	}
	return outConds;
};

/**
 * Converts the response into a {ZmSearchResult} and passes it along.
 * 
 * @private
 */
ZmSearch.prototype._handleResponseExecute =
function(callback, result) {
	
	if (result) {
		var response = result.getResponse();
	
		if      (this.isGalSearch)				{ response = response.SearchGalResponse; }
		else if (this.isCalResSearch)			{ response = response.SearchCalendarResourcesResponse; }
		else if (this.isAutocompleteSearch)		{ response = response.AutoCompleteResponse; }
		else if (this.isGalAutocompleteSearch)	{ response = response.AutoCompleteGalResponse; }
		else if (this.soapInfo)					{ response = response[this.soapInfo.response]; }
		else									{ response = response.SearchResponse; }
	}
	else {
		response = { _jsns: "urn:zimbraMail", more: false };
	}
	var searchResult = new ZmSearchResult(this);
	searchResult.set(response);
	result = result || new ZmCsfeResult();
	result.set(searchResult);

	if (callback) {
		callback.run(result);
	}
};

/**
 * Fetches a conversation from the server.
 *
 * @param {Hash}		params				a hash of parameters:
 * @param {String}		params.cid			the conv ID
 * @param {AjxCallback}	params.callback		the callback to run with result
 * @param {String}		params.fetch		which msg bodies to load (see soap.txt)
 * @param {Boolean}		params.markRead		if <code>true</code>, mark msg read
 * @param {Boolean}		params.noTruncate	if <code>true</code>, do not limit size of msg
 * @param {boolean}		params.needExp		if not <code>false</code>, have server check if addresses are DLs
 */
ZmSearch.prototype.getConv =
function(params) {
	if ((!this.query && !this.queryHint) || !params.cid) { return; }

	var jsonObj = {SearchConvRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.SearchConvRequest;
	this._getStandardMethodJson(request);
	request.cid = params.cid;
	if (params.fetch) {
		request.fetch = params.fetch;
		if (params.markRead) {
			request.read = 1;			// mark that msg read
		}
		if (this.getHtml) {
			request.html = 1;			// get it as HTML
		}
		if (params.needExp !== false) {
			request.needExp = 1;
		}
	}

	if (!params.noTruncate) {
		request.max = appCtxt.get(ZmSetting.MAX_MESSAGE_SIZE);
	}

	//get both TO and From
	request.recip =  "2";

	var searchParams = {
		jsonObj:		jsonObj,
		asyncMode:		true,
		callback:		this._handleResponseGetConv.bind(this, params.callback),
		accountName:	this.accountName
	};
	appCtxt.getAppController().sendRequest(searchParams);
};

/**
 * @private
 */
ZmSearch.prototype._handleResponseGetConv =
function(callback, result) {
	var response = result.getResponse().SearchConvResponse;
	var searchResult = new ZmSearchResult(this);
	searchResult.set(response, null, true);
	result.set(searchResult);

	if (callback) {
		callback.run(result);
	}
};

/**
 * Clears cursor-related fields from this search so that it will not create a cursor.
 */
ZmSearch.prototype.clearCursor =
function() {
	this.lastId = this.lastSortVal = this.endSortVal = null;
};

/**
 * Gets a title that summarizes this search.
 * 
 * @return	{String}	the title
 */
ZmSearch.prototype.getTitle =
function() {
	var where;
	var pq = this.parsedQuery;
	// if this is a saved search, show its name, otherwise show folder or tag name if it's the only term
	var orgId = this.searchId || ((pq && (pq.getNumTokens() == 1)) ? this.folderId || this.tagId : null);
	if (orgId) {
		var org = appCtxt.getById(ZmOrganizer.getSystemId(orgId));
		if (org) {
			where = org.getName(true, ZmOrganizer.MAX_DISPLAY_NAME_LENGTH, true);
		}
	}
	return where ? ([ZmMsg.zimbraTitle, where].join(": ")) : ([ZmMsg.zimbraTitle, ZmMsg.searchResults].join(": "));
};

/**
 * Checks if this search is multi-account.
 * 
 * @return	{Boolean}	<code>true</code> if multi-account
 */
ZmSearch.prototype.isMultiAccount =
function() {
	if (!this._isMultiAccount) {
		this._isMultiAccount = (this.queryHint && this.queryHint.length > 0 &&
								(this.queryHint.split("inid:").length > 1 ||
								 this.queryHint.split("underid:").length > 1));
	}
	return this._isMultiAccount;
};

/**
 * @private
 */
ZmSearch.prototype._getStandardMethod =
function(soapDoc) {

	var method = soapDoc.getMethod();

	if (this.sortBy) {
		method.setAttribute("sortBy", this.sortBy);
	}

	if (this.types.contains(ZmItem.MSG) || this.types.contains(ZmItem.CONV)) {
		ZmMailMsg.addRequestHeaders(soapDoc);
	}

	// bug 5771: add timezone and locale info
	ZmTimezone.set(soapDoc, AjxTimezone.DEFAULT, null);
	soapDoc.set("locale", appCtxt.get(ZmSetting.LOCALE_NAME), null);

	if (this.lastId != null && this.lastSortVal) {
		// cursor is used for paginated searches
		var cursor = soapDoc.set("cursor");
		cursor.setAttribute("id", this.lastId);
		cursor.setAttribute("sortVal", this.lastSortVal);
		if (this.endSortVal) {
			cursor.setAttribute("endSortVal", this.endSortVal);
		}
	}

	this.offset = this.offset || 0;
	method.setAttribute("offset", this.offset);

	// always set limit
	method.setAttribute("limit", this._getLimit());

	var query = this._getQuery();

	soapDoc.set("query", query);

	// set search field if provided
	if (this.field) {
		method.setAttribute("field", this.field);
	}

	return method;
};

/**
 * @private
 */
ZmSearch.prototype._getStandardMethodJson = 
function(req) {

	if (this.sortBy) {
		req.sortBy = this.sortBy;
	}

	if (this.types.contains(ZmItem.MSG) || this.types.contains(ZmItem.CONV)) {
		ZmMailMsg.addRequestHeaders(req);
	}

	// bug 5771: add timezone and locale info
	ZmTimezone.set(req, AjxTimezone.DEFAULT);
	// bug 15878: We can't use appCtxt.get(ZmSetting.LOCALE) because that
	//            will return the server's default locale if it is not set
	//            set for the user or their COS. But AjxEnv.DEFAULT_LOCALE
	//            is set to the browser's locale setting in the case when
	//            the user's (or their COS) locale is not set.
	req.locale = { _content: AjxEnv.DEFAULT_LOCALE };

	if (this.lastId != null && this.lastSortVal) {
		// cursor is used for paginated searches
		req.cursor = {id:this.lastId, sortVal:this.lastSortVal};
		if (this.endSortVal) {
			req.cursor.endSortVal = this.endSortVal;
		}
	}

	req.offset = this.offset = this.offset || 0;

	// always set limit
	req.limit = this._getLimit();

	if (this.idsOnly) {
		req.resultMode = "IDS";
	}

	req.query = this._getQuery();

	// set search field if provided
	if (this.field) {
		req.field = this.field;
	}
};

/**
 * @private
 */
ZmSearch.prototype._getQuery =
function() {
	// and of course, always set the query and append the query hint if applicable
	// only use query hint if this is not a "simple" search
	if (this.queryHint) {
		var query = this.query ? ["(", this.query, ") "].join("") : "";
		return [query, "(", this.queryHint, ")"].join("");
	}
	return this.query;
};

/**
 * @private
 */
ZmSearch.prototype._getLimit =
function() {

	if (this.limit) { return this.limit; }

	var limit;
	if (this.isGalAutocompleteSearch) {
		limit = appCtxt.get(ZmSetting.AUTOCOMPLETE_LIMIT);
	} else {
		var type = this.types && this.types.get(0);
		var app = appCtxt.getApp(ZmItem.APP[type]) || appCtxt.getCurrentApp();
		if (app && app.getLimit) {
			limit = app.getLimit(this.offset);
		} else {
			limit = appCtxt.get(ZmSetting.PAGE_SIZE) || ZmSearch.DEFAULT_LIMIT;
		}
	}

	this.limit = limit;
	return limit;
};

/**
 * Tests the given item against a matching function generated from the query.
 * 
 * @param {ZmItem}	item		an item
 * @return	true if the item matches, false if it doesn't, and null if a matching function could not be generated
 */
ZmSearch.prototype.matches =
function(item) {

	if (!this.parsedQuery) {
		return null;
	}

	// if search is constrained to a folder, we can return false if item is not in that folder
	if (this.folderId && !this.parsedQuery.hasOrTerm) {
		if (item.type === ZmItem.CONV) {
			if (item.folders && !item.folders[this.folderId]) {
				return false;
			}
		}
		else if (item.folderId && item.folderId !== this.folderId) {
			return false;
		}
	}

	var matchFunc = this.parsedQuery.getMatchFunction();
	return matchFunc ? matchFunc(item) : null;
};

/**
 * Returns true if the query has a folder-related term with the given value.
 * 
 * @param 	{string}	path		a folder path (optional)
 */
ZmSearch.prototype.hasFolderTerm =
function(path) {
	return this.parsedQuery && this.parsedQuery.hasTerm(["in", "under"], path);
};

/**
 * Replaces the old folder path with the new folder path in the query string, if found.
 * 
 * @param	{string}	oldPath		the old folder path
 * @param	{string}	newPath		the new folder path
 * 
 * @return	{boolean}	true if replacement was performed
 */
ZmSearch.prototype.replaceFolderTerm =
function(oldPath, newPath) {
	if (!this.parsedQuery) {
		return this.query;
	}
	var newQuery = this.parsedQuery.replaceTerm(["in", "under"], oldPath, newPath);
	if (newQuery) {
		this.query = newQuery;
	}
	return Boolean(newQuery);
};

/**
 * Returns true if the query has a tag term with the given value.
 * 
 * @param 	{string}	tagName		a tag name (optional)
 */
ZmSearch.prototype.hasTagTerm =
function(tagName) {
	return this.parsedQuery && this.parsedQuery.hasTerm("tag", tagName);
};

/**
 * Replaces the old tag name with the new tag name in the query string, if found.
 * 
 * @param	{string}	oldName		the old tag name
 * @param	{string}	newName		the new tag name
 * 
 * @return	{boolean}	true if replacement was performed
 */
ZmSearch.prototype.replaceTagTerm =
function(oldName, newName) {
	if (!this.parsedQuery) {
		return this.query;
	}
	var newQuery = this.parsedQuery.replaceTerm("tag", oldName, newName);
	if (newQuery) {
		this.query = newQuery;
	}
	return Boolean(newQuery);
};

/**
 * Returns true if the query has a term related to unread status.
 */
ZmSearch.prototype.hasUnreadTerm =
function() {
	return (this.parsedQuery && (this.parsedQuery.hasTerm("is", "read") ||
								 this.parsedQuery.hasTerm("is", "unread")));
};

/**
 * Returns true if the query has the term "is:anywhere".
 */
ZmSearch.prototype.isAnywhere =
function() {
	return (this.parsedQuery && this.parsedQuery.hasTerm("is", "anywhere"));
};

/**
 * Returns true if the query has a "content" term.
 */
ZmSearch.prototype.hasContentTerm =
function() {
	return (this.parsedQuery && this.parsedQuery.hasTerm("content"));
};

/**
 * Returns true if the query has just one term, and it's a folder or tag term.
 */
ZmSearch.prototype.isSimple =
function() {
	var pq = this.parsedQuery;
	if (pq && (pq.getNumTokens() == 1)) {
		return pq.hasTerm(["in", "inid", "tag"]);
	}
	return false;
};

ZmSearch.prototype.getTokens =
function() {
	return this.parsedQuery && this.parsedQuery.getTokens();
};

ZmSearch.prototype._setProperties =
function() {
	var props = this.parsedQuery && this.parsedQuery.getProperties();
	for (var key in props) {
		this[key] = props[key];
	}
};





/**
 * This class is a parsed representation of a query string. It parses the string into tokens.
 * A token is a paren, a conditional operator, or a search term (which has an operator and an
 * argument). The query string is assumed to be valid.
 * 
 * Compound terms such as "in:(inbox or sent)" will be exploded into multiple terms.
 * 
 * @param	{string}	query		a query string
 * 
 * TODO: handle "field[lastName]" and "#lastName"
 */
ZmParsedQuery = function(query) {

	this.hasOrTerm = false;
	this._tokens = this._parse(AjxStringUtil.trim(query, true));

	// preconditions for flags
	if (!ZmParsedQuery.IS_VALUE_PRECONDITION) {
		ZmParsedQuery.IS_VALUE_PRECONDITION = {};
		ZmParsedQuery.IS_VALUE_PRECONDITION['flagged']      = ZmSetting.FLAGGING_ENABLED;
		ZmParsedQuery.IS_VALUE_PRECONDITION['unflagged']    = ZmSetting.FLAGGING_ENABLED;
	}
};

ZmParsedQuery.prototype.isZmParsedQuery = true;
ZmParsedQuery.prototype.toString = function() { return "ZmParsedQuery"; };

ZmParsedQuery.TERM	= "TERM";	// search operator such as "in"
ZmParsedQuery.COND	= "COND";	// AND OR NOT
ZmParsedQuery.GROUP	= "GROUP";	// ( or )

ZmParsedQuery.OP_CONTENT	= "content";

ZmParsedQuery.OP_LIST = [
	"content", "subject", "msgid", "envto", "envfrom", "contact", "to", "from", "cc", "tofrom", 
	"tocc", "fromcc", "tofromcc", "in", "under", "inid", "underid", "has", "filename", "type", 
	"attachment", "is", "date", "mdate", "day", "week", "month", "year", "after", "before", 
	"size", "bigger", "larger", "smaller", "tag", "priority", "message", "my", "modseq", "conv", 
	"conv-count", "conv-minm", "conv-maxm", "conv-start", "conv-end", "appt-start", "appt-end", "author", "title", "keywords", 
	"company", "metadata", "item", "sort"
];
ZmParsedQuery.IS_OP		= AjxUtil.arrayAsHash(ZmParsedQuery.OP_LIST);

// valid arguments for the search term "is:"
ZmParsedQuery.IS_VALUES = [	"unread", "read", "flagged", "unflagged",
							"draft", "sent", "received", "replied", "unreplied", "forwarded", "unforwarded",
							"invite",
							"solo",
							"tome", "fromme", "ccme", "tofromme", "toccme", "fromccme", "tofromccme",
							"local", "remote", "anywhere" ];

// ops that can appear more than once in a query
ZmParsedQuery.MULTIPLE = {};
ZmParsedQuery.MULTIPLE["to"]			= true;
ZmParsedQuery.MULTIPLE["is"]			= true;
ZmParsedQuery.MULTIPLE["has"]			= true;
ZmParsedQuery.MULTIPLE["tag"]			= true;
ZmParsedQuery.MULTIPLE["appt-start"]	= true;
ZmParsedQuery.MULTIPLE["appt-end"]		= true;
ZmParsedQuery.MULTIPLE["type"]			= true;

ZmParsedQuery.isMultiple =
function(term) {
	return Boolean(term && ZmParsedQuery.MULTIPLE[term.op]);
};

// ops that are mutually exclusive
ZmParsedQuery.EXCLUDE = {};
ZmParsedQuery.EXCLUDE["before"]	= ["date"];
ZmParsedQuery.EXCLUDE["after"]	= ["date"];

// values that are mutually exclusive - list value implies full multi-way exclusivity
ZmParsedQuery.EXCLUDE["is"]					= {};
ZmParsedQuery.EXCLUDE["is"]["read"]			= ["unread"];
ZmParsedQuery.EXCLUDE["is"]["flagged"]		= ["unflagged"];
ZmParsedQuery.EXCLUDE["is"]["sent"]			= ["received"];
ZmParsedQuery.EXCLUDE["is"]["replied"]		= ["unreplied"];
ZmParsedQuery.EXCLUDE["is"]["forwarded"]	= ["unforwarded"];
ZmParsedQuery.EXCLUDE["is"]["local"]		= ["remote", "anywhere"];
ZmParsedQuery.EXCLUDE["is"]["tome"]			= ["tofromme", "toccme", "tofromccme"];
ZmParsedQuery.EXCLUDE["is"]["fromme"]		= ["tofromme", "fromccme", "tofromccme"];
ZmParsedQuery.EXCLUDE["is"]["ccme"]			= ["toccme", "fromccme", "tofromccme"];

ZmParsedQuery._createExcludeMap =
function(excludes) {

	var excludeMap = {};
	for (var key in excludes) {
		var value = excludes[key];
		if (AjxUtil.isArray1(value)) {
			value.push(key);
			ZmParsedQuery._permuteExcludeMap(excludeMap, value);
		}
		else {
			for (var key1 in value) {
				var value1 = excludes[key][key1];
				value1.push(key1);
				ZmParsedQuery._permuteExcludeMap(excludeMap, AjxUtil.map(value1,
						function(val) {
							return new ZmSearchToken(key, val).toString();
						}));
			}
		}
	}
	return excludeMap;
};

// makes each possible pair in the list exclusive
ZmParsedQuery._permuteExcludeMap =
function(excludeMap, list) {
	if (list.length < 2) { return; }
	for (var i = 0; i < list.length - 1; i++) {
		var a = list[i];
		for (var j = i + 1; j < list.length; j++) {
			var b = list[j];
			excludeMap[a] = excludeMap[a] || {};
			excludeMap[b] = excludeMap[b] || {};
			excludeMap[a][b] = true;
			excludeMap[b][a] = true;
		}
	}
};

/**
 * Returns true if the given search terms should not appear in the same query.
 * 
 * @param {ZmSearchToken}	termA	search term
 * @param {ZmSearchToken}	termB	search term
 */
ZmParsedQuery.areExclusive =
function(termA, termB) {
	if (!termA || !termB) { return false; }
	var map = ZmParsedQuery.EXCLUDE_MAP;
	if (!map) {
		map = ZmParsedQuery.EXCLUDE_MAP = ZmParsedQuery._createExcludeMap(ZmParsedQuery.EXCLUDE);
	}
	var opA = termA.op, opB = termB.op;
	var strA = termA.toString(), strB = termB.toString();
	return Boolean((map[opA] && map[opA][opB]) || (map[opB] && map[opB][opA]) ||
				   (map[strA] && map[strA][strB]) || (map[strB] && map[strB][strA]));
};

// conditional ops
ZmParsedQuery.COND_AND		= "and"
ZmParsedQuery.COND_OR		= "or";
ZmParsedQuery.COND_NOT		= "not";
ZmParsedQuery.GROUP_OPEN	= "(";
ZmParsedQuery.GROUP_CLOSE	= ")";

// JS version of conditional
ZmParsedQuery.COND_OP = {};
ZmParsedQuery.COND_OP[ZmParsedQuery.COND_AND]	= " && ";
ZmParsedQuery.COND_OP[ZmParsedQuery.COND_OR]	= " || ";
ZmParsedQuery.COND_OP[ZmParsedQuery.COND_NOT]	= " !";

// word separators
ZmParsedQuery.EOW_LIST	= [" ", ":", ZmParsedQuery.GROUP_OPEN, ZmParsedQuery.GROUP_CLOSE];
ZmParsedQuery.IS_EOW	= AjxUtil.arrayAsHash(ZmParsedQuery.EOW_LIST);

// map is:xxx to item properties
ZmParsedQuery.FLAG = {};
ZmParsedQuery.FLAG["unread"]		= "item.isUnread";
ZmParsedQuery.FLAG["read"]			= "!item.isUnread";
ZmParsedQuery.FLAG["flagged"]		= "item.isFlagged";
ZmParsedQuery.FLAG["unflagged"]		= "!item.isFlagged";
ZmParsedQuery.FLAG["forwarded"]		= "item.isForwarded";
ZmParsedQuery.FLAG["unforwarded"]	= "!item.isForwarded";
ZmParsedQuery.FLAG["sent"]			= "item.isSent";
ZmParsedQuery.FLAG["draft"]			= "item.isDraft";
ZmParsedQuery.FLAG["replied"]		= "item.isReplied";
ZmParsedQuery.FLAG["unreplied"]		= "!item.isReplied";

ZmParsedQuery.prototype._parse =
function(query) {

	function getQuotedStr(str, pos, q) {
		var q = q || str.charAt(pos);
		pos++;
		var done = false, ch, quoted = "";
		while (pos < str.length && !done) {
			ch = str.charAt(pos);
			if (ch == q) {
				done = true;
			} else {
				quoted += ch;
				pos++;
			}
		}

		return done ? {str:quoted, pos:pos + 1} : null;
	}
	
	function skipSpace(str, pos) {
		while (pos < str.length && str.charAt(pos) == " ") {
			pos++;
		}
		return pos;
	}
	
	function fail(reason, query) {
		DBG.println(AjxDebug.DBG1, "ZmParsedQuery failure: " + reason + "; query: [" + query + "]");
		this.parseFailed = reason;
		return tokens;		
	}

	var len = query.length;
	var tokens = [], ch, lastCh, op, word = "", isEow = false, endOk = true, compound = 0, numParens = 0;
	var pos = skipSpace(query, 0);
	while (pos < len) {
		lastCh = (ch != " ") ? ch : lastCh;
		ch = query.charAt(pos);
		isEow = ZmParsedQuery.IS_EOW[ch];

		if (ch == ":") {
			if (ZmParsedQuery.IS_OP[word]) {
				op = word;
			} else {
				return fail("unrecognized op '" + word + "'", query);
			}
			word = "";
			pos = skipSpace(query, pos + 1);
			continue;
		}

		if (isEow) {
			var lcWord = word.toLowerCase();
			var isCondOp = !!ZmParsedQuery.COND_OP[lcWord];
			if (op && word && !(isCondOp && compound > 0)) {
				tokens.push(new ZmSearchToken(op, lcWord));
				if (compound == 0) {
					op = "";
				}
				word = "";
				endOk = true;
			} else if (!op || (op && compound > 0)) {
				if (isCondOp) {
					tokens.push(new ZmSearchToken(lcWord));
					endOk = false;
					if (lcWord == ZmParsedQuery.COND_OR) {
						this.hasOrTerm = true;
					}
				} else if (word) {
					tokens.push(new ZmSearchToken(ZmParsedQuery.OP_CONTENT, word));
				}
				word = "";
			}
		}

		if (ch == '"') {
			var results = getQuotedStr(query, pos);
			if (results) {
				word = results.str;
				pos = results.pos;
			} else {
				return fail("improper use of quotes", query);
			}
		} else if (ch == ZmParsedQuery.GROUP_OPEN) {
			var done = false;
			if (compound > 0) {
				compound++;
			}
			else if (lastCh == ":") {
				compound = 1;
				// see if parens are being used as secondary quoting mechanism by looking for and/or
				var inside = query.substr(pos, query.indexOf(ZmParsedQuery.GROUP_CLOSE, pos + 1));
				inside = inside && inside.toLowerCase();
				if (inside && (inside.indexOf(" " + ZmParsedQuery.COND_OR + " ") == -1) &&
							  (inside.indexOf(" " + ZmParsedQuery.COND_AND + " ") == -1)) {
					var results = getQuotedStr(query, pos, ZmParsedQuery.GROUP_CLOSE);
					if (results) {
						word = results.str;
						pos = results.pos;
						compound = 0;
					} else {
						return fail("improper use of paren-based quoting", query);
					}
					done = true;
				}
			}
			if (!done) {
				tokens.push(new ZmSearchToken(ch));
				numParens++;
			}
			pos = skipSpace(query, pos + 1);
		} else if (ch == ZmParsedQuery.GROUP_CLOSE) {
			if (compound > 0) {
				compound--;
			}
			if (compound == 0) {
				op = "";
			}
			tokens.push(new ZmSearchToken(ch));
			pos = skipSpace(query, pos + 1);
		} else if (ch == "-" && !word && !op) {
			tokens.push(new ZmSearchToken(ZmParsedQuery.COND_NOT));
			pos = skipSpace(query, pos + 1);
			endOk = false;
		} else {
			if (ch != " ") {
				word += ch;
			}
			pos++;
		}
	}

	// check for term at end
	if ((pos >= query.length) && op && word) {
		tokens.push(new ZmSearchToken(op, word));
		endOk = true;
	} else if (!op && word) {
		tokens.push(new ZmSearchToken(word));
	}
	
	// remove unnecessary enclosing parens from when a single compound term is expanded, for example when
	// "subject:(foo bar)" is expanded into "(subject:foo subject:bar)"
	if (tokens.length >= 3 && numParens == 1 && tokens[0].op == ZmParsedQuery.GROUP_OPEN &&
			tokens[tokens.length - 1].op == ZmParsedQuery.GROUP_CLOSE) {
		tokens.shift();
		tokens.pop();
	}

	if (!endOk) {
		return fail("unexpected end of query", query);
	}
	
	return tokens;
};

ZmParsedQuery.prototype.getTokens =
function() {
	return this._tokens;
};

ZmParsedQuery.prototype.getNumTokens =
function() {
	return this._tokens ? this._tokens.length : 0;
};

ZmParsedQuery.prototype.getProperties =
function() {
	
	var props = {};
	for (var i = 0, len = this._tokens.length; i < len; i++) {
		var t = this._tokens[i];
		if (t.type == ZmParsedQuery.TERM) {
			var prev = i > 0 ? this._tokens[i-1] : null;
			if (!((prev && prev.op == ZmParsedQuery.COND_NOT) || this.hasOrTerm)) {
				if ((t.op == "in" || t.op == "inid") ) {
					this.folderId = props.folderId = (t.op == "in") ? this._getFolderId(t.arg) : t.arg;
				} else if (t.op == "tag") {
					// TODO: make sure there's only one tag term?
					this.tagId = props.tagId = this._getTagId(t.arg, true);
				}
			}
		}
	}
	return props;
};

/**
 * Returns a function based on the parsed query. The function is passed an item (msg or conv) and returns
 * true if the item matches the search.
 * 
 * @return {Function}	the match function
 */
ZmParsedQuery.prototype.getMatchFunction =
function() {
	
	if (this._matchFunction) {
		return this._matchFunction;
	}
	if (this.parseFailed || this.hasTerm(ZmParsedQuery.OP_CONTENT)) {
		return null;
	}
	
	var folderId, tagId;
	var func = ["return Boolean("];
	for (var i = 0, len = this._tokens.length; i < len; i++) {
		var t = this._tokens[i];
		if (t.type === ZmParsedQuery.TERM) {
			if (t.op === "in" || t.op === "inid") {
				folderId = (t.op === "in") ? this._getFolderId(t.arg) : t.arg;
				if (folderId) {
					func.push("((item.type === ZmItem.CONV) ? item.folders && item.folders['" + folderId +"'] : item.folderId === '" + folderId + "')");
				}
			}
			else if (t.op === "tag") {
				tagId = this._getTagId(t.arg, true);
				if (tagId) {
					func.push("item.hasTag('" + t.arg + "')");
				}
			}
			else if (t.op === "is") {
				var test = ZmParsedQuery.FLAG[t.arg];
				if (test) {
					func.push(test);
				}
			}
			else if (t.op === 'has' && t.arg === 'attachment') {
				func.push("item.hasAttach");
			}
			else {
				// search had a term we don't know how to match
				return null;
			}
			var next = this._tokens[i + 1];
			if (next && (next.type == ZmParsedQuery.TERM || next == ZmParsedQuery.COND_OP[ZmParsedQuery.COND_NOT] || next == ZmParsedQuery.GROUP_CLOSE)) {
				func.push(ZmParsedQuery.COND_OP[ZmParsedQuery.COND_AND]);
			}
		}
		else if (t.type === ZmParsedQuery.COND) {
			func.push(ZmParsedQuery.COND_OP[t.op]);
		}
		else if (t.type === ZmParsedQuery.GROUP) {
			func.push(t.op);
		}
	}
	func.push(")");

	// the way multi-account searches are done, we set the queryHint *only* so
	// set the folderId if it exists for simple multi-account searches
	// TODO: multi-acct part seems wrong; search with many folders joined by OR would incorrectly set folderId to last folder
	var isMultiAccountSearch = (appCtxt.multiAccounts && this.isMultiAccount() && !this.query && this.queryHint);
	if (!this.hasOrTerm || isMultiAccountSearch) {
		this.folderId = folderId;
		this.tagId = tagId;
	}
	
	try {
		this._matchFunction = new Function("item", func.join(""));
	} catch(ex) {}
	
	return this._matchFunction;
};

/**
 * Returns a query string that should be logically equivalent to the original query.
 */
ZmParsedQuery.prototype.createQuery =
function() {
	var terms = [];
	for (var i = 0, len = this._tokens.length; i < len; i++) {
		terms.push(this._tokens[i].toString());
	}
	return terms.join(" ");
};

// Returns the fully-qualified ID for the given folder path.
ZmParsedQuery.prototype._getFolderId =
function(path) {
	// first check if it's a system folder (name in query string may not match actual name)
	var folderId = ZmFolder.QUERY_ID[path];

	var accountName = this.accountName;
	if (!accountName) {
		var active = appCtxt.getActiveAccount();
		accountName = active ? active.name : appCtxt.accountList.mainAccount;
	}

	// now check all folders by name
	if (!folderId) {
		var account = accountName && appCtxt.accountList.getAccountByName(accountName);
		var folders = appCtxt.getFolderTree(account);
		var folder = folders ? folders.getByPath(path, true) : null;
		if (folder) {
			folderId = folder.id;
		}
	}

	if (accountName) {
		folderId = ZmOrganizer.getSystemId(folderId, appCtxt.accountList.getAccountByName(accountName));
	}

	return folderId;
};

// Returns the ID for the given tag name.
ZmParsedQuery.prototype._getTagId =
function(name, normalized) {
	var tagTree = appCtxt.getTagTree();
	if (tagTree) {
		var tag = tagTree.getByName(name.toLowerCase());
		if (tag) {
			return normalized ? tag.nId : tag.id;
		}
	}
	return null;
};

/**
 * Gets the given term with the given argument. Case-insensitive. Returns the first term found.
 * 
 * @param	{array}		opList		list of ops 
 * @param	{string}	value		argument value (optional)
 * 
 * @return	{object}	a token object, or null
 */
ZmParsedQuery.prototype.getTerm =
function(opList, value) {
	var opHash = AjxUtil.arrayAsHash(opList);
	var lcValue = value && value.toLowerCase();
	for (var i = 0, len = this._tokens.length; i < len; i++) {
		var t = this._tokens[i];
		var lcArg = t.arg && t.arg.toLowerCase();
		if (t.type == ZmParsedQuery.TERM && opHash[t.op] && (!value || lcArg == lcValue)) {
			return t;
		}
	}
	return null;
};

/**
 * Returns true if the query contains the given term with the given argument. Case-insensitive.
 * 
 * @param	{array}		opList		list of ops 
 * @param	{string}	value		argument value (optional)
 * 
 * @return	{boolean}	true if the query contains the given term with the given argument
 */
ZmParsedQuery.prototype.hasTerm =
function(opList, value) {
	return Boolean(this.getTerm(opList, value));
};

/**
 * Replaces the argument within the query for the given ops, if found. Case-insensitive. Replaces
 * only the first match.
 * 
 * @param	{array}		opList		list of ops 
 * @param	{string}	oldValue	the old argument
 * @param	{string}	newValue	the new argument
 * 
 * @return	{string}	a new query string (if the old argument was found and replaced), or the empty string
 */
ZmParsedQuery.prototype.replaceTerm =
function(opList, oldValue, newValue) {
	var lcValue = oldValue && oldValue.toLowerCase();
	var opHash = AjxUtil.arrayAsHash(opList);
	if (oldValue && newValue) {
		for (var i = 0, len = this._tokens.length; i < len; i++) {
			var t = this._tokens[i];
			var lcArg = t.arg && t.arg.toLowerCase();
			if (t.type == ZmParsedQuery.TERM && opHash[t.op] && (lcArg == lcValue)) {
				t.arg = newValue;
				return this.createQuery();
			}
		}
	}
	return "";
};

/**
 * This class represents one unit of a search query. That may be a search term ("is:unread"),
 * and conditional operator (AND, OR, NOT), or a grouping operator (left or right paren).
 * 
 * @param {string}	op		operator
 * @param {string}	arg		argument part of search term
 */
ZmSearchToken = function(op, arg) {
	
	if (op && arguments.length == 1) {
		var parts = op.split(":");
		op = parts[0];
		arg = parts[1];
	}
	
	this.op = op;
	this.arg = arg;
	if (ZmParsedQuery.IS_OP[op] && arg) {
		this.type = ZmParsedQuery.TERM;
	}
	else if (op && ZmParsedQuery.COND_OP[op.toLowerCase()]) {
		this.type = ZmParsedQuery.COND;
		this.op = op.toLowerCase();
	}
	else if (op == ZmParsedQuery.GROUP_OPEN || op == ZmParsedQuery.GROUP_CLOSE) {
		this.type = ZmParsedQuery.GROUP;
	} else if (op) {
		this.type = ZmParsedQuery.TERM;
		this.op = ZmParsedQuery.OP_CONTENT;
		this.arg = op;
	}
};

ZmSearchToken.prototype.isZmSearchToken = true;

/**
 * Returns the string version of this token.
 * 
 * @param {boolean}		force		if true, return "and" instead of an empty string ("and" is implied)
 */
ZmSearchToken.prototype.toString =
function(force) {
	if (this.type == ZmParsedQuery.TERM) {
		var arg = this.arg;
		if (this.op == ZmParsedQuery.OP_CONTENT) {
			return /\W/.test(arg) ? '"' + arg.replace(/"/g, '\\"') + '"' : arg;
		}
		else {
			// quote arg if it has any spaces and is not already quoted
			arg = (arg && (arg.indexOf('"') !== 0) && arg.indexOf(" ") != -1) ? '"' + arg + '"' : arg;
			return [this.op, arg].join(":");
		}
	}
	else {
		return (!force && this.op == ZmParsedQuery.COND_AND) ? "" : this.op;
	}
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmSearchResult")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the search result class.
 */

/**
 * Creates the search result
 * @class
 * This class represents a search result.
 * 
 * @param	{ZmSearch}	search		the search
 */
ZmSearchResult = function(search) {
	if (!search) { return; }
	this._results = {};
	this.search = search;
	this.type = search.searchFor;
};

ZmSearchResult.prototype.isZmSearchResult = true;
ZmSearchResult.prototype.toString = function() { return "ZmSearchResult"; };

/**
 * Gets the results.
 * 
 * @param	{constant}	type	the type
 * @return	{Array}	an array of results
 */
ZmSearchResult.prototype.getResults =
function(type) {

	type = type || this.type;
	if (!this._results) {
		// probably got an exception - return an empty list
		return this._getResultsList(type);
	} else if (this.search.idsOnly) {
		return this._results;
	} else {
		// if we don't have results for the requested type, the search was probably for the wrong type
		return this._results[type] ? this._results[type] : type && this._getResultsList(type);
	}
};

/**
 * Gets the attribute.
 * 
 * @param	{String}	name		the attribute name
 * @return	{Object}	the attribute
 */
ZmSearchResult.prototype.getAttribute = 
function(name) {
	return this._respEl ? this._respEl[name] : null;
};

/**
 * Sets the response.
 * 
 * @private
 */
ZmSearchResult.prototype.set =
function(respEl) {

	if (!this.search) { return; }

	this._respEl = respEl;

	// <match> objects are returned for autocomplete search, not items; let caller handle them
	if (this.search.isAutocompleteSearch) { return; }

	var foundType = {};
	var numTypes = 0;
	var currentType, defaultType;
	var isGalSearch = this.search.isGalSearch;
	
	var _st = new Date();
	var count = 0;
	if (isGalSearch || this.search.isCalResSearch) {
		// process JS eval result for SearchGalRequest
		currentType = defaultType = isGalSearch ? ZmItem.CONTACT : ZmItem.RESOURCE;
		var data = isGalSearch ? respEl.cn : respEl.calresource;
		if (data) {
			if (!this._results[currentType]) {
				// create list as needed - may invoke package load
				this._results[currentType] =  this._getResultsList(currentType);
			}
			for (var j = 0; j < data.length; j++) {
				this._results[currentType].addFromDom(data[j]);
			}

			// manually sort gal results since server won't do it for us :(
			if (isGalSearch) {
				this._results[currentType].getArray().sort(ZmSearchResult._sortGalResults)
			}
			count = data.length;
		}
	} else if (this.search.idsOnly) {
		this._results = respEl.hit || [];
		return;
	} else {
		// process JS eval result for SearchResponse
		var types = this.search.types.getArray();
		defaultType = types[0];

		// bug fix #44232 - resolve default type if none provided
		if (!defaultType) {
			var allTypes = AjxUtil.values(ZmList.NODE);
			for (var i = 0; i < allTypes.length; i++) {
				var t = allTypes[i];
				if (respEl[t]) {
					defaultType = ZmList.ITEM_TYPE[t];
					if (types && types.length == 0) {
						types = [defaultType];
					}
					break;
				}
			}
		}

		if (!defaultType) {
			var curApp = appCtxt.getCurrentAppName();
			var types = ZmApp.SEARCH_TYPES[curApp];
			defaultType = types && types.length && types[0];
		}

		for (var i = 0; i < types.length; i++) {
			var type = types[i];
			var data = respEl[ZmList.NODE[type]];

			// A chat isa message. Futz with the types to deal with this.
			// (Eventually we'll avoid this problem by displying chat history in im app.)
			if (!data && (type == ZmItem.MSG)) {
				data = respEl["chat"];
			}
			// Likewise, a Resource is a Contact. Futz with the types to deal with this.
			if (!data && (type == ZmItem.RESOURCE)) {
				data = respEl[ZmList.NODE[ZmItem.CONTACT]];
			}

			// do a bunch of sanity checks
			if (data && data.length) {
				count += data.length;
				if (!this._results[type]) {
					// create list as needed - may invoke package load
					this._results[type] = this._getResultsList(type);
				}
				for (var j = 0; j < data.length; j++) {
					var item = data[j];
					item._type = type;
					this._results[type].addFromDom(item);
				}

				if (!foundType[type]) {
					foundType[type] = true;
					numTypes++;
					currentType = type;
				}
			}
		}
	}
	if (!count && defaultType) {
		this._results[defaultType] = this._getResultsList(defaultType);
	}
	if ((isGalSearch || this.search.isGalAutocompleteSearch) && this._results[ZmItem.CONTACT]) {
		this._results[ZmItem.CONTACT].setIsGal(true);
	}
	if (this.search.isGalAutocompleteSearch) {
		this.isTokenized = (this._respEl.tokenizeKey != null);
	}
	
	var _en = new Date();
	DBG.println(AjxDebug.DBG1, "TOTAL PARSE TIME for " + count + " NODES: " + (_en.getTime() - _st.getTime()));

	currentType = currentType || defaultType;
	if (numTypes <= 1) {
		this.type = currentType;
	}

	return this.type;
};

/**
 * @private
 */
ZmSearchResult._sortGalResults =
function(a, b) {
	var af = a.getFileAs && a.getFileAs().toLowerCase();
	var bf = b.getFileAs && b.getFileAs().toLowerCase();
	return af < bf ? -1 : (af > bf ? 1 : 0);
};

ZmSearchResult.prototype._getResultsList =
function(type) {

	if (type && typeof(ZmItem.RESULTS_LIST[type]) === "function") {
		return ZmItem.RESULTS_LIST[type](this.search);
	} else {
		DBG.println(
			AjxDebug.DBG1,
			AjxMessageFormat.format(
				"!type || ZmItem.RESULTS_LIST[type] !== function. Active app: {0}, type: {1}, searchFor: {2}.",
				[appCtxt.getCurrentAppName(), type, this.search.searchFor]
			)
		);
		return new ZmList(type, this.search);
	}

};

}
if (AjxPackage.define("zimbraMail.share.model.ZmTree")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the tree class
 */

/**
 * Creates the tree
 * @class
 * This class represents a tree.
 * 
 * @param	{constant}	type		the type
 * @extends	ZmModel
 */
ZmTree = function(type) {

	if (arguments.length == 0) { return; }
	ZmModel.call(this, type);

	this.type = type;
	this.root = null;
};

ZmTree.prototype = new ZmModel;
ZmTree.prototype.constructor = ZmTree;

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmTree.prototype.toString = 
function() {
	return "ZmTree";
};

/**
 * Gets this tree as a string.
 * 
 * @return	{String}	the tree
 */
ZmTree.prototype.asString = 
function() {
	return this.root ? this._asString(this.root, "") : "";
};

/**
 * Gets the item by id.
 * 
 * @param	{String}	id		the id
 * @return	{Object}	the item
 */
ZmTree.prototype.getById =
function(id) {
	return this.root ? this.root.getById(id) : null;
};

/**
 * Gets the item by name.
 * 
 * @param	{String}	name		the name
 * @return	{Object}	the item
 */
ZmTree.prototype.getByName =
function(name) {
	return this.root ? this.root.getByName(name) : null;
};

/**
 * Gets the item type by name.
 *
 * @param	{String}	name		the name
 * @return	{String}    type of folder
 */
//Bug:47848: new method that returns type of the item given its name
ZmTree.prototype.getFolderTypeByName =
function(name){

    //As folder names are case-insensitive
    var formattedName = name.toLowerCase();

    //Iterate through folders of loaded apps
    var folderList = appCtxt.getTree(ZmOrganizer.FOLDER).asList();
    var type;
    var i;
    for(i=0 ; i < folderList.length ; i ++){
        var currentName = folderList[i].name;
        if(formattedName == currentName.toLowerCase()){
            return folderList[i].type;
        }
    }

    // check for _deferredFolders in the apps that have not been loaded
    var apps = ZmApp.APPS;

    for(i=0 ; i<apps.length; i++){
       var currentApp = appCtxt.getApp(apps[i]);
       var deferredFolders = currentApp && currentApp._deferredFolders;
       if(!deferredFolders){
           continue;
       }
       var j;
       for(j=0 ; j < deferredFolders.length ; j++){
           var currentFolder = deferredFolders[j];
           var currentName = currentFolder.obj && currentFolder.obj.name;
            if(formattedName == currentName.toLowerCase()){
                return currentFolder.type;
            }
       }

    }
    // if still not found return type as "Folder"
    type = ZmOrganizer.FOLDER;
    return type;
}

/**
 * Gets the item by type.
 * 
 * @param	{String}	name		the type name
 * @return	{Object}	the item
 */
ZmTree.prototype.getByType =
function(name) {
	return this.root ? this.root.getByType(name) : null;
};

/**
 * Gets the size of the tree.
 * 
 * @return	{int}	the size
 */
ZmTree.prototype.size =
function() {
	return this.root ? this.root.size() : 0;
};

/**
 * Resets the tree.
 */
ZmTree.prototype.reset =
function() {
	this.root = null;
};

/**
 * Gets the tree as a list.
 * 
 * @return	{Array}	an array
 */
ZmTree.prototype.asList =
function(options) {
	var list = [];
	return this.root ? this._addToList(this.root, list, options) : list;
};

/**
 * Gets the unread hash.
 * 
 * @param	{Hash}	unread		the unread hash
 * @return	{Hash} the unread tree as a hash
 */
ZmTree.prototype.getUnreadHash =
function(unread) {
	if (!unread) {
		unread = {};
	}
	return this.root ? this._getUnreadHash(this.root, unread) : unread;
};

/**
 * @private
 */
ZmTree.prototype._addToList =
function(organizer, list, options) {
	var incRemote = options && options.includeRemote;
	var remoteOnly = options && options.remoteOnly;
	var isRemote = organizer.isRemote();
	if ((!isRemote && !remoteOnly) || (isRemote && (remoteOnly || incRemote))) {
		list.push(organizer);
	}
	var children = organizer.children.getArray();
    for (var i = 0; i < children.length; i++) {
        this._addToList(children[i], list, options);
    }
	return list;
};

/**
 * @private
 */
ZmTree.prototype._asString =
function(organizer, str) {
	if (organizer.id) {
		str = str + organizer.id;
	}
	var children = organizer.children.clone().getArray();
	if (children.length) {
		children.sort(function(a,b){return a.id - b.id;});
		str = str + "[";
		for (var i = 0; i < children.length; i++) {
			if (children[i].id == ZmFolder.ID_TAGS) { // Tags "folder" added when view is set
				continue;
			}
			if (i > 0) {
				str = str + ",";
			}
			str = this._asString(children[i], str);
		}
		str = str + "]";
	}
	return str;
};

/**
 * @private
 */
ZmTree.prototype._getUnreadHash =
function(organizer, unread) {
	unread[organizer.id] = organizer.numUnread;
	var children = organizer.children.getArray();
	for (var i = 0; i < children.length; i++) {
		this._getUnreadHash(children[i], unread);
	}

	return unread;
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmFolderTree")) {
	/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines a folder tree.
 *
 */

/**
 * Creates an empty folder tree.
 * @class
 * This class represents a tree of folders. It may be typed, in which case
 * the folders are all of that type, or untyped.
 * 
 * @author Conrad Damon
 * 
 * @param {constant}	type		the organizer type
 * 
 * @extends	ZmTree
 */
ZmFolderTree = function(type) {
	ZmTree.call(this, type);
};

ZmFolderTree.prototype = new ZmTree;
ZmFolderTree.prototype.constructor = ZmFolderTree;


// Consts
ZmFolderTree.IS_PARSED = {};


// Public Methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmFolderTree.prototype.toString =
function() {
	return "ZmFolderTree";
};

/**
 * Loads the folder or the zimlet tree.
 * 
 * @param	{Object}		rootObj		the root object
 * @param	{String}		elementType		the element type
 * @param	{ZmZimbraAccount}		account		the account
 */
ZmFolderTree.prototype.loadFromJs =
function(rootObj, elementType, account) {
	this.root = (elementType == "zimlet")
		? ZmZimlet.createFromJs(null, rootObj, this)
		: ZmFolderTree.createFromJs(null, rootObj, this, elementType, null, account);
};

/**
 * Generic function for creating a folder. Handles any organizer type that comes
 * in the folder list.
 * 
 * @param {ZmFolder}	parent		the parent folder
 * @param {Object}	obj			the JSON with folder data
 * @param {ZmFolderTree}	tree			the containing tree
 * @param {String}	elementType		the type of containing JSON element
 * @param {Array}	path			the list of path elements
 * @param {ZmZimbraAccount}	account		the account this folder belongs to
 */
ZmFolderTree.createFromJs =
function(parent, obj, tree, elementType, path, account) {
	if (!(obj && obj.id)) { return; }

	var folder;
	if (elementType == "search") {
		var types;
		var idParts = obj.id.split(":");
		// Suppress display of searches for the shared mailbox (See Bug 96090) - it will have an id
		// of the form 'uuid:id'.  Local searches will just have 'id'
		if (!idParts || (idParts.length <= 1)) {
			if (obj.types) {
				var t = obj.types.split(",");
				types = [];
				var mailEnabled = appCtxt.get(ZmSetting.MAIL_ENABLED);
				for (var i = 0; i < t.length; i++) {
					var type = ZmSearch.TYPE_MAP[t[i]];
					if (!type || (!mailEnabled && (type == ZmItem.CONV || type == ZmItem.MSG))) {
						continue;
					}
					types.push(type);
				}
				if (types.length == 0) {
					return null;
				}
			}
			DBG.println(AjxDebug.DBG2, "Creating SEARCH with id " + obj.id + " and name " + obj.name);
			var params = {
				id: obj.id,
				name: obj.name,
				parent: parent,
				tree: tree,
				numUnread: obj.u,
				query: obj.query,
				types: types,
				sortBy: obj.sortBy,
				account: account,
				color: obj.color,
				rgb: obj.rgb
			};
			folder = new ZmSearchFolder(params);
			ZmFolderTree._fillInFolder(folder, obj, path);
			ZmFolderTree._traverse(folder, obj, tree, (path || []), elementType, account);
		}
	} else {
		var type = obj.view
			? (ZmOrganizer.TYPE[obj.view])
			: (parent ? parent.type : ZmOrganizer.FOLDER);

		if (!type) {
			DBG.println(AjxDebug.DBG1, "No known type for view " + obj.view);
			return;
		}
		// let's avoid deferring folders for offline since multi-account folder deferring is hairy
		var hasGrants = (obj.acl && obj.acl.grant && obj.acl.grant.length > 0);
		if (appCtxt.inStartup && ZmOrganizer.DEFERRABLE[type] && !appCtxt.isOffline) {
			var app = appCtxt.getApp(ZmOrganizer.APP[type]);
			var defParams = {
				type:			type,
				parent:			parent,
				obj:			obj,
				tree:			tree,
				path:			path,
				elementType:	elementType,
				account:		account
			};
			app.addDeferredFolder(defParams);
		} else {
			var pkg = ZmOrganizer.ORG_PACKAGE[type];
			if (pkg) {
				AjxDispatcher.require(pkg);
			}
			folder = ZmFolderTree.createFolder(type, parent, obj, tree, path, elementType, account);
            if (appCtxt.isExternalAccount() && folder.isSystem() && folder.id != ZmOrganizer.ID_ROOT) { return; }
			ZmFolderTree._traverse(folder, obj, tree, (path || []), elementType, account);
		}
	}

	return folder;
};

ZmFolderTree.createAllDeferredFolders =
function() {
	var ac = appCtxt.getAppController();
	for (var appId in ZmApp.ORGANIZER) {
		var app = ac.getApp(appId);
		app.createDeferred();
	}
};

/**
 * @private
 */
ZmFolderTree._traverse =
function(folder, obj, tree, path, elementType, account) {

	var isRoot = (folder.nId == ZmOrganizer.ID_ROOT);
	if (obj.folder && obj.folder.length) {
		if (!isRoot) {
			path.push(obj.name);
		}
		for (var i = 0; i < obj.folder.length; i++) {
			var folderObj = obj.folder[i];
			var childFolder = ZmFolderTree.createFromJs(folder, folderObj, tree, (elementType || "folder"), path, account);
			if (folder && childFolder) {
				folder.children.add(childFolder);
			}
		}
		if (!isRoot) {
			path.pop();
		}
	}
	
	if (obj.search && obj.search.length) {
		if (!isRoot) {
			path.push(obj.name);
		}
		for (var i = 0; i < obj.search.length; i++) {
			var searchObj = obj.search[i];
			var childSearch = ZmFolderTree.createFromJs(folder, searchObj, tree, "search", path, account);
			if (childSearch) {
				folder.children.add(childSearch);
			}
		}
		if (!isRoot) {
			path.pop();
		}
	}

	if (obj.link && obj.link.length) {
		for (var i = 0; i < obj.link.length; i++) {
			var link = obj.link[i];
			var childFolder = ZmFolderTree.createFromJs(folder, link, tree, "link", path, account);
			if (childFolder) {
				folder.children.add(childFolder);
			}
		}
	}
};

/**
 * Creates the folder.
 * 
 * @param {String}	type		the folder type
 * @param {ZmFolder}	parent		the parent folder
 * @param {Object}	obj			the JSON with folder data
 * @param {ZmFolderTree}	tree			the containing tree
 * @param {Array}	path			the list of path elements
 * @param {String}	elementType		the type of containing JSON element
 * @param {ZmZimbraAccount}	account		the account this folder belongs to
 */
ZmFolderTree.createFolder =
function(type, parent, obj, tree, path, elementType, account) {
	var orgClass = eval(ZmOrganizer.ORG_CLASS[type]);
	if (!orgClass) { return null; }

	DBG.println(AjxDebug.DBG2, "Creating " + type + " with id " + obj.id + " and name " + obj.name);

	var params = {
		id: 		obj.id,
		name: 		obj.name,
		parent: 	parent,
		tree: 		tree,
		color: 		obj.color,
		rgb:		obj.rgb,
		owner: 		obj.owner,
		oname: 		obj.oname,
		zid: 		obj.zid,
		rid: 		obj.rid,
		restUrl: 	obj.rest,
		url: 		obj.url,
		numUnread: 	obj.u,
		numTotal: 	obj.n,
		sizeTotal: 	obj.s,
		perm: 		obj.perm,
		link: 		elementType == "link",
		broken: 	obj.broken,
		account:	account,
        webOfflineSyncDays : obj.webOfflineSyncDays,
        retentionPolicy: obj.retentionPolicy
	};

	var folder = new orgClass(params);
	ZmFolderTree._fillInFolder(folder, obj, path);
	ZmFolderTree.IS_PARSED[type] = true;

	return folder;
};

/**
 * @private
 */
ZmFolderTree._fillInFolder =
function(folder, obj, path) {
	if (path && path.length) {
		folder.path = path.join("/");
	}

	if (obj.f && folder._parseFlags) {
		folder._parseFlags(obj.f);
	}

	folder._setSharesFromJs(obj);
};

/**
 * Gets the folder by type.
 * 
 * @param	{String}	type	the type
 * @return	{ZmFolder}	the folder or <code>null</code> if not found
 */
ZmFolderTree.prototype.getByType =
function(type) {
	return this.root ? this.root.getByType(type) : null;
};

/**
 * Gets the folder by path.
 * 
 * @param	{String}	path	the path
 * @param	{Boolean}	useSystemName		<code>true</code> to use the system name
 * @return	{ZmFolder}	the folder or <code>null</code> if not found
 */
ZmFolderTree.prototype.getByPath =
function(path, useSystemName) {
	return this.root ? this.root.getByPath(path, useSystemName) : null;
};

/**
 * Handles a missing link by marking its organizer as not there, redrawing it in
 * any tree views, and asking to delete it.
 *
 * @param {int}	organizerType		the type of organizer (constants defined in {@link ZmOrganizer})
 * @param {String}	zid			the zid of the missing folder
 * @param {String}	rid			the rid of the missing folder
 * @return	{Boolean}	<code>true</code> if the error is handled
 */
ZmFolderTree.prototype.handleNoSuchFolderError =
function(organizerType, zid, rid) {
	var items = this.getByType(organizerType);

	var treeView;
	var handled = false;
	if (items) {
		for (var i = 0; i < items.length; i++) {
			if ((items[i].zid == zid) && (items[i].rid == rid)) {
				// Mark that the item is not there any more.
				items[i].noSuchFolder = true;

				// Change its appearance in the tree.
				if (!treeView) {
					var overviewId = appCtxt.getAppController().getOverviewId();
					treeView = appCtxt.getOverviewController().getTreeView(overviewId, organizerType);
				}
				var node = treeView.getTreeItemById(items[i].id);
				node.setText(items[i].getName(true));

				// Ask if it should be deleted now.
				this.handleDeleteNoSuchFolder(items[i]);
				handled = true;
			}
		}
	}
	return handled;
};

/**
 * Handles no such folder. The user will be notified that a linked organizer generated a "no such folder",
 * error, giving the user a chance to delete the folder.
 *
 * @param {ZmOrganizer}	organizer	the organizer
 */
ZmFolderTree.prototype.handleDeleteNoSuchFolder =
function(organizer) {
	var ds = appCtxt.getYesNoMsgDialog();
	ds.reset();
	ds.registerCallback(DwtDialog.YES_BUTTON, this._deleteOrganizerYesCallback, this, [organizer, ds]);
	ds.registerCallback(DwtDialog.NO_BUTTON, appCtxt.getAppController()._clearDialog, this, ds);
	var msg = AjxMessageFormat.format(ZmMsg.confirmDeleteMissingFolder, AjxStringUtil.htmlEncode(organizer.getName(false, 0, true)));
	ds.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
	ds.popup();
};

/**
 * Handles the "Yes" button in the delete organizer dialog.
 * 
 * @param	{ZmOrganizer}	organizer		the organizer
 * @param	{ZmDialog}		dialog		the dialog
 */
ZmFolderTree.prototype._deleteOrganizerYesCallback =
function(organizer, dialog) {
	organizer._delete();
	appCtxt.getAppController()._clearDialog(dialog);
};

/**
 * Issues a <code>&lt;BatchRequest&gt;</code> of <code>&lt;GetFolderRequest&gt;</code>s for existing
 * mountpoints that do not have permissions set.
 *
 * @param	{Hash}	params	a hash of parameters
 * @param {int}	params.type			the {@link ZmItem} type constant
 * @param {AjxCallback}	params.callback			the callback to trigger after fetching permissions
 * @param {Boolean}	params.skipNotify		<code>true</code> to skip notify after fetching permissions
 * @param {Array}	params.folderIds			the list of folder Id's to fetch permissions for
 * @param {Boolean}	params.noBusyOverlay		<code>true</code> to not block the UI while fetching permissions
 * @param {String}	params.accountName		the account to issue request under
 */
ZmFolderTree.prototype.getPermissions =
function(params) {
	var needPerms = params.folderIds || this._getItemsWithoutPerms(params.type);

	// build batch request to get all permissions at once
	if (needPerms.length > 0) {
		var soapDoc = AjxSoapDoc.create("BatchRequest", "urn:zimbra");
		soapDoc.setMethodAttribute("onerror", "continue");

		var doc = soapDoc.getDoc();
		for (var j = 0; j < needPerms.length; j++) {
			var folderRequest = soapDoc.set("GetFolderRequest", null, null, "urn:zimbraMail");
			var folderNode = doc.createElement("folder");
			folderNode.setAttribute("l", needPerms[j]);
			folderRequest.appendChild(folderNode);
		}

		var respCallback = new AjxCallback(this, this._handleResponseGetShares, [params.callback, params.skipNotify]);
		appCtxt.getRequestMgr().sendRequest({
			soapDoc: soapDoc, 
			asyncMode: true,
			callback: respCallback,
			noBusyOverlay: params.noBusyOverlay,
			accountName: params.accountName
		});
	} else {
		if (params.callback) {
			params.callback.run();
		}
	}
};

/**
 * @private
 */
ZmFolderTree.prototype._getItemsWithoutPerms =
function(type) {
	var needPerms = [];
	var orgs = type ? [type] : [ZmOrganizer.FOLDER, ZmOrganizer.CALENDAR, ZmOrganizer.TASKS, ZmOrganizer.BRIEFCASE, ZmOrganizer.ADDRBOOK];

	for (var j = 0; j < orgs.length; j++) {
		var org = orgs[j];
		if (!ZmFolderTree.IS_PARSED[org]) { continue; }

		var items = this.getByType(org);

		for (var i = 0; i < items.length; i++) {
			if (items[i].link && items[i].shares == null) {
				needPerms.push(items[i].id);
			}
		}
	}

	return needPerms;
};

/**
 * @private
 */
ZmFolderTree.prototype._handleResponseGetShares =
function(callback, skipNotify, result) {
	var batchResp = result.getResponse().BatchResponse;
	this._handleErrorGetShares(batchResp);

	var resp = batchResp.GetFolderResponse;
	if (resp) {
		for (var i = 0; i < resp.length; i++) {
			var link = resp[i].link ? resp[i].link[0] : null;
			if (link) {
				var mtpt = appCtxt.getById(link.id);
				if (mtpt) {
					// update the mtpt perms with the updated link perms
					mtpt.perm = link.perm;
                    if (link.n) mtpt.numTotal=link.n;
                    if (link.u) mtpt.numUnread=link.u;
					mtpt._setSharesFromJs(link);
				}

				if (link.folder && link.folder.length > 0) {
					var parent = appCtxt.getById(link.id);
					if (parent) {
						// TODO: only goes one level deep - should we recurse?
						for (var j = 0; j < link.folder.length; j++) {
							if (appCtxt.getById(link.folder[j].id)) { continue; }
							parent.notifyCreate(link.folder[j], "link", skipNotify);
						}
					}
				}
			}
		}
	}

	if (callback) {
		callback.run();
	}
};

/**
 * Handles errors that come back from the GetShares batch request.
 *
 * @param {Array}	organizerTypes	the types of organizer (constants defined in {@link ZmOrganizer})
 * @param {Object}	batchResp			the response
 *
 */
ZmFolderTree.prototype._handleErrorGetShares =
function(batchResp) {
	var faults = batchResp.Fault;
	if (faults) {
		var rids = [];
		var zids = [];
		for (var i = 0, length = faults.length; i < length; i++) {
			var ex = ZmCsfeCommand.faultToEx(faults[i]);
			if (ex.code == ZmCsfeException.MAIL_NO_SUCH_FOLDER) {
				var itemId = ex.data.itemId[0];
				var index = itemId.lastIndexOf(':');
				zids.push(itemId.substring(0, index));
				rids.push(itemId.substring(index + 1, itemId.length));
			}
		}
		if (zids.length) {
			this._markNoSuchFolder(zids, rids);
		}
	}
};

/**
 * Handles missing links by marking the organizers as not there
 *
 * @param {Array}	zids		the zids of the missing folders
 * @param {Array}	rids		the rids of the missing folders. rids and zids must have the same length
 *
 */
ZmFolderTree.prototype._markNoSuchFolder =
function(zids, rids) {
	var treeData = appCtxt.getFolderTree();
	var items = treeData && treeData.root
		? treeData.root.children.getArray()
		: null;

	for (var i = 0; i < items.length; i++) {
		for (var j = 0; j < rids.length; j++) {
			if ((items[i].zid == zids[j]) && (items[i].rid == rids[j])) {
				items[i].noSuchFolder = true;
			}
		}
	}
};

/**
 * @private
 */
ZmFolderTree.prototype._sortFolder =
function(folder) {
	var children = folder.children;
	if (children && children.length) {
		children.sort(ZmFolder.sortCompare);
		for (var i = 0; i < children.length; i++)
			this._sortFolder(children[i]);
	}
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmList")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines a list of items.
 */

/**
 * Creates an empty list of items of the given type.
 * @class
 * This class represents a list of items ({@link ZmItem} objects). Any SOAP method that can be
 * applied to a list of item IDs is represented here, so that we can perform an action
 * on multiple items with just one CSFE call. For the sake of convenience, a hash 
 * matching item IDs to items is maintained. Items are assumed to have an 'id'
 * property.
 * <br/>
 * <br/>
 * The calls are made asynchronously. We are assuming that any action taken will result
 * in a notification, so the action methods generally do not have an async callback 
 * chain and thus are leaf nodes. An exception is moving conversations. We don't
 * know enough from the ensuing notifications (which only indicate that messages have
 * moved), we need to update the UI based on the response.
 *
 * @author Conrad Damon
 * 
 * @param {constant}	type		the item type
 * @param {ZmSearch}	search	the search that generated this list
 * 
 * @extends	ZmModel
 */
ZmList = function(type, search) {

	if (arguments.length == 0) return;
	ZmModel.call(this, type);

	this.type = type;
	this.search = search;
	
	this._vector = new AjxVector();
	this._hasMore = false;
	this._idHash = {};

	var tagList = appCtxt.getTagTree();
	if (tagList) {
		this._tagChangeListener = new AjxListener(this, this._tagTreeChangeListener);
		tagList.addChangeListener(this._tagChangeListener);
	}
	
	this.id = "LIST" + ZmList.NEXT++;
	appCtxt.cacheSet(this.id, this);
};

ZmList.prototype = new ZmModel;
ZmList.prototype.constructor = ZmList;

ZmList.prototype.isZmList = true;
ZmList.prototype.toString = function() { return "ZmList"; };


ZmList.NEXT = 1;

// for item creation
ZmList.ITEM_CLASS = {};

// node names for item types
ZmList.NODE = {};

// item types based on node name (reverse map of above)
ZmList.ITEM_TYPE = {};

ZmList.CHUNK_SIZE	= 100;	// how many items to act on at a time via a server request
ZmList.CHUNK_PAUSE	= 500;	// how long to pause to allow UI to catch up


/**
 * Gets the item.
 * 
 * @param	{int}	index		the index
 * @return	{ZmItem}	the index
 */
ZmList.prototype.get =
function(index) {
	return this._vector.get(index);
};

/**
 * Adds an item to the list.
 *
 * @param {ZmItem}	item	the item to add
 * @param {int}	index	the index at which to add the item (defaults to end of list)
 */
ZmList.prototype.add = 
function(item, index) {
	this._vector.add(item, index);
	if (item.id) {
		this._idHash[item.id] = item;
	}
};

/**
 * Removes an item from the list.
 *
 * @param {ZmItem}	item	the item to remove
 */
ZmList.prototype.remove = 
function(item) {
	this._vector.remove(item);
	if (item.id) {
		delete this._idHash[item.id];
	}
};

/**
 * Creates an item from the given arguments. A subclass may override
 * <code>sortIndex()</code> to add it to a particular point in the list. By default, it
 * will be added at the end.
 *
 * <p>
 * The item will invoke a SOAP call, which generates a create notification from the
 * server. That will be handled by notifyCreate(), which will call _notify()
 * so that views can be updated.
 * </p>
 *
 * @param {Hash}	args	a hash of arugments to pass along to the item constructor
 * @return	{ZmItem}	the newly created item
 */
ZmList.prototype.create =
function(args) {
	var item;
	var obj = eval(ZmList.ITEM_CLASS[this.type]);
	if (obj) {
		item = new obj(this);
		item.create(args);
	}

	return item;
};

/**
 * Returns the number of items in the list.
 * 
 * @return	{int}	the number of items
 */
ZmList.prototype.size = 
function() {
	return this._vector.size();
};

/**
 * Returns the index of the given item in the list.
 * 
 * @param	{ZmItem}	item		the item
 * @return	{int}	the index
 */
ZmList.prototype.indexOf = 
function(item) {
	return this._vector.indexOf(item);
};

/**
 * Gets if there are more items for this search.
 * 
 * @return	{Boolean}	<code>true</code> if there are more items
 */
ZmList.prototype.hasMore = 
function() {
	return this._hasMore;
};

/**
 * Sets the "more" flag for this list.
 *
 * @param {Boolean}	bHasMore	<code>true</code> if there are more items
 */
ZmList.prototype.setHasMore = 
function(bHasMore) {
	this._hasMore = bHasMore;
};

/**
 * Returns the list as an array.
 * 
 * @return	{Array}	an array of {ZmItem} objects
 */
ZmList.prototype.getArray =
function() {
	return this._vector.getArray();
};

/**
 * Returns the list as a vector.
 * 
 * @return	{AjxVector}	a vector of {ZmItem} objects
 */
ZmList.prototype.getVector =
function() {
	return this._vector;
};

/**
 * Gets the item with the given id.
 *
 * @param {String}	id		an item id
 * 
 * @return	{ZmItem}	the item
 */
ZmList.prototype.getById =
function(id) {
	return this._idHash[id];
};

/**
 * Clears the list, including the id hash.
 * 
 */
ZmList.prototype.clear =
function() {
	// First, let each item run its clear() method
	var a = this.getArray();
	for (var i = 0; i < a.length; i++) {
		a[i].clear();
	}

	this._evtMgr.removeAll(ZmEvent.L_MODIFY);
	this._vector.removeAll();
	for (var id in this._idHash) {
		this._idHash[id] = null;
	}
	this._idHash = {};
};

/**
 * Populates the list with elements created from the response to a SOAP command. Each
 * node in the response should represent an item of the list's type. Items are added
 * in the order they are received; no sorting is done.
 *
 * @param {Object}	respNode	an XML node whose children are item nodes
 */
ZmList.prototype.set = 
function(respNode) {
	this.clear();
	var nodes = respNode.childNodes;
	var args = {list:this};
	for (var i = 0; i < nodes.length; i++) {
		var node = nodes[i];
		if (node.nodeName == ZmList.NODE[this.type]) {
			/// TODO: take this out, let view decide whether to show items in Trash
			if (parseInt(node.getAttribute("l")) == ZmFolder.ID_TRASH && (this.type != ZmItem.CONTACT))	{ continue; }
			var obj = eval(ZmList.ITEM_CLASS[this.type]);
			if (obj) {
				this.add(obj.createFromDom(node, args));
			}
		}
	}
};

/**
 * Adds an item to the list from the given XML node.
 *
 * @param {Object}	node	an XML node
 * @param {Hash}	args	an optional list of arguments to pass to the item contructor
 */
ZmList.prototype.addFromDom = 
function(node, args) {
	args = args || {};
	args.list = this;
	var obj = eval(ZmList.ITEM_CLASS[this.type]);
	if (obj) {
		this.add(obj.createFromDom(node, args));
	}
};

/**
 * Gets a vector containing a subset of items of this list.
 *
 * @param {int}		offset		the starting index
 * @param {int}		limit		the size of sublist
 * @return	{AjxVector}	the vector
 */
ZmList.prototype.getSubList = 
function(offset, limit) {
	var subVector = null;
	var end = (offset + limit > this.size()) ? this.size() : offset + limit;
	var subList = this.getArray();
	if (offset < end) {
		subVector = AjxVector.fromArray(subList.slice(offset, end));
	}
	return subVector;
};

/**
 * Caches the list.
 * 
 * @param	{int}	offset	the index
 * @param	{AjxVector}	newList		the new list
 */
ZmList.prototype.cache = 
function(offset, newList) {
	this.getVector().merge(offset, newList);
	// reparent each item within new list, and add it to ID hash
	var list = newList.getArray();
	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		item.list = this;
		if (item.id) {
			this._idHash[item.id] = item;
		}
	}
};

// Actions

/**
 * Sets and unsets a flag for each of a list of items.
 *
 * @param 	{Hash}				params					a hash of parameters
 * @param	{Array}     		params.items			a list of items to set/unset a flag for
 * @param	{String}			params.op				the name of the flag operation ("flag" or "read")
 * @param	{Boolean|String}	params.value			whether to set the flag, or for "update" the flags string
 * @param	{AjxCallback}		params.callback			the callback to run after each sub-request
 * @param	{closure}			params.finalCallback	the callback to run after all items have been processed
 * @param	{int}				params.count			the starting count for number of items processed
 * @param   {String}    		params.actionTextKey   	pattern for generating action summarykey to action summary message
 */
ZmList.prototype.flagItems =
function(params) {

	params = Dwt.getParams(arguments, ["items", "op", "value", "callback"]);

	params.items = AjxUtil.toArray(params.items);

	if (params.op == "update") {
		params.action = params.op;
		params.attrs = {f:params.value};
	} else {
		params.action = params.value ? params.op : "!" + params.op;
	}

    if (appCtxt.multiAccounts) {
		// check if we're flagging item from remote folder, in which case, always send
		// request on-behalf-of the account the item originally belongs to.
        var folderId = this.search.folderId;
        var fromFolder = folderId && appCtxt.getById(folderId);
        if (fromFolder && fromFolder.isRemote()) {
                params.accountName = params.items[0].getAccount().name;
        }
	}

	this._itemAction(params);
};

/**
 * Tags or untags a list of items. A sanity check is done first, so that items
 * aren't tagged redundantly, and so we don't try to remove a nonexistent tag.
 *
 * @param {Hash}		params					a hash of parameters
 * @param {Array}		params.items			a list of items to tag/untag
 * @param {String}  	params.tagId            ID of tag to add/remove
 * @param {String}		params.tag  			the tag to add/remove from each item (optional)
 * @param {Boolean}		params.doTag			<code>true</code> if adding the tag, <code>false</code> if removing it
 * @param {AjxCallback}	params.callback			the callback to run after each sub-request
 * @param {closure}		params.finalCallback	the callback to run after all items have been processed
 * @param {int}			params.count			the starting count for number of items processed
 */
ZmList.prototype.tagItems =
function(params) {

	params = Dwt.getParams(arguments, ["items", "tagId", "doTag"]);

    var tagName = params.tagName || (params.tag && params.tag.name);

	//todo - i hope this is no longer needed. I think the item we apply the tag to should determine the tag id on the server side.
//	// for multi-account mbox, normalize tagId
//	if (appCtxt.multiAccounts && !appCtxt.getActiveAccount().isMain) {
//		tagId = ZmOrganizer.normalizeId(tagId);
//	}

	// only tag items that don't have the tag, and untag ones that do
	// always tag a conv, because we don't know if all items in the conv have the tag yet
	var items = AjxUtil.toArray(params.items);
	var items1 = [], doTag = params.doTag;
	if (items[0] && items[0] instanceof ZmItem) {
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			if ((doTag && (!item.hasTag(tagName) || item.type == ZmItem.CONV)) ||	(!doTag && item.hasTag(tagName))) {
				items1.push(item);
			}
		}
	} else {
		items1 = items;
	}
	params.items = items1;
	params.attrs = {tn: tagName};
	params.action = doTag ? "tag" : "!tag";
    params.actionTextKey = doTag ? 'actionTag' : 'actionUntag';
	params.actionArg = params.tag && params.tag.name;

	this._itemAction(params);
};

/**
 * Removes all tags from a list of items.
 *
 * @param	{Hash}			params					a hash of parameters
 * @param	{Array}			params.items			a list of items to tag/untag
 * @param	{AjxCallback}	params.callback			the callback to run after each sub-request
 * @param	{closure}		params.finalCallback	the callback to run after all items have been processed
 * @param	{int}			params.count			the starting count for number of items processed
 */
ZmList.prototype.removeAllTags = 
function(params) {

	params = (params && params.items) ? params : {items:params};

	var items = AjxUtil.toArray(params.items);
	var items1 = [];
	if (items[0] && items[0] instanceof ZmItem) {
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			if (item.tags && item.tags.length) {
				items1.push(item);
			}
		}
	} else {
		items1 = items;
	}

	params.items = items1;
	params.action = "update";
	params.attrs = {t: ""};
    params.actionTextKey = 'actionRemoveTags';

	this._itemAction(params);
};

/**
 * Moves a list of items to the given folder.
 * <p>
 * Search results are treated as though they're in a temporary folder, so that they behave as
 * they would if they were in any other folder such as Inbox. When items that are part of search
 * results are moved, they will disappear from the view, even though they may still satisfy the
 * search.
 * </p>
 *
 * @param	{Hash}			params					a hash of parameters
 * @param	{Array}			params.items			a list of items to move
 * @param	{ZmFolder}		params.folder			the destination folder
 * @param	{Hash}			params.attrs			the additional attrs for SOAP command
 * @param	{AjxCallback}	params.callback			the callback to run after each sub-request
 * @param	{closure}		params.finalCallback	the callback to run after all items have been processed
 * @param	{int}			params.count			the starting count for number of items processed
 * @param	{boolean}		params.noUndo			true if the action is not undoable (e.g. performed as an undo)
 */
ZmList.prototype.moveItems =
function(params) {
	
	params = Dwt.getParams(arguments, ["items", "folder", "attrs", "callback", "errorCallback" ,"finalCallback", "noUndo"]);

	var params1 = AjxUtil.hashCopy(params);
	params1.items = AjxUtil.toArray(params.items);
	params1.attrs = params.attrs || {};
	params1.childWin = params.childWin;
	params1.closeChildWin = params.closeChildWin;
	
	if (params1.folder.id == ZmFolder.ID_TRASH) {
		params1.actionTextKey = 'actionTrash';
		params1.action = "trash";
	} else {
		params1.actionTextKey = 'actionMove';
		params1.actionArg = params.folder.getName(false, false, true);
		params1.action = "move";
		params1.attrs.l = params.folder.id;
	}
	params1.callback = new AjxCallback(this, this._handleResponseMoveItems, [params]);
	if (params.noToast) {
		params1.actionTextKey = null;
	}

    if (appCtxt.multiAccounts) {
		// Reset accountName for multi-account to be the respective account if we're
		// moving a draft out of Trash.
		// OR,
		// check if we're moving to or from a shared folder, in which case, always send
		// request on-behalf-of the account the item originally belongs to.

        var folderId = params.items[0].getFolderId && params.items[0].getFolderId();

        // on bulk delete, when the second chunk loads try to get folderId from the item id.
        if (!folderId) {
            var itemId = params.items[0] && params.items[0].id;
            folderId = itemId && appCtxt.getById(itemId) && appCtxt.getById(itemId).folderId;
        }
        var fromFolder = appCtxt.getById(folderId);
		if ((params.items[0].isDraft && params.folder.id == ZmFolder.ID_DRAFTS) ||
			(params.folder.isRemote()) || (fromFolder && fromFolder.isRemote()))
		{
			params1.accountName = params.items[0].getAccount().name;
		}
	}
	//Error Callback
	params1.errorCallback = params.errorCallback;

	if (this._handleDeleteFromSharedFolder(params, params1)) {
		return;
	}
    
	this._itemAction(params1);
};

ZmList.prototype._handleDeleteFromSharedFolder =
function(params, params1) {

	// Bug 26103: when deleting an item in a folder shared to us, save a copy in our own trash
	if (params.folder && params.folder.id == ZmFolder.ID_TRASH) {
		var fromFolder;
		var toCopy = [];
		for (var i = 0; i < params.items.length; i++) {
			var item = params.items[i];
			var index = item.id.indexOf(":");
			if (index != -1) { //might be shared
				var acctId = item.id.substring(0, index);
				if (!appCtxt.accountList.getAccount(acctId)) {
					fromFolder = appCtxt.getById(item.folderId);
					// Don't do the copy if the source folder is shared with view only rights
					if (fromFolder && !fromFolder.isReadOnly()) {
						toCopy.push(item);
					}
				}
			}
		}
		if (toCopy.length) {
			var params2 = {
				items:			toCopy,
				folder:			params.folder, // Should refer to our own trash folder
				finalCallback:	this._itemAction.bind(this, params1, null),
				actionTextKey:	null
			};
			this.copyItems(params2);
			return true;
		}
	}
};

/**
 * @private
 */
ZmList.prototype._handleResponseMoveItems =
function(params, result) {

	var movedItems = result.getResponse();
	if (movedItems && movedItems.length && (movedItems[0] instanceof ZmItem)) {
		this.moveLocal(movedItems, params.folder.id);
		for (var i = 0; i < movedItems.length; i++) {
			var item = movedItems[i];
			var details = {oldFolderId:item.folderId};
			item.moveLocal(params.folder.id);
			//ZmModel.prototype._notify.call(item, ZmEvent.E_MOVE, details);
		}
		// batched change notification
		//todo - it's probably possible that different items have different _lists they are in
		// thus getting the lists just from the first item is not enough. But hopefully good
		// enough for the most common cases. Prior to this fix it was only taking the current list
		// the first item is in, so this is already better. :)
		var item = movedItems[0];
		for (var listId in item._list) {
			var ac = window.parentAppCtxt || appCtxt; //always get the list in the parent window. The child might be closed or closing, causing bugs.
			var list = ac.getById(listId);
			if (!list) {
				continue;
			}
            list._evt.batchMode = true;
            list._evt.item = item;	// placeholder
            list._evt.items = movedItems;
            list._notify(ZmEvent.E_MOVE, details);
        }
	}

	if (params.callback) {
		params.callback.run(result);
	}
};

/**
 * Copies a list of items to the given folder.
 *
 * @param {Hash}		params					the hash of parameters
 * @param {Array}		params.items			a list of items to move
 * @param {ZmFolder}	params.folder			the destination folder
 * @param {Hash}		params.attrs			the additional attrs for SOAP command
 * @param {closure}		params.finalCallback	the callback to run after all items have been processed
 * @param {int}			params.count			the starting count for number of items processed
 * @param {String}		params.actionTextKey	key to optional text to display in the confirmation toast instead of the default summary. May be set explicitly to null to disable the confirmation toast
 */
ZmList.prototype.copyItems =
function(params) {

	params = Dwt.getParams(arguments, ["items", "folder", "attrs", "actionTextKey"]);

	params.items = AjxUtil.toArray(params.items);
	params.attrs = params.attrs || {};
    if (!appCtxt.isExternalAccount()) {
        params.attrs.l = params.folder.id;
        params.action = "copy";
        params.actionTextKey = 'itemCopied';
    }
    else {
        params.action = 'trash';
    }
	params.actionArg = params.folder.getName(false, false, true);
	params.callback = new AjxCallback(this, this._handleResponseCopyItems, params);

	if (appCtxt.multiAccounts && params.folder.isRemote()) {
		params.accountName = params.items[0].getAccount().name;
	}

	this._itemAction(params);
};

/**
 * @private
 */
ZmList.prototype._handleResponseCopyItems =
function(params, result) {
	var resp = result.getResponse();
	if (resp.length > 0) {
		if (params.actionTextKey) {
			var msg = AjxMessageFormat.format(ZmMsg[params.actionTextKey], resp.length);
			appCtxt.getAppController().setStatusMsg(msg);
		}
	}
};

/**
 * Deletes one or more items from the list. Normally, deleting an item just
 * moves it to the Trash (soft delete). However, if it's already in the Trash,
 * it will be removed from the data store (hard delete).
 *
 * @param {Hash}	params		a hash of parameters
 * @param	{Array}		params.items			list of items to delete
 * @param	{Boolean}	params.hardDelete		<code>true</code> to force physical removal of items
 * @param	{Object}	params.attrs			additional attrs for SOAP command
 * @param	{window}	params.childWin			the child window this action is happening in
 * @param	{closure}	params.finalCallback	the callback to run after all items have been processed
 * @param	{int}		params.count			the starting count for number of items processed
 * @param	{Boolean}	params.confirmDelete		the user confirmed hard delete
 */
ZmList.prototype.deleteItems =
function(params) {

	params = Dwt.getParams(arguments, ["items", "hardDelete", "attrs", "childWin"]);

	var items = params.items = AjxUtil.toArray(params.items);

	// figure out which items should be moved to Trash, and which should actually be deleted
	var toMove = [];
	var toDelete = [];
	if (params.hardDelete) {
		toDelete = items;
	} else if (items[0] && items[0] instanceof ZmItem) {
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			var folderId = item.getFolderId();
			var folder = appCtxt.getById(folderId);
			if (folder && folder.isHardDelete()) {
				toDelete.push(item);
			} else {
				toMove.push(item);
			}
		}
	} else {
		toMove = items;
	}

	if (toDelete.length && !params.confirmDelete) {
		params.confirmDelete = true;
		var callback = ZmList.prototype.deleteItems.bind(this, params);
		this._popupDeleteWarningDialog(callback, toMove.length, toDelete.length);
		return;
	}

	params.callback = params.childWin && new AjxCallback(this._handleDeleteNewWindowResponse, params.childWin);

	// soft delete - items moved to Trash
	if (toMove.length) {
		if (appCtxt.multiAccounts) {
			var accounts = this._filterItemsByAccount(toMove);
			if (!params.callback) {
				params.callback = new AjxCallback(this, this._deleteAccountItems, [accounts, params]);
			}
			this._deleteAccountItems(accounts, params);
		}
		else {
			params.items = toMove;
			params.folder = appCtxt.getById(ZmFolder.ID_TRASH);
			this.moveItems(params);
		}
	}

	// hard delete - items actually deleted from data store
	if (toDelete.length) {
		params.items = toDelete;
		params.action = "delete";
        params.actionTextKey = 'actionDelete';
		this._itemAction(params);
	}
};


ZmList.prototype._popupDeleteWarningDialog =
function(callback, onlySome, count) {
	var dialog = appCtxt.getOkCancelMsgDialog();
	dialog.reset();
	dialog.setMessage(AjxMessageFormat.format(ZmMsg[onlySome ? "confirmDeleteSomeForever" : "confirmDeleteForever"], [count]), DwtMessageDialog.WARNING_STYLE); 
	dialog.registerCallback(DwtDialog.OK_BUTTON, this._deleteWarningDialogListener.bind(this, callback, dialog));
	dialog.associateEnterWithButton(DwtDialog.OK_BUTTON);
	dialog.popup(null, DwtDialog.OK_BUTTON);
};

ZmList.prototype._deleteWarningDialogListener =
function(callback, dialog) {
	dialog.popdown();
	callback();
};


/**
 * @private
 */
ZmList.prototype._deleteAccountItems =
function(accounts, params) {
	var items;
	for (var i in accounts) {
		items = accounts[i];
		break;
	}

	if (items) {
		delete accounts[i];

        var ac = window.parentAppCtxt || window.appCtxt;
        params.accountName = ac.accountList.getAccount(i).name;
		params.items = items;
		params.folder = appCtxt.getById(ZmFolder.ID_TRASH);

		this.moveItems(params);
	}
};

/**
 * @private
 */
ZmList.prototype._filterItemsByAccount =
function(items) {
	// separate out the items based on which account they belong to
	var accounts = {};
	if (items[0] && items[0] instanceof ZmItem) {
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			var acctId = item.getAccount().id;
			if (!accounts[acctId]) {
				accounts[acctId] = [];
			}
			accounts[acctId].push(item);
		}
	} else {
		var id = appCtxt.accountList.mainAccount.id;
		accounts[id] = items;
	}

	return accounts;
};

/**
 * @private
 */
ZmList.prototype._handleDeleteNewWindowResponse =
function(childWin, result) {
	if (childWin) {
		childWin.close();
	}
};

/**
 * Applies the given list of modifications to the item.
 *
 * @param {ZmItem}	item			the item to modify
 * @param {Hash}	mods			hash of new properties
 * @param	{AjxCallback}	callback	the callback
 */
ZmList.prototype.modifyItem =
function(item, mods, callback) {
	item.modify(mods, callback);
};

// Notification handling

/**
 * Create notification.
 * 
 * @param	{Object}	node		not used
 */
ZmList.prototype.notifyCreate =
function(node) {
	var obj = eval(ZmList.ITEM_CLASS[this.type]);
	if (obj) {
		var item = obj.createFromDom(node, {list:this});
		this.add(item, this._sortIndex(item));
		this.createLocal(item);
		this._notify(ZmEvent.E_CREATE, {items: [item]});
	}
};

// Local change handling

// These generic methods allow a derived class to perform the appropriate internal changes

/**
 * Modifies the items (local).
 * 
 * @param	{Array}	items		an array of items
 * @param	{Object}	mods	a hash of properties to modify
 */
ZmList.prototype.modifyLocal 		= function(items, mods) {};

/**
 * Creates the item (local).
 * 
 * @param	{ZmItem}	item	the item to create
 */
ZmList.prototype.createLocal 		= function(item) {};

// These are not currently used; will need support in ZmItem if they are.
ZmList.prototype.flagLocal 			= function(items, flag, state) {};
ZmList.prototype.tagLocal 			= function(items, tag, state) {};
ZmList.prototype.removeAllTagsLocal = function(items) {};

// default action is to remove each deleted item from this list
/**
 * Deletes the items (local).
 * 
 * @param	{Array}	items		an array of items
 */
ZmList.prototype.deleteLocal =
function(items) {
	for (var i = 0; i < items.length; i++) {
		this.remove(items[i]);
	}
};

// default action is to remove each moved item from this list
/**
 * Moves the items (local).
 * 
 * @param	{Array}	items		an array of items
 * @param	{String}	folderId	the folder id
 */
ZmList.prototype.moveLocal = 
function(items, folderId) {
	for (var i = 0; i < items.length; i++) {
		this.remove(items[i]);
	}
};

/**
 * Performs an action on items via a SOAP request.
 *
 * @param {Hash}				params				a hash of parameters
 * @param	{Array}				params.items			a list of items to act upon
 * @param	{String}			params.action			the SOAP operation
 * @param	{Object}			params.attrs			a hash of additional attrs for SOAP request
 * @param	{AjxCallback}		params.callback			the async callback
 * @param	{closure}			params.finalCallback	the callback to run after all items have been processed
 * @param	{AjxCallback}		params.errorCallback	the async error callback
 * @param	{String}			params.accountName		the account to send request on behalf of
 * @param	{int}				params.count			the starting count for number of items processed
 * @param	{ZmBatchCommand}	batchCmd				if set, request data is added to batch request
 * @param	{boolean}			params.noUndo			true if the action is performed as an undo (not undoable)
 * @param	{boolean}			params.safeMove			true if the action wants to resolve any conflicts before completion
 */
ZmList.prototype._itemAction =
function(params, batchCmd) {

	var result = this._getIds(params.items);
	var idHash = result.hash;
	var idList = result.list;
	if (!(idList && idList.length)) {
		if (params.callback) {
			params.callback.run(new ZmCsfeResult([]));
		}
		if (params.finalCallback) {
			params.finalCallback(params);
		}
		return;
	}

	DBG.println("sa", "ITEM ACTION: " + idList.length + " items");
	var type;
	if (params.items.length == 1 && params.items[0] && params.items[0].type) {
		type = params.items[0].type;
	} else {
		type = this.type;
	}
	if (!type) { return; }

	// set accountName for multi-account to be the main "local" account since we
	// assume actioned ID's will always be fully qualified
	if (!params.accountName && appCtxt.multiAccounts) {
		params.accountName = appCtxt.accountList.mainAccount.name;
	}

	var soapCmd = ZmItem.SOAP_CMD[type] + "Request";
	var useJson = batchCmd ? batchCmd._useJson : true ;
	var request, action;
	if (useJson) {
		request = {};
		var urn = this._getActionNamespace();
		request[soapCmd] = {_jsns:urn};
		var action = request[soapCmd].action = {};
		action.op = params.action;
		for (var attr in params.attrs) {
			action[attr] = params.attrs[attr];
		}
	} else {
		request = AjxSoapDoc.create(soapCmd, this._getActionNamespace());
		action = request.set("action");
		action.setAttribute("op", params.action);
		for (var attr in params.attrs) {
			action.setAttribute(attr, params.attrs[attr]);
		}
	}
    var ac =  window.parentAppCtxt || appCtxt;
	var actionController = ac.getActionController();
	var undoPossible = !params.noUndo && (this.type != ZmItem.CONV || this.search && this.search.folderId); //bug 74169 - since the convs might not be fully loaded we might not know where the messages are moved from at all. so no undo.
	var actionLogItem = (undoPossible && actionController && actionController.actionPerformed({op: params.action, ids: idList, attrs: params.attrs})) || null;
	var respCallback = new AjxCallback(this, this._handleResponseItemAction, [params.callback, actionLogItem]);

	var params1 = {
		ids:			idList,
		idHash:			idHash,
		accountName:	params.accountName,
		request:		request,
		action:			action,
		type:			type,
		callback:		respCallback,
		finalCallback:	params.finalCallback,
		errorCallback:	params.errorCallback,
		batchCmd:		batchCmd,
		numItems:		params.count || 0,
		actionTextKey:	params.actionTextKey,
		actionArg:		params.actionArg,
		actionLogItem:	actionLogItem,
		childWin:		params.childWin,
		closeChildWin: 	params.closeChildWin,
		safeMove:		params.safeMove
	};

	if (idList.length >= ZmList.CHUNK_SIZE) {
		var pdParams = {
			state:		ZmListController.PROGRESS_DIALOG_INIT,
			callback:	new AjxCallback(this, this._cancelAction, [params1])
		}
		ZmListController.handleProgress(pdParams);
	}
	
	this._doAction(params1);
};

/**
 * @private
 */
ZmList.prototype._handleResponseItemAction =
function(callback, actionLogItem, items, result) {
	if (actionLogItem) {
		actionLogItem.setComplete();
	}
	
	if (callback) {
		result.set(items);
		callback.run(result);
	}
};

/**
 * @private
 */
ZmList.prototype._doAction =
function(params) {

	var list = params.ids.splice(0, ZmList.CHUNK_SIZE);
	var idStr = list.join(",");
	var useJson = true;
	if (params.action.setAttribute) {
		params.action.setAttribute("id", idStr);
		useJson = false;
	} else {
		params.action.id = idStr;
	}
	var more = Boolean(params.ids.length && !params.cancelled);

	var respCallback = new AjxCallback(this, this._handleResponseDoAction, [params]);
    var isOutboxFolder = this.controller && this.controller.isOutboxFolder();
    var offlineCallback = this._handleOfflineResponseDoAction.bind(this, params, isOutboxFolder);

	if (params.batchCmd) {
		params.batchCmd.addRequestParams(params.request, respCallback, params.errorCallback);
	} else {
		var reqParams = {asyncMode:true, callback:respCallback, errorCallback: params.errorCallback, offlineCallback: offlineCallback, accountName:params.accountName, more:more};
		if (useJson) {
			reqParams.jsonObj = params.request;
		} else {
			reqParams.soapDoc = params.request;
		}
		if (params.safeMove) {
			reqParams.useChangeToken = true;
		}
        if (isOutboxFolder) {
            reqParams.offlineRequest = true;
        }
		DBG.println("sa", "*** do action: " + list.length + " items");
		params.reqId = appCtxt.getAppController().sendRequest(reqParams);
	}
};

/**
 * @private
 */
ZmList.prototype._handleResponseDoAction =
function(params, result) {

	var summary;
	var response = result.getResponse();
	var resp = response[ZmItem.SOAP_CMD[params.type] + "Response"];
	if (resp && resp.action) {
		var ids = resp.action.id.split(",");
		if (ids) {
			var items = [];
			for (var i = 0; i < ids.length; i++) {
				var item = params.idHash[ids[i]];
				if (item) {
					items.push(item);
				}
			}
			params.numItems += items.length;
			if (params.callback) {
				params.callback.run(items, result);
			}

			if (params.actionTextKey) {
				summary = ZmList.getActionSummary(params);
				var pdParams = {
					state:		ZmListController.PROGRESS_DIALOG_UPDATE,
					summary:	summary
				}
				ZmListController.handleProgress(pdParams);
			}
		}
	}

	if (params.ids.length && !params.cancelled) {
		DBG.println("sa", "item action setting up next chunk, remaining: " + params.ids.length);
		AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._doAction, [params]), ZmItem.CHUNK_PAUSE);
	} else {
		params.reqId = null;
		params.actionSummary = summary;
		if (params.finalCallback) {
			// finalCallback is responsible for showing status or clearing dialog
			DBG.println("sa", "item action running finalCallback");
			params.finalCallback(params);
		} else {
			DBG.println("sa", "no final callback");
			ZmListController.handleProgress({state:ZmListController.PROGRESS_DIALOG_CLOSE});
			ZmBaseController.showSummary(params.actionSummary, params.actionLogItem, params.closeChildWin);
		}
	}
};

/**
 * @private
 */
ZmList.prototype._handleOfflineResponseDoAction =
function(params, isOutboxFolder, requestParams) {

    var action = params.action,
        callback = this._handleOfflineResponseDoActionCallback.bind(this, params, isOutboxFolder, requestParams.callback);

    if (isOutboxFolder && action.op === "trash") {
        var key = {
            methodName : "SendMsgRequest", //Outbox folder only contains offline sent emails
			id : action.id.split(",")
        };
        ZmOfflineDB.deleteItemInRequestQueue(key, callback);
    }
    else {
        var obj = requestParams.jsonObj;
        obj.methodName = ZmItem.SOAP_CMD[params.type] + "Request";
        obj.id = action.id;
        ZmOfflineDB.setItem(obj, ZmOffline.REQUESTQUEUE, callback);
    }
};

/**
 * @private
 */
ZmList.prototype._handleOfflineResponseDoActionCallback =
function(params, isOutboxFolder, callback) {

    var data = {},
        header = this._generateOfflineHeader(params),
        result,
        hdr,
        notify;

    data[ZmItem.SOAP_CMD[params.type] + "Response"] = params.request[ZmItem.SOAP_CMD[params.type] + "Request"];
    result = new ZmCsfeResult(data, false, header);
    hdr = result.getHeader();
    if (callback) {
        callback.run(result);
    }
    if (hdr) {
        notify = hdr.context.notify[0];
        if (notify) {
            appCtxt._requestMgr._notifyHandler(notify);
            this._updateOfflineData(params, isOutboxFolder, notify);
        }
    }
};

/**
 * @private
 */
ZmList.prototype._generateOfflineHeader =
function(params) {

    var action = params.action,
        op = action.op,
        ids = action.id.split(","),
        idsLength = ids.length,
        id,
        msg,
        flags,
        folderId,
        folder,
        targetFolder,
        mObj,
        cObj,
        folderObj,
        m = [],
        c = [],
        folderArray = [],
        header;

    for (var i = 0; i < idsLength; i++) {

        id = ids[i];
        msg = this.getById(id);
        flags =  msg.flags || "";
        folderId = msg.getFolderId();
        folder = appCtxt.getById(folderId);
        mObj = {
            id : id
        };
        cObj = {
            id : "-" + mObj.id
        };
        folderObj = {
            id : folderId
        };

        switch (op)
        {
            case "flag":
                mObj.f = flags + "f";
                break;
            case "!flag":
                mObj.f = flags.replace("f", "");
                break;
            case "read":
                mObj.f = flags.replace("u", "");
                folderObj.u = folder.numUnread - 1;
                break;
            case "!read":
                mObj.f = flags + "u";
                folderObj.u = folder.numUnread + 1;
                break;
            case "trash":
                mObj.l = ZmFolder.ID_TRASH;
                break;
            case "spam":
                mObj.l = ZmFolder.ID_SPAM;
                break;
            case "!spam":
                mObj.l = ZmFolder.ID_INBOX;// Have to set the old folder id. Currently point to inbox
                break;
            case "move":
                if (action.l) {
                    mObj.l = action.l;
                }
                folderObj.n = folder.numTotal - 1;
                if (msg.isUnread && folder.numUnread > 1) {
                    folderObj.u = folder.numUnread - 1;
                }
                targetFolder = appCtxt.getById(mObj.l);
                folderArray.push({
                    id : targetFolder.id,
                    n : targetFolder.numTotal + 1,
                    u : (msg.isUnread ? targetFolder.numUnread + 1 : targetFolder.numUnread)
                });
                break;
            case "tag":
                msg.tags.push(action.tn);
                mObj.tn = msg.tags.join();
                break;
            case "!tag":
                AjxUtil.arrayRemove(msg.tags, action.tn);
                mObj.tn = msg.tags.join();
                break;
            case "update":
                if (action.t === "") {//Removing all tag names for a msg
                    mObj.tn = "";
                    mObj.t = "";
                }
                break;
        }
        m.push(mObj);
        c.push(cObj);
        folderArray.push(folderObj);
    }

    header = {
        context : {
            notify : [{
                modified : {
                    m : m,
                    c : c,
                    folder : folderArray
                }
            }]
        }
    };

    return header;
};

ZmList.prototype._updateOfflineData =
function(params, isOutboxFolder, notify) {

    var modified = notify.modified;
    if (!modified) {
        return;
    }

    var m = modified.m;
    if (!m) {
        return;
    }

    var callback = this._updateOfflineDataCallback.bind(this, params, m);
    ZmOfflineDB.getItem(params.action.id.split(","), ZmApp.MAIL, callback);
};

ZmList.prototype._updateOfflineDataCallback =
function(params, msgArray, result) {
    result = ZmOffline.recreateMsg(result);
    var newMsgArray = [];
    result.forEach(function(res) {
        msgArray.forEach(function(msg) {
            if (msg.id === res.id) {
                newMsgArray.push($.extend(res, msg));
            }
        });
    });
    ZmOfflineDB.setItem(newMsgArray, ZmApp.MAIL);
};

/**
 * Returns a string describing an action, intended for display as toast to tell the
 * user what they just did.
 *
 * @param   {Object}        params          hash of params:
 *          {String}        type            item type (ZmItem.*)
 *          {Number}        numItems        number of items affected
 *          {String}        actionTextKey   ZmMsg key for text string describing action
 *          {String}        actionArg       (optional) additional argument
 *
 * @return {String}     action summary
 */
ZmList.getActionSummary =
function(params) {

	var type = params.type,
		typeKey = ZmItem.MSG_KEY[type],
		typeText = ZmMsg[typeKey],
		capKey = AjxStringUtil.capitalizeFirstLetter(typeKey),
		countKey = 'type' + capKey,
		num = params.numItems,
		alternateKey = params.actionTextKey + capKey,
		text = ZmMsg[alternateKey] || ZmMsg[params.actionTextKey],
		countText = ZmMsg[countKey],
		arg = AjxStringUtil.htmlEncode(params.actionArg),
		textAuto = countText ? AjxMessageFormat.format(countText, num) : typeText,
		textSingular = countText ? AjxMessageFormat.format(ZmMsg[countKey], 1) : typeText;

	return AjxMessageFormat.format(text, [ num, textAuto, arg, textSingular ]);
};

/**
 * Cancel current server request if there is one, and set flag to
 * stop cascade of requests.
 *
 * @param {Hash}	params	a hash of parameters
 * 
 * @private
 */
ZmList.prototype._cancelAction =
function(params) {
	params.cancelled = true;
	if (params.reqId) {
		appCtxt.getRequestMgr().cancelRequest(params.reqId);
	}
	if (params.finalCallback) {
		params.finalCallback(params);
	}
	ZmListController.handleProgress({state:ZmListController.PROGRESS_DIALOG_CLOSE});
};

/**
 * @private
 */
ZmList.prototype._getTypedItems =
function(items) {
	var typedItems = {};
	for (var i = 0; i < items.length; i++) {
		var type = items[i].type;
		if (!typedItems[type]) {
			typedItems[type] = [];
		}
		typedItems[type].push(items[i]);
	}
	return typedItems;
};

/**
 * Grab the IDs out of a list of items, and return them as both a string and a hash.
 * 
 * @private
 */
ZmList.prototype._getIds =
function(list) {

	var idHash = {};
	if (list instanceof ZmItem) {
		list = [list];
	}
	
	var ids = [];
	if ((list && list.length)) {
		for (var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item.id;
			if (id) {
				ids.push(id);
				idHash[id] = item;
			}
		}
	}

	return {hash:idHash, list:ids};
};

/**
 * Returns the index at which the given item should be inserted into this list.
 * Subclasses should override to return a meaningful value.
 * 
 * @private
 */
ZmList.prototype._sortIndex = 
function(item) {
	return 0;
};

/**
 * @private
 */
ZmList.prototype._redoSearch = 
function(ctlr) {
	var sc = appCtxt.getSearchController();
	sc.redoSearch(ctlr._currentSearch);
};

/**
 * @private
 */
ZmList.prototype._getActionNamespace =
function() {
	return "urn:zimbraMail";
};

/**
 * @private
 */
ZmList.prototype._folderTreeChangeListener = 
function(ev) {
	if (ev.type != ZmEvent.S_FOLDER) return;

	var folder = ev.getDetail("organizers")[0];
	var fields = ev.getDetail("fields");
	var ctlr = appCtxt.getCurrentController();
	var isCurrentList = (appCtxt.getCurrentList() == this);

	if (ev.event == ZmEvent.E_DELETE &&
		(ev.source instanceof ZmFolder) &&
		ev.source.id == ZmFolder.ID_TRASH)
	{
		// user emptied trash - reset a bunch of stuff w/o having to redo the search
		var curView = ctlr.getListView && ctlr.getListView();
		if (curView) {
			curView.offset = 0;
		}
		ctlr._resetNavToolBarButtons(view);
	}
	else if (isCurrentList && ctlr && ctlr._currentSearch &&
			 (ev.event == ZmEvent.E_MOVE || (ev.event == ZmEvent.E_MODIFY) && fields && fields[ZmOrganizer.F_NAME]))
	{
		// on folder rename or move, update current query if folder is part of query
		if (ctlr._currentSearch.replaceFolderTerm(ev.getDetail("oldPath"), folder.getPath())) {
			appCtxt.getSearchController().setSearchField(ctlr._currentSearch.query);
		}
	}
};

/**
 * this method is for handling changes in the tag tree itself (tag rename, delete). In some places it is named _tagChangeListener.
 * the ZmListView equivalent is actually called ZmListView.prototype._tagChangeListener 
 * @private
 */
ZmList.prototype._tagTreeChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_TAG) { return; }

	var tag = ev.getDetail("organizers")[0];
	var fields = ev.getDetail("fields");
	var ctlr = appCtxt.getCurrentController();
	if (!ctlr) { return; }

	var a = this.getArray();

	if ((ev.event == ZmEvent.E_MODIFY) && fields && fields[ZmOrganizer.F_NAME]) {
		// on tag rename, update current query if tag is part of query
		var oldName = ev.getDetail("oldName");
		if (ctlr._currentSearch && ctlr._currentSearch.hasTagTerm(oldName)) {
			ctlr._currentSearch.replaceTagTerm(oldName, tag.getName());
			appCtxt.getSearchController().setSearchField(ctlr._currentSearch.query);
		}

		//since we tag (and map the tags) by name, replace the tag name in the list and hash of tags.
		var newName = tag.name;
		for (var i = 0; i < a.length; i++) {
			var item = a[i]; //not using the following here as it didn't seem to work for contacts, the list is !isCanonical and null is returned, even though a[i] is fine ==> this.getById(a[i].id); // make sure item is realized (contact may not be)
			if (!item || !item.isZmItem || !item.hasTag(oldName)) {
				continue; //nothing to do if item does not have tag
			}
			if (item.isShared()) {
				continue; //overview tag rename does not affect remote items tags
			}
			var tagHash = item.tagHash;
			var tags = item.tags;
			delete tagHash[oldName];
			tagHash[newName] = true;
			for (var j = 0 ; j < tags.length; j++) {
				if (tags[j] == oldName) {
					tags[j] = newName;
					break;
				}
			}
		}


	} else if (ev.event == ZmEvent.E_DELETE) {
		// Remove tag from any items that have it
		var hasTagListener = this._evtMgr.isListenerRegistered(ZmEvent.L_MODIFY);
		for (var i = 0; i < a.length; i++) {
			var item = this.getById(a[i].id);	// make sure item is realized (contact may not be)
            if (item) {
                if (item.isShared()) {
                    continue; //overview tag delete does not affect remote items tags
                }
                if (item.hasTag(tag.name)) {
                    item.tagLocal(tag.name, false);
                    if (hasTagListener) {
                        this._notify(ZmEvent.E_TAGS, {items:[item]});
                    }
                }
            }
		}

		// If search results are based on this tag, keep them around so that user can still
		// view msgs or open convs, but disable pagination and sorting since they're based
		// on the current query.
		if (ctlr._currentSearch && ctlr._currentSearch.hasTagTerm(tag.getName())) {
			var viewId = appCtxt.getCurrentViewId();
			var viewType = appCtxt.getCurrentViewType();
			ctlr.enablePagination(false, viewId);
			var view = ctlr.getListView && ctlr.getListView();
			if (view && view.sortingEnabled) {
				view.sortingEnabled = false;
			}
			if (viewType == ZmId.VIEW_CONVLIST) {
				ctlr._currentSearch.query = "is:read is:unread";
			}
			ctlr._currentSearch.tagId = null;
			appCtxt.getSearchController().setSearchField("");
		}
	}
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmAccountList")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines a list of accounts.
 *
 */

/**
 * Creates the account list.
 * @class
 * This class is used to store and manage a list of accounts for a mailbox.
 *
 * @author Parag Shah
 */
ZmAccountList = function() {
	this._accounts = {};
	this._count = 0;
	this.visibleAccounts = [];
	this.mainAccount = null;
	this.activeAccount = null;
	this.defaultAccount = null; // the first non-main account.

	this._evtMgr = new AjxEventMgr();
};

ZmAccountList.prototype.constructor = ZmAccountList;


// Consts

ZmAccountList.DEFAULT_ID = "main";


// Public methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmAccountList.prototype.toString =
function() {
	return "ZmAccountList";
};

/**
 * Gets the number of visible accounts for this mailbox.
 *
 * @param	{Boolean}	includeInvisible	if <code>true</code>, include the number of invisible accounts for this mailbox
 * @return	{int}							the number of accounts for this mailbox
 */
ZmAccountList.prototype.size =
function(includeInvisible) {
	return (includeInvisible) ? this._count : this.visibleAccounts.length;
};

/**
 * Adds the account.
 * 
 * @param	{ZmAccount}	account		the account
 */
ZmAccountList.prototype.add =
function(account) {
	this._accounts[account.id] = account;
	this._count++;

	if (account.visible || account.id == ZmAccountList.DEFAULT_ID) {
		this.visibleAccounts.push(account);
	}

	if (account.id == ZmAccountList.DEFAULT_ID) {
		this.mainAccount = account;
	}
};

/**
 * Gets the accounts.
 * 
 * @return	{Array}	an array of {ZmAccount} objects
 */
ZmAccountList.prototype.getAccounts =
function() {
	return this._accounts;
};

/**
 * Gets the account by id.
 * 
 * @param	{String}	id		the id
 * @return	{ZmAccount}	the account
 */
ZmAccountList.prototype.getAccount =
function(id) {
	return id ? this._accounts[id] : this.mainAccount;
};

/**
 * Gets the account by name.
 * 
 * @param	{String}	name	the name
 * @return	{ZmAccount}	the account
 */
ZmAccountList.prototype.getAccountByName =
function(name) {
	for (var i in this._accounts) {
		if (this._accounts[i].name == name) {
			return this._accounts[i];
		}
	}
	return null;
};

/**
 * Gets the account by email.
 * 
 * @param	{String}	email	the email
 * @return	{ZmAccount}	the account
 */
ZmAccountList.prototype.getAccountByEmail =
function(email) {
	for (var i in this._accounts) {
		if (this._accounts[i].getEmail() == email) {
			return this._accounts[i];
		}
	}
	return null;
};

/**
 * Gets the cumulative item count of all accounts for the given folder ID.
 *
 * @param {String}	folderId		the folder id
 * @param {Boolean}	checkUnread		if <code>true</code>, checks the unread count instead of item count
 * @return	{int}	the item count
 */
ZmAccountList.prototype.getItemCount =
function(folderId, checkUnread) {
	var count = 0;
	for (var i = 0; i < this.visibleAccounts.length; i++) {
		var acct = this.visibleAccounts[i];
		if (acct.isMain) { continue; } // local account should never have drafts

		var fid = ZmOrganizer.getSystemId(folderId, acct);
		var folder = appCtxt.getById(fid);
		if (folder) {
			count += (checkUnread ? folder.numUnread : folder.numTotal);
		}
	}

	return count;
};

/**
 * Generates a query.
 * 
 * @param {String}	folderId		the folder id
 * @param	{Array}	types		the types
 * @return	{String}	the query
 */
ZmAccountList.prototype.generateQuery =
function(folderId, types) {
	// XXX: for now, let's just search for *one* type at a time
	var type = types && types.get(0);
	var query = [];
	var list = this.visibleAccounts;
	var fid = folderId || ZmOrganizer.ID_ROOT;
	var syntax = folderId ? "inid" : "underid";
	for (var i = 0; i < list.length; i++) {
		var acct = list[i];

		// dont add any apps not supported by this account
		if ((type && !acct.isAppEnabled(ZmItem.APP[type])) || acct.isMain) { continue; }

		var part = [syntax, ':"', ZmOrganizer.getSystemId(fid, acct, true), '"'];
		query.push(part.join(""));
	}
    if(fid == ZmOrganizer.ID_ROOT) {
        query.push([syntax, ':"', appCtxt.accountList.mainAccount.id, ':', fid, '"'].join(""));
    }
	DBG.println(AjxDebug.DBG2, "query = " + query.join(" OR "));
	return (query.join(" OR "));
};

/**
 * Loads each visible account serially by requesting the following requests from
 * the server in a batch request:
 * 
 * <ul>
 * <li><code><GetInfoRequest></code></li>
 * <li><code><GetTafReqyuest></code></li>
 * <li><code><GetFolderRequest></code></li>
 * </ul>
 * 
 * @param {AjxCallback}	callback		the callback to trigger once all accounts have been loaded
 */
ZmAccountList.prototype.loadAccounts =
function(callback) {
	var list = (new Array()).concat(this.visibleAccounts);
	this._loadAccount(list, callback);
};

/**
 * @private
 */
ZmAccountList.prototype._loadAccount =
function(accounts, callback) {
	var acct = accounts.shift();
	if (acct) {
		var respCallback = new AjxCallback(this, this._loadAccount, [accounts, callback]);
		acct.load(respCallback);
	} else {
		// do any post account load initialization
		ZmOrganizer.HIDE_EMPTY[ZmOrganizer.TAG] = true;
		ZmOrganizer.HIDE_EMPTY[ZmOrganizer.SEARCH] = true;

		// enable compose based on whether at least one account supports smtp
		for (var i = 0; i < this.visibleAccounts.length; i++) {
			if (appCtxt.get(ZmSetting.OFFLINE_SMTP_ENABLED, null, this.visibleAccounts[i])) {
				appCtxt.set(ZmSetting.OFFLINE_COMPOSE_ENABLED, true, null, null, true);
				break;
			}
		}

		if (callback) {
			callback.run();
		}
	}
};

/**
 * Sets the given account as the active one, which will then be used when fetching
 * any account-specific data such as settings or folder tree.
 *
 * @param {ZmZimbraAccount}	account		the account to make active
 * @param {Boolean}	skipNotify		if <code>true</code>, skip notify
 */
ZmAccountList.prototype.setActiveAccount =
function(account, skipNotify) {
	this.activeAccount = account;

	this._evt = this._evt || new ZmEvent();
	this._evt.account = account;

	if (!skipNotify) {
		this._evtMgr.notifyListeners("ACCOUNT", this._evt);
	}
};

/**
 * Adds an active account listener.
 * 
 * @param	{AjxListener}	listener		the listener
 * @param	{int}	index		the index where to insert the listener
 */
ZmAccountList.prototype.addActiveAcountListener =
function(listener, index) {
	return this._evtMgr.addListener("ACCOUNT", listener, index);
};

/**
 * Checks if any of the non-main, visible accounts is currently doing an initial sync.
 * 
 * @return	{Boolean}	<code>true</code> if any of the non-main accounts are doing initial sync
 */
ZmAccountList.prototype.isInitialSyncing =
function() {
	for (var i = 0; i < this.visibleAccounts.length; i++) {
		var acct = this.visibleAccounts[i];
		if (acct.isMain) { continue; }

		if (acct.isOfflineInitialSync()) {
			return true;
		}
	}

	return false;
};

/**
 * Returns true if any of the visible accounts have the given status
 *
 * @param 	{String}		status 		Status to check for
 */
ZmAccountList.prototype.isSyncStatus =
function(status) {
	for (var i = 0; i < this.visibleAccounts.length; i++) {
		var acct = this.visibleAccounts[i];
		if (acct.isMain) { continue; }

		if (acct.status == status) {
			return true;
		}
	}

	return false;
};

/**
 * Checks if there is at least one of the given account types in the
 * account list. Note: if the given account type is ZCS, the local parent
 * account is NOT included when searching the account list.
 *
 * @param {String}	type	the type of account to check
 * @return	{Boolean}	<code>true</code> if the account exists
 */
ZmAccountList.prototype.accountTypeExists =
function(type) {
	for (var i = 0; i < this.visibleAccounts.length; i++) {
		var acct = this.visibleAccounts[i];
		if (type == ZmAccount.TYPE_ZIMBRA && acct.isMain) { continue; }
		if (acct.type == type) { return true; }
	}

	return false;
};

/**
 * Syncs all visible accounts.
 * 
 * @param	{AjxCallback}	callback		the callback
 */
ZmAccountList.prototype.syncAll =
function(callback) {
	var list = (new Array()).concat(this.visibleAccounts);
	this._sendSync(list, callback);
};

/**
 * @private
 */
ZmAccountList.prototype._sendSync =
function(accounts, callback) {
	var acct = accounts.shift();
	if (acct) {
		if (!acct.isMain) { // skip the main account
			acct.sync();
		}
		AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._sendSync, [accounts, callback]), 500);
	} else {
		if (callback) {
			callback.run();
		}
	}
};

/**
 * Creates the main account and all its children. In the normal case, the "main"
 * account is the only account, and represents the user who logged in. If family
 * mailbox is enabled, that account is a parent account with dominion over child
 * accounts. If offline, the main account is the "local" account.
 *
 * @param {ZmSettings}	settings	the settings for the main account
 * @param {Object}	obj		the JSON obj containing meta info about the main account and its children
 */
ZmAccountList.prototype.createAccounts =
function(settings, obj) {
	// first, replace the dummy main account with real information
	var account = appCtxt.accountList.mainAccount;
	account.id = obj.id;
	account.name = obj.name;
	account.isMain = true;
	account.isZimbraAccount = true;
	account.loaded = true;
	account.visible = true;
	account.settings = settings;
	account.type = ZmAccount.TYPE_ZIMBRA;
	account.icon = "AccountZimbra";
	account.active = true; // always set active for main/parent account

	this._accounts[account.id] = account;
	delete this._accounts[ZmAccountList.DEFAULT_ID];

	this.setActiveAccount(account);

	if (appCtxt.isOffline) {
		account.displayName = ZmMsg.localFolders;
	}

	// second, create all child accounts if applicable
	var childAccounts = obj.childAccounts && obj.childAccounts.childAccount;
	if (childAccounts) {
		for (var i = 0; i < childAccounts.length; i++) {
			this.add(ZmZimbraAccount.createFromDom(childAccounts[i]));
		}

		// set global vars per number of child accounts
		appCtxt.multiAccounts = this.size() > 1;
		appCtxt.isFamilyMbox = appCtxt.multiAccounts && !appCtxt.isOffline;

		this.defaultAccount = appCtxt.isFamilyMbox ? this.mainAccount : this.visibleAccounts[1];
	}
};

/**
 * Resets the trees.
 * 
 */
ZmAccountList.prototype.resetTrees =
function() {
	for (var i = 0; i < this.visibleAccounts.length; i++) {
		for (var type in trees) {
			var tree = trees[type];
			if (tree && tree.reset) {
				tree.reset();
			}
		}
	}
};

/**
 * Saves the implicit preferences on the visible accounts.
 * 
 */
ZmAccountList.prototype.saveImplicitPrefs =
function() {
	for (var i = 0; i < this.visibleAccounts.length; i++) {
		this.visibleAccounts[i].saveImplicitPrefs();
	}
};

/**
 * Gets the tool tip for the folder.
 * 
 * @param	{String}	folderId	the folder id
 * @return	{String}	the tool tip
 */
ZmAccountList.prototype.getTooltipForVirtualFolder =
function(folderId) {
	var numTotal = 0;
	var sizeTotal = 0;

	for (var i = 0; i < this.visibleAccounts.length; i++) {
		var acct = this.visibleAccounts[i];
		var fid = ZmOrganizer.getSystemId(folderId, acct);
		var folder = appCtxt.getById(fid);
		if (folder) {
			numTotal += folder.numTotal;
			sizeTotal += folder.sizeTotal;
		}
	}

	var subs = {
		itemText: ZmMsg.messages,
		numTotal: numTotal,
		sizeTotal: sizeTotal
	};

	return AjxTemplate.expand("share.App#FolderTooltip", subs);
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmAccount")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines the account base class.
 *
 */

/**
 * Creates the account.
 * @class
 * This class represents an account.
 * 
 * @param	{constant}	type	the account type (see <code>ZmAccount.TYPE_</code> constants)
 * @param	{String}	id		the account id
 * @param	{String}	name	the account name
 * @see		ZmAccount
 */
ZmAccount = function(type, id, name) {
	if (arguments.length == 0) { return; }

	this.id = id;
	this.name = name;
	this.type = type || ZmAccount.TYPE_ZIMBRA;
};


//
// Consts
//

/**
 * Defines the "AOL" account type.
 */
ZmAccount.TYPE_AOL		= "AOL";
/**
 * Defines the "Gmail" account type.
 */
ZmAccount.TYPE_GMAIL	= "Gmail";
/**
 * Defines the "IMAP" account type.
 */
ZmAccount.TYPE_IMAP		= "Imap";
/**
 * Defines the "Microsoft Live" or "Hotmail" account type.
 */
ZmAccount.TYPE_LIVE		= "Live";   // MS Live / hotmail
/**
 * Defines the "Microsoft Exchange IMAP" account type.
 */
ZmAccount.TYPE_MSE		= "MSE";    // exchange IMAP
/**
 * Defines the "Microsoft Exchange Mobile Sync" account type.
 */
ZmAccount.TYPE_EXCHANGE = "Xsync";  // exchange (using mobile sync protocol)
/**
 * Defines the "persona" account type.
 */
ZmAccount.TYPE_PERSONA	= "PERSONA";
/**
 * Defines the "POP" account type.
 */
ZmAccount.TYPE_POP		= "Pop";
/**
 * Defines the "Y! Mail" account type.
 */
ZmAccount.TYPE_YMP		= "YMP";    // Y! mail
/**
 * Defines the "Zimbra" account type.
 */
ZmAccount.TYPE_ZIMBRA	= "Zimbra";
/**
 * Defines the "Zimbra" account type.
 */
ZmAccount.TYPE_CALDAV	= "CalDAV";


ZmAccount.LOCAL_ACCOUNT_ID = "ffffffff-ffff-ffff-ffff-ffffffffffff";


//
// Public static methods
//

/**
 * Gets the name of the specified type.
 * 
 * @param	{constant}	type		the type (see <code>ZmAccount.TYPE_</code> constants)
 * @return	{String}	the name or unknown
 * 
 * @see		ZmAccount
 */
ZmAccount.getTypeName =
function(type) {
	switch (type) {
		case ZmAccount.TYPE_AOL:		return ZmMsg.aol;
		case ZmAccount.TYPE_GMAIL:		return ZmMsg.gmail;
		case ZmAccount.TYPE_IMAP:		return ZmMsg.accountTypeImap;
		case ZmAccount.TYPE_LIVE:		return ZmMsg.msLive;
		case ZmAccount.TYPE_MSE:		return ZmMsg.msExchange;
		case ZmAccount.TYPE_EXCHANGE:	return ZmMsg.msExchange;
		case ZmAccount.TYPE_PERSONA:	return ZmMsg.accountTypePersona;
		case ZmAccount.TYPE_POP:		return ZmMsg.accountTypePop;
		case ZmAccount.TYPE_YMP:		return ZmMsg.yahooMail;
		case ZmAccount.TYPE_ZIMBRA:		return ZmMsg.zimbraTitle;
	}
	return ZmMsg.unknown;
};


//
// Public methods
//

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmAccount.prototype.toString =
function() {
	return "ZmAccount";
};

/**
 * Sets the name of the account.
 * 
 * @param		{String}	name		the account name
 */
ZmAccount.prototype.setName =
function(name) {
	this.name = name;
};

/**
 * Gets the name of the account.
 * 
 * @return		{String}		the account name
 */
ZmAccount.prototype.getName =
function() {
	return this.name;
};

// sub-classes MUST override these methods

/**
 * Sets the email address for this account. Subclasses should override this method.
 * 
 * @param	{String}	email 	the email address
 */
ZmAccount.prototype.setEmail =
function(email) {
	throw this.toString()+"#setEmail";
};

/**
 * Gets the email address for this account. Subclasses should override this method.
 * 
 * @return	{String}	the email address
 */
ZmAccount.prototype.getEmail =
function() {
	throw this.toString()+"#getEmail";
};

/**
 * Gets the identity for this account. Subclasses should override this method.
 * 
 * @return	{String}	the identity
 */
ZmAccount.prototype.getIdentity =
function() {
	throw this.toString()+"#getIdentity";
};

ZmAccount.prototype.isLocal =
function() {
	return this.id == ZmAccount.LOCAL_ACCOUNT_ID;
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmZimbraAccount")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the zimbra account class.
 */

/**
 * Creates an account object containing meta info about the account.
 * @class
 * This class represents an account. This object is created primarily if a user has added sub-accounts
 * to manage (i.e. a family mailbox).
 *
 * @author Parag Shah
 *
 * @param {String}		id			the unique ID for this account
 * @param {String}		name		the email address
 * @param {Boolean}		visible		if <code>true</code>, make this account available in the overview (i.e. child accounts)
 *
 * @extends	ZmAccount
 */
ZmZimbraAccount = function(id, name, visible) {

	ZmAccount.call(this, null, id, name);

	this.visible = (visible !== false);
	/**
	 * The account settings.
	 * @type	ZmSettings
	 */
	this.settings = null;
	this.trees = {};
	this.loaded = false;
	/**
	 * The account Access Control List.
	 * @type	ZmAccessControlList
	 */
	this.acl = new ZmAccessControlList();
	this.metaData = new ZmMetaData(this);
};

ZmZimbraAccount.prototype = new ZmAccount;
ZmZimbraAccount.prototype.constructor = ZmZimbraAccount;

ZmZimbraAccount.prototype.isZmZimbraAccount = true;
ZmZimbraAccount.prototype.toString = function() { return "ZmZimbraAccount"; };


//
// Constants
//

/**
 * Defines the "unknown" status.
 */
ZmZimbraAccount.STATUS_UNKNOWN	= "unknown";
/**
 * Defines the "offline" status.
 */
ZmZimbraAccount.STATUS_OFFLINE	= "offline";
/**
 * Defines the "online" status.
 */
ZmZimbraAccount.STATUS_ONLINE	= "online";
/**
 * Defines the "running" status.
 */
ZmZimbraAccount.STATUS_RUNNING	= "running";
/**
 * Defines the "authentication fail" status.
 */
ZmZimbraAccount.STATUS_AUTHFAIL	= "authfail";
/**
 * Defines the "error" status.
 */
ZmZimbraAccount.STATUS_ERROR	= "error";

//
// Public methods
//

/**
 * Sets the name of the account.
 * 
 * @param		{String}	name	the account name
 */
ZmZimbraAccount.prototype.setName =
function(name) {
	var identity = this.getIdentity();
	// TODO: If no identity and name is set, should create one!
	if (!identity) return;
	identity.name = name;
};

/**
 * Gets the name of the account.
 * 
 * @return		{String}		the account name
 */
ZmZimbraAccount.prototype.getName =
function() {
	var identity = this.getIdentity();
	var name = (!identity)
		? this.settings.get(ZmSetting.DISPLAY_NAME)
		: identity.name;

	if (!name) {
		name = this.getDisplayName();
	}
	return identity.isDefault && name == ZmIdentity.DEFAULT_NAME ? ZmMsg.accountDefault : name;
};

/**
 * Sets the email address for this account. This method does nothing. The email address is set
 * when the object is created.
 * 
 * @param	{String}	email 	the email address (ignored)
 */
ZmZimbraAccount.prototype.setEmail =
function(email) {}; // IGNORE

/**
 * Gets the email address for this account.
 * 
 * @return	{String}	the email address
 */
ZmZimbraAccount.prototype.getEmail =
function() {
	return this.name;
};

/**
 * Gets the display name.
 * 
 * @return	{String}	the display name
 */
ZmZimbraAccount.prototype.getDisplayName =
function() {
	if (!this.displayName) {
		var dispName = this.isMain
			? this.settings.get(ZmSetting.DISPLAY_NAME)
			: this._displayName;
		this.displayName = (this._accountName || dispName || this.name);
	}
	return this.displayName;
};

/**
 * Gets the identity.
 * 
 * @return	{ZmIdentity}	the identity
 */
ZmZimbraAccount.prototype.getIdentity =
function() {
	var defaultIdentity = appCtxt.getIdentityCollection(this).defaultIdentity;
	if (!appCtxt.isFamilyMbox || this.isMain) {
		return defaultIdentity;
	}

	// for family mbox, create dummy identities for child accounts
	if (!this.dummyIdentity) {
		this.dummyIdentity = new ZmIdentity(this.name);
		AjxUtil.hashUpdate(this.dummyIdentity, defaultIdentity, true, ["name","isDefault"]);
	}
	return this.dummyIdentity;
};

/**
 * Gets the tool tip.
 * 
 * @return	{String}		the tool tip
 */
ZmZimbraAccount.prototype.getToolTip =
function() {
	if (this.status || this.lastSync || this.isMain) {
		var lastSyncDate = (this.lastSync && this.lastSync != 0)
			? (new Date(parseInt(this.lastSync))) : null;

		var quota = appCtxt.get(ZmSetting.QUOTA_USED, null, this);
		var lastSync;
		if (!lastSyncDate) {
			// this means, we've synced but server lost the last sync timestamp
			if (quota > 0 && !this.isMain) {
				lastSync = ZmMsg.unknown;
			}
		} else {
			lastSync = AjxDateUtil.computeWordyDateStr(new Date(), lastSyncDate);
		}

		var params = {
			lastSync: lastSync,
			hasNotSynced: this.hasNotSynced(),
			status: this.getStatusMessage(),
			quota: AjxUtil.formatSize(quota, false, 1)
		};

		return AjxTemplate.expand("share.App#ZimbraAccountTooltip", params);
	}
	return "";
};

/**
 * Gets the default color.
 * 
 * @return	{String}		the default color
 * @see		ZmOrganizer
 */
ZmZimbraAccount.prototype.getDefaultColor =
function() {
	if (this.isMain) {
		return ZmOrganizer.C_GRAY;
	}

	switch (this.type) {
		case ZmAccount.TYPE_GMAIL:		return ZmOrganizer.C_RED;
		case ZmAccount.TYPE_MSE:		return ZmOrganizer.C_GREEN;
		case ZmAccount.TYPE_EXCHANGE:	return ZmOrganizer.C_GREEN;
		case ZmAccount.TYPE_YMP:		return ZmOrganizer.C_PURPLE;
	}

	return null;
};

/**
 * Checks if the account has sync'd.
 * 
 * @return	{Boolean}	if <code>true</code>, this account has never been sync'd
 */
ZmZimbraAccount.prototype.hasNotSynced =
function() {
	return (this.isOfflineInitialSync() && 
			this.status == ZmZimbraAccount.STATUS_UNKNOWN &&
			appCtxt.get(ZmSetting.QUOTA_USED, null, this) == 0);
};

/**
 * Check is this account is currently sync'ing for the first time.
 * 
 * @return	{Boolean}	if <code>true</code>, this account is currently sync'ing for the first time
 */
ZmZimbraAccount.prototype.isOfflineInitialSync =
function() {
	return (appCtxt.isOffline && (!this.lastSync || (this.lastSync && this.lastSync == 0)));
};

/**
 * Checks if this account is CalDAV based.
 * 
 * @return	{Boolean}	if <code>true</code>, account is CalDAV based
 */
ZmZimbraAccount.prototype.isCalDavBased =
function() {
	return (this.type == ZmAccount.TYPE_GMAIL ||
			this.type == ZmAccount.TYPE_YMP);
};

/**
 * Gets the default calendar. For CalDAV based accounts, the default calendar is hidden;
 * therefore, this method returns the first non-default calendar.
 * 
 * @return	{Object}		the calendar
 * @see		ZmZimbraAccount.isCalDavBased
 */
ZmZimbraAccount.prototype.getDefaultCalendar =
function() {
	var tree = appCtxt.getFolderTree(this);
	if (this.isCalDavBased()) {
		var calendars = tree.getByType(ZmOrganizer.CALENDAR);
		for (var i = 0; i < calendars.length; i++) {
			if (calendars[i].nId == ZmOrganizer.ID_CALENDAR) { continue; }
			return calendars[i];
		}
	}
	return tree.getById(ZmOrganizer.ID_CALENDAR);
};

/**
 * Updates the account status.
 * 
 * @private
 */
ZmZimbraAccount.prototype.updateState =
function(acctInfo) {
	if (this.isMain) { return; } // main account doesn't sync

	// update last sync timestamp
	var updateTooltip = false;
	if (this.lastSync != acctInfo.lastsync) {
		this.lastSync = acctInfo.lastsync;
		if (this.visible) {
			updateTooltip = true;
		}
	}

	// set to update account (offline) status if changed
	var updateStatus = false;
	if (this.status != acctInfo.status) {
		this.status = acctInfo.status;
		if (this.visible) {
			updateStatus = true;
		}
	}

	// for all overview containers, update status/tooltip
	var container = appCtxt.getOverviewController()._overviewContainer;
	for (var i in container) {
		var c = container[i];
		if (updateStatus || updateTooltip) {
			c.updateAccountInfo(this, updateStatus, updateTooltip);
		}
	}

	if (this.visible && acctInfo.unread != this.unread) {
		this.unread = acctInfo.unread;
	}

	this.code = acctInfo.code;
	if (acctInfo.error) {
		var error = acctInfo.error[0];
		this.errorDetail = error.exception[0]._content;
		this.errorMessage = error.message;
	}
};

/**
 * Gets the status icon.
 * 
 * @return	{String}	the status icon
 */
ZmZimbraAccount.prototype.getStatusIcon =
function() {
	if (this.inNewMailMode) {
		return "NewMailAlert";
	}

	switch (this.status) {
//		case ZmZimbraAccount.STATUS_UNKNOWN:	return "Offline"; 				// bug: 42403 - remove
		case ZmZimbraAccount.STATUS_OFFLINE:	return "ImAway";
//		case ZmZimbraAccount.STATUS_ONLINE:		return "";						// no icon for "online"
//		case ZmZimbraAccount.STATUS_RUNNING:	// animated, so cannot be set using AjxImg
		case ZmZimbraAccount.STATUS_AUTHFAIL:	return "ImDnd";
		case ZmZimbraAccount.STATUS_ERROR:		return "Critical";
	}
	return null;
};

/**
 * Checks if this account is in error status.
 * 
 * @return	{Boolean}	if <code>true</code>, the account is in error status
 */
ZmZimbraAccount.prototype.isError =
function() {
	return (this.status == ZmZimbraAccount.STATUS_AUTHFAIL ||
			this.status == ZmZimbraAccount.STATUS_ERROR);
};

/**
 * Gets the icon.
 * 
 * @return	{String}	the icon
 */
ZmZimbraAccount.prototype.getIcon =
function() {
	return (this.isMain && appCtxt.isOffline) ? "LocalFolders" : this.icon;
};

/**
 * Gets the Zd message.
 * 
 * @private
 */
ZmZimbraAccount.prototype.getZdMsg =
function(code) {
	var msg = ((ZdMsg["client." + code]) || (ZdMsg["exception." + code]));
	if (!msg && code) {
		msg = ZdMsg["exception.offline.UNEXPECTED"];
	}
	return msg;
};

/**
 * Gets the status message.
 * 
 * @return	{String}		the status message
 */
ZmZimbraAccount.prototype.getStatusMessage =
function() {
	if (this.inNewMailMode) {
		return AjxMessageFormat.format(ZmMsg.unreadCount, this.unread);
	}

	switch (this.status) {
//		case ZmZimbraAccount.STATUS_UNKNOWN:	return ZmMsg.unknown;
		case ZmZimbraAccount.STATUS_OFFLINE:	return ZmMsg.netStatusOffline;
		case ZmZimbraAccount.STATUS_ONLINE:		return ZmMsg.netStatusOnline;
		case ZmZimbraAccount.STATUS_RUNNING:	return ZmMsg.running;
		case ZmZimbraAccount.STATUS_AUTHFAIL:	return this.code ? this.getZdMsg(this.code) : AjxMessageFormat.format(ZmMsg.authFailure, this.getEmail());
		case ZmZimbraAccount.STATUS_ERROR:		return this.code ? this.getZdMsg(this.code) : ZmMsg.error;
	}
	return "";
};

/**
 * Shows an error message.
 * 
 * Offline use only.
 * 
 * @private
 */
ZmZimbraAccount.prototype.showErrorMessage =
function() {
	if (!this.isError()) { return; }

	var dialog = (this.status == ZmZimbraAccount.STATUS_ERROR)
		? appCtxt.getErrorDialog() : appCtxt.getMsgDialog();

	// short message
	var msg = this.getZdMsg(this.code);
	if (msg == "") {
		msg = this.getStatusMessage();
	}
	dialog.setMessage(msg);

	if (this.status == ZmZimbraAccount.STATUS_ERROR) {
		// detailed message
		var html = [];
		var i = 0;
		if (this.errorMessage) {
			html[i++] = "<p><b>";
			html[i++] = ZdMsg.DebugMsg;
			html[i++] = "</b>: ";
			html[i++] = this.errorMessage;
			html[i++] = "</p>";
		}

		if (this.errorDetail) {
			html[i++] = "<p><b>";
			html[i++] = ZdMsg.DebugStack;
			html[i++] = "</b>:</p><p><pre>";
			html[i++] = this.errorDetail;
			html[i++] = "</pre></p>";
		}

		html[i++] = "<p><b>";
		html[i++] = ZdMsg.DebugActionNote;
		html[i++] = "</b></p>";

		dialog.setDetailString(html.join(""));
	}

	dialog.popup(null, true);
};

/**
 * @private
 */
ZmZimbraAccount.createFromDom =
function(node) {
	var acct = new ZmZimbraAccount();
	acct._loadFromDom(node);
	return acct;
};

/**
 * Loads the account.
 * 
 * @param	{AjxCallback}	callback		the callback
 */
ZmZimbraAccount.prototype.load =
function(callback) {
	if (!this.loaded) {
		// create new ZmSetting for this account
		this.settings = new ZmSettings();

		// check "{APP}_ENABLED" state against main account's settings
		var mainAcct = appCtxt.accountList.mainAccount;

		// for all *loaded* apps, add their app-specific settings
		for (var i = 0; i < ZmApp.APPS.length; i++) {
			var appName = ZmApp.APPS[i];
			var setting = ZmApp.SETTING[appName];
			if (setting && appCtxt.get(setting, null, mainAcct)) {
				var app = appCtxt.getApp(appName);
				if (app) {
					app._registerSettings(this.settings);
				}
			}
		}

		var command = new ZmBatchCommand(null, this.name);

		// load user settings retrieved from server now
		var loadCallback = new AjxCallback(this, this._handleLoadSettings);
		this.settings.loadUserSettings(loadCallback, null, this.name, null, command);

		// get tag info for this account *FIRST* - otherwise, root ID get overridden
		var tagDoc = AjxSoapDoc.create("GetTagRequest", "urn:zimbraMail");
		var tagCallback = new AjxCallback(this, this._handleLoadTags);
		command.addNewRequestParams(tagDoc, tagCallback);

		// get meta data for this account
		this.loadMetaData(null, command);

		// get folder info for this account
		var folderDoc = AjxSoapDoc.create("GetFolderRequest", "urn:zimbraMail");
		folderDoc.getMethod().setAttribute("visible", "1");
		var folderCallback = new AjxCallback(this, this._handleLoadFolders);
		command.addNewRequestParams(folderDoc, folderCallback);

		var respCallback = new AjxCallback(this, this._handleLoadUserInfo, callback);
		var errCallback = new AjxCallback(this, this._handleErrorLoad, callback);
		command.run(respCallback, errCallback);
	}
	else if (callback) {
		callback.run();
	}
};

ZmZimbraAccount.prototype.loadMetaData =
function(callback, batchCommand) {
	var metaDataCallback = new AjxCallback(this, this._handleLoadMetaData, [callback]);
	var sections = [ZmSetting.M_IMPLICIT, ZmSetting.M_OFFLINE];
	this.metaData.load(sections, metaDataCallback, batchCommand);
};

/**
 * Unloads the account and removes any account-specific data stored globally.
 * 
 */
ZmZimbraAccount.prototype.unload =
function() {
	if (!appCtxt.inStartup) {
		// unset account-specific shortcuts
		this.settings.loadShortcuts(true);
	}
};

/**
 * Sync the account.
 * 
 * @param	{AjxCallback}	callback		the callback
 */
ZmZimbraAccount.prototype.sync =
function(callback) {
	var soapDoc = AjxSoapDoc.create("SyncRequest", "urn:zimbraOffline");
	if (appCtxt.get(ZmSetting.OFFLINE_DEBUG_TRACE)) {
		var method = soapDoc.getMethod();
		method.setAttribute("debug", 1);
	}
	appCtxt.getAppController().sendRequest({
		soapDoc:soapDoc,
		asyncMode:true,
		noBusyOverlay:true,
		callback:callback,
		accountName:this.name
	});
};

/**
 * Saves the account.
 * 
 * @param	{AjxCallback}	callback		the callback
 * @param	{AjxCallback}	errorCallback		the error callback
 * @param	{Object}	batchCmd		the batch command
 */
ZmZimbraAccount.prototype.save =
function(callback, errorCallback, batchCmd) {
	return (this.getIdentity().save(callback, errorCallback, batchCmd));
};

/**
 * Saves implicit prefs. Because it's done onunload, the save is sync.
 * 
 * @private
 */
ZmZimbraAccount.prototype.saveImplicitPrefs =
function() {
    var isExternal = this.settings ? this.settings.get(ZmSetting.IS_EXTERNAL) : false;
    if (isExternal) {
        return;
    }
	var list = [];
	for (var id in ZmSetting.CHANGED_IMPLICIT) {
		var setting = this.settings ? this.settings.getSetting(id) : null;
		if (ZmSetting.IS_GLOBAL[setting.id] && !this.isMain) { continue; }
		if (setting && (setting.getValue(null, true) != setting.getOrigValue(null, true))) {
			list.push(setting);
		}
	}

	if (list.length > 0) {
		this.settings.save(list, null, null, this);
	}
};

/**
 * Checks if this account supports the given application name
 *
 * @param {String}		appName		the name of the application
 * @return	{Boolean}	<code>true</code> if account supports the application
 */
ZmZimbraAccount.prototype.isAppEnabled =
function(appName) {
	switch (appName) {
		case ZmApp.BRIEFCASE: 	return appCtxt.get(ZmSetting.BRIEFCASE_ENABLED, null, this);
		case ZmApp.CALENDAR:	return appCtxt.get(ZmSetting.CALENDAR_ENABLED, 	null, this);
		case ZmApp.CONTACTS:	return appCtxt.get(ZmSetting.CONTACTS_ENABLED, 	null, this);
		case ZmApp.MAIL:		return appCtxt.get(ZmSetting.MAIL_ENABLED, 		null, this);
		case ZmApp.PREFERENCES:	return appCtxt.get(ZmSetting.OPTIONS_ENABLED, 	null, this);
		case ZmApp.TASKS:		return appCtxt.get(ZmSetting.TASKS_ENABLED, 	null, this);
	}
	return false;
};


//
// Protected methods
//

/**
 * @private
 */
ZmZimbraAccount.prototype._handleLoadSettings =
function(result) {
	DBG.println(AjxDebug.DBG1, "Account settings successfully loaded for " + this.name);

	// set account type
	this.type = appCtxt.isOffline
		? appCtxt.get(ZmSetting.OFFLINE_ACCOUNT_FLAVOR, null, this)
		: ZmAccount.TYPE_ZIMBRA;

	this.isZimbraAccount = this.type == ZmAccount.TYPE_ZIMBRA;

	// set icon now that we know the type
	switch (this.type) {
		case ZmAccount.TYPE_AOL:		this.icon = "AccountAOL"; break;
		case ZmAccount.TYPE_GMAIL:		this.icon = "AccountGmail"; break;
		case ZmAccount.TYPE_IMAP:		this.icon = "AccountIMAP"; break;
		case ZmAccount.TYPE_LIVE:		this.icon = "AccountMSN"; break;
		case ZmAccount.TYPE_MSE:		this.icon = "AccountExchange"; break;
		case ZmAccount.TYPE_EXCHANGE:	this.icon = "AccountExchange"; break;
		case ZmAccount.TYPE_POP:		this.icon = "AccountPOP"; break;
		case ZmAccount.TYPE_YMP:		this.icon = "AccountYahoo"; break;
		case ZmAccount.TYPE_ZIMBRA:		this.icon = "AccountZimbra"; break;
	}

	// initialize identities/data-sources/signatures for this account
	var obj = result.getResponse().GetInfoResponse;
	appCtxt.getIdentityCollection(this).initialize(obj.identities);
	appCtxt.getDataSourceCollection(this).initialize(obj.dataSources);
	appCtxt.getSignatureCollection(this).initialize(obj.signatures);

};

/**
 * @private
 */
ZmZimbraAccount.prototype._handleLoadFolders =
function(result) {
	var resp = result.getResponse().GetFolderResponse;
	var folders = resp ? resp.folder[0] : null;
	if (folders) {
		appCtxt.getRequestMgr()._loadTree(ZmOrganizer.FOLDER, null, resp.folder[0], "folder", this);
	}
};

/**
 * @private
 */
ZmZimbraAccount.prototype._handleLoadTags =
function(result) {
	var resp = result.getResponse().GetTagResponse;
	appCtxt.getRequestMgr()._loadTree(ZmOrganizer.TAG, null, resp, null, this);
};

/**
 * @private
 */
ZmZimbraAccount.prototype._handleLoadUserInfo =
function(callback) {
	this.loaded = true;

	// bug fix #33168 - get perms for all mountpoints in account
	var folderTree = appCtxt.getFolderTree(this);
	if (folderTree) {
		folderTree.getPermissions({noBusyOverlay:true, accountName:this.name});
	}

	if (callback) {
		callback.run();
	}
};

/**
 * @private
 */
ZmZimbraAccount.prototype._handleLoadMetaData =
function(callback, sections) {
	for (var i in sections) {
		this.settings.createFromJs(sections[i]);
	}

	if (callback) {
		callback.run();
	}
};

/**
 * @private
 */
ZmZimbraAccount.prototype._handleErrorLoad =
function(callback, ev) {
	DBG.println(AjxDebug.DBG1, "------- ERROR loading account settings for " + this.name);
	if (callback) {
		callback.run();
	}
};

/**
 * @private
 */
ZmZimbraAccount.prototype._loadFromDom =
function(node) {
	this.id = node.id;
	this.name = node.name;
	this.visible = node.visible;
	this.active = node.active;

	var data = node.attrs && node.attrs._attrs;
	this._displayName = data ? data.displayName : this.email;
	this._accountName = data && data.zimbraPrefLabel;
};
}
if (AjxPackage.define("zimbraMail.share.model.ZmTag")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the tag class.
 */

/**
 * Creates a tag
 * @class
 * This class represents a tag.
 * 
 * @param	{Hash}	params		a hash of parameters
 * @extends	ZmOrganizer
 */
ZmTag = function(params) {
	params.type = ZmOrganizer.TAG;
	ZmOrganizer.call(this, params);
	this.notLocal = params.notLocal;
};

ZmTag.prototype = new ZmOrganizer;
ZmTag.prototype.constructor = ZmTag;
ZmTag.prototype.isZmTag = true;

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmTag.prototype.toString = 
function() {
	return "ZmTag";
};

// color icons
ZmTag.COLOR_ICON = new Object();
ZmTag.COLOR_ICON[ZmOrganizer.C_ORANGE]	= "TagOrange";
ZmTag.COLOR_ICON[ZmOrganizer.C_BLUE]	= "TagBlue";
ZmTag.COLOR_ICON[ZmOrganizer.C_CYAN]	= "TagCyan";
ZmTag.COLOR_ICON[ZmOrganizer.C_GREEN]	= "TagGreen";
ZmTag.COLOR_ICON[ZmOrganizer.C_PURPLE]	= "TagPurple";
ZmTag.COLOR_ICON[ZmOrganizer.C_RED]		= "TagRed";
ZmTag.COLOR_ICON[ZmOrganizer.C_YELLOW]	= "TagYellow";


// system tags
ZmTag.ID_ROOT = ZmOrganizer.ID_ROOT;
ZmTag.ID_UNREAD		= 32;
ZmTag.ID_FLAGGED	= 33;
ZmTag.ID_FROM_ME	= 34;
ZmTag.ID_REPLIED	= 35;
ZmTag.ID_FORWARDED	= 36;
ZmTag.ID_ATTACHED	= 37;

/**
 * Tags come from back end as a flat list, and we manually create a root tag, so all tags
 * have the root as parent. If tags ever have a tree structure, then this should do what
 * ZmFolder does (recursively create children).
 * 
 * @private
 */
ZmTag.createFromJs =
function(parent, obj, tree, sorted, account) {
	var tag;
	var nId = ZmOrganizer.normalizeId(obj.id);
	if (nId < ZmOrganizer.FIRST_USER_ID[ZmOrganizer.TAG]) { return; }
	tag = tree.getById(obj.id);
	if (tag) { return tag; }

	var params = {
		id: obj.id,
		name: obj.name,
		color: ZmTag.checkColor(obj.color),
		rgb: obj.rgb,
		parent: parent,
		tree: tree,
		numUnread: obj.u,
		account: account
	};
	tag = new ZmTag(params);
	var index = sorted ? ZmOrganizer.getSortIndex(tag, ZmTag.sortCompare) : null;
	parent.children.add(tag, index);

	var tagNameMap = parent.getTagNameMap();
	tagNameMap[obj.name] = tag;

	return tag;
};

ZmTag.createNotLocalTag =
function(name) {
	//cache so we don't create many objects in case many items are tagged by non local tags.
	var cache = ZmTag.notLocalCache = ZmTag.notLocalCache || [];
	var tag = cache[name];
	if (tag) {
		return tag;
	}
	tag = new ZmTag({notLocal: true, id: "notLocal_" + name, name: name});
	cache[name] = tag;
	return tag;
};

/**
 * Compares the tags by name.
 * 
 * @param	{ZmTag}	tagA		the first tag
 * @param	{ZmTag}	tagB		the second tag
 * @return	{int}	0 if the tag names match (case-insensitive); 1 if "a" is before "b"; -1 if "b" is before "a"
 */
ZmTag.sortCompare = 
function(tagA, tagB) {
	var check = ZmOrganizer.checkSortArgs(tagA, tagB);
	if (check != null) return check;

	if (tagA.name.toLowerCase() > tagB.name.toLowerCase()) return 1;
	if (tagA.name.toLowerCase() < tagB.name.toLowerCase()) return -1;
	return 0;
};

/**
 * Checks the tag name.
 * 
 * @param	{String}	name		the name
 * @return	{String}	<code>null</code> if the name is valid or a error message
 */
ZmTag.checkName =
function(name) {
	var msg = ZmOrganizer.checkName(name);
	if (msg) { return msg; }

	if (name.indexOf('\\') == 0) {
		return AjxMessageFormat.format(ZmMsg.errorInvalidName, AjxStringUtil.htmlEncode(name));
	}

	return null;
};

/**
 * Checks the color.
 * 
 * @param	{String}	color	the color
 * @return	{Number}	the valid color
 */
ZmTag.checkColor =
function(color) {
	color = Number(color);
	return ((color != null) && (color >= 0 && color <= ZmOrganizer.MAX_COLOR)) ? color : ZmOrganizer.DEFAULT_COLOR[ZmOrganizer.TAG];
};

ZmTag.getIcon = function(color) {
    var object = { getIcon:ZmTag.prototype.getIcon, getColor:ZmTag.prototype.getColor, color:color };
    if (String(color).match(/^#/)) {
        object.rgb = color;
        object.color = null;
    }
    return ZmTag.prototype.getIconWithColor.call(object);
}

/**
 * Creates a tag.
 * 
 * @param	{Hash}	params	a hash of parameters
 */
ZmTag.create =
function(params) {
	var request = {_jsns: "urn:zimbraMail"};
	var jsonObj = {CreateTagRequest: request};
	request.tag = {name: params.name}

    if (params.rgb) {
        request.tag.rgb = params.rgb;
    }
    else {
        request.tag.color = ZmOrganizer.checkColor(params.color) || ZmOrganizer.DEFAULT_COLOR[ZmOrganizer.TAG];
    }
	var errorCallback = new AjxCallback(null, ZmTag._handleErrorCreate, params);
	appCtxt.getAppController().sendRequest({
			jsonObj: jsonObj,
			asyncMode: true,
			errorCallback: errorCallback,
			accountName: params.accountName
	});
};

/**
 * @private
 */
ZmTag._handleErrorCreate =
function(params, ex) {
	if (ex.code == ZmCsfeException.MAIL_INVALID_NAME) {
		var msg = AjxMessageFormat.format(ZmMsg.errorInvalidName, AjxStringUtil.htmlEncode(params.name));
		var msgDialog = appCtxt.getMsgDialog();
		msgDialog.setMessage(msg, DwtMessageDialog.CRITICAL_STYLE);
		msgDialog.popup();
		return true;
	}
	return false;
};

/**
 * Gets the icon.
 * 
 * @return	{String}	the icon or <code>null</code> for no icon
 */
ZmTag.prototype.getIcon = 
function() {
	if (this.notLocal) {
		return "TagShared";
	}
	
	return (this.id == ZmOrganizer.ID_ROOT) ? null : "Tag";
};

/**
 * map from tag names to tags. used by getByNameOrRemote
 */
ZmTag.prototype.getTagNameMap =
function() {
	if (!this.tagNameMap) {
		this.tagNameMap = {};
	}
	return this.tagNameMap;
};

/**
 * Creates a query for this tag.
 * 
 * @return	{String}	the tag query
 */
ZmTag.prototype.createQuery =
function() {
	return ['tag:"', this.name, '"'].join("");
};

/**
 * Gets the tool tip.
 * 
 * @return	{String}	the tool tip
 */
ZmTag.prototype.getToolTip = function() {};

/**
 * @private
 */
ZmTag.prototype.notifyCreate =
function(obj) {
	var child = ZmTag.createFromJs(this, obj, this.tree, true);
	child._notify(ZmEvent.E_CREATE);
};


ZmTag.prototype.notifyModify =
function(obj) {
	if (obj.name) {
		//this is a rename - update the tagNameMap
		var oldName = this.name;
		var nameMap = this.parent.getTagNameMap();
		delete nameMap[oldName];
		nameMap[obj.name] = this;
		//we don't change the name on this ZmTag object here, it is done in ZmOrganizer.prototype.notifyModify
	}
	ZmOrganizer.prototype.notifyModify.call(this, obj);
};


ZmTag.prototype.notifyDelete =
function() {
	var nameMap = this.parent.getTagNameMap();
	delete nameMap[this.name];  //remove from name map
	
	ZmOrganizer.prototype.notifyDelete.call(this);
};

/**
 * Checks if the tag supports sharing.
 * 
 * @return	{Boolean}	always returns <code>false</code>. Tags cannot be shared.
 */
ZmTag.prototype.supportsSharing =
function() {
	// tags cannot be shared
	return false;
};

ZmTag.prototype.getByNameOrRemote =
function(name) {
	var tagNameMap = this.getTagNameMap();
	var tag = tagNameMap[name];
	if (tag) {
		return tag;
	}
	return ZmTag.createNotLocalTag(name);
};



}

if (AjxPackage.define("zimbraMail.core.ZmApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 *
 * This file defines a Zimbra Application class.
 *
 */

/**
 * Creates the application.
 * @class
 * This object represents a Zimbra Application. This class is a base class for application classes.
 * "App" is a useful abstraction for a set of related functionality, such as mail,
 * address book, or calendar. Looked at another way, an app is a collection of one or more controllers.
 * 
 * @param	{String}	name		the application name
 * @param	{DwtControl}	container	the control that contains components
 * @param	{ZmController}	parentController	the parent window controller (set by the child window)
 *
 */
ZmApp = function(name, container, parentController) {

	if (arguments.length == 0) return;
	
	this._name = name;
	this._container = container;
	this._parentController = parentController;
	this._active = false;
	this.currentSearch = null;
    this._defaultFolderId = null;   //reqd in case of external user

	this._deferredFolders = [];
	this._deferredFolderHash = {};
	this._deferredNotifications = [];

	this._sessionController		= {};
	this._nextSessionId			= {};
	this._curSessionId			= {};

	ZmApp.DROP_TARGETS[name] = {};

	this._defineAPI();
	if (!parentController) {
		this._registerSettings();
	}
	this._registerOperations();
	this._registerItems();
	this._registerOrganizers();
	if (!parentController) {
		this._setupSearchToolbar();
	}
	this._registerApp();

};

// app information ("_R" means "reverse map")

// these are needed statically (before we get user settings)
ZmApp.CLASS					= {};	// constructor for app class
ZmApp.SETTING				= {};	// ID of setting that's true when app is enabled
ZmApp.UPSELL_SETTING		= {};	// ID of setting that's true when app upsell is enabled
ZmApp.LOAD_SORT				= {};	// controls order in which apps are instantiated
ZmApp.BUTTON_ID				= {};	// ID for app button on app chooser toolbar

// these are set via registerApp() in app constructor
ZmApp.MAIN_PKG				= {};	// main package that composes the app
ZmApp.NAME					= {};	// msg key for app name
ZmApp.ICON					= {};	// name of app icon class
ZmApp.TEXT_PRECEDENCE		= {};	// order for removing button text
ZmApp.IMAGE_PRECEDENCE		= {};	// order for removing button image
ZmApp.QS_ARG				= {};	// arg for 'app' var in QS to jump to app
ZmApp.QS_ARG_R				= {};
ZmApp.CHOOSER_TOOLTIP		= {};	// msg key for app view menu tooltip
ZmApp.VIEW_TOOLTIP			= {};	// msg key for app tooltip
ZmApp.DEFAULT_SEARCH		= {};	// type of item to search for in the app
ZmApp.ORGANIZER				= {};	// main organizer for this app
ZmApp.OVERVIEW_TREES		= {};	// list of tree IDs to show in overview
ZmApp.HIDE_ZIMLETS			= {};	// whether to show Zimlet tree in overview
ZmApp.SEARCH_TYPES			= {};	// list of types of saved searches to show in overview
ZmApp.SEARCH_TYPES_R		= {};
ZmApp.GOTO_ACTION_CODE		= {};	// key action for jumping to this app
ZmApp.GOTO_ACTION_CODE_R	= {};
ZmApp.NEW_ACTION_CODE		= {};	// default "new" key action
ZmApp.ACTION_CODES			= {};	// key actions that map to ops
ZmApp.ACTION_CODES_R		= {};
ZmApp.OPS					= {};	// IDs of operations for the app
ZmApp.OPS_R					= {};	// map of operation ID to app
ZmApp.QS_VIEWS				= {};	// list of views to handle in query string
ZmApp.TRASH_VIEW_OP			= {};	// menu choice for "Show Only ..." in Trash view
ZmApp.UPSELL_URL			= {};	// URL for content of upsell
//ZmApp.QUICK_COMMAND_TYPE	= {};
ZmApp.DROP_TARGETS			= {};	// drop targets (organizers) by item/organizer type
ZmApp.SEARCH_RESULTS_TAB	= {};	// whether to show search results in a tab

// indexes to control order of appearance/action
ZmApp.CHOOSER_SORT			= {};	// controls order of apps in app chooser toolbar
ZmApp.DEFAULT_SORT			= {};	// controls order in which app is chosen as default start app

ZmApp.ENABLED_APPS			= {};	// hash for quick detection if app is enabled

// ordered lists of apps
ZmApp.APPS					= [];	// ordered list
ZmApp.DEFAULT_APPS			= [];	// ordered list

ZmApp.OVERVIEW_ID			= "main";	// ID for main overview

ZmApp.BATCH_NOTIF_LIMIT = 25;	// threshold for doing batched change notifications

ZmApp.MAIN_SESSION			= "main";
ZmApp.HIDDEN_SESSION		= "hidden";

/**
 * Initializes the application.
 *
 * @private
 */
ZmApp.initialize =
function() {
	if (appCtxt.get(ZmSetting.USE_KEYBOARD_SHORTCUTS)) {
		ZmApp.ACTION_CODES[ZmKeyMap.NEW_FOLDER]	= ZmOperation.NEW_FOLDER;
		ZmApp.ACTION_CODES[ZmKeyMap.NEW_TAG]	= ZmOperation.NEW_TAG;
	}
};

/**
 * Registers and stores information about an app. Note: Setting a value that evaluates to
 * false (such as 0 or an empty string) will not do anything.
 *
 * @param {constant}	app				the app ID
 * @param {Hash}	params			a hash of parameters
 * @param params.mainPkg			[string]	main package that contains the app
 * @param params.nameKey			[string]	msg key for app name
 * @param params.icon				[string]	name of app icon class
 * @param params.textPrecedence		[int]		order for removing button text
 * @param params.imagePrecedence	[int]		order for removing button image
 * @param params.chooserTooltipKey	[string]	msg key for app tooltip
 * @param params.viewTooltipKey		[string]	msg key for app view menu tooltip
 * @param params.defaultSearch		[constant]	type of item to search for in the app
 * @param params.organizer			[constant]	main organizer for this app
 * @param params.overviewTrees		[array]		list of tree IDs to show in overview
 * @param params.hideZimlets		[boolean]	if true, hide Zimlet tree in overview
 * @param params.searchTypes		[array]		list of types of saved searches to show in overview
 * @param params.gotoActionCode		[constant]	key action for jumping to this app
 * @param params.newActionCode		[constant]	default "new" action code
 * @param params.actionCodes		[hash]		keyboard actions mapped to operations
 * @param params.newItemOps			[hash]		IDs of operations that create a new item, and their text keys
 * @param params.newOrgOps			[hash]		IDs of operations that create a new organizer, and their text keys
 * @param params.qsViews			[array]		list of views to handle in query string
 * @param params.chooserSort		[int]		controls order of apps in app chooser toolbar
 * @param params.defaultSort		[int]		controls order in which app is chosen as default start app
 * @param params.trashViewOp		[constant]	menu choice for "Show Only ..." in Trash view
 * @param params.upsellUrl			[string]	URL for content of upsell
 * @param params.searchResultsTab	[string]	if true, show search results in a tab
 *
 * @private
 */
ZmApp.registerApp =
function(app, params) {

	// TODO: why the ifs? this should only be called once per app
	if (params.mainPkg)				{ ZmApp.MAIN_PKG[app]			= params.mainPkg; }
	if (params.nameKey)				{ ZmApp.NAME[app]				= params.nameKey; }
	if (params.icon)				{ ZmApp.ICON[app]				= params.icon; }
	if (params.textPrecedence)		{ ZmApp.TEXT_PRECEDENCE[app]	= params.textPrecedence; }
	if (params.imagePrecedence)		{ ZmApp.IMAGE_PRECEDENCE[app]	= params.imagePrecedence; }
	if (params.chooserTooltipKey)	{ ZmApp.CHOOSER_TOOLTIP[app]	= params.chooserTooltipKey; }
	if (params.viewTooltipKey)		{ ZmApp.VIEW_TOOLTIP[app]		= params.viewTooltipKey; }
	if (params.defaultSearch)		{ ZmApp.DEFAULT_SEARCH[app]		= params.defaultSearch; }
	if (params.organizer)			{ ZmApp.ORGANIZER[app]			= params.organizer; }
	if (params.overviewTrees)		{ ZmApp.OVERVIEW_TREES[app]		= params.overviewTrees; }
	if (params.hideZimlets)			{ ZmApp.HIDE_ZIMLETS[app]		= params.hideZimlets; }
	if (params.searchTypes) 		{ ZmApp.SEARCH_TYPES[app]		= params.searchTypes; }
	if (params.gotoActionCode)		{ ZmApp.GOTO_ACTION_CODE[app]	= params.gotoActionCode; }
	if (params.newActionCode)		{ ZmApp.NEW_ACTION_CODE[app]	= params.newActionCode; }
	if (params.qsViews)				{ ZmApp.QS_VIEWS[app]			= params.qsViews; }
	if (params.chooserSort)			{ ZmApp.CHOOSER_SORT[app]		= params.chooserSort; }
	if (params.defaultSort)			{ ZmApp.DEFAULT_SORT[app]		= params.defaultSort; }
	if (params.trashViewOp)			{ ZmApp.TRASH_VIEW_OP[app]		= params.trashViewOp; }
	if (params.upsellUrl)			{ ZmApp.UPSELL_URL[app]			= params.upsellUrl; }
	//if (params.quickCommandType)	{ ZmApp.QUICK_COMMAND_TYPE[app]	= params.quickCommandType; }
	if (params.searchResultsTab)	{ ZmApp.SEARCH_RESULTS_TAB[app]	= params.searchResultsTab; }

	if (params.searchTypes) {
		ZmApp.SEARCH_TYPES_R[app] = {};
		for (var i = 0; i < params.searchTypes.length; i++) {
			ZmApp.SEARCH_TYPES_R[app][params.searchTypes[i]] = true;
		}
	}

	if (params.gotoActionCode) {
		ZmApp.GOTO_ACTION_CODE_R[params.gotoActionCode] = app;
	}

	if (params.actionCodes) {
		for (var ac in params.actionCodes) {
			if (!ac) { continue; }
			ZmApp.ACTION_CODES_R[ac] = app;
			ZmApp.ACTION_CODES[ac] = params.actionCodes[ac];
		}
	}

    var appEnabled = appCtxt.get(ZmApp.SETTING[app]);
	if (params.newItemOps && appEnabled) {
		for (var op in params.newItemOps) {
			if (!op) { continue; }
			ZmApp.OPS_R[op] = app;
			ZmOperation.NEW_ITEM_OPS.push(op);
			ZmOperation.NEW_ITEM_KEY[op] = params.newItemOps[op];
		}
	}
	if (params.newOrgOps && appEnabled) {
		for (var op in params.newOrgOps) {
			if (!op) { continue; }
			ZmApp.OPS_R[op] = app;
			ZmOperation.NEW_ORG_OPS.push(op);
			ZmOperation.NEW_ORG_KEY[op] = params.newOrgOps[op];
		}
	}

	if (params.qsViews) {
		for (var i = 0; i < params.qsViews.length; i++) {
			ZmApp.QS_VIEWS[params.qsViews[i]] = app;
		}
	}

    /* if (params.quickCommandType) {
        ZmQuickCommand.itemTypes.push(params.quickCommandType);
    } */
};


/**
 * Runs the given function for all known (e.g. part of ZmApp.CLASS)
 * app classes, passing args.
 * NOTE: This runs class functions only, not instance (prototype) functions.
 * @static
 * @param funcName {String} The name of the function we will run on each
 * application.
 * @param mixed {mixed} 0 to n additional arguments are passed to funcName
 * via apply.
 */
ZmApp.runAppFunction =
function(funcName) {
    var args;

    for (var appName in ZmApp.CLASS) {
        var app = window[ZmApp.CLASS[appName]];
        var func = app && app[funcName];
        if (func && (typeof(func) == "function")) {
            args = args || Array.prototype.slice.call(arguments, 1);
            func.apply(app, args);
        }
    }
};


// Public instance methods

/**
 * Returns a string representation of the object.
 *
 * @return		{String}		a string representation of the object
 */
ZmApp.prototype.toString =
function() {
	return "ZmApp";
};

// Functions called during construction
ZmApp.prototype._defineAPI				= function() {};
ZmApp.prototype._registerSettings		= function() {};
ZmApp.prototype._registerOperations		= function() {};
ZmApp.prototype._registerItems			= function() {};
ZmApp.prototype._registerOrganizers		= function() {};
ZmApp.prototype._setupSearchToolbar		= function() {};
ZmApp.prototype._registerApp			= function() {};
ZmApp.prototype._registerPrefs			= function() {};						// called when Preferences pkg is loaded

// Functions that apps can override in response to certain events
ZmApp.prototype.startup					= function(result) {};					// run during startup
ZmApp.prototype.preNotify				= function(notify) {};					// run before handling notifications
ZmApp.prototype.deleteNotify			= function(ids) {};						// run on delete notifications
ZmApp.prototype.createNotify			= function(list) {};					// run on create notifications
ZmApp.prototype.modifyNotify			= function(list) {};					// run on modify notifications
ZmApp.prototype.postNotify				= function(notify) {};					// run after handling notifications
ZmApp.prototype.refresh					= function(refresh) {};					// run when a <refresh> block arrives
ZmApp.prototype.handleOp				= function(op, params) {};				// handle an operation

/**
 * Gets the application name.
 *
 * @return	{String}	the name
 */
ZmApp.prototype.getName =
function() {
	return this._name;
};

/**
 * Gets the application display name.
 *
 * @return	{String}	the display name
 */
ZmApp.prototype.getDisplayName =
function() {
	return ZmMsg[ZmApp.NAME[this._name]] || ZmApp.NAME[this._name];
};

/**
 * Gets the initial search type.
 *
 * @return	{Object}	<code>null</code> since only set if different from the default
 */
ZmApp.prototype.getInitialSearchType =
function() {
	return null;
};

/**
 * Gets the limit for the search triggered by the application launch or an overview click.
 *
 * @return	{int}	the limit
 */
ZmApp.prototype.getLimit =
function(offset) {
	return appCtxt.get(ZmSetting.PAGE_SIZE);
};

/**
 * Sets the application view.
 *
 * @param		{String}	view		the view
 * @see		ZmAppViewMgr
 */
ZmApp.prototype.setAppView =
function(view) {
	appCtxt.getAppViewMgr().setAppView(this._name, view);
};

/**
 * Creates the application view.
 *
 * @param		{Hash}	params		a hash of parameters
 * @see		ZmAppViewMgr
 * @see		ZmAppViewMgr#createView
 */
ZmApp.prototype.createView =
function(params) {
	params.appName = this._name;
	return appCtxt.getAppViewMgr().createView(params);
};

/**
 * Pushes the application view.
 *
 * @param	{String}	name	the view name
 * @param	{Boolean}	force	<code>true</code> to force the view onto the stack
 * @see		ZmAppViewMgr#pushView
 */
ZmApp.prototype.pushView =
function(name, force) {
	return appCtxt.getAppViewMgr().pushView(name, force);
};

/**
 * Pops the application view.
 *
 * @param	{Boolean}	force	<code>true</code> to force the view off the stack
 * @see		ZmAppViewMgr#popView
 */
ZmApp.prototype.popView =
function(force, viewId, skipHistory) {
	return appCtxt.getAppViewMgr().popView(force, viewId, skipHistory);
};

/**
 * Sets the application view.
 *
 * @param	{String}	name	the view name
 * @param	{Boolean}	force	<code>true</code> to force the view
 * @see		ZmAppViewMgr#setView
 */
ZmApp.prototype.setView =
function(name, force) {
	return appCtxt.getAppViewMgr().setView(name, force);
};

/**
 * Stages the application view.
 *
 * @param	{String}	name	the view name
 * @see		ZmAppViewMgr#stageView
 */
ZmApp.prototype.stageView =
function(name) {
	return appCtxt.getAppViewMgr().stageView(name);
};

/**
 * Adds a deferred folder.
 *
 * @param	{Hash}	params		a hash of parameters
 */
ZmApp.prototype.addDeferredFolder =
function(params) {
	var id = params.obj && params.obj.id;
	if (id && !this._deferredFolderHash[id]) {
		this._deferredFolders.push(params);
		this._deferredFolderHash[id] = true;
		appCtxt.cacheSetDeferred(id, this._name);
	}
};

/**
 * Gets the remote folder ids.
 *
 * @param	{Object}	account		the account
 * @return	{Array}		an array of {String} ids
 */
ZmApp.prototype.getRemoteFolderIds =
function(account) {
	// XXX: optimize by caching this list? It would have to be cleared anytime
	// folder structure changes
	var list = [];
	if (appCtxt.getOverviewController(true)) {
		var type = ZmApp.ORGANIZER[this.getName()];

		// first, make sure there aren't any deferred folders that need to be created
		if (this._deferredFolders.length) {
			this._createDeferredFolders(type);
		}

		var tree = appCtxt.getFolderTree(account);
		var folders = tree ? tree.getByType(type) : [];
		for (var i = 0; i < folders.length; i++) {
			var folder = folders[i];
			if (folder.isRemote()) {
				list.push(folder.id);
			}
		}
	}
	return list;
};

/**
 * Creates the overview content for this app. The default implementation creates
 * a {@link ZmOverview} with standard options. Other apps may want to use different
 * options, or create a {@link DwtComposite} instead.
 *
 * @return	{String}	the content
 */
ZmApp.prototype.getOverviewPanelContent =
function() {
	if (!this._overviewPanelContent) {
		var params = this._getOverviewParams();
		params.overviewId = this.getOverviewId();
		var ov = this._overviewPanelContent = appCtxt.getOverviewController().createOverview(params);
		ov.set(this._getOverviewTrees());
	}

	return this._overviewPanelContent;
};



/**
 * Gets the overview container.
 *
 * @return	{ZmOverview}		the overview container
 */
ZmApp.prototype.getOverviewContainer =
function(dontCreate) {
	if (!this._overviewContainer && !dontCreate) {
		var containerParams = {
			appName: this._name,
			containerId: ([ZmApp.OVERVIEW_ID, this._name].join("_")),
			posStyle: Dwt.ABSOLUTE_STYLE
		};
		var overviewParams = this._getOverviewParams();
		overviewParams.overviewTrees = this._getOverviewTrees();

		this._overviewContainer = appCtxt.getOverviewController().createOverviewContainer(containerParams, overviewParams);
	}

	return this._overviewContainer;
};

/**
 * Sets the overview tree to display overview content for this application.
 *
 * @param {Boolean}	reset		if <code>true</code>, clear the content first
 */
ZmApp.prototype.setOverviewPanelContent =
function(reset) {
	if (reset) {
		this._overviewPanelContent = null;
		this._overviewContainer = null;
	}

	// only set overview panel content if not in full screen mode
	var avm = appCtxt.getAppViewMgr();
	if (!avm.isFullScreen()) {
		Dwt.setLoadingTime(this.toString() + "-overviewPanel");
		var ov = ((appCtxt.multiAccounts && appCtxt.accountList.size() > 1) || this.getName() == ZmApp.VOICE)
			? this.getOverviewContainer()
			: this.getOverviewPanelContent();
		var components = {};
		components[ZmAppViewMgr.C_TREE] = ov;
		avm.setViewComponents(ZmAppViewMgr.APP, components, true, this.getName());
		Dwt.setLoadedTime(this.toString() + "-overviewPanel");
	}
};

/**
 * Gets the current overview, if any. Subclasses should ensure that a {@link ZmOverview} is returned.
 *
 * @return	{ZmOverview}	the overview
 */
ZmApp.prototype.getOverview =
function() {
	var opc = appCtxt.getOverviewController();
	return opc && opc.getOverview(this.getOverviewId());
};

/**
 * Resets the current overview, preserving expansion.
 *
 * @param {String}		overviewId	the id of overview to reset
 */
ZmApp.prototype.resetOverview =
function(overviewId) {
	var overview = overviewId ? appCtxt.getOverviewController().getOverview(overviewId) : this.getOverview();
	if (overview) {
		var expIds = [];
		var treeIds = overview.getTreeViews(), len = treeIds.length;
		for (var i = 0; i < len; i++) {
			var treeId = treeIds[i];
			var treeView = overview.getTreeView(treeId);
			if (treeView) {
				var items = treeView.getTreeItemList();
				var len1 = items.length;
				for (var j = 0; j < len1; j++) {
					var treeItem = items[j];
					if (treeItem._expanded) {
						expIds.push(treeItem._htmlElId);
					}
				}
			}
		}
		overview.clear();
		overview.set(this._getOverviewTrees());
		len = expIds.length;
		for (var i = 0; i < len; i++) {
			var treeItem = DwtControl.fromElementId(expIds[i]);
			if (treeItem && !treeItem._expanded) {
				treeItem.setExpanded(true);
			}
		}
	}
};

/**
 * Gets the overview id of the current {@link ZmOverview}, if any.
 *
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{String}	the id
 */
ZmApp.prototype.getOverviewId =
function(account) {
	return appCtxt.getOverviewId([ZmApp.OVERVIEW_ID, this._name], account);
};

/**
 * Returns a hash of params with the standard overview options.
 *
 * @private
 */
ZmApp.prototype._getOverviewParams =
function() {
	// Get the sorted list of overview trees.
	var treeIds = [];
	for (var id in ZmOverviewController.CONTROLLER) {
		treeIds.push(id);
	}
	var sortFunc = function(a, b) {
		return (ZmOrganizer.DISPLAY_ORDER[a] || 9999) - (ZmOrganizer.DISPLAY_ORDER[b] || 9999);
	};
	treeIds.sort(sortFunc);

	return {
		posStyle:			Dwt.ABSOLUTE_STYLE,
		selectionSupported:	true,
		actionSupported:	true,
		dndSupported:		true,
		showUnread:			true,
		showNewButtons:		true,
		isAppOverview:		true,
		treeIds:			treeIds,
		appName:			this._name,
		account:			appCtxt.getActiveAccount()
	};
};

/**
 * Returns the list of trees to show in the overview for this app. Don't show
 * Folders unless mail is enabled. Other organizer types won't be created unless
 * their apps are enabled, so we don't need to check for them.
 *
 * @private
 */
ZmApp.prototype._getOverviewTrees =
function() {
	var list = ZmApp.OVERVIEW_TREES[this._name] || [];
	var newList = [];
	for (var i = 0, count = list.length; i < count; i++) {
		if ((list[i] == ZmOrganizer.FOLDER && !appCtxt.get(ZmSetting.MAIL_ENABLED))) {
			continue;
		}
		newList.push(list[i]);
	}

	if (!appCtxt.multiAccounts &&
		window[ZmOverviewController.CONTROLLER[ZmOrganizer.ZIMLET]] &&
		!ZmApp.HIDE_ZIMLETS[this._name])
	{
		newList.push(ZmOrganizer.ZIMLET);
	}
	return newList;
};

/**
 * Gets the number of active session controllers
 *
 * @return	{number} the number of active session controllers
 */
ZmApp.prototype.getNumSessionControllers =
function(type) {
    var controllers = this._sessionController[type] || [];
    var activeCount = 0;
    for (var id in controllers) {
        if (!controllers[id].inactive) {
            activeCount++;
        }
    }
    return activeCount;
};

/**
 * Evaluates the controller class and returns the default view type from that controller.
 *
 * @param	{hash}							params						hash of params:
 * @param	{string}						controllerClass				string name of controller class
 * @param	{string}						sessionId					unique identifier for this controller
 * @param 	{ZmSearchResultsController}		searchResultsController		containing controller
 *
 * @returns	{string}													default view type
 */
ZmApp.prototype.getTypeFromController =
function(controllerClass) {
	var controller = eval(controllerClass);
	if (!controller.getDefaultViewType) {
		throw new AjxException("Session controller " + controllerClass + " must implement getDefaultViewType()");
	}
	return controller.getDefaultViewType();
};

/**
 * Returns a controller of the given type and class. If no sessionId is provided, then
 * the controller's session ID will be an incremental number. If a sessionId is given,
 * then a check is made for an existing controller with that session ID. If none is
 * found, one is created and given that session ID.
 * 
 * @param	{hash}							params						hash of params:
 * @param	{string}						controllerClass				string name of controller class
 * @param	{string}						sessionId					unique identifier for this controller
 * @param 	{ZmSearchResultsController}		searchResultsController		containing controller
 */
ZmApp.prototype.getSessionController =
function(params) {

	var type = this.getTypeFromController(params.controllerClass);

	// track controllers of this type
	if (!this._sessionController[type]) {
		this._sessionController[type] = {};
		this._nextSessionId[type] = 1;
	}

	// check if we've already created a session controller with the given ID
	var sessionId = params.sessionId;
	if (sessionId && this._sessionController[type][sessionId]) {
		return this._sessionController[type][sessionId];
	}

	// re-use an inactive controller if possible
	var controller;
	if (!sessionId) {
		var controllers = this._sessionController[type];
		for (var id in controllers) {
			if (controllers[id].inactive && !controllers[id].isPinned && !controllers[id].isHidden) {
				controller = controllers[id];
				break;
			}
		}
	}

	sessionId = (controller && controller.getSessionId()) || sessionId || String(this._nextSessionId[type]++);

	if (!controller) {
		var ctlrClass = eval(params.controllerClass);
		controller = this._sessionController[type][sessionId] =
			new ctlrClass(this._container, this, type, sessionId, params.searchResultsController);
	}
	this._curSessionId[type] = sessionId;
	controller.inactive = false;

	return controller;
};

/**
 * Deletes a controller of the given type, class, and sessionId.
 *
 * @param	{hash}							params						hash of params:
 * @param	{string}						controllerClass				string name of controller class
 * @param	{string}						sessionId					unique identifier for this controller
 * @param 	{ZmSearchResultsController}		searchResultsController		containing controller
 */
ZmApp.prototype.deleteSessionController =
function(params) {
	var type		= this.getTypeFromController(params.controllerClass);
	var sessionId	= params.sessionId;

	if (!this._sessionController[type]) {
		return;
	}
	delete this._sessionController[type][sessionId];
};

// returns the session ID of the most recently retrieved controller of the given type
ZmApp.prototype.getCurrentSessionId =
function(type) {
	return this._curSessionId[type];
};

// returns a list of this app's controllers
ZmApp.prototype.getAllControllers =
function() {

	var controllers = [];
	for (var viewType in this._sessionController) {
		var viewHash = this._sessionController[viewType];
		if (viewHash) {
			for (var viewId in viewHash) {
				var ctlr = viewHash[viewId];
				if (ctlr) {
					controllers.push(ctlr);
				}
			}
		}
	}
	
	return controllers;
};

/**
 * @private
 */
ZmApp.prototype._addSettingsChangeListeners =
function() {
	if (!this._settingListener) {
		this._settingListener = new AjxListener(this, this._settingChangeListener);
	}
};

/**
 * @private
 */
ZmApp.prototype._settingChangeListener =
function(ev) {

};

// Returns a hash of properties for the New Button
ZmApp.prototype.getNewButtonProps =
function() {
	return {};
};

/**
 * Gets the search parameters.
 *
 * @param {Hash}	params	a hash of arguments for the search
 * @see		ZmSearchController
 */
ZmApp.prototype.getSearchParams =
function(params) {
	return (params || {});
};

/**
 * Default function to run after an app's core package has been loaded. It assumes that the
 * classes that define items and organizers for this app are in the core package.
 *
 * @private
 */
ZmApp.prototype._postLoadCore =
function() {
	if (!appCtxt.isChildWindow) {
		this._setupDropTargets();
	}
};

/**
 * Default function to run after an app's main package has been loaded.
 *
 * @private
 */
ZmApp.prototype._postLoad =
function(type) {
	if (type) {
		this._createDeferredFolders(type);
	}
	this._handleDeferredNotifications();
    if(appCtxt.isExternalAccount()) {
        this._handleExternalAccountSettings(type);
    }
};


ZmApp.prototype.containsWritableFolder =
function() {
    return appCtxt.isExternalAccount() ? (this._containsWritableFolder ? true : false) : true;
};

ZmApp.prototype.getDefaultFolderId =
function() {
    return this._defaultFolderId;
};

/**
 * @private
 */
ZmApp.prototype._handleExternalAccountSettings =
function(type) {
    //Handle the external account settings
    var dataTree = appCtxt.getTree(type, appCtxt.getActiveAccount()),
        folders = dataTree ? dataTree.getByType(type) : [],
        len = folders.length,
        folder,
        i;
    this._containsWritableFolder = false;
    for (i=0; i<len; i++) {
        folder = folders[i];
        if(!this._defaultFolderId) { this._defaultFolderId = folder.id; }
        if (folder.isPermAllowed(ZmOrganizer.PERM_WRITE)) {
            this._containsWritableFolder = true;
        }
    }
};

/**
 * @private
 */
ZmApp.prototype._setupDropTargets =
function() {
	var appTargets = ZmApp.DROP_TARGETS[this._name];
	for (var type in appTargets) {
		var targets = appTargets[type];
		for (var i = 0; i < targets.length; i++) {
			var orgType = targets[i];
			var ctlr = appCtxt.getOverviewController().getTreeController(orgType, true);
			var className = ZmList.ITEM_CLASS[type] || ZmOrganizer.ORG_CLASS[type];
			if (ctlr) {
				ctlr._dropTgt.addTransferType(className);
			} else {
				if (!ZmTreeController.DROP_SOURCES[orgType]) {
					ZmTreeController.DROP_SOURCES[orgType] = [];
				}
				ZmTreeController.DROP_SOURCES[orgType].push(className);
			}
		}
	}
};

/**
 * Disposes of the tree controllers (right now mainly gets rid of change listeners.
 */
ZmApp.prototype.disposeTreeControllers =
function() {

	var overviewController = appCtxt.getOverviewController(true); //see if overview controller was created (false param means it won't create it if not created)
	//this is created lazily in case of child window. There's nothing to do if it was not created.
	if (!overviewController) {
		return;
	}

	var appTargets = ZmApp.DROP_TARGETS[this._name];
	for (var type in appTargets) {
		var targets = appTargets[type];
		for (var i = 0; i < targets.length; i++) {
			var orgType = targets[i];
			var treeController = overviewController.getTreeController(orgType, true);
			if (!treeController) {
				continue;
			}
			treeController.dispose();
		}
	}
};


/**
 * @private
 */
ZmApp.prototype.createDeferred = function() {
	var types = ZmOrganizer.APP2ORGANIZER[this._name] || [];
	for (var i = 0; i < types.length; i++) {
		var type = types[i];
		var packageName = ZmOrganizer.ORG_PACKAGE[type];
		AjxDispatcher.require(packageName);
		this._createDeferredFolders(type);
	}
};

/**
 * Lazily create folders received in the initial <refresh> block.
 *
 * @private
 */
ZmApp.prototype._createDeferredFolders =
function(type) {
	for (var i = 0; i < this._deferredFolders.length; i++) {
		var params = this._deferredFolders[i];
		var folder = ZmFolderTree.createFolder(params.type, params.parent, params.obj, params.tree, params.path, params.elementType);
        if (appCtxt.isExternalAccount() && folder.isSystem()) {
            continue;
        }
		params.parent.children.add(folder); // necessary?
		folder.parent = params.parent;
		ZmFolderTree._traverse(folder, params.obj, params.tree, params.path || []);
	}
	this._clearDeferredFolders();
};

/**
 * @private
 */
ZmApp.prototype._clearDeferredFolders =
function() {
	this._deferredFolders = [];
	this._deferredFolderHash = {};
};

/**
 * Defer notifications if this app's main package has not been loaded.
 * Returns true if notifications were deferred.
 *
 * @param type	[string]	type of notification (delete, create, or modify)
 * @param data	[array]		list of notifications
 *
 * TODO: revisit use of MAIN_PKG, it's hokey
 *
 * @private
 */
ZmApp.prototype._deferNotifications =
function(type, data) {
	var pkg = ZmApp.MAIN_PKG[this._name];
	if (pkg && !AjxDispatcher.loaded(pkg)) {
		this._deferredNotifications.push({type:type, data:data});
		return true;
	} else {
		this._noDefer = true;
		return false;
	}
};

/**
 * @private
 */
ZmApp.prototype._handleDeferredNotifications =
function() {
	var dns = this._deferredNotifications;
	for (var i = 0; i < dns.length; i++) {
		var dn = dns[i];
		if (dn.type == "delete") {
			this.deleteNotify(dn.data, true);
		} else if (dn.type == "create") {
			this.createNotify(dn.data, true);
		} else if (dn.type == "modify") {
			this.modifyNotify(dn.data, true);
		}
	}
};

/**
 * Notify change listeners with a list of notifications, rather than a single
 * item, so that they can optimize. For example, a list view can wait to
 * fix its alternation of dark and light rows until after all the moved ones
 * have been taken out, rather than after the removal of each row.
 *
 * @param mods	{Array}		list of notification objects
 */
ZmApp.prototype._batchNotify =
function(mods) {

	if (!(mods && mods.length >= ZmApp.BATCH_NOTIF_LIMIT)) { return; }

	var notifs = {}, item, gotOne = false;
	for (var i = 0, len = mods.length; i < len; i++) {
		var mod = mods[i];
		item = appCtxt.cacheGet(mod.id);
		if (item) {
			var ev = item.notifyModify(mod, true);
			if (ev) {
				if (!notifs[ev]) {
					notifs[ev] = [];
				}
				mod.item = item;
				notifs[ev].push(mod);
				gotOne = true;
			}
		}
	}

	if (!gotOne || !item) { return; }

	var list = item.list;
	if (!list) { return; }
	list._evt.batchMode = true;
	list._evt.item = item;	// placeholder - change listeners like it to be there
	list._evt.items = null;
	for (var ev in notifs) {
		var details = {notifs:notifs[ev]};
		list._notify(ev, details);
	}
};

/**
 * Depending on "Always in New Window" option and whether Shift key is pressed,
 * determine whether action should be in new window or not.
 *
 * @private
 */
ZmApp.prototype._inNewWindow =
function(ev) {
	if (appCtxt.isWebClientOffline()) {
		return false;
	}  else {
		var setting = appCtxt.get(ZmSetting.NEW_WINDOW_COMPOSE);
		return !ev ? setting : ((!setting && ev && ev.shiftKey) || (setting && ev && !ev.shiftKey));
	}
};

/**
 * @private
 */
ZmApp.prototype._handleCreateFolder =
function(create, org) {
	var parent = appCtxt.getById(create.l);
	if (parent && (ZmOrganizer.VIEW_HASH[org][create.view])) {
		parent.notifyCreate(create, "folder");
		create._handled = true;
	}
};

/**
 * @private
 */
ZmApp.prototype._handleCreateLink =
function(create, org) {
	var parent = appCtxt.getById(create.l);
	var view = create.view || "message";
	if (parent && parent.supportsSharing() && (ZmOrganizer.VIEW_HASH[org][view])) {
		parent.notifyCreate(create, "link");
		create._handled = true;
	}
};

// Abstract/protected methods

/**
 * Launches the application.
 *
 * @param	{Hash}	params		a hash of parameters
 * @param	{AjxCallback}	callback		the callback
 */
ZmApp.prototype.launch =
function(params, callback) {
	this.createDeferred();
    if (callback) {
        callback.run();
    }
};

/**
 * Activates the application.
 *
 * @param	{Boolean}	active	<code>true</code> if the application is active
 * @param	{string}	viewId	ID of view becoming active
 */
ZmApp.prototype.activate =
function(active, viewId) {
	this._active = active;
	if (active) {
		appCtxt.getAppController().setNewButtonProps(this.getNewButtonProps());
		this.setOverviewPanelContent();
		this.stopAlert();
		if (appCtxt.isWebClientOfflineSupported) {
			this.resetWebClientOfflineOperations();
		}
		this._setRefreshButtonTooltip();
	}
};

/**
 * Handle the common aspects of a transition from online to offline and offline to online, and also do so
 * when an app is activated
 */
ZmApp.prototype.resetWebClientOfflineOperations =
function() {
	var isWebClientOnline = !appCtxt.isWebClientOffline();
	var overview = this.getOverview();
	if (overview) {
		var zimletTreeView = overview.getTreeView(ZmOrganizer.ZIMLET);
		if (zimletTreeView) {
			zimletTreeView.setVisible(isWebClientOnline);
		}
		// enable/disable right click
		overview.actionSupported = isWebClientOnline;
		// enable/disable drag and drop
		overview.dndSupported = isWebClientOnline;
	}
	// new button enable/disable
	var newButton = appCtxt.getAppController().getNewButton();
	if (newButton) {
		if (ZmController._defaultNewId === ZmOperation.NEW_MESSAGE) {
			newButton._setDropDownCellMouseHandlers(isWebClientOnline);
		}
		else {
			newButton.setEnabled(isWebClientOnline);
		}
	}
};

/**
 * Checks if the application is active.
 *
 * @return	{Boolean}	<code>true</code> if the application is active
 */
ZmApp.prototype.isActive =
function() {
	return this._active;
};

/**
 * Resets the application state.
 *
 * @return	{Boolean}	<code>true</code> if the application is active
 */
ZmApp.prototype.reset =
function(active) {
};

/**
 * Starts an alert on the application tab.
 * 
 */
ZmApp.prototype.startAlert =
function() {
	AjxDispatcher.require("Alert");
	this._alert = this._alert || new ZmAppAlert(this);
	this._alert.start();
};

/**
 * Stops an alert on the application tab.
 */
ZmApp.prototype.stopAlert =
function() {
	if (this._alert) {
		this._alert.stop();
	}
};

ZmApp.prototype._setRefreshButtonTooltip =
function() {
	if (appCtxt.refreshButton) {
		appCtxt.refreshButton.setToolTipContent(this._getRefreshButtonTooltip());
	}
};

/**
 * this is the default refresh button tooltip. overridden in Calendar. (see bug 85965)
 * @private
 */
ZmApp.prototype._getRefreshButtonTooltip =
function() {
	 return ZmMsg.checkMailPrefUpdate;
};

/**
 * @private
 */
ZmApp.prototype._notifyRendered =
function() {
	if (!this._hasRendered) {
		appCtxt.getAppController().appRendered(this._name);
		this._hasRendered = true;
	}
	this.stopAlert();
};

/**
 * @private
 */
ZmApp.prototype._getExternalAccount =
function() {

	// bug #43464 - get the first non-local account that supports this app
	var defaultAcct;
	if (appCtxt.multiAccounts) {
		var accounts = appCtxt.accountList.visibleAccounts;
		for (var i = 0; i < accounts.length; i++) {
			var acct = accounts[i];
			if (acct.isMain) { continue; }

			if (appCtxt.get(ZmApp.SETTING[this.name], null, acct)) {
				defaultAcct = acct;
				break;
			}
		}
	}
	return defaultAcct;
};

/**
 * Sets a hidden div for performance metrics.  Marks the time an app has been launched
 * @param appName {String}
 * @param date {Date}
 * @private
 */
ZmApp.prototype._setLaunchTime = 
function(appName, date) {
	if (!window.isPerfMetric) {
		return;
	}
	var id = appName + "_launched";
	if (!date) {
		date = new Date();
	}
	if (!document.getElementById(id)) {
		var div = document.createElement("DIV");
		div.id = id;
		div.innerHTML = date.getTime();
		div.style.display = "none";
		document.body.appendChild(div);
	}
	if (window.appDevMode) {
		console.profile(id);
	}
};

/**
 * Sets a hidden div for performance metrics.  Marks the time an app has completed loading
 * @param appName {String}
 * @param date {Date}
 * @private
 */
ZmApp.prototype._setLoadedTime = 
function(appName, date) {
	if (!window.isPerfMetric) {
		return;
	}
	var id = appName + "_loaded";
	if (!date) {
		date = new Date();
	}
	if (!document.getElementById(id)) {
		var div = document.createElement("DIV");
		div.id = id;
		div.innerHTML = date.getTime();
		div.style.display = "none";
		document.body.appendChild(div);
	}
	if (window.appDevMode) {
		console.profileEnd();
	}
};
}

if (AjxPackage.define("zimbraMail.share.view.ZmToolBar")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines a toolbar.
 */

/**
 * Creates a toolbar.
 * @class
 * This class represents a basic toolbar which can add buttons, manage listeners, and
 * enable/disabled its buttons.
 *
 * @author Conrad Damon
 *
 * @param {Hash}	params		a hash of parameters
 * @param	{DwtComposite}	params.parent		the containing widget
 * @param	{String}	params.className	the CSS class
 * @param	{constant}	params.posStyle		the positioning style
 * @param	{String}	params.id			an explicit ID to use for the control's HTML element
 * @param	{ZmController}	params.controller	the owning controller
 * @param	{String}	params.refElementId	the id of element that contains toolbar
 *        
 * @extends	DwtToolBar
 */
ZmToolBar = function(params) {
	if (arguments.length == 0) return;

	params.posStyle = params.posStyle || DwtControl.ABSOLUTE_STYLE;
	DwtToolBar.call(this, params);

	var controller = params.controller || appCtxt.getCurrentController();
	if (controller) {
		this._controller = controller;
		this._keyMap = this._controller.getKeyMapName();
	}

	this._refElementId = params.refElementId;
	this._buttons = {};
};

ZmToolBar.prototype = new DwtToolBar;
ZmToolBar.prototype.constructor = ZmToolBar;

ZmToolBar.prototype.isZmToolBar = true;
ZmToolBar.prototype.toString = function() { return "ZmToolBar"; };

/**
 * Adds a selection listener.
 * 
 * @param	{String}	buttonId	the button id
 * @param	{AjxListener}	listener	the listener
 */
ZmToolBar.prototype.addSelectionListener =
function(buttonId, listener) {
	var button = this._buttons[buttonId];
	if (button) {
		button.addSelectionListener(listener);
	}
};

/**
 * Removes a selection listener.
 * 
 * @param	{String}	buttonId	the button id
 * @param	{AjxListener}	listener	the listener
 */
ZmToolBar.prototype.removeSelectionListener =
function(buttonId, listener) {
	var button = this._buttons[buttonId];
	if (button) {
		button.removeSelectionListener(listener);
	}
};

/**
 * Gets the button.
 * 
 * @param	{String}	buttonId	the button id
 * @return	{ZmAppButton}	the button
 */
ZmToolBar.prototype.getButton =
function(buttonId) {
	return this._buttons[buttonId];
};

/**
 * sets an item visibility. finds the button by id. 
 *
 * @param	{String}	buttonId	the button id
 * @param	{Boolean}	visible
 */
ZmToolBar.prototype.setItemVisible =
function(buttonId, visible) {
	var button = this.getButton(buttonId);
	if (!button) {
		return;
	}
	button.setVisible(visible);
};


/**
 * Sets the data.
 * 
 * @param	{String}	buttonId	the button id
 * @param	{String}	key		the data key
 * @param	{Object}	data	the data
 */
ZmToolBar.prototype.setData = 
function(buttonId, key, data) {
	this._buttons[buttonId].setData(key, data);
};

/**
 * Enables or disables the specified buttons.
 *
 * @param {Array}	ids		a list of button ids
 * @param {Boolean}	enabled	if <code>true</code>, enable the buttons
 */
ZmToolBar.prototype.enable =
function(ids, enabled) {
	ids = (ids instanceof Array) ? ids : [ids];
	for (var i = 0; i < ids.length; i++) {
		if (this._buttons[ids[i]]) {
			this._buttons[ids[i]].setEnabled(enabled);
		}
	}
};

ZmToolBar.prototype.setSelected =
function(id) {
    var oldButton = this._selectedId ? this._buttons[this._selectedId] : null;
    var newButton = id ? this._buttons[id] : null;
    if (oldButton) {
        oldButton.setSelected(false);
    }
    if (newButton) {
        newButton.setSelected(true);
        this._selectedId = id;
    }
};

/**
 * Enables or disables all buttons.
 *
 * @param {Boolean}	enabled			if <code>true</code>, enable the buttons
 */
ZmToolBar.prototype.enableAll =
function(enabled) {
	for (var i in this._buttons) {
		this._buttons[i].setEnabled(enabled);
	}
};

/**
 * Creates a button and adds the button to this toolbar.
 *
 * @param {String}	id			the button id
 * @param {Hash}	params		a hash of parameters:
 * @param {function}	params.constructor	the constructor for button object (default is {@link DwtToolBarButton})
 * @param {String}	params.template		the button template
 * @param {String}	params.text			the button text
 * @param {String}	params.tooltip		the button tooltip text
 * @param {String}	params.image		the icon class for the button
 * @param {String}	params.disImage	the disabled version of icon
 * @param {Boolean}	params.enabled		if <code>true</code>, button is enabled
 * @param {String}	params.className	the CSS class name
 * @param {String}	params.style		the button style
 * @param {int}	params.index			the position at which to add the button
 * @param {constant}	params.shortcut		the shortcut id (from {@link ZmKeyMap}) for showing hint
 * @param {AjxCallback|DwtMenu}	params.menu				the menu creation callback (recommended) or menu
 * @param {Boolean}	params.menuAbove	if <code>true</code>, popup menu above the button.
 *
 * @param {Object}	params.whatToShow		if exists, determines what to show as follows: (for usage, see ZmToolBar.prototype._createButton and DwtButton.prototype.setImage and DwtButton.prototype.setText
 * @param {Boolean}	params.whatToShow.showImage		if <code>true</code>, display image
 * @param {Boolean}	params.whatToShow.showText		if <code>true</code>, display text
 *
 */
ZmToolBar.prototype.createButton =
function(id, params) {
	var b = this._buttons[id] = this._createButton(params);
	if (params.image) {
		b.setImage(params.image);
	}
	if (params.text) {
		b.setText(params.text);
	}
	if (params.tooltip) {
		b.setToolTipContent(ZmOperation.getToolTip(id, this._keyMap) || params.tooltip, true);
	}
	b.setEnabled(params.enabled !== false);
	b.setData("_buttonId", id);
	if (params.menu) {
		b.setMenu(params.menu, false, null, params.menuAbove);
	}

	return b;
};

//
// Data
//

ZmToolBar.prototype.SEPARATOR_TEMPLATE = "share.Widgets#ZmToolBarSeparator";

//
// Protected methods
//

/**
 * @private
 */
ZmToolBar.prototype._createButton =
function(params, className) {
	var ctor = params.ctor || DwtToolBarButton;
    var button = new ctor({
		parent:this,
		style:params.style,
		className:className,
		index:params.index,
		id:params.id,
		template: params.template
	});
	button.textPrecedence = params.textPrecedence;
	button.imagePrecedence = params.imagePrecedence;
	button.whatToShow = params.whatToShow;

	return button;
};

/**
 * @private
 */
ZmToolBar.prototype._buttonId =
function(button) {
	return button.getData("_buttonId");
};

/**
 * Creates an ordered list of which bits of text or images get removed when we need space.
 * 
 * @private
 */
ZmToolBar.prototype._createPrecedenceList =
function() {
	this._precedenceList = [];
	for (var id in this._buttons) {
		if (ZmOperation.isSep(id)) { continue; }
		var b = this._buttons[id];
		var tp = b.textPrecedence;
		if (tp) {
			this._precedenceList.push({id:id, type:"text", precedence:tp});
		}
		var ip = b.imagePrecedence;
		if (ip) {
			this._precedenceList.push({id:id, type:"image", precedence:ip});
		}
	}
	this._precedenceList.sort(function(a, b) {
		return (a.precedence > b.precedence) ? 1 : (a.precedence < b.precedence) ? -1 : 0;
	});
};

// The following overrides are so that we check our width after a call to a function that
// may affect our size.

/**
 * Sets the size. This method is called by the application view manager <code>fitToContainer()</code>,
 * which happens during initial layout as well as in response to the user changing the browser size.
 * 
 * @param	{int}	width	the width (in pixels)
 * @param	{int}	height	the height (in pixels)
 */
ZmToolBar.prototype.setSize =
function(width, height) {
	DBG.println("tb", "------ setSize " + width + " x " + height);
	var sz = this.getSize();
	if (sz && (width != sz.x || height != sz.y)) {
		DwtToolBar.prototype.setSize.apply(this, arguments);
	}
};

ZmToolBar.prototype.adjustSize =
function() {
	if (!this._refElementId || !this._inited) { return; }
    if (!this._refElement) {
        this._refElement = document.getElementById(this._refElementId);
    }
    var container = this._refElement && this._refElement.parentNode;
    var offsetWidth;
    if (container && ((offsetWidth = container.offsetWidth) >= 30)) {
        var style = this._refElement.style;
		style.maxWidth = style.width =  (offsetWidth - 30) + "px";
        style.overflow = "hidden";
    }
}

/**
 * Adds a button to the element with the given ID. Designed to handle non-ZmToolBar toolbars.
 * 
 * @param params	[hash]			hash of params:
 * 		  parent	[DwtControl]	parent control
 *        setting	[const]			setting that must be true for this button to be added
 *        tdId		[string]		ID of TD that is to contain this button
 *        buttonId	[string]*		ID of the button
 *        style		[const]*		button style
 *        type		[string]*		used to differentiate between regular and toolbar buttons
 *        lbl		[string]*		button text
 *        icon		[string]*		button icon
 *        tooltip	[string]*		button tooltip
 */
ZmToolBar.addButton =
function(params) {

	if (params.setting && !appCtxt.get(params.setting)) { return; }

	var button;
	var tdId = params.parent._htmlElId + (params.tdId || params.buttonId);
	var buttonEl = document.getElementById(tdId);
	if (buttonEl) {
		var btnParams = {parent:params.parent, index: params.index, style:params.style, id:params.buttonId, template: params.template, className: params.className};
		button = (params.type && params.type == "toolbar") ? (new DwtToolBarButton(btnParams)) : (new DwtButton(btnParams));
		var hint = Dwt.getAttr(buttonEl, "hint");
		ZmToolBar._setButtonStyle(button, hint, params.lbl, params.icon);
		if (params.tooltip) {
			button.setToolTipContent(params.tooltip, true);
		}
		button.reparentHtmlElement(tdId);
	}

	return button;
};

ZmToolBar._setButtonStyle =
function(button, hint, text, image) {
	if (hint == "text") {
		button.whatToShow = { showText: true };
	} else if (hint == "icon") {
		button.whatToShow = { showImage: true };
	} else { // add icon and text if no hint (or unsupported hint) provided
		button.whatToShow = { showImage: true, showText: true };
	}

	button.setText(text);
	button.setImage(image);
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmButtonToolBar")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates a toolbar with the given buttons.
 * @class
 * This class represents a toolbar that contains buttons.
 * It can be easily created using a set of standard operations, and/or custom buttons
 * can be provided. This class is designed for use with items ({@link ZmItem}), so it can for
 * example contain a button with a tab submenu. See also {@link ZmActionMenu}.
 *
 * @author Conrad Damon
 *
 * @param {Hash}	params			a hash of parameters
 * @param	       {DwtComposite}	params.parent		the containing widget
 * @param	{Array}	params.buttons			a list of operation IDs
 * @param	{constant}	params.posStyle			the positioning style
 * @param	{String}	params.className			the CSS class name
 * @param	{Stirng}	params.buttonClassName	the CSS class name for buttons
 * @param	{Hash}	params.overrides			a hash of overrides by op ID
 * @param	{Array}	params.secondaryButtons		a list of operation IDs
 * @param	{Array}	params.rightSideButtons		a list of operation IDs
 * @param	{constant}	params.context			the vcontextID (used to generate button IDs)
 * @param	{constant}	params.toolbarType		the toolbar type (used to generate button IDs)
 * @param	{Boolean}	params.addTextElement		if true, add a text "button" (element) at the end (but before the view button, if any). This can be used for message counts etc
 * @param	{ZmController}	params.controller		the owning controller
 *
 * @extends		ZmToolBar
 */
ZmButtonToolBar = function(params) {
	if (arguments.length == 0) return;

	if (!params.className && (params.controller && params.controller._elementsToHide == ZmAppViewMgr.LEFT_NAV)) {
		params.className = "ZToolbar itemToolbar";
	}
    params.className = params.className || "ZToolbar";
    params.id = params.context ? ZmId.getToolbarId(params.context, params.toolbarType) : null;
    ZmToolBar.call(this, params);
	
	this._context = params.context;
	this._toolbarType = params.toolbarType;
	this._buttonStyle = params.buttonClassName;

	// standard buttons default to New/Tag/Print/Delete
	var buttonOps = params.buttons;
	if (!buttonOps) {
		buttonOps = [ZmOperation.NEW_MENU, ZmOperation.TAG_MENU, ZmOperation.PRINT, ZmOperation.DELETE];
	} else if (buttonOps == ZmOperation.NONE) {
		buttonOps = null;
	}
	// weed out disabled ops, save list of ones that make it
	/**
	 * The operation list property.
	 * @type Array
	 */
	this.opList = ZmOperation.filterOperations(buttonOps);

	this._zimletButtonLocation = this.opList.length;

	var secondaryOpList = ZmOperation.filterOperations(params.secondaryButtons);

	if (secondaryOpList && secondaryOpList.length) {
		this.opList.push(ZmOperation.SEP, ZmOperation.ACTIONS_MENU);
	}

	var rightSideOpList = ZmOperation.filterOperations(params.rightSideButtons);

	if (rightSideOpList.length > 0 || params.addTextElement) {
		this.opList.push(ZmOperation.FILLER);
	}
	
	if (params.addTextElement) {
		this.opList.push(ZmOperation.TEXT);
	}

	if (rightSideOpList.length > 0) {
		this.opList = this.opList.concat(rightSideOpList);
	}

	this._buttons = ZmOperation.createOperations(this, this.opList, params.overrides);

	if (secondaryOpList && secondaryOpList.length) {
		var actionsButton =  this._secondaryButton = this.getButton(ZmOperation.ACTIONS_MENU);

		actionsButton.noMenuBar = true;

		var secondaryMenu = this._secondaryButtonMenu = new ZmActionMenu({parent: actionsButton, menuItems: ZmOperation.NONE, context: this._context, controller: params.controller});
		var secondaryButtons  = ZmOperation.createOperations(secondaryMenu, secondaryOpList, params.overrides);
		actionsButton.setMenu(secondaryMenu);

		//add secondary buttons to buttons list as I believe from now on it shouldn't matter if they are primary or under the secondary "actions" menu.
		//that way we don't need to operate on 2 different collections when enabling/disabling, adding listeners, etc.
		//var secondaryButtons = secondaryMenu._menuItems;
		for (var id in secondaryButtons) {
			this._buttons[id] = secondaryButtons[id];
		}
		//same as buttons, with opList.
		this.opList = this.opList.concat(secondaryOpList);

	}

	//todo - I guess in the new UI a button (primary) will have either text or image. not both. Think of whether this precedence is still required then.
	this._createPrecedenceList(); //this is only done to the primary, not the secondary buttons (since the secondary are in a drop-down so removing one's image or text won't make sense.)
	
	this._inited = true;
};

ZmButtonToolBar.prototype = new ZmToolBar;
ZmButtonToolBar.prototype.constructor = ZmButtonToolBar;

ZmButtonToolBar.prototype.isZmButtonToolBar = true;
ZmButtonToolBar.prototype.toString = function() { return "ZmButtonToolBar"; };


// Public methods


/**
 * Creates a button and adds its operation ID as data.
 * 
 * @param {String}	id			the name of the operation
 * @param {Hash}	params		a hash of parameters
 * @param {String}	params.text			a button text
 * @param {String}	params.tooltip		a button tooltip text
 * @param {String}	params.image			a icon class for the button
 * @param {String}	params.disImage		a disabled version of icon
 * @param {Boolean}	params.enabled		if <code>true</code>, button is enabled
 * @param {String}	params.className		the CSS class name
 * @param {String}	params.style			thebutton style
 * @param {int} params.index			the position at which to add the button
 * @param {Boolean}	params.showImageInToolbar	if <code>true</code>, the button should show image (default is false)
 * @param {Boolean}	params.showTextInToolbar	if <code>true</code>, the button should show text (default is !params.showImageInToolbar)
 */
ZmButtonToolBar.prototype.createOp =
function(id, params) {
	params.className = this._buttonStyle;
	var b;
	if (id == ZmOperation.TEXT) {
		var id;
		if (this._context) {
			var context = this._toolbarType ? [this._context, this._toolbarType].join("_") : this._context;
			id = [ZmId.WIDGET, AjxStringUtil.toMixed(context, "_", true), AjxStringUtil.toMixed(id, "_")].join("");
		}
		params.textClassName = params.textClassName || "DwtText ZWidgetTitle";
		b = new DwtText({parent:this, className:params.textClassName, id:id});
	} else {
		params.id = params.domId || (this._context ? ZmId.getButtonId(this._context, id, this._toolbarType) : null);
		params.textPrecedence = ZmOperation.getProp(id, "textPrecedence");
		params.iconPrecedence = ZmOperation.getProp(id, "iconPrecedence");
		var showImage = params.showImageInToolbar || false; //default to false;
		var showText = !showImage || params.showTextInToolbar;
		showImage = showImage || !params.text; //no text? gotta show image
		showText = showText || !params.image; //no image? gotta show text
		params.image = showImage && params.image;
		params.whatToShow = {showImage: showImage, showText: showText}
		b = this.createButton(id, params);
	}
	b.setData(ZmOperation.KEY_ID, id);

	return b;
};

/**
 * Creates a zimlet button and adds its operation ID as data. This method selects the best location for the zimlet, so zimlets don't have to do it and it's consistent.
 *
 * for parameters see createOp
 */
ZmButtonToolBar.prototype.createZimletOp =
function(id, params) {
	params.index = this._zimletButtonLocation;
	return this.createOp(id, params);
};


/**
 * Adds the operation.
 * 
 * @param	{String}	id		the id
 * @param	{int}		index	the index
 */
ZmButtonToolBar.prototype.addOp =
function(id, index) {
	if(this.getOp(id)) {
		return;
	}
	ZmOperation.addOperation(this, id, this._buttons, index);
	AjxUtil.arrayAdd(this.opList, id, index);
};

/**
 * Removes the operation.
 * 
 * @param	{String}	id		the id
 * 
 * @see ZmOperation
 */
ZmButtonToolBar.prototype.removeOp =
function(id) {
	ZmOperation.removeOperation(this, id, this._buttons);
	AjxUtil.arrayRemove(this.opList, id);
};

/**
 * Gets the button.
 *
 * @param {constant}	id		the button
 * @return	{DwtButton}	the button
 * 
 * @see ZmOperation
 */
ZmButtonToolBar.prototype.getOp =
function(id) {
	return this.getButton(id);
};

/**
 * Gets the menu tag sub-menu (if any).
 * 
 * @return	{ZmTagMenu}		the menu
 */
ZmButtonToolBar.prototype.getTagMenu =
function() {
	var button = this.getButton(ZmOperation.TAG_MENU);
	if (button) {
		return button.getMenu();
	}
};

/**
 * gets the secondary menu (the "Actions" menu in the toolbar)
 */
ZmButtonToolBar.prototype.getActionsMenu =
function() {
	return this._secondaryButtonMenu;
};

/**
 * gets the secondary button (the "Actions" button in the toolbar)
 */
ZmButtonToolBar.prototype.getActionsButton =
function() {
	return this._secondaryButton;
};


//
// Private methods
//

// Returns the ID for the given button.
ZmButtonToolBar.prototype._buttonId =
function(button) {
	return button.getData(ZmOperation.KEY_ID);
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmPopupMenu")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates a popup menu.
 * @class
 * This class represents a basic popup menu which can add menu items, manage listeners, and
 * enable/disabled its menu items.
 *
 * @author Conrad Damon
 *
 * @param {DwtComposite}	parent		the containing widget
 * @param {string}	className		the CSS class
 * @param {string}	id			an explicit ID to use for the control's HTML element
 * @param {ZmController}	controller	the owning controller
 * 
 * @extends		DwtMenu
 */
ZmPopupMenu = function(parent, className, id, controller) {

	if (arguments.length == 0) return;
	var params = Dwt.getParams(arguments, ZmPopupMenu.PARAMS);
	params.className = params.className ? params.className : "ActionMenu";
	params.style = params.style || DwtMenu.POPUP_STYLE;
    params.id = params.id || "POPUP_" + Dwt.getNextId();
	DwtMenu.call(this, params);

	controller = controller || appCtxt.getCurrentController();
	if (controller) {
		this._controller = controller;
		this._keyMap = this._controller.getKeyMapName();
	}

	this._menuItems = {};
};

ZmPopupMenu.PARAMS = ["parent", "className", "id", "controller"];

ZmPopupMenu.prototype = new DwtMenu;
ZmPopupMenu.prototype.constructor = ZmPopupMenu;

ZmPopupMenu.prototype.isZmPopupMenu = true;
ZmPopupMenu.prototype.toString = function() { return "ZmPopupMenu"; };

/**
 * Adds a section listener.
 * 
 * @param	{string}		menuItemId		the menu item id
 * @param	{AjxListener}	listener		the selection listener
 * @param	{number}		index				the index where to insert the listener
 */
ZmPopupMenu.prototype.addSelectionListener =
function(menuItemId, listener, index) {
	var menuItem = this._menuItems[menuItemId];
	if (menuItem) {
		menuItem.addSelectionListener(listener, index);
	}
};

/**
 * Removes a section listener.
 * 
 * @param	{string}		menuItemId		the menu item id
 * @param	{AjxListener}	listener		the selection listener
 */
ZmPopupMenu.prototype.removeSelectionListener =
function(menuItemId, listener) {
	var menuItem = this._menuItems[menuItemId];
	if (menuItem) {
		menuItem.removeSelectionListener(listener);
	}
};

ZmPopupMenu.prototype.popup =
function(delay, x, y, kbGenerated) {
	delay = delay ? delay : 0;
	x = (x != null) ? x : Dwt.DEFAULT;
	y = (y != null) ? y : Dwt.DEFAULT;
	DwtMenu.prototype.popup.call(this, delay, x, y, kbGenerated);
};

/**
 * Enables/disables menu items.
 *
 * @param {array}	ids		a list of menu item IDs
 * @param {boolean}		enabled	if <code>true</code>, enable the menu items
 */
ZmPopupMenu.prototype.enable =
function(ids, enabled) {
	ids = (ids instanceof Array) ? ids : [ids];
	for (var i = 0; i < ids.length; i++) {
		if (this._menuItems[ids[i]]) {
			this._menuItems[ids[i]].setEnabled(enabled);
		}
	}
};

/**
 * Enables/disables all menu items.
 *
 * @param {boolean}		enabled	if <code>true</code>, enable the menu items
 */
ZmPopupMenu.prototype.enableAll =
function(enabled) {
	for (var i in this._menuItems) {
		this._menuItems[i].setEnabled(enabled);
	}
};

/**
 * Creates a menu item and adds the item to this menu.
 *
 * @param {string}	id			the menu item ID
 * @param {hash}	params		a hash of parameters
 * @param {string}	params.text		the menu item text
 * @param {string}	params.image		the icon class for the or menu item
 * @param {string}	params.disImage	disabled version of icon
 * @param {boolean}	params.enabled		if <code>true</code>, menu item is enabled
 * @param {constant}	params.style			the menu item style
 * @param {string}	params.radioGroupId	the ID of radio group for this menu item
 * @param {constant}	params.shortcut		the shortcut ID (from {@link ZmKeyMap}) for showing hint
 * 
 * @see		DwtMenuItem
 */
ZmPopupMenu.prototype.createMenuItem =
function(id, params, htmlElId) {
	var mi = this._menuItems[id] = new DwtMenuItem({parent:this, style:params.style, radioGroupId:params.radioGroupId,
													id: (htmlElId || params.id || id), index: params.index});
	if (params.image) {
		mi.setImage(params.image);
	}
	if (params.text) {
		mi.setText(params.text);
	}
	if (params.shortcut) {
		mi.setShortcut(appCtxt.getShortcutHint(this._keyMap, params.shortcut));
	}

	mi.setEnabled(params.enabled !== false);
	mi.setData(ZmOperation.MENUITEM_ID, id);

    //set context menu tr id
    var row = mi.getRowElement();
	if (row) {
		row.setAttribute("id", "POPUP" + "_" + mi.getHTMLElId().toString().replace(/\s/g, ""));
    }

	return mi;
};

/**
 * Gets the menu item with the given ID.
 *
 * @param {string}	id		an operation ID
 * @return	{DwtMenuItem}		the menu item
 */
ZmPopupMenu.prototype.getMenuItem =
function(id) {
	return this._menuItems[id];
};

/**
 * sets an item visibility. finds the menu item by id. 
 *
 * @param	{String}	id  the operation id
 * @param	{Boolean}	visible
 */
ZmPopupMenu.prototype.setItemVisible =
function(id, visible) {
	var item = this.getMenuItem(id);
	if (!item) {
		return;
	}
	item.setVisible(visible);
};

/**
 * Gets the menu items.
 *
 * @return	{array}		an array of {@link DwtMenuItem} objects
 */
ZmPopupMenu.prototype.getMenuItems =
function() {
	return this._menuItems;
};

/**
 * Gets the menu search sub-menu (if any).
 *
 * @return {DwtMenu}        the menu
 */
ZmPopupMenu.prototype.getSearchMenu =
function() {
    var menuItem = this.getMenuItem(ZmOperation.SEARCH_MENU);
    if (menuItem) {
        return menuItem.getMenu();
    }
};

ZmPopupMenu.prototype.getContactGroupMenu =
function() {
	var menuItem = this.getMenuItem(ZmOperation.CONTACTGROUP_MENU);
	if (menuItem) {
		return menuItem.getMenu();
	}
};


/**
 * Creates a menu item separator.
 * 
 * @return	{DwtMenuItem}	the separator menu item
 */
ZmPopupMenu.prototype.createSeparator =
function() {
	new DwtMenuItem({parent:this, style:DwtMenuItem.SEPARATOR_STYLE});
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmActionMenu")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates an action menu with the given menu items.
 * @class
 * This class represents an action menu, which is a popup menu with a few added features.
 * It can be easily created using a set of standard operations, and/or custom menu items
 * can be provided. This class is designed for use with items ({@link ZmItem}), so it can for
 * example contain a tab submenu. See also {@link ZmButtonToolBar}.
 *
 * @author Conrad Damon
 *
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}	params.parent		the containing widget
 * @param {ZmController}	params.controller	the owning controller
 * @param {array}	params.menuItems	a list of operation IDs
 * @param {hash}	params.overrides	a hash of overrides by op ID
 * @param {string}	params.context		the context (used to create ID)
 * @param {constant}	params.menuType		the menu type (used to generate menu item IDs)
 * 
 * @extends		ZmPopupMenu
 */
ZmActionMenu = function(params) {

    var id = params.id || (params.context ? ZmId.getMenuId(params.context, params.menuType) : null);
	ZmPopupMenu.call(this, params.parent, null, id, params.controller);

	// standard menu items default to Tag/Print/Delete
	var menuItems = params.menuItems;
	if (!menuItems) {
		menuItems = [ZmOperation.TAG_MENU, ZmOperation.PRINT, ZmOperation.DELETE];
	} else if (menuItems == ZmOperation.NONE) {
		menuItems = null;
	}
	// weed out disabled ops, save list of ones that make it
	this.opList = ZmOperation.filterOperations(menuItems);
	this._context = params.context;
	this._menuType = params.menuType;

	this._menuItems = ZmOperation.createOperations(this, this.opList, params.overrides);
};

ZmActionMenu.prototype = new ZmPopupMenu;
ZmActionMenu.prototype.constructor = ZmActionMenu;

ZmActionMenu.prototype.isZmActionMenu = true;
ZmActionMenu.prototype.toString = function() { return "ZmActionMenu"; };


// Public methods


/**
 * Creates a menu item and adds its operation ID as data.
 * 
 * @param {String}	id			the name of the operation
 * @param	{hash}	params		a hash of parameters
 * @param  {string}	params.text			the menu item text
 * @param {string}	params.image			the icon class for the menu item
 * @param {string}	params.disImage		the disabled version of icon
 * @param {boolean}	params.enabled		if <code>true</code>, menu item is enabled
 * @param {constant}	params.style			the menu item style
 * @param {string}	params.radioGroupId	the ID of radio group for this menu item
 * @param {constant}	params.shortcut		the shortcut ID (from {@link ZmKeyMap}) for showing hint
 * 
 * @private
 */
ZmActionMenu.prototype.createOp =
function(id, params, elementId) {
	params.id = this._context ? ZmId.getMenuItemId(this._context, id, this._menuType) : null;
	var mi = this.createMenuItem(id, params, elementId);
	mi.setData(ZmOperation.KEY_ID, id);

	return mi;
};

ZmActionMenu.prototype.addOp =
function(id) {
	ZmOperation.addOperation(this, id, this._menuItems);
};

ZmActionMenu.prototype.removeOp =
function(id) {
	ZmOperation.removeOperation(this, id, this._menuItems);
};

/**
 * Gets the menu item with the given ID.
 *
 * @param {constant}	id		an operation ID
 * @return	{DwtMenuItem}	the menu item
 * @see		ZmOperation
 */
ZmActionMenu.prototype.getOp =
function(id) {
	return this.getMenuItem(id);
};

/**
 * Gets the menu tag sub-menu (if any).
 * 
 * @return	{DwtMenu}		the menu
 */
ZmActionMenu.prototype.getTagMenu =
function() {
	var menuItem = this.getMenuItem(ZmOperation.TAG_MENU);
	if (menuItem) {
		return menuItem.getMenu();
	}
};


// Private methods

// Returns the ID for the given menu item.
ZmActionMenu.prototype._menuItemId =
function(menuItem) {
	return menuItem.getData(ZmOperation.KEY_ID);
};

ZmActionMenu.prototype.removeMenuItemById =
function(menuItemId) {
    var mi = this.getMenuItem(menuItemId);
    this.removeMenuItem(mi);
};

ZmActionMenu.prototype.removeMenuItem =
function(menuItem) {
    if (!menuItem) {return};
    this.removeChild(menuItem);
    menuItem.dispose();
};

}
if (AjxPackage.define("zimbraMail.share.view.ZmAutocompleteListView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 */

/**
 * Creates a new autocomplete list. The list isn't populated or displayed until some
 * autocompletion happens. Takes a data class and loader, so that when data is needed (it's
 * loaded lazily), the loader can be called on the data class.
 * @class
 * This class implements autocomplete functionality. It has two main parts: matching data based
 * on keystroke events, and displaying/managing the list of matches. This class is theoretically
 * neutral concerning the data that gets matched (as long as its class has an <code>autocompleteMatch()</code>
 * method), and the field that it's being called from.
 * 
 * The data class's <code>autocompleteMatch()</code> method should returns a list of matches, where each match is
 * an object with the following properties:
 * <table border="1" width="50%">
 * <tr><td width="15%">data</td><td>the object being matched</td></tr>
 * <tr><td>text</td><td>the text to display for this object in the list</td></tr>
 * <tr><td>[key1]</td><td>a string that may be used to replace the typed text</td></tr>
 * <tr><td>[keyN]</td><td>a string that may be used to replace the typed text</td></tr>
 * </table>
 * 
 * The calling client also specifies the key in the match result for the string that will be used
 * to replace the typed text (also called the "completion string"). For example, the completion 
 * string for matching contacts could be a full address, or just the email.
 * 
 * The client may provide additional key event handlers in the form of callbacks. If the callback
 * explicitly returns true or false, that's what the event handler will return.
 * 
 * A single autocomplete list view may handle several related input fields. With the "quick complete" feature, there
 * may be multiple outstanding autocomplete requests to the server. Each request is managed through a context which
 * has all the information needed to make the request and handle its results.
 * 
 * 
 * 
 * Using Autocomplete
 * 
 * Autocomplete kicks in after there is a pause in the typing (that pause has to be at least 300ms by default). Let's say that
 * you are entering addresses into the To: field while composing an email. You type a few characters and then pause:
 * 
 * 	dav
 * 
 * ZCS will ask the user for people whose name or email address matches "dav", and display the matches in a list that pops up.
 * The matches will be sorted with the people you email the most at the top. When you select a match, that person's address
 * will replace the search string ("dav") in the To: field. Typically the address will be in a bubble.
 * 
 * 	Davey Jones x
 * 
 * Quick Complete
 * 
 * Many times you will know which address you're looking for, and you will type enough characters so that they will appear at
 * the top of the matches, and then you type semicolon or a return to select them once the list has come up. If you know that
 * the address you want will appear at the top of the matches based on what you've typed, then there's a way to select it 
 * without waiting for the list to come up: just type a semicolon. For example, let's assume that I email Davey Jones a lot,
 * and I know that if I type "dav" he will be the first match. I can just type
 * 
 * 	dav;
 * 
 * and continue, whether that's adding more addresses, or moving on to the subject and body (done easily via the Tab key).
 * Autocompletion will happen in the background, and will automatically replace "dav;" with the first match from the list. If 
 * no matches are found, nothing changes. One way to think of the Quick Complete feature is as the autocomplete version of 
 * Google's "I'm Feeling Lucky", though in this case you have a much better idea of what the results are going to be. You 
 * don't have to wait for the list to appear in order to add the bubble. It gets added for you.
 * 
 * You can type in multiple Quick Complete strings, and they will all be handled. For example, I could type
 * 
 * 	dav;pb;ann;x;
 * 
 * and see bubbles pop up for Davey Jones, Phil Bates, Ann Miller, and Xavier Gold without any more action on my part. I could
 * even type "dav;" into the To: field, hit Tab to go to the Cc: field, type "pb;" there, and then Tab to the Subject: field,
 * and start writing my message.
 * 
 * One small limitation of Quick Complete is that the bubbles will pop up within a field in the order that the results come 
 * back, which may not match the order of the strings you typed in. You can drag the bubbles to rearrange them if you want.
 * 
 * Special Keys
 * 
 * There are a number of keys that have special meanings when you are working with an input field that supports autocomplete. 
 * Most of them apply while the list of matches is showing, and are used to control selection of the match you want:
 * 
 * Return		Adds the selected address
 * Tab		Adds the selected address
 * ;		Adds the selected address
 * ,		Adds the selected address (if enabled in Preferences/Address Book/Autocomplete)
 * DownArrow	Selects the next address (hold to repeat)
 * UpArrow		Selects the previous address (hold to repeat)
 * Esc		Hides the list
 * 
 * A few keys have special meanings while the list is not showing:
 * 
 * Return		If the input contains an email address, turn it into a bubble
 * Tab		Go to the next field
 * Esc		If requests are pending (it will say "Autocompleting"), cancel them. If not, cancel compose.
 * 
 * 
 * 
 * @author Conrad Damon
 *
 * @param {Hash}	params			a hash of parameters:
 * @param	{String}		matchValue			the name of field in match result to use for completion
 * @param	{function}		dataClass			the class that has the data loader
 * @param	{function}		dataLoader			a method of dataClass that returns data to match against
 * @param	{DwtComposite}	parent				the control that created this list (defaults to shell)
 * @param	{String}		className			the CSS class
 * @param	{Array}			delims				the list of delimiters (which separate tokens such as addresses)
 * @param	{Array}			delimCodes			the list of delimiter key codes
 * @param	{String}		separator			the separator (gets added to the end of a match)
 * @param	{AjxCallback}	compCallback		the callback into client to notify it that completion happened
 * @param	{AjxCallback}	selectionCallback	the callback into client to notify it that selection from extended DL happened (passed from email.js, and accessed from ZmDLAutocompleteListView.prototype._doUpdate)
 * @param	{AjxCallback}	keyDownCallback		the additional client ONKEYDOWN handler
 * @param	{AjxCallback}	keyPressCallback	the additional client ONKEYPRESS handler
 * @param	{AjxCallback}	keyUpCallback		the additional client ONKEYUP handler
 * @param	{string}		contextId			ID from parent
 * @param	{Hash}			options				the additional options for the data class
 * @param	{function}		locationCallback	used to customize list location (optional)
 * 
 * @extends		DwtComposite
 */
ZmAutocompleteListView = function(params) {

	if (arguments.length == 0) {
		return;
	}

	params.parent = params.parent || appCtxt.getShell();
	params.className = params.className || "ZmAutocompleteListView";
	params.posStyle = DwtControl.ABSOLUTE_STYLE;
	params.id = params.contextId ? DwtId.makeId(ZmId.WIDGET_AUTOCOMPLETE, params.contextId) :
								   this._htmlElId || Dwt.getNextId("ZmAutocompleteListView_");
	DBG.println("acid", "ID: " + params.id);
	DwtComposite.call(this, params);

	this._dataClass = this._dataAPI = params.dataClass;
	this._dataLoader = params.dataLoader;
	this._dataLoaded = false;
	this._matchValue = params.matchValue;
	this._selectionCallback = params.selectionCallback;
	this._separator = (params.separator != null) ? params.separator : AjxEmailAddress.SEPARATOR;
    this._options = params.options || {};
	this._locationCallback = params.locationCallback;
	this._autocompleteType = params.autocompleteType;

	this._callbacks = {};
	for (var i = 0; i < ZmAutocompleteListView.CALLBACKS.length; i++) {
		this._setCallbacks(ZmAutocompleteListView.CALLBACKS[i], params);
	}

	this._isDelim = AjxUtil.arrayAsHash(params.delims || ZmAutocompleteListView.DELIMS);
	this._isDelimCode = AjxUtil.arrayAsHash(params.delimCodes || ZmAutocompleteListView.DELIM_CODES);
	if (!params.delims && !params.delimCodes) {
		this._isDelim[','] = this._isDelimCode[188] = appCtxt.get(ZmSetting.AUTOCOMPLETE_ON_COMMA); 
		var listener = new AjxListener(this, this._settingChangeListener);
		var aoc = appCtxt.getSettings().getSetting(ZmSetting.AUTOCOMPLETE_ON_COMMA);
		if (aoc) {
			aoc.addChangeListener(listener);
		}
	}

    // mouse event handling
	this._setMouseEventHdlrs();
	this.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
	this.addListener(DwtEvent.ONMOUSEOVER, new AjxListener(this, this._mouseOverListener));
	this._addSelectionListener(new AjxListener(this, this._listSelectionListener));
	this._outsideListener = new AjxListener(null, ZmAutocompleteListView._outsideMouseDownListener);

	// only trigger matching after a sufficient pause
	this._acInterval = appCtxt.get(ZmSetting.AC_TIMER_INTERVAL);
	this._acActionId = {};	// per element

	// for managing focus on Tab in Firefox
	if (AjxEnv.isGeckoBased) {
		this._focusAction = new AjxTimedAction(null, this._autocompleteFocus);
	}

	this._origClass = "acRow";
	this._selClass = "acRow-selected";
	this._showLinkTextClass = "LinkText";
	this._hideLinkTextClass = "LinkText-hide";
	this._hideSelLinkTextClass = "LinkText-hide-selected";

	this._contexts 			= {};	// key is element ID
	this._inputValue		= {};	// key is element ID
	
	this.setVisible(false);
	this.setScrollStyle(Dwt.SCROLL);
	this.reset();
};

ZmAutocompleteListView.prototype = new DwtComposite;
ZmAutocompleteListView.prototype.constructor = ZmAutocompleteListView;
ZmAutocompleteListView.prototype.toString = function() { return "ZmAutocompleteListView"; };

ZmAutocompleteListView.CB_ADDR_FOUND	= "addrFound";
ZmAutocompleteListView.CB_COMPLETION	= "comp";
ZmAutocompleteListView.CB_KEYDOWN		= "keyDown";
ZmAutocompleteListView.CB_KEYPRESS		= "keyPress";
ZmAutocompleteListView.CB_KEYUP			= "keyUp";
ZmAutocompleteListView.CALLBACKS = [
		ZmAutocompleteListView.CB_ADDR_FOUND,
		ZmAutocompleteListView.CB_COMPLETION,
		ZmAutocompleteListView.CB_KEYDOWN,
		ZmAutocompleteListView.CB_KEYPRESS,
		ZmAutocompleteListView.CB_KEYUP
];

// map of characters that are completion characters
ZmAutocompleteListView.DELIMS = [',', ';', '\n', '\r'];	// used when list is not showing
ZmAutocompleteListView.DELIM_CODES = [                  // used when list is showing
    DwtKeyEvent.KEY_COMMA,
    DwtKeyEvent.KEY_SEMICOLON,
    DwtKeyEvent.KEY_SEMICOLON_1,
    DwtKeyEvent.KEY_END_OF_TEXT,
    DwtKeyEvent.KEY_RETURN
];

ZmAutocompleteListView.WAIT_ID = "wait";

// for list selection with up/down arrows
ZmAutocompleteListView.NEXT = -1;
ZmAutocompleteListView.PREV = -2;

// possible states of an autocomplete context
ZmAutocompleteListView.STATE_NEW		= "NEW";
ZmAutocompleteListView.STATE_REQUEST	= "REQUEST";
ZmAutocompleteListView.STATE_RESPONSE	= "RESPONSE";
ZmAutocompleteListView.STATE_DONE		= "DONE";




/**
 * Handles the on key down event.
 * 
 * @param	{Event}	event		the event
 */
ZmAutocompleteListView.onKeyDown =
function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	var key = DwtKeyEvent.getCharCode(ev);
	var result = true;
	var element = DwtUiEvent.getTargetWithProp(ev, "_aclvId");
	DBG.println("ac", ev.type.toUpperCase() + " in " + (element && element.id) + ": " + key);
	var aclv = element && DwtControl.ALL_BY_ID[element._aclvId];
	if (aclv) {
		// if the user types a single delimiting character with the list showing, do completion
		var isDelim = (!ev.shiftKey && (aclv._isDelimCode[key] || (key === DwtKeyEvent.KEY_TAB && aclv.getVisible())));
		var visible = aclv.getVisible();
		aclv._actionHandled = false;
		// DBG.println("ac", "key = " + key + ", isDelim: " + isDelim);
		if (visible && aclv.handleAction(key, isDelim, element)) {
			aclv._actionHandled = true;
			result = false;
		}

		aclv._inputValue[element.id] = element.value;
		var cbResult = aclv._runCallbacks(ZmAutocompleteListView.CB_KEYDOWN, element && element.id, [ev, aclv, result, element]);
		// DBG.println("ac", ev.type.toUpperCase() + " cbResult: " + cbResult);
		result = (cbResult === true || cbResult === false) ? cbResult : result;
	}
	if (AjxEnv.isFirefox){
		ZmAutocompleteListView.clearTimer();
		ZmAutocompleteListView.timer =  new AjxTimedAction(this, ZmAutocompleteListView.onKeyUp, [ev]);
		AjxTimedAction.scheduleAction(ZmAutocompleteListView.timer, 300)
	}
	return ZmAutocompleteListView._echoKey(result, ev);
};

/**
 * Handles the on key press event.
 * 
 * @param	{Event}	event		the event
 */
ZmAutocompleteListView.onKeyPress =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	DwtKeyEvent.geckoCheck(ev);
	var result = true;
	var key = DwtKeyEvent.getCharCode(ev);
	var element = DwtUiEvent.getTargetWithProp(ev, "_aclvId");
	DBG.println("ac", ev.type.toUpperCase() + " in " + (element && element.id) + ": " + key);
	var aclv = element && DwtControl.ALL_BY_ID[element._aclvId];
	if (aclv) {
		if (aclv._actionHandled) {
			result = false;
		}
		var cbResult = aclv._runCallbacks(ZmAutocompleteListView.CB_KEYPRESS, element && element.id, [ev, aclv, result, element]);
		DBG.println("ac", ev.type.toUpperCase() + " cbResult: " + cbResult);
		result = (cbResult === true || cbResult === false) ? cbResult : true;
	}

	return ZmAutocompleteListView._echoKey(result, ev);
};

/**
 * Handles the on key up event.
 * 
 * @param	{Event}	event		the event
 */
ZmAutocompleteListView.onKeyUp =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	var result = true;
	var key = DwtKeyEvent.getCharCode(ev);
	var element = DwtUiEvent.getTargetWithProp(ev, "_aclvId");
	DBG.println("ac", ev.type.toUpperCase() + " in " + (element && element.id) + ": " + key);
	var aclv = element && DwtControl.ALL_BY_ID[element._aclvId];
	if (aclv) {
		if (aclv._actionHandled) {
			result = false;
		}
		var result = ZmAutocompleteListView._onKeyUp(ev);
		var cbResult = aclv._runCallbacks(ZmAutocompleteListView.CB_KEYUP, element && element.id, [ev, aclv, result, element]);
		DBG.println("ac", ev.type.toUpperCase() + " cbResult: " + cbResult);
		result = (cbResult === true || cbResult === false) ? cbResult : result;
	}
	return ZmAutocompleteListView._echoKey(result, ev);
};

/**
 * "onkeyup" handler for performing autocompletion. The reason it's an "onkeyup" handler is that it's the only one
 * that arrives after the input has been updated.
 *
 * @param ev		the key event
 * 
 * @private
 */
ZmAutocompleteListView._onKeyUp =
function(ev) {

	var element = DwtUiEvent.getTargetWithProp(ev, "_aclvId");
	if (!element) {
		return ZmAutocompleteListView._echoKey(true, ev);
	}

	var aclv = DwtControl.ALL_BY_ID[element._aclvId];
	var key = DwtKeyEvent.getCharCode(ev);
	var value = element.value;
	var elId = element.id;
	DBG.println("ac", ev.type + " event, key = " + key + ", value = " + value);
	ev.inputChanged = (value != aclv._inputValue[elId]);

	// reset timer on any address field key activity
	if (aclv._acActionId[elId] !== -1 && !DwtKeyMap.IS_MODIFIER[key] && key !== DwtKeyEvent.KEY_TAB) {
		DBG.println("ac", "canceling autocomplete");
		AjxTimedAction.cancelAction(aclv._acActionId[elId]);
		aclv._acActionId[elId] = -1;
	}

	// ignore modifier keys (including Shift), or a key with a modifier that makes it nonprintable
	if (DwtKeyMap.IS_MODIFIER[key] || DwtKeyMapMgr.hasModifier(ev)) {
		return true;
	}

	// if the input is empty, clear the list (if it's for this input)
	if (!value && aclv._currentContext && element == aclv._currentContext.element) {
		aclv.reset(element);
		return true;
	}

	// a Return following an address turns it into a bubble
	if (DwtKeyEvent.IS_RETURN[key] && aclv._complete(element)) {
		return false;
	}

	// skip if input value is not changed
	if (!ev.inputChanged) {
		return true;
	}

	ZmAutocompleteListView.clearTimer();

	// regular input, schedule autocomplete
	var ev1 = new DwtKeyEvent();
	DwtKeyEvent.copy(ev1, ev);
	ev1.aclv = aclv;
	ev1.element = element;
	DBG.println("ac", "scheduling autocomplete for: " + elId);

	var aif = DwtControl.ALL_BY_ID[element._aifId];
	if (aif && aif._editMode) {
		return false;
	}
	
	var acAction = new AjxTimedAction(aclv, aclv._autocompleteAction, [ev1]);
	aclv._acActionId[elId] = AjxTimedAction.scheduleAction(acAction, aclv._acInterval);
	
	return true;
};

ZmAutocompleteListView.clearTimer =
function(ev){
    if (ZmAutocompleteListView.timer){
        AjxTimedAction.cancelAction(ZmAutocompleteListView.timer)
    }
};

/**
 * Invokes or prevents the browser's default behavior (which is to echo the typed key).
 * 
 * @param {Boolean}	echo	if <code>true</code>, echo the key
 * @param {Event}	ev	the UI event
 * 
 * @private
 */
ZmAutocompleteListView._echoKey =
function(echo, ev) {
	DwtUiEvent.setBehaviour(ev, !echo, echo);
	return echo;
};

/**
 * Hides list if there is a click elsewhere.
 * 
 * @private
 */
ZmAutocompleteListView._outsideMouseDownListener =
function(ev, context) {

	var curList = context && context.obj;
	if (curList) {
		DBG.println("out", "outside listener, cur " + curList.toString() + ": " + curList._htmlElId);
		curList.show(false);
		curList.setWaiting(false);
	}
};

/**
 * Sets the active account.
 * 
 * @param	{ZmAccount}		account		the account
 */
ZmAutocompleteListView.prototype.setActiveAccount =
function(account) {
	this._activeAccount = account;
};

/**
 * Adds autocompletion to the given field by setting key event handlers.
 *
 * @param {Element}	element			an HTML element
 * @param {string}	addrInputId		ID of ZmAddressInputField (for addr bubbles)
 * 
 * @private
 */
ZmAutocompleteListView.prototype.handle =
function(element, addrInputId) {
	
	var elId = element.id = element.id || Dwt.getNextId();
	DBG.println("ac", "HANDLE " + elId);
	// TODO: use el id instead of expando
	element._aclvId = this._htmlElId;
	if (addrInputId) {
		element._aifId = addrInputId;
	}
	this._contexts[elId] = {};
	this._acActionId[elId] = -1;
	Dwt.setHandler(element, DwtEvent.ONKEYDOWN, ZmAutocompleteListView.onKeyDown);
	Dwt.setHandler(element, DwtEvent.ONKEYPRESS, ZmAutocompleteListView.onKeyPress);
	Dwt.setHandler(element, DwtEvent.ONKEYUP, ZmAutocompleteListView.onKeyUp);
	if (AjxEnv.isFirefox){
		// don't override the element input handler directly, as DwtControl uses
		// that for changing style, etc.
		var control = DwtControl.findControl(element);

		if (control && control.getInputElement && control.getInputElement() === element) {
			control.addListener(DwtEvent.ONBLUR, ZmAutocompleteListView.clearTimer);
		} else {
			Dwt.setHandler(element, DwtEvent.ONBLUR, ZmAutocompleteListView.clearTimer);
		}
	}
	this.isActive = true;
};

ZmAutocompleteListView.prototype.unhandle =
function(element) {
	DBG.println("ac", "UNHANDLE " + element.id);
	Dwt.clearHandler(element, DwtEvent.ONKEYDOWN);
	Dwt.clearHandler(element, DwtEvent.ONKEYPRESS);
	Dwt.clearHandler(element, DwtEvent.ONKEYUP);
	this.isActive = false;
};

// Kicks off an autocomplete cycle, which scans the content of the given input and then
// handles the strings it finds, possible making requests to the data provider.
ZmAutocompleteListView.prototype.autocomplete =
function(element) {

	if (this._dataLoader && !this._dataLoaded) {
		this._data = this._dataLoader.call(this._dataClass);
		this._dataAPI = this._data;
		this._dataLoaded = true;
	}

	var results = this._parseInput(element);
	this._process(results, element);
};

/**
 * See if the text in the input is an address. If it is, complete it.
 * 
 * @param {Element}		element
 * @return {boolean}	true if the value in the input was completed
 */
ZmAutocompleteListView.prototype._complete =
function(element) {

	var value = element.value;
	if (this._dataAPI.isComplete && this._dataAPI.isComplete(value)) {
		DBG.println("ac", "got a Return or Tab, found an addr: " + value);
		var result = this._parseInput(element)[0];
		var context = {
			element:	element,
			str:		result.str,
			isAddress:	true,
			isComplete:	result.isComplete,
			key:		this._getKey(result)
		}
		this._update(context);
		this.reset(element);
		return true;
	}
	return false;
};

// Parses the content of the given input by splitting the text at delimiters. Returns a list of
// objects with information about each string it found.
ZmAutocompleteListView.prototype._parseInput =
function(element) {

	DBG.println("ac", "parse input for element: " + element.id); 
	var results = [];
	var text = element && element.value;
	if (!text) {
		return results;
	}
	DBG.println("ac", "PARSE: " + text);
	var str = "";
	for (var i = 0; i < text.length; i++) {
		var c = text.charAt(i);
		if (c == ' ' && !str) { continue; }	// ignore leading space
		var isDelim = this._isDelim[c];
		if (isDelim || c == ' ') {
			// space counts as delim if bubbles are on and the space follows an address
			var str1 = (this._dataAPI.isComplete && this._dataAPI.isComplete(str, true));
			if (str1) {
				DBG.println("ac", "parse input found address: " + str);
				str1 = (str1 === true) ? str : str1;
				results.push({element:element, str:str1, isComplete:true, isAddress:true});
				str = "";
			}
			else if (c == ";") {
				// semicolon triggers Quick Complete
				results.push({element:element, str:str, isComplete:true});
				str = "";
			}
			else {
				// space typed, but not after an address so no special meaning
				str += c;
			}
		}
		else {
			str += c;
		}
	}
	if (str) {
		results.push({str:str, isComplete:false});
	}

	return results;
};

/**
 * Look through the parsed contents of the input and make any needed autocomplete requests. If there is a 
 * delimited email address, go ahead and handle it now. Also, make sure to cancel any requests that no
 * longer match the contents of the input. This function will run only after a pause in the user's typing
 * (via a setTimeout call), so existing contexts will be in either the REQUEST state or the DONE state.
 */
ZmAutocompleteListView.prototype._process =
function(results, element) {

	// for convenience, create a hash of current keys for this input
	var resultsHash = {};
	for (var i = 0; i < results.length; i++) {
		var key = this._getKey(results[i]);
		resultsHash[key] = true;
	}
	
	// cancel any outstanding requests for strings that are no longer in the input
	var pendingContextHash = {};
	var oldContexts = this._contexts[element.id];
	if (oldContexts && oldContexts.length) {
		for (var i = 0; i < oldContexts.length; i++) {
			var context = oldContexts[i];
			var key = context.key;
			if (key && context.reqId && context.state == ZmAutocompleteListView.STATE_REQUEST && !resultsHash[key]) {
				DBG.println("ac", "request for '" + context.str + "' no longer current, canceling req " + context.reqId);
				appCtxt.getAppController().cancelRequest(context.reqId);
				context.state = ZmAutocompleteListView.STATE_DONE;
				if (context.str == this._waitingStr) {
					this.setWaiting(false);
				}
			}
			else if (context.state == ZmAutocompleteListView.STATE_REQUEST) {
				pendingContextHash[context.key] = context;
			}
		}
	}
	
	// process the parsed content
	var newContexts = [];
	for (var i = 0; i < results.length; i++) {
		var result = results[i];
		var str = result.str;
		var key = this._getKey(result);
		var pendingContext = pendingContextHash[key];
		// see if we already have a pending request for this result; if so, leave it alone
		if (pendingContext) {
			DBG.println("ac", "PROCESS: propagate pending context for '" + str + "'");
			newContexts.push(pendingContext);
		}
		else {
			// add a new context
			DBG.println("ac", "PROCESS: add new context for '" + str + "', isComplete: " + result.isComplete);
			var context = {
				element:	element,
				str:		str,
				isComplete:	result.isComplete,
				key:		key,
				isAddress:	result.isAddress,
				state:		ZmAutocompleteListView.STATE_NEW
			}
			newContexts.push(context);
			if (result.isAddress) {
				// handle a completed email address now
				this._update(context);
			}
			else {
				// go get autocomplete results from the data provider
				this._autocomplete(context);
			}
		}
	}
	this._contexts[element.id] = newContexts;
};

// Returns a key that combines the string with whether it's subject to Quick Complete
ZmAutocompleteListView.prototype._getKey =
function(context) {
	return context.str + (context.isComplete ? this._separator : "");
};

/**
 * Resets the visible state of the autocomplete list. The state-related properties are not
 * per-element because there can only be one visible autocomplete list.
 */
ZmAutocompleteListView.prototype.reset =
function(element) {

	DBG.println("ac", "RESET");
	this._matches = null;
	this._selected = null;

	this._matchHash			= {};
	this._forgetLink		= {};
	this._expandLink		= {};

	this.show(false);
	if (this._memberListView) {
		this._memberListView.show(false);
	}
	this.setWaiting(false);
	
	if (element) {
		this._removeDoneRequests(element);
	}
};

/**
 * Checks the given key to see if it's used to control the autocomplete list in some way.
 * If it does, the action is taken and the key won't be echoed into the input area.
 *
 * The following keys are action keys:
 *	38 40		up/down arrows (list selection)
 *	37 39		left/right arrows (dl expansion)
 *	27			escape (hide list)
 *
 * The following keys are delimiters (trigger completion when list is up):
 *	3 13		return
 *	9			tab
 *	59 186		semicolon
 *	188			comma (depends on user pref)
 *
 * @param {int}		key			a numeric key code
 * @param {boolean}	isDelim		true if a single delimiter key was typed
 * @param {Element}	element		element key event happened in 
 * 
 * @private
 */
ZmAutocompleteListView.prototype.handleAction = function(key, isDelim, element) {

	DBG.println("ac", "autocomplete handleAction for key " + key + " / " + isDelim);

	if (isDelim) {
		this._update();
	}
    else if (key === DwtKeyEvent.KEY_ARROW_RIGHT) {
		// right arrow
		var dwttext = this._expandText && this._expandText[this._selected];

		// if the caret is at the end of the input, expand a distribution list,
		// if possible
		if(!dwttext || Dwt.getSelectionStart(element) !== element.value.length) {
			return false;
		}

		// fake a click
		dwttext.notifyListeners(DwtEvent.ONMOUSEDOWN);

	}
    else if (key === DwtKeyEvent.KEY_ARROW_UP || key === DwtKeyEvent.KEY_ARROW_DOWN) {
		// handle up and down arrow keys
		if (this.size() < 1) {
			return;
		}
		if (key === DwtKeyEvent.KEY_ARROW_DOWN) {
			this._setSelected(ZmAutocompleteListView.NEXT);
		}
        else if (key === DwtKeyEvent.KEY_ARROW_UP) {
			this._setSelected(ZmAutocompleteListView.PREV);
		}
	}
    else if (key === DwtKeyEvent.KEY_ESCAPE) {
		if (this.getVisible()) {
			this.reset(element); // ESC hides the list
		}
		else if (!this._cancelPendingRequests(element)) {
			return false;
		}
	}
    else if (key === DwtKeyEvent.KEY_TAB) {
		this._popdown();
		return false;
	}
    else {
		return false;
	}
	return true;
};

// Cancels the XHR of any context in the REQUEST state.
ZmAutocompleteListView.prototype._cancelPendingRequests =
function(element) {

	var foundOne = false;
	var contexts = this._contexts[element.id];
	if (contexts && contexts.length) {
		for (var i = 0; i < contexts.length; i++) {
			var context = contexts[i];
			if (context.state == ZmAutocompleteListView.STATE_REQUEST) {
				DBG.println("ac", "user-initiated cancel of request for '" + context.str + "', " + context.reqId);
				appCtxt.getAppController().cancelRequest(context.reqId);
				context.state = ZmAutocompleteListView.STATE_DONE;
				foundOne = true;
			}
		}
	}
	this.setWaiting(false);
	
	return foundOne;
};

// Clean up contexts we are done with
ZmAutocompleteListView.prototype._removeDoneRequests =
function(element) {

	var contexts = this._contexts[element.id];
	var newContexts = [];
	if (contexts && contexts.length) {
		for (var i = 0; i < contexts.length; i++) {
			var context = contexts[i];
			if (context.state == ZmAutocompleteListView.STATE_DONE) {
				newContexts.push(context);
			}
		}
	}
	this._contexts[element.id] = newContexts;
};

/**
 * Sets the waiting status.
 * 
 * @param	{Boolean}	on		if <code>true</code>, turn waiting "on"
 * @param	{string}	str		string that pending request is for
 * 
 */
ZmAutocompleteListView.prototype.setWaiting =
function(on, str) {

	if (!on && !this._waitingDiv) {
		return;
	}

	var div = this._waitingDiv;
	if (!div) {
		div = this._waitingDiv = document.createElement("div");
		div.className = "acWaiting";
		var html = [], idx = 0;
		html[idx++] = "<table role='presentation' cellpadding=0 cellspacing=0 border=0>";
		html[idx++] = "<tr>";
		html[idx++] = "<td><div class='ImgSpinner'></div></td>";
		html[idx++] = "<td>" + ZmMsg.autocompleteWaiting + "</td>";
		html[idx++] = "</tr>";
		html[idx++] = "</table>";
		div.innerHTML = html.join("");
		Dwt.setPosition(div, Dwt.ABSOLUTE_STYLE);
		appCtxt.getShell().getHtmlElement().appendChild(div);
	}

	if (on) {
		this._popdown();
		var loc = this._getDefaultLoc();
		Dwt.setLocation(div, loc.x, loc.y);

		this._setLiveRegionText(ZmMsg.autocompleteWaiting);
	}
	this._waitingStr = on ? str : "";

	Dwt.setZIndex(div, on ? Dwt.Z_DIALOG_MENU : Dwt.Z_HIDDEN);
	Dwt.setVisible(div, on);
};

// Private methods

/**
 * Called as a timed action, after a sufficient pause in typing within an address field.
 * 
 * @private
 */
ZmAutocompleteListView.prototype._autocompleteAction =
function(ev) {
	var aclv = ev.aclv;
	aclv._acActionId[ev.element.id] = -1; // so we don't try to cancel
	aclv.autocomplete(ev.element);
};

/**
 * Displays the current matches in a popup list, selecting the first.
 *
 * @param {Boolean}	show	if <code>true</code>, display the list
 * @param {String}	loc		where to display the list
 * 
 */
ZmAutocompleteListView.prototype.show =
function(show, loc) {

	if (show) {
		this.setWaiting(false);
		this._popup(loc);
	} else {
		this._popdown();
	}
};

// Makes an autocomplete request to the data provider.
ZmAutocompleteListView.prototype._autocomplete =
function(context) {

	var str = AjxStringUtil.trim(context.str);
	if (!str || !(this._dataAPI && this._dataAPI.autocompleteMatch)) {
		return;
	}
	DBG.println("ac", "autocomplete: " + context.str);
	
	this._currentContext = context;	// so we can figure out where to pop up the "waiting" indicator
	var respCallback = this._handleResponseAutocomplete.bind(this, context);
	context.state = ZmAutocompleteListView.STATE_REQUEST;
	context.reqId = this._dataAPI.autocompleteMatch(str, respCallback, this, this._options, this._activeAccount, this._autocompleteType);
	DBG.println("ac", "Request ID for " + context.element.id + " / '" + context.str + "': " + context.reqId);
};

ZmAutocompleteListView.prototype._handleResponseAutocomplete =
function(context, list) {

	context.state = ZmAutocompleteListView.STATE_RESPONSE;

	if (list && list.length) {
		DBG.println("ac", "matches found for '" + context.str + "': " + list.length);
		context.list = list;
		if (context.isComplete) {
			// doing Quick Complete, go ahead and update with the first match
			DBG.println("ac", "performing quick completion for: " + context.str);
			this._update(context, list[0]);
		} else {
			// pop up the list of matches
			this._set(list, context);
			this._currentContext = context;
			this.show(true);
		}
	} else if (!context.isComplete) {
		this._popdown();
		this._showNoResults();

		var msg = AjxMessageFormat.format(ZmMsg.autocompleteMatches, 0);
		this._setLiveRegionText(msg);
	}
};

// Returns the field in the match that we show the user.
ZmAutocompleteListView.prototype._getCompletionValue =
function(match) {
	var value = "";
	if (this._matchValue instanceof Array) {
		for (var i = 0, len = this._matchValue.length; i < len; i++) {
			if (match[this._matchValue[i]]) {
				value = match[this._matchValue[i]];
				break;
			}
		}
	} else {
		value = match[this._matchValue] || "";
	}
	return value;
};

// Updates the content of the input with the given match and adds a bubble
ZmAutocompleteListView.prototype._update =
function(context, match) {

	context = context || this._currentContext;
	if (!context) {
		return;
	}
	match = match || this._matchHash[this._selected];
	
	if (match && match.needDerefGroup) {
		var contact = new ZmContact(match.groupId, {});
		var continuationCb = new AjxCallback(this, this._updateContinuation, [context, match]);
		var derefCallback = new AjxCallback(match, match.setContactGroupMembers, [match.groupId, continuationCb]);
		contact.load(derefCallback, null, null, true);
	}
	else {
		this._updateContinuation(context, match);
	}
};

// continuation of _update
ZmAutocompleteListView.prototype._updateContinuation = 
function(context, match) {

	var newText = "";
	var address = context.address = context.address || (context.isAddress && context.str) || (match && this._getCompletionValue(match));
	DBG.println("ac", "UPDATE: result for '" + context.str + "' is " + AjxStringUtil.htmlEncode(address));

	var bubbleAdded = this._addBubble(context, match, context.isComplete);
	if (!bubbleAdded) {
		newText = address + this._separator;
	}

	// figure out what the content of the input should now be
	var el = context.element;
	if (el) {
		// context.add means don't change the content (used by DL selection)
		if (!context.add) {
			// Parse the input again so we know what to replace. There is a race condition here, since the user
			// may have altered the content during the request. In that case, the altered content will not match
			// and get replaced, which is fine. Reparsing the input seems like a better option than trying to use
			// regexes.
			var results = this._parseInput(el);
			var newValue = "";
			for (var i = 0; i < results.length; i++) {
				var result = results[i];
				var key = this._getKey(result);
				// Compare el.value to key too. Edge case: user types complete email and presses enter
				// before new autocomplete request is sent. In this case context.key is only a part of key and el.value.
				// Bug 86577
				if (context.key === key || el.value === key) {
					newValue += newText;
				}
				else {
					newValue += key;
				}
			}
			if (bubbleAdded) {
				newValue = AjxStringUtil.trim(newValue);
			}
			if (el.value !== newValue) {
				el.value = newValue;
			}
		}
		
		if (!context.isComplete) {
			// match was selected from visible list, refocus the input and clear the list
			el.focus();
			this.reset(el);
		}
	}
	context.state = ZmAutocompleteListView.STATE_DONE;

	this._runCallbacks(ZmAutocompleteListView.CB_COMPLETION, el && el.id, [address, el, match]);
};

// Adds a bubble. If we are adding it via Quick Complete, we don't want the input field to set
// focus since the user may have tabbed into another input field.
ZmAutocompleteListView.prototype._addBubble =
function(context, match, noFocus) {

	var el = context.element;
	var addrInput = el && el._aifId && DwtControl.ALL_BY_ID[el._aifId];
	if (addrInput) {
		var bubbleCount = addrInput.getBubbleCount();

		if (match && match.multipleAddresses) {
			// mass complete (add all) from a DL
			addrInput.addValue(context.address);
		}
		else {
			var addedClass = this._dataAPI && this._dataAPI.getAddedBubbleClass && this._dataAPI.getAddedBubbleClass(context.str);
			var bubbleParams = {
				address:	context.address,
				match:		match,
				noFocus:	noFocus,
				addClass:	addedClass,
				noParse:	this._options.noBubbleParse
			}
			addrInput.addBubble(bubbleParams);
		}

		var msg = AjxMessageFormat.format(ZmMsg.autocompleteAddressesAdded,
		                                  addrInput.getBubbleCount() - bubbleCount);
		this._setLiveRegionText(msg);

		el = addrInput._input;
		// Input field loses focus along the way. Restore it when the stack is finished
		if (AjxEnv.isIE) {
			AjxTimedAction.scheduleAction(new AjxTimedAction(addrInput, addrInput.focus), 0);
		}
		return true;
	}
	else {
		return false;
	}
};

// Listeners

// MOUSE_DOWN selects a match and performs an update. Note that we don't wait for
// a corresponding MOUSE_UP event.
ZmAutocompleteListView.prototype._mouseDownListener = 
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	var row = DwtUiEvent.getTargetWithProp(ev, "id");
	if (!row || !row.id || row.id.indexOf("Row") === -1) {
		return;
	}
	if (ev.button == DwtMouseEvent.LEFT) {
		this._setSelected(row.id);
		if (this.isListenerRegistered(DwtEvent.SELECTION)) {
	    	var selEv = DwtShell.selectionEvent;
	    	DwtUiEvent.copy(selEv, ev);
	    	selEv.detail = 0;
	    	this.notifyListeners(DwtEvent.SELECTION, selEv);
	    	return true;
	    }		
	}
};

// Mouse over selects a match
ZmAutocompleteListView.prototype._mouseOverListener = 
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	var row = Dwt.findAncestor(DwtUiEvent.getTarget(ev), "id");
	if (row) {
		this._setSelected(row.id);
	}
	return true;
};

// Seems like DwtComposite should define this method
ZmAutocompleteListView.prototype._addSelectionListener = 
function(listener) {
	this._eventMgr.addListener(DwtEvent.SELECTION, listener);
};

ZmAutocompleteListView.prototype._listSelectionListener = 
function(ev) {
	this._update();
};

// Layout

// Lazily create main table, since we may need it to show "Waiting..." row before
// a call to _set() is made.
ZmAutocompleteListView.prototype._getTable =
function() {

	var table = this._tableId && document.getElementById(this._tableId);
	if (!table) {
		var html = [], idx = 0;
		this._tableId = this.getHTMLElId() + '_table';
		html[idx++] = "<table role='presentation' id='" + this._tableId + "' cellpadding=0 cellspacing=0 border=0>";
		html[idx++] = "</table>";
		this.getHtmlElement().innerHTML = html.join("");
		table = document.getElementById(this._tableId);
	}
	return table;
};

ZmAutocompleteListView.prototype._setLiveRegionText =
function(text) {
	// Lazily create accessibility live region
	var id = this.getHTMLElId() + '_liveRegion';
	var liveRegion = Dwt.byId(id);

	if (!liveRegion) {
		liveRegion = document.createElement('div');
		liveRegion.id = id;
		liveRegion.className = 'ScreenReaderOnly';
		liveRegion.setAttribute('role', 'alert');
		liveRegion.setAttribute('aria-label', ZmMsg.autocomplete);
		liveRegion.setAttribute('aria-live', 'assertive');
		liveRegion.setAttribute('aria-relevant', 'additions');
		liveRegion.setAttribute('aria-atomic', true);
		appCtxt.getShell().getHtmlElement().appendChild(liveRegion);
	}

	// Set the live region text content
	Dwt.removeChildren(liveRegion);
	if (text) {
		var paragraph = document.createElement('p');
		paragraph.appendChild(document.createTextNode(text));
		liveRegion.appendChild(paragraph);
	}
};

// Creates the list and its member elements based on the matches we have. Each match becomes a
// row. The first match is automatically selected.
ZmAutocompleteListView.prototype._set =
function(list, context) {

	this._removeAll();
	var table = this._getTable();
	this._matches = list;
	var forgetEnabled = (this._options.supportForget !== false);
	var expandEnabled = (this._options.supportExpand !== false);
	var len = this._matches.length;
	for (var i = 0; i < len; i++) {
		var match = this._matches[i];
		if (match && (match.text || match.icon)) {
			var rowId = match.id = this._getId("Row", i);
			this._matchHash[rowId] = match;
			var row = table.insertRow(-1);
			row.className = this._origClass;
			row.id = rowId;
			row.index = i;
			var html = [], idx = 0;
			var cell = row.insertCell(-1);
			cell.className = "AutocompleteMatchIcon";
			if (match.icon) {
				cell.innerHTML = (match.icon.indexOf('Dwt') !== -1) ? ["<div class='", match.icon, "'></div>"].join("") :
								 									 AjxImg.getImageHtml(match.icon);
			} else {
				cell.innerHTML = "&nbsp;";
			}
			cell = row.insertCell(-1);
			cell.innerHTML = match.text || "&nbsp;";
			if (forgetEnabled) {
				this._insertLinkCell(this._forgetLink, row, rowId, this._getId("Forget", i), (match.score > 0));
			}
			if (expandEnabled) {
				this._insertLinkCell(this._expandLink, row, rowId, this._getId("Expand", i), match.canExpand);
			}
		}
	}
	if (forgetEnabled) {
		this._forgetText = {};
		this._addLinks(this._forgetText, "Forget", ZmMsg.forget, ZmMsg.forgetTooltip, this._handleForgetLink, context);
	}
	if (expandEnabled) {
		this._expandText = {};
		this._addLinks(this._expandText, "Expand", ZmMsg.expand, ZmMsg.expandTooltip, this.expandDL, context);
	}

	var msg = AjxMessageFormat.format(ZmMsg.autocompleteMatches, len);
	this._setLiveRegionText(msg);

	AjxTimedAction.scheduleAction(new AjxTimedAction(this,
		function() {
			this._setSelected(this._getId("Row", 0));
		}), 100);
};

ZmAutocompleteListView.prototype._showNoResults =
function() {
	// do nothing. Overload to show something.
};

ZmAutocompleteListView.prototype._insertLinkCell =
function(hash, row, rowId, linkId, addLink) {
	hash[rowId] = addLink ? linkId : null;
	var cell = row.insertCell(-1);
	cell.className = "Link";
	cell.innerHTML = addLink ? "<a id='" + linkId + "'></a>" : "";
};

ZmAutocompleteListView.prototype._getId =
function(type, num) {
	return [this._htmlElId, "ac" + type, num].join("_");
};

// Add a DwtText to the link so it can have a tooltip.
ZmAutocompleteListView.prototype._addLinks =
function(textHash, idLabel, label, tooltip, handler, context) {

	var len = this._matches.length;
	for (var i = 0; i < len; i++) {
		var match = this._matches[i];
		var rowId = match.id = this._getId("Row", i);
		var linkId = this._getId(idLabel, i);
		var link = document.getElementById(linkId);
		if (link) {
			var textId = this._getId(idLabel + "Text", i);
			var text = new DwtText({parent:this, className:this._hideLinkTextClass, id:textId});
			textHash[rowId] = text;
			text.isLinkText = true;
			text.setText(label);
			text.setToolTipContent(tooltip);
			var listener = handler.bind(this, {email:match.email, textId:textId, rowId:rowId, element:context.element});
			text.addListener(DwtEvent.ONMOUSEDOWN, listener);
			text.reparentHtmlElement(link);
		}
	}
};

ZmAutocompleteListView.prototype._showLink =
function(hash, textHash, rowId, show) {
	var text = textHash && textHash[rowId];
	if (text) {
		text.setClassName(!show ? this._hideLinkTextClass :
			hash[rowId] ? this._showLinkTextClass : this._hideSelLinkTextClass);
	}
};

// Displays the list
ZmAutocompleteListView.prototype._popup =
function(loc) {

	if (this.getVisible()) {
		return;
	}

	loc = loc || this._getDefaultLoc();
	var x = loc.x;
	var y = loc.y;

	var windowSize = this.shell.getSize();
	var availHeight = windowSize.y - y;
	var fullHeight = this.size() * this._getRowHeight();
	this.setLocation(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	this.setVisible(true);
	var curSize = this.getSize();
	if (availHeight < fullHeight) {
	  //we are short add text to alert user to keep typing
      this._showMoreResultsText(availHeight);
      // if we don't fit, resize so we are scrollable
      this.setSize(Dwt.DEFAULT, availHeight - (AjxEnv.isIE ? 30 : 10));
	   // see if we need to account for width of vertical scrollbar
	  var div = this.getHtmlElement();
	  if (div.clientWidth != div.scrollWidth) {
			this.setSize(curSize.x + Dwt.SCROLLBAR_WIDTH, Dwt.DEFAULT);
	  }
      
	} else if (curSize.y < fullHeight) {
		this.setSize(Dwt.CLEAR, fullHeight);
	} else {
		this.setSize(Dwt.CLEAR, Dwt.CLEAR);	// set back to auto-sizing
	}

	var newX = (x + curSize.x >= windowSize.x) ? windowSize.x - curSize.x : x;

	DBG.println("ac", this.toString() + " popup at: " + newX + "," + y);
    this.setLocation(newX, y);
	this.setVisible(true);
	this.setZIndex(Dwt.Z_DIALOG_MENU);

	var omem = appCtxt.getOutsideMouseEventMgr();
	var omemParams = {
		id:					"ZmAutocompleteListView",
		obj:				this,
		outsideListener:	this._outsideListener,
		noWindowBlur:		appCtxt.get(ZmSetting.IS_DEV_SERVER)
	}
	omem.startListening(omemParams);
};

// returns a point with a location just below the input field
ZmAutocompleteListView.prototype._getDefaultLoc = 
function() {

	if (this._locationCallback) {
		return this._locationCallback();
	}
	
	var el = this._currentContext && this._currentContext.element;
	if (!el) {
		return {};
	}
	
	var elLoc = Dwt.getLocation(el);
	var elSize = Dwt.getSize(el);
	var x = elLoc.x;
	var y = elLoc.y + elSize.y + 3;
	DwtPoint.tmp.set(x, y);
	return DwtPoint.tmp;
};

// Hides the list
ZmAutocompleteListView.prototype._popdown = 
function() {

	if (!this.getVisible()) {
		return;
	}
	DBG.println("out", "popdown " + this.toString() + ": " + this._htmlElId);

	if (this._memberListView) {
		this._memberListView._popdown();
	}
	
	this.setZIndex(Dwt.Z_HIDDEN);
	this.setVisible(false);
	this._removeAll();
	this._selected = null;

	var omem = appCtxt.getOutsideMouseEventMgr();
	omem.stopListening({id:"ZmAutocompleteListView", obj:this});
};

/*
    Display message to user that more results are available than fit in the current display
    @param {int}    availHeight available height of display
 */
ZmAutocompleteListView.prototype._showMoreResultsText =
function (availHeight){
    //over load for implementation
};

/**
 * Selects a match by changing its CSS class.
 *
 * @param	{string}	id		ID of row to select, or NEXT / PREV
 */
ZmAutocompleteListView.prototype._setSelected =
function(id) {

	DBG.println("ac", "setting selected id to " + id);
	var table = document.getElementById(this._tableId);
	var rows = table && table.rows;
	if (!(rows && rows.length)) {
		return;
	}

	var len = rows.length;

	// handle selection of next/prev via arrow keys
	if (id == ZmAutocompleteListView.NEXT || id == ZmAutocompleteListView.PREV) {
		id = this._getRowId(rows, id, len);
		if (!id) {
			return;
		}
	}

	// make sure the ID matches one of our rows
	var found = false;
	for (var i = 0; i < len; i++) {
		if (rows[i].id == id) {
			found = true;
			break;
		}
	}
	if (!found) {
		return;
	}
	
	// select one row, deselect the rest
	for (var i = 0; i < len; i++) {
		var row = rows[i];
		var curStyle = row.className;
		if (row.id == id) {
			row.className = this._selClass;
		} else if (curStyle != this._origClass) {
			row.className = this._origClass;
		}
	}

	// links only shown for selected row
	this._showLink(this._forgetLink, this._forgetText, this._selected, false);
	this._showLink(this._forgetLink, this._forgetText, id, true);

	this._showLink(this._expandLink, this._expandText, this._selected, false);
	this._showLink(this._expandLink, this._expandText, id, true);

	this._selected = id;

	var match = this._matchHash[id];
	var msg;

	if (!match) {
		msg = AjxStringUtil.convertHtml2Text(Dwt.byId(this._selected));
	} else {
		var msg = AjxMessageFormat.format(ZmMsg.autocompleteMatchText, [ match.name, match.email ]);
		if (match.isGroup) {
			msg = AjxMessageFormat.format(ZmMsg.autocompleteGroup, msg);
		}
		else if (match.isDL) {
			msg = AjxMessageFormat.format(ZmMsg.autocompleteDL, msg);
		}
	}

	this._setLiveRegionText(msg);
};

ZmAutocompleteListView.prototype._getRowId =
function(rows, id, len) {

	if (len < 1) {
		return;
	}

	var idx = -1;
	for (var i = 0; i < len; i++) {
		if (rows[i].id == this._selected) {
			idx = i;
			break;
		}
	}
	var newIdx = (id == ZmAutocompleteListView.PREV) ? idx - 1 : idx + 1;
	if (newIdx == -1) {
		newIdx = len - 1;
	}
	if (newIdx == len) {
		newIdx = 0;
	}
	
	if (newIdx >= 0 && newIdx < len) {
		Dwt.scrollIntoView(rows[newIdx], this.getHtmlElement());
		return rows[newIdx].id;
	}
	return null;
};

ZmAutocompleteListView.prototype._getRowHeight =
function() {
	if (!this._rowHeight) {
		if (!this.getVisible()) {
			this.setLocation(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
			this.setVisible(true);
		}
		var row = this._getTable().rows[0];
		this._rowHeight = row && Dwt.getSize(row).y;
	}
	return this._rowHeight || 18;
};



// Miscellaneous

// Clears the internal list of matches
ZmAutocompleteListView.prototype._removeAll =
function() {
	this._matches = null;
	var table = this._getTable();
	for (var i = table.rows.length - 1; i >= 0; i--) {
		var row = table.rows[i];
		if (row != this._waitingRow) {
			table.deleteRow(i);
		}
	}
	this._removeLinks(this._forgetText);
	this._removeLinks(this._expandText);
};

ZmAutocompleteListView.prototype._removeLinks =
function(textHash) {
	if (!textHash) {
		return;
	}
	for (var id in textHash) {
		var textCtrl = textHash[id];
		if (textCtrl) {
			textCtrl.dispose();
		}
	}
};

// Returns the number of matches
ZmAutocompleteListView.prototype.size =
function() {
	return this._getTable().rows.length;
};

// Force focus to the input element (handle Tab in Firefox)
ZmAutocompleteListView.prototype._autocompleteFocus =
function(htmlEl) {
	htmlEl.focus();
};

ZmAutocompleteListView.prototype._getAcListLoc =
function(ev) {
	var element = ev.element;
	var loc = Dwt.getLocation(element);
	var height = Dwt.getSize(element).y;
	return (new DwtPoint(loc.x, loc.y + height));
};

ZmAutocompleteListView.prototype._settingChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_SETTING) {
		return;
	}
	if (ev.source.id == ZmSetting.AUTOCOMPLETE_ON_COMMA) {
		this._isDelim[','] = this._isDelimCode[188] = appCtxt.get(ZmSetting.AUTOCOMPLETE_ON_COMMA);
	}
};

ZmAutocompleteListView.prototype._handleForgetLink =
function(params) {
	if (this._dataAPI.forget) {
		this._dataAPI.forget(params.email, this._handleResponseForget.bind(this, params.email, params.rowId));
	}
};

ZmAutocompleteListView.prototype._handleResponseForget =
function(email, rowId) {
	var row = document.getElementById(rowId);
	if (row) {
		row.parentNode.removeChild(row);
		var msg = AjxMessageFormat.format(ZmMsg.forgetSummary, [email]);
		appCtxt.setStatusMsg(msg);
	}
	appCtxt.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);
};

/**
 * Displays a second popup list with the members of the given distribution list.
 *
 * @param {hash}			params				hash of params:
 * @param {string}			params.email		address of a distribution list
 * @param {string}			params.textId		ID of link text
 * @param {string}			params.rowId		ID or list view row
 * @param {DwtMouseEvent}	params.ev			mouse event
 * @param {DwtPoint}		params.loc			location to popup at; default is right of parent ACLV
 * @param {Element}			params.element		input element
 */
ZmAutocompleteListView.prototype.expandDL =
function(params) {

	if (!this._dataAPI.expandDL) {
		return;
	}

	var mlv = this._memberListView;
	if (mlv && mlv.getVisible() && params.textId && this._curExpanded == params.textId) {
		// User has clicked "Collapse" link
		mlv.show(false);
		this._curExpanded = null;
		this._setExpandText(params.textId, false);
	} else {
		// User has clicked "Expand" link
		if (mlv && mlv.getVisible()) {
			// expanding a DL while another one is showing
			this._setExpandText(this._curExpanded, false);
			mlv.show(false);
		}
		var contactsApp = appCtxt.getApp(ZmApp.CONTACTS);
		var contact = contactsApp.getContactByEmail(params.email);
		if (!contact) {
			contact = new ZmContact(null);
			contact.initFromEmail(params.email);	// don't cache, since it's not a real contact (no ID)
		}
		contact.isDL = true;
		if (params.textId && params.rowId) {
			this._curExpanded = params.textId;
			this._setExpandText(params.textId, true);
		}
		this._dataAPI.expandDL(contact, 0, this._handleResponseExpandDL.bind(this, contact, params));
	}

};

ZmAutocompleteListView.prototype._handleResponseExpandDL =
function(contact, params, matches) {

	var mlv = this._memberListView;
	if (!mlv) {
		mlv = this._memberListView = new ZmDLAutocompleteListView({parent:appCtxt.getShell(), parentAclv:this,
                                                                   selectionCallback: this._selectionCallback,
                                                                   expandTextId: params.textId});
	}
	mlv._dlContact = contact;
	mlv._dlBubbleId = params.textId;
	mlv._set(matches, contact);

	// default position is just to right of parent ac list
	var loc = params.loc;
	if (this.getVisible()) {
		loc = this.getLocation();
		loc.x += this.getSize().x;
	}

	mlv.show(true, loc);
	if (!mlv._rowHeight) {
		var table = document.getElementById(mlv._tableId);
		if (table) {
			mlv._rowHeight = Dwt.getSize(table.rows[0]).y;
		}
	}
};

ZmAutocompleteListView.prototype._setExpandText =
function(textId, expanded) {
	var textCtrl = DwtControl.fromElementId(textId);
	if (textCtrl && textCtrl.setText) {
		textCtrl.setText(expanded ? ZmMsg.collapse : ZmMsg.expand);
	}
};

ZmAutocompleteListView.prototype._setCallbacks =
function(type, params) {

	var cbKey = type + "Callback";
	var list = this._callbacks[type] = [];
	if (params[cbKey]) {
		list.push({callback:params[cbKey]});
	}
};

/**
 * Adds a callback of the given type. In an input ID is provided, then the callback
 * will only be run if the event happened in that input.
 *
 * @param {constant}				type		autocomplete callback type (ZmAutocompleteListView.CB_*)
 * @param {AjxCallback|function}	callback	callback to add
 * @param {string}					inputId		DOM ID of an input element (optional)
 */
ZmAutocompleteListView.prototype.addCallback =
function(type, callback, inputId) {
	this._callbacks[type].push({callback:callback, inputId:inputId});
};

ZmAutocompleteListView.prototype._runCallbacks =
function(type, inputId, args) {

	var result = null;
	var list = this._callbacks[type];
	if (list && list.length) {
		for (var i = 0; i < list.length; i++) {
			var cbObj = list[i];
			if (inputId && cbObj.inputId && (inputId != cbObj.inputId)) { continue; }
			var callback = cbObj.callback;
			var r;
			if (typeof(callback) == "function") {
				r = callback.apply(callback, args);
			}
			else if (callback && callback.isAjxCallback) {
				r = AjxCallback.prototype.run.apply(cbObj.callback, args);
			}
			if (r === true || r === false) {
				result = (result == null) ? r : result && r;
			}
		}
	}
	return result;
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmAddressInputField")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an address input field that shows addresses as bubbles.
 * @constructor
 * @class
 * This class creates and manages a control for entering email addresses and displaying
 * them in bubbles. An address's surrounding bubble can be used to remove it, or, if the
 * address is a distribution list, expand it. They can be dragged to other address fields,
 * or reordered within this one. They can be selected via a "rubber band" selection box.
 * The bubbles support a few shortcuts.
 *
 * It is not a DwtInputField. If you don't want bubbles, use that (or a native INPUT) instead.
 *
 * @author Conrad Damon
 *
 * @param {hash}					params						hash of params:
 * @param {ZmAutocompleteListView}	autocompleteListView		associated autocomplete control
 * @param {string}      			inputId						an explicit ID to use for the control's INPUT element
 * @param {string}					templateId					custom template to use
 * @param {string}					type						arbitrary type to uniquely identify this among others
 * @param {boolean}					strictMode					if true (default), bubbles must contain valid addresses
 * @param {AjxCallback|function}	bubbleAddedCallback			called when a bubble is added
 * @param {AjxCallback|function}	bubbleRemovedCallback		called when a bubble is removed
 * @param {AjxCallback|function}	bubbleMenuCreatedCallback	called when the action menu has been created
 * @param {AjxCallback|function}	bubbleMenuResetOperationsCallback	called when the action menu has reset its operations
 * @param {boolean}					noOutsideListening			don't worry about outside mouse clicks
 */
ZmAddressInputField = function(params) {

	params.parent = params.parent || appCtxt.getShell();
	params.className = params.className || "addrBubbleContainer";
	DwtComposite.call(this, params);

	this._initialize(params);

	if (params.autocompleteListView) {
		this.setAutocompleteListView(params.autocompleteListView);
	}

	this.type = params.type;
	this._strictMode = (params.strictMode !== false);
	this._noOutsideListening = params.noOutsideListening;
	this._singleBubble = params.singleBubble;

    this._bubbleAddedCallback = params.bubbleAddedCallback;
    this._bubbleRemovedCallback = params.bubbleRemovedCallback;
    this._bubbleMenuCreatedCallback = params.bubbleMenuCreatedCallback;
    this._bubbleResetOperationsCallback = params.bubbleMenuResetOperationsCallback;

	this._bubbleClassName = "addrBubble";

	this._bubbleList = new ZmAddressBubbleList({parent:this, separator:this._separator});
	this._bubbleList.addSelectionListener(this._selectionListener.bind(this));
	this._bubbleList.addActionListener(this._actionListener.bind(this));

	this._listeners = {};
	this._listeners[ZmOperation.DELETE]		= this._deleteListener.bind(this);
	this._listeners[ZmOperation.EDIT]		= this._editListener.bind(this);
	this._listeners[ZmOperation.EXPAND]		= this._expandListener.bind(this);
	this._listeners[ZmOperation.CONTACT]	= this._contactListener.bind(this);

	// drag-and-drop of bubbles
	var dropTgt = new DwtDropTarget("ZmAddressBubble");
	dropTgt.markAsMultiple();
	dropTgt.addDropListener(this._dropListener.bind(this));
	this.setDropTarget(dropTgt);

	// rubber-band selection of bubbles
	this._setEventHdlrs([DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEMOVE, DwtEvent.ONMOUSEUP]);
	var dragBox = new DwtDragBox();
	dragBox.addDragListener(this._dragBoxListener.bind(this));
	this.setDragBox(dragBox);

    // Let this be a single tab stop, then manage focus among bubbles (if any) and the input using arrow keys
    this.tabGroupMember = this;

    this.addListener(DwtEvent.ONMOUSEDOWN, this._mouseDownListener);
	this._reset();
};

ZmAddressInputField.prototype = new DwtComposite;
ZmAddressInputField.prototype.constructor = ZmAddressInputField;

ZmAddressInputField.prototype.isZmAddressInputField = true;
ZmAddressInputField.prototype.isInputControl = true;
//ZmAddressInputField.prototype.role = 'combobox';
ZmAddressInputField.prototype.toString = function() { return "ZmAddressInputField"; };

ZmAddressInputField.prototype.TEMPLATE = "share.Widgets#ZmAddressInputField";

ZmAddressInputField.INPUT_EXTRA = 30;		// extra width for the INPUT
ZmAddressInputField.INPUT_EXTRA_SMALL = 10;	// edit mode

// tie a bubble SPAN to a widget that can handle clicks
ZmAddressInputField.BUBBLE_OBJ_ID = {};

// several ZmAddressInputField's can share an action menu, so save context statically
ZmAddressInputField.menuContext = {};

ZmAddressInputField.prototype.setAutocompleteListView =
function(aclv) {
	this._aclv = aclv;
	this._separator = (aclv._separator) || AjxEmailAddress.SEPARATOR;
	aclv.addCallback(ZmAutocompleteListView.CB_KEYDOWN, this._keyDownCallback.bind(this), this._inputId);
	aclv.addCallback(ZmAutocompleteListView.CB_KEYUP, this._keyUpCallback.bind(this), this._inputId);
};

// Override since we normally want to add bubble before the INPUT, and not at the end. If we're
// leaving edit mode, we want to put the bubble back where it was via the index.
ZmAddressInputField.prototype.addChild =
function(child, index) {

	DwtComposite.prototype.addChild.apply(this, arguments);

	var el = child.getHtmlElement();
	if (this._input.parentNode == this._holder) {
		var refElement;
		if (index != null) {
			var refBubble = this._getBubbleList().getBubble(index);
			refElement = refBubble && refBubble.getHtmlElement();
		}
		this._holder.insertBefore(el, refElement || this._input);
	} else {
		this._holder.appendChild(el);
	}
};

/**
 * Creates a bubble for the given address and adds it into the holding area. If the address
 * is a local group, it is expanded and the members are added individually.
 *
 * @param {hash}				params		hash of params:
 * @param {string}				address		address text to go in the bubble
 * @param {ZmAutocompleteMatch}	match		match object
 * @param {ZmAddressBubble}		bubble		bubble to clone
 * @param {int}					index		position (relative to bubbles, not elements) at which to add bubble
 * @param {boolean}				skipNotify	if true, don't call bubbleAddedCallback
 * @param {boolean}				noFocus		if true, don't focus input after bubble is added
 * @param {string}				addClass	additional class name for bubble
 * @param {boolean}				noParse		if true, do not parse content to see if it is an address
 */
ZmAddressInputField.prototype.addBubble =
function(params) {

	params = params || {};
	if (!params.address && !params.bubble) { return; }
	
	if (params.bubble) {
		params.address = params.bubble.address;
		params.match = params.bubble.match;
		params.canExpand = params.bubble.canExpand;
	}
	params.parent		= this;
	params.addrInput	= this;
	params.parentId		= this._htmlElId;
	params.className	= this._bubbleClassName ;
	params.canRemove	= true;
	params.separator	= this._separator;
	params.type			= this.type;
	
	if (params.index == null && this._editModeIndex != null) {
		params.index = this._getInsertionIndex(this._holder.childNodes[this._editModeIndex]);
	}
	
	var bubble, bubbleAdded = false;
	
	// if it's a local group, expand it and add each address separately
	var match = params.match;
	if (match && match.isGroup && match.type == ZmAutocomplete.AC_TYPE_CONTACT) {
		var addrs = AjxEmailAddress.split(params.address);
		for (var i = 0, len = addrs.length; i < len; i++) {
			params.id = params.addrObj = params.match = params.email = params.canExpand = null;
			params.address = addrs[i];
			params.index = (params.index != null) ? params.index + i : null;
			if (this._hasValidAddress(params)) {
				this._addBubble(new ZmAddressBubble(params), params.index);
				bubbleAdded = true;
			}
		}
	}
	else {
		if (this._hasValidAddress(params)) {
			bubble = new ZmAddressBubble(params);
			this._addBubble(bubble, params.index, params.noFocus);
			bubbleAdded = true;
		}
		else {
			// if handed a non-address while in strict mode, append it to the INPUT and bail
			var value = this._input.value;
			var sep = value ? this._separator : "";
			this._setInputValue([value, sep, params.address].join(""));
		}
	}

	if (bubbleAdded) {
		this._holder.className = "addrBubbleHolder";
		if (this._bubbleAddedCallback && !params.skipNotify) {
			this._bubbleAddedCallback.run(bubble, true);
		}
		this._leaveEditMode();
		return bubble;
	}
};

ZmAddressInputField.prototype._addBubble =
function(bubble, index, noFocus) {

	if (!bubble || (this._singleBubble && this._numBubbles > 0)) {
		return;
	}
	
	DBG.println("aif1", "ADD bubble: " + AjxStringUtil.htmlEncode(bubble.address));
	bubble.setDropTarget(this.getDropTarget());
	this._bubbleList.add(bubble, index);
	this._numBubbles++;

	var bubbleId = bubble._htmlElId;
	this._bubble[bubbleId] = bubble;
	this._addressHash[bubble.hashKey] = bubbleId;

	if (!noFocus) {
		this.focus();
	}

	if (this._singleBubble) {
		this._setInputEnabled(false);
	}
};

ZmAddressInputField.prototype.getAddressBubble =
function(email) {
    return this._addressHash[email];
};

ZmAddressInputField.prototype._hasValidAddress =
function(params) {
	if (!this._strictMode) {
		return true;
	}
	var addr = (params.addrObj && params.addrObj.getAddress()) || params.address || (params.match && params.match.email);
	return (Boolean(AjxEmailAddress.parse(addr)));
};

/**
 * Removes the bubble with the given ID from the holding area.
 *
 * @param {string}	bubbleId	ID of bubble to remove
 * @param {boolean}	skipNotify	if true, don't call bubbleRemovedCallback
 */
ZmAddressInputField.prototype.removeBubble =
function(bubbleId, skipNotify) {

	var bubble = DwtControl.fromElementId(bubbleId);
	if (!bubble) { return; }
	
	this._bubbleList.remove(bubble);

	bubble.dispose();

	this._bubble[bubbleId] = null;
	delete this._bubble[bubbleId];
	delete this._addressHash[bubble.hashKey];
	this._numBubbles--;

	if (this._numBubbles == 0) {
		this._holder.className = "addrBubbleHolder-empty";
	}

	this._resizeInput();

	if (this._bubbleRemovedCallback && !skipNotify) {
		this._bubbleRemovedCallback.run(bubble, false);
	}

	if (this._singleBubble && this._numBubbles === 0) {
		this._setInputEnabled(true);
	}
};

/**
 * Removes all bubbles from the holding area.
 */
ZmAddressInputField.prototype.clear =
function(skipNotify) {
	for (var id in this._bubble) {
		this.removeBubble(id, skipNotify);
	}
	this._reset();
};

/**
 * Returns a string of concatenated bubble addresses.
 */
ZmAddressInputField.prototype.getValue =
function() {
	var list = this.getAddresses();
	if (this._input.value) {
		list.push(this._input.value);
	}
	return list.join(this._separator);
};

/**
 * Parses the given text into email addresses, and adds a bubble for each one
 * that we don't already have. Since text is passed in, we don't recognize expandable DLs.
 * A bubble may be added for a string even if it doesn't parse as an email address.
 *
 * @param {string}	text				email addresses
 * @param {boolean}	add					if true, control is not cleared first
 * @param {boolean}	skipNotify			if true, don't call bubbleAddedCallback
 * @param {boolean}	invokeAutocomplete	if true, trigger autocomplete
 * 										(useful in paste event when keyup/down events don't take place
 */
ZmAddressInputField.prototype.setValue =
function(text, add, skipNotify, invokeAutocomplete) {

	if (!add) {
		this.clear();
	}
	if (!text) {
		return;
	}

	var index = null;
	if (this._editModeIndex != null) {
		index = this._getInsertionIndex(this._holder.childNodes[this._editModeIndex]);
	}

	var addrs = AjxEmailAddress.parseEmailString(text);
	var good, bad;
	if (this.type === ZmId.SEARCH) {
		// search field query isn't supposed to be validated for emails
		good = addrs.all.getArray();
		bad = [];
		// skip notify because we don't need to trigger search on text to bubble conversion
		skipNotify = true;
	}
	else {
		good = addrs.good.getArray();
		bad = addrs.bad.getArray();
	}

	for (var i = 0; i < good.length; i++) {
		var addr = good[i];
		if ((addr && !this._addressHash[addr.address])) {
			this.addBubble({
				address: addr.toString(),
				addrObj: addr,
				index: (index != null) ? index + i : null,
				skipNotify: skipNotify
			});
		}
	}

	this._setInputValue(bad.length ? bad.join(this._separator) : "");
	if (invokeAutocomplete && bad.length) {
		this._aclv.autocomplete(this.getInputElement());
	}
};

/**
 * Sets the value of the input without looking for email addresses. No bubbles will be added.
 * 
 * @param {string}	text		new input content
 */
ZmAddressInputField.prototype.setInputValue =
function(text) {
	this._input.value = text;
	this._resizeInput();
};

/**
 * Adds address(es) to the input.
 * 
 * @param {string}	text		email addresses
 * @param {boolean}	skipNotify	if true, don't call bubbleAddedCallback
 */
ZmAddressInputField.prototype.addValue =
function(text, skipNotify) {
	this.setValue(text, true, skipNotify);
};

/**
 * Removes the selected bubble. If none are selected, selects the last one.
 *
 * @param {boolean}		checkInput		if true, make sure INPUT is empty
 *
 * @return {boolean}	true if the delete selected or removed a bubble
 */
ZmAddressInputField.prototype.handleDelete =
function(checkInput) {

	if (checkInput && this._input.value.length > 0) {
		return false;
	}

	var sel = this.getSelection();
	if (sel.length) {
		for (var i = 0, len = sel.length; i < len; i++) {
			if (sel[i]) {
				this.removeBubble(sel[i].id);
			}
		}
		this.focus();
		return true;
	}
	else {
		return this._selectBubbleBeforeInput();
	}
};

// Selects the bubble to the left of the (empty) INPUT, if there is one.
ZmAddressInputField.prototype._selectBubbleBeforeInput =
function() {
	
	if (!this._input.value) {
		var index = this._getInputIndex();
		var span = (index > 0) && this._holder.childNodes[index - 1];
		var bubble = DwtControl.fromElement(span);
		if (bubble) {
			this.setSelected(bubble, true);
			this.blur();
			appCtxt.getKeyboardMgr().grabFocus(bubble);
			return true;
		}
	}
	return false;
};

/**
 * Sets selection of the given bubble.
 *
 * @param {Element}	bubble		bubble to select
 * @param {boolean} selected	if true, select the bubble, otherwise deselect it
 */
ZmAddressInputField.prototype.setSelected =
function(bubble, selected) {
	this._bubbleList.setSelected(bubble, selected);
};

/**
 * Returns a list of the currently selected bubbles. If a bubble has been selected via right-click,
 * but is not part of the current left-click selection, only it will be returned.
 *
 * @param {ZmAddressBubble}	bubble	reference bubble
 */
ZmAddressInputField.prototype.getSelection =
function(bubble) {
	return this._bubbleList.getSelection(bubble);
};

ZmAddressInputField.prototype.getSelectionCount =
function(bubble) {
	return this._bubbleList.getSelectionCount(bubble);
};

ZmAddressInputField.prototype.deselectAll =
function() {
	this._bubbleList.deselectAll();
};

ZmAddressInputField.prototype.preventSelection =
function(targetEl) {
	return !(this._bubble[targetEl.id] || this.__isInputEl(targetEl));
};

/**
 * Makes bubbles out of addresses in pasted text.
 *
 * @param ev
 */
ZmAddressInputField.onPaste =
function(ev) {
	var addrInput = ZmAddressInputField._getAddrInputFromEvent(ev);
	if (addrInput) {
		// trigger autocomplete after paste to accommodate  mouse click pastes
		var invokeAutocomplete = true;
		// give browser time to update input - easier than dealing with clipboard
		// will also resize the INPUT
		AjxTimedAction.scheduleAction(
			new AjxTimedAction(
				addrInput,
				addrInput._checkInput,
				[null, invokeAutocomplete]
			), 100
		);
	}
};

ZmAddressInputField.onCut =
function(ev) {
	var addrInput = ZmAddressInputField._getAddrInputFromEvent(ev);
	if (addrInput) {
		addrInput._resizeInput();
	}
};

/**
 * Handle arrow up, arrow down for bubble holder
 *
 * @param ev
 */
ZmAddressInputField.onHolderKeyClick =
function(ev) {
    ev = DwtUiEvent.getEvent(ev);
    var key = DwtKeyEvent.getCharCode(ev);
    if (key === DwtKeyEvent.KEY_ARROW_UP) {
        if (this.clientHeight >= this.scrollHeight) { return; }
	    this.scrollTop = Math.max(this.scrollTop - this.clientHeight, 0);
        DBG.println("aif", "this.scrollTop  = " + this.scrollTop);
    }
    else if (key === DwtKeyEvent.KEY_ARROW_DOWN) {
         if (this.clientHeight >= this.scrollHeight) { return; }
	     this.scrollTop = Math.min(this.scrollTop + this.clientHeight, this.scrollHeight - this.clientHeight);
         DBG.println("aif", "this.scrollTop  = " + this.scrollTop);
    }
};

// looks for valid addresses in the input, and converts them to bubbles
ZmAddressInputField.prototype._checkInput =
function(text, invokeAutocomplete) {
	text = text || this._input.value;
	DBG.println("aif", "CHECK input: " + AjxStringUtil.htmlEncode(text));
	if (text) {
		this.setValue(text, true, false, invokeAutocomplete);
	}
};

// focus input when holder div is clicked
ZmAddressInputField.onHolderClick =
function(ev) {
	DBG.println("aif", "ZmAddressInputField.onHolderClick");
	var addrInput = ZmAddressInputField._getAddrInputFromEvent(ev);
	if (addrInput) {
		addrInput.focus();

		// bug 85036: ensure caret visibility on IE by resetting the selection
		var input = addrInput.getInputElement();
		Dwt.setSelectionRange(input, Dwt.getSelectionStart(input),
		                      Dwt.getSelectionEnd(input));
	}
};

/**
 * Removes the bubble with the given ID from the holding area.
 *
 * @param {string}	bubbleId	ID of bubble to remove
 * @param {boolean}	skipNotify	if true, don't call bubbleRemovedCallback
 *
 */
ZmAddressInputField.removeBubble =
function(bubbleId, skipNotify) {

	var bubble = document.getElementById(bubbleId);
	DBG.println("aif", "REMOVE bubble: " + AjxStringUtil.htmlEncode(bubble.address));
	var parentId = bubble._aifId || ZmAddressInputField.BUBBLE_OBJ_ID[bubbleId];
	var addrInput = bubble && DwtControl.ALL_BY_ID[parentId];
	if (addrInput && addrInput.getEnabled()) {
		addrInput.removeBubble(bubbleId, skipNotify);
		addrInput.focus();
	}
};

ZmAddressInputField.prototype.getInputElement =
function() {
	return this._input;
};

ZmAddressInputField.prototype._focus = function() {
    this.setDisplayState(DwtControl.FOCUSED);
};

ZmAddressInputField.prototype._blur = function() {
    this.setDisplayState(DwtControl.NORMAL);
};

ZmAddressInputField.prototype.setEnabled =
function(enabled) {
	DwtControl.prototype.setEnabled.call(this, enabled);
	this._input.disabled = !enabled;
};

/**
 * Enables or disables the input without affecting the bubbles.
 *
 * @param {boolean} enabled		enable input if true, disable if false
 */
ZmAddressInputField.prototype._setInputEnabled =
function(enabled) {
	this._input.disabled = !enabled;
};

ZmAddressInputField.prototype._initialize =
function(params) {

	this._holderId = Dwt.getNextId();
	this._inputId = params.inputId || Dwt.getNextId();
	this._label = params.label;
	this._dragInsertionBarId = Dwt.getNextId();
	var data = {
		inputTagName:		AjxEnv.isIE || AjxEnv.isModernIE ? 'textarea' : 'input type="text" ',
		holderId:			this._holderId,
		inputId:			this._inputId,
		label:				this._label,
		dragInsertionBarId:	this._dragInsertionBarId
	};
	this._createHtmlFromTemplate(params.templateId || this.TEMPLATE, data);

	this._holder = document.getElementById(this._holderId);
	this._holder._aifId = this._htmlElId;
	this._input = document.getElementById(this._inputId);
	this._input.supportsAutoComplete = true;
	this._dragInsertionBar = document.getElementById(this._dragInsertionBarId);

	Dwt.setHandler(this._holder, DwtEvent.ONCLICK, ZmAddressInputField.onHolderClick);
	Dwt.setHandler(this._input, DwtEvent.ONCUT, ZmAddressInputField.onCut);
	Dwt.setHandler(this._input, DwtEvent.ONPASTE, ZmAddressInputField.onPaste);
    Dwt.setHandler(this._holder, DwtEvent.ONKEYDOWN, ZmAddressInputField.onHolderKeyClick);

    this.setFocusElement(); // now that INPUT has been created

    var args = {container:this._holder, threshold:10, amount:15, interval:5, id:this._holderId};
    this._dndScrollCallback = DwtControl._dndScrollCallback.bind(null, [args]);
    this._dndScrollId = this._holderId;
};

ZmAddressInputField.prototype._reset =
function() {

	this._bubble		= {};	// bubbles by bubble ID
	this._addressHash	= {};	// used addresses, so we can check for dupes

	this._numBubbles	= 0;

	this._bubbleList.reset();

	this._editMode = false;
	this._editModeIndex = this._editModeBubble = null;

	this._dragInsertionBarIndex = null;	// node index vertical bar indicating insertion point

	this._holder.className = "addrBubbleHolder-empty";
	this._setInputValue("");
};

ZmAddressInputField.prototype.moveCursorToEnd =
function() {
	Dwt.moveCursorToEnd(this._input);
};

ZmAddressInputField.prototype._setInputValue =
function(value) {
	DBG.println("aif", "SET input value to: " + AjxStringUtil.htmlEncode(value));
	this._input.value = value && value.replace(/\s+/g, ' ');
	this._resizeInput();
};

// Handles key events that occur in the INPUT.
ZmAddressInputField.prototype._keyDownCallback =
function(ev, aclv) {
	ev = DwtUiEvent.getEvent(ev);
	var key = DwtKeyEvent.getCharCode(ev);
	var propagate;
	var clearInput = false;
	
	if (DwtKeyMapMgr.hasModifier(ev) || ev.shiftKey) {
		return propagate;
	}

	// Esc in edit mode restores the original address to the bubble
	if (key === DwtKeyEvent.KEY_ESCAPE && this._editMode) {
		DBG.println("aif", "_keyDownCallback found ESC key in edit mode");
		this._leaveEditMode(true);
		propagate = false;	// eat the event - eg don't let compose view catch Esc and pop the view
		clearInput = true;
	}
	// Del removes selected bubbles, or selects last bubble if there is no input
	else if (key === DwtKeyEvent.KEY_BACKSPACE) {
		DBG.println("aif", "_keyDownCallback found DEL key");
		if (this.handleDelete(true)) {
			propagate = false;
		}
	}
	// Left arrow selects last bubble if there is no input
	else if (key === DwtKeyEvent.KEY_ARROW_LEFT) {
		DBG.println("aif", "_keyDownCallback found left arrow");
		if (this._selectBubbleBeforeInput()) {
			propagate = false;
		}
	}
	// Handle case where user is leaving edit while we're not in strict mode
	// (in strict mode, aclv will call addrFoundCallback if it gets a Return)
	else if (!this._strictMode && DwtKeyEvent.IS_RETURN[key]) {
		DBG.println("aif", "_keyDownCallback found RETURN");
		var bubble = this._editMode && this._editModeBubble;
		if (bubble && !bubble.addrObj) {
			this._leaveEditMode();
			propagate = false;
			clearInput = true;
		}
	}

	if (clearInput && AjxEnv.isGeckoBased) {
		AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._setInputValue, [""]), 20);
	}
	
	return propagate;
};

// need to do this on keyup, after character has appeared in the INPUT
ZmAddressInputField.prototype._keyUpCallback =
function(ev, aclv) {
	if (!this._input.value && this._editMode) {
		if (this._bubbleRemovedCallback) {
			this._bubbleRemovedCallback.run(this._editModeBubble, false);
		}
		this._leaveEditMode();
	}
	this._resizeInput();
};

ZmAddressInputField.prototype._selectionListener =
function(ev) {

	var bubble = ev.item;
	if (ev.detail == DwtEvent.ONDBLCLICK) {
		// Double-clicking a bubble moves it into edit mode. It is replaced by the
		// INPUT, which is moved to the bubble's position. The bubble's address fills
		// the input and is selected.
		this.setSelected(bubble, false);
		this._checkInput();
		this._enterEditMode(bubble);
	}
	else {
		this._resetOperations();
	}
};

ZmAddressInputField.prototype._actionListener =
function(ev) {

	var bubble = ev.item;
	var menu = this.getActionMenu();
	ZmAddressInputField.menuContext.addrInput = this;
	ZmAddressInputField.menuContext.event = ev;
	ZmAddressInputField.menuContext.bubble = bubble;

	DBG.println("aif", "right sel bubble: " + bubble.id);
	this._resetOperations();

	var email = bubble.email;
	var contactsApp = appCtxt.getApp(ZmApp.CONTACTS);
	if (email && contactsApp) {
		// first check if contact is cached, and no server call is needed
		var contact = contactsApp.getContactByEmail(email);
		if (contact) {
			this._handleResponseGetContact(ev, contact);
		} else {
			menu.getOp(ZmOperation.CONTACT).setText(ZmMsg.loading);
			var respCallback = this._handleResponseGetContact.bind(this, ev);
			contactsApp.getContactByEmail(email, respCallback);
		}
	}
	else {
		var actionMenu = this.getActionMenu();
		actionMenu.getOp(ZmOperation.CONTACT).setVisible(false);
		actionMenu.getOp(ZmOperation.EXPAND).setVisible(false);

		this._setContactText(null);
		menu.popup(0, ev.docX || bubble.getXW(), ev.docY || bubble.getYH());
	}

	// if we are listening for outside mouse clicks, add the action menu to the elements
	// defined as "inside" so that clicking a menu item doesn't call our outside listener
	// and deselectAll before the menu listener does its thing
	if (!this._noOutsideListening && (this.getSelectionCount() > 0)) {
		var omem = appCtxt.getOutsideMouseEventMgr();
		var omemParams = {
			id:					"ZmAddressBubbleList",
			obj:				menu,
			outsideListener:	this.getOutsideListener()
		}
		DBG.println("aif", "ADD menu to outside listening " + this._input.id);
		omem.startListening(omemParams);
	}
};

ZmAddressInputField.prototype.getOutsideListener =
function() {
	return this._bubbleList ? this._bubbleList._outsideMouseListener.bind(this._bubbleList) : null;
};

ZmAddressInputField.prototype.getActionMenu =
function() {
	var menu = this._actionMenu || this.parent._bubbleActionMenu;
	if (!menu) {
		menu = this._actionMenu = this.parent._bubbleActionMenu = this._createActionMenu();
	}
	return menu;
};

ZmAddressInputField.prototype._createActionMenu =
function() {

	DBG.println("aif", "create action menu for " + this._input.id);
	var menuItems = this._getActionMenuOps();
	var menu = new ZmActionMenu({parent:this.shell, menuItems:menuItems});
	for (var i = 0; i < menuItems.length; i++) {
		var menuItem = menuItems[i];
		if (this._listeners[menuItem]) {
			menu.addSelectionListener(menuItem, this._listeners[menuItem]);
		}
	}

	var copyMenuItem = menu.getOp(ZmOperation.COPY);
	if (copyMenuItem) {
		appCtxt.getClipboard().init(copyMenuItem, {
			onMouseDown:    this._clipCopy.bind(this),
			onComplete:     this._clipCopyComplete.bind(this)
		});
	}

	menu.addPopdownListener(this._menuPopdownListener.bind(this));

	if (this._bubbleMenuCreatedCallback) {
		this._bubbleMenuCreatedCallback.run(this, menu);
	}

	return menu;
};

ZmAddressInputField.prototype._resetOperations =
function() {

	var menu = this.getActionMenu();
	if (menu) {
		var sel = this.getSelection();
		var bubble = (sel.length == 1) ? sel[0] : null;
		menu.enable(ZmOperation.DELETE, sel.length > 0);
		menu.enable(ZmOperation.COPY, sel.length > 0);
		menu.enable(ZmOperation.EDIT, Boolean(bubble));
		var email = bubble && bubble.email;
		var ac = window.parentAppCtxt || window.appCtxt;
		var isExpandableDl = ac.isExpandableDL(email);
		menu.enable(ZmOperation.EXPAND, isExpandableDl);
		//not sure this is %100 good, since isExpandableDL returns false also if EXPAND_DL_ENABLED setting is false.
		//but I tried to do this in _setContactText by passing in the contact we get (using getContactByEmail) - but that contact somehow doesn't
		//have isGal set or type "group" (the type is "contact"), thus isDistributionList returns null. Not sure what this inconsistency comes from.

		//so this is messy and I just try to do the best with information - see the comment above - so I use isExpandableDl as indication of DL (sometimes it's false despite it being an expandable DL)
		//and I also use isDL as another way to try to know if it's a DL (by trying to find the contact from the contactsApp cache - sometimes it's there, sometimes not (it's there
		//after you go to the DL folder).
		var contactsApp = appCtxt.getApp(ZmApp.CONTACTS);
		var contact = contactsApp && contactsApp.getContactByEmail(email);
		var isDL = contact && contact.isDistributionList();
		var canEdit = !(isDL || isExpandableDl) || (contact && contact.dlInfo && contact.dlInfo.isOwner);
		menu.enable(ZmOperation.CONTACT, canEdit);

	}

	if (this._bubbleResetOperationsCallback) {
		this._bubbleResetOperationsCallback.run(this, menu);
	}
};

ZmAddressInputField.prototype._getActionMenuOps =
function() {

	var ops = [ZmOperation.DELETE];
	if (AjxClipboard.isSupported()) {
		ops.push(ZmOperation.COPY);
	};
	ops.push(ZmOperation.EDIT);
	ops.push(ZmOperation.EXPAND);
	ops.push(ZmOperation.CONTACT);
	
	return ops;
};

ZmAddressInputField.prototype._handleResponseGetContact = function(ev, contact) {

	ZmAddressInputField.menuContext.contact = contact;
	this._setContactText(contact);
    var x = ev.docX > 0 ? ev.docX : ev.item.getXW(),
        y = ev.docY > 0 ? ev.docY : ev.item.getYH();

	this.getActionMenu().popup(0, x, y);
};

ZmAddressInputField.prototype._setContactText =
function(contact) {
	ZmBaseController.setContactTextOnMenu(contact, this.getActionMenu());
};

ZmAddressInputField.prototype._deleteListener =
function() {
	var addrInput = ZmAddressInputField.menuContext.addrInput;
	var sel = addrInput && addrInput.getSelection();
	if (sel && sel.length) {
		for (var i = 0; i < sel.length; i++) {
			addrInput.removeBubble(sel[i].id);
		}
	}
};

ZmAddressInputField.prototype._editListener =
function() {
	var addrInput = ZmAddressInputField.menuContext.addrInput;
	var bubble = ZmAddressInputField.menuContext.bubble;
	if (addrInput && bubble) {
		addrInput._enterEditMode(bubble);
	}
};

ZmAddressInputField.prototype._expandListener =
function() {
	var addrInput = ZmAddressInputField.menuContext.addrInput;
	var bubble = ZmAddressInputField.menuContext.bubble;
	if (addrInput && bubble) {
		ZmAddressBubble.expandBubble(bubble.id, bubble.email);
	}
};

/**
 * If there's a contact for the participant, edit it, otherwise add it.
 *
 * @private
 */
ZmAddressInputField.prototype._contactListener =
function(ev) {
	var addrInput = ZmAddressInputField.menuContext.addrInput;
	if (addrInput) {
		var loadCallback = addrInput._handleLoadContactListener.bind(addrInput);
		AjxDispatcher.require(["ContactsCore", "Contacts"], false, loadCallback, null, true);
	}
};

/**
 * @private
 */
ZmAddressInputField.prototype._handleLoadContactListener =
function() {

	var ctlr = window.parentAppCtxt ? window.parentAppCtxt.getApp(ZmApp.CONTACTS).getContactController() :
									  AjxDispatcher.run("GetContactController");
	var contact = ZmAddressInputField.menuContext.contact;
	if (contact) {
		if (contact.isLoaded) {
			ctlr.show(contact);
		} else {
			var callback = this._loadContactCallback.bind(this);
			contact.load(callback);
		}
	} else {
		var contact = new ZmContact(null);
		var bubble = ZmAddressInputField.menuContext.bubble;
		var email = bubble && bubble.email;
		if (email) {
			contact.initFromEmail(email);
			ctlr.show(contact, true);
		}
	}
};

ZmAddressInputField.prototype._loadContactCallback =
function(resp, contact) {
	var ctlr = window.parentAppCtxt ? window.parentAppCtxt.getApp(ZmApp.CONTACTS).getContactController() :
									  AjxDispatcher.run("GetContactController");
	ctlr.show(contact);
};

// Copies address text from the active bubble to the clipboard.
ZmAddressInputField.prototype._clipCopy =
function(clip) {
	clip.setText(ZmAddressInputField.menuContext.bubble.address + this._separator);
};

ZmAddressInputField.prototype._clipCopyComplete =
function(clip) {
	this._actionMenu.popdown();
};

ZmAddressInputField.prototype._menuPopdownListener =
function() {

	var bubble = ZmAddressInputField.menuContext.bubble;
	if (bubble) {
		bubble.setClassName(this._bubbleClassName);
	}

	if (!this._noOutsideListening && (this.getSelectionCount() > 0)) {
		DBG.println("aif", "REMOVE menu from outside listening " + this._input.id);
		var omem = appCtxt.getOutsideMouseEventMgr();
		omem.stopListening({id:"ZmAddressInputField", obj:this.getActionMenu()});
	}

	// use a timer since popdown happens before listeners are called; alternatively, we could put the
	// code below at the end of every menu action listener
	AjxTimedAction.scheduleAction(new AjxTimedAction(this,
		function() {
			DBG.println("aif", "_menuPopdownListener");
			ZmAddressInputField.menuContext = {};
			this._bubbleList.clearRightSelection();
		}), 10);
};

ZmAddressInputField.prototype._enterEditMode =
function(bubble) {

	DBG.println("aif", "ENTER edit mode");
	if (this._editMode) {
		// user double-clicked a bubble while another bubble was being edited
		this._leaveEditMode();
	}

	this._editMode = true;
	this._editModeIndex = this._getBubbleIndex(bubble);
	DBG.println("aif", "MOVE input");
	this._holder.insertBefore(this._input, bubble.getHtmlElement());
	this.removeBubble(bubble.id, true);

	this._editModeBubble = bubble;
	this._setInputValue(bubble.address);

	// Chrome triggers BLUR after DBLCLICK, so use a timer to make sure select works
	AjxTimedAction.scheduleAction(new AjxTimedAction(this,
		function() {
			this.focus();
			this._input.select();
		}), 20);

	if (this._singleBubble) {
		this._setInputEnabled(true);
	}
};

ZmAddressInputField.prototype._leaveEditMode =
function(restore) {

	DBG.println("aif", "LEAVE edit mode");
	if (!this._editMode) {
		return;
	}

	if (this._holder.lastChild != this._input) {
		this._holder.appendChild(this._input);
	}
	var bubble = restore && this._editModeBubble;
	this._checkInput(bubble && bubble.address);
	this.focus();

	this._editMode = false;
	this._editModeIndex = this._editModeBubble = null;
	DBG.println("aif", "input value: " + AjxStringUtil.htmlEncode(this._input.value));
};

// size the input to a bit more than its current content
ZmAddressInputField.prototype._resizeInput =
function() {
	var val = AjxStringUtil.htmlEncode(this._input.value);
	var paddings = Dwt.getMargins(this._holder);
	var margins = Dwt.getMargins(this._input);
	var maxWidth = Dwt.getSize(this._holder).x - (this._input.offsetLeft + ((AjxEnv.isTrident) ? (margins.left + paddings.left) : 0) + paddings.right + margins.right + 1);
	maxWidth = Math.max(maxWidth, 3); //don't get too small - minimum 3 - if it gets negative, the cursor would not show up before starting to type (bug 84924)

	var inputWidth = "100%";
	if (this._input.supportsAutoComplete) {
		var inputFontSize = DwtCssStyle.getProperty(this._input, "font-size");
		var strW = AjxStringUtil.getWidth(val, false, inputFontSize);
		if (AjxEnv.isWindows && (AjxEnv.isFirefox || AjxEnv.isSafari || AjxEnv.isChrome) ){
			// FF/Win: fudge factor since string is longer in INPUT than when measured in SPAN
			strW = strW * 1.2;
		}
		var pad = this._editMode ? ZmAddressInputField.INPUT_EXTRA_SMALL : ZmAddressInputField.INPUT_EXTRA;
		inputWidth = Math.min(strW + pad, maxWidth);
		if (this._editMode) {
			inputWidth = Math.max(inputWidth, ZmAddressInputField.INPUT_EXTRA);
		}
	}
	Dwt.setSize(this._input, inputWidth, Dwt.DEFAULT);
};

ZmAddressInputField.prototype.hasFocus =
function(ev) {
	return true;
};

ZmAddressInputField.prototype.getKeyMapName =
function() {
	return ZmKeyMap.MAP_ADDRESS;
};

// invoked when at least one bubble is selected
ZmAddressInputField.prototype.handleKeyAction =
function(actionCode, ev) {

	var selCount = this.getSelectionCount();
	if (!selCount || this._editMode) {
        // it might be nicer to allow arrowing out of the field (eg right arrow when at end of input) to move to
        // another bubble or toolbar control, but getting the cursor position is not reliable
        ev.forcePropagate = true;
		return true;
	}
	DBG.println("aif", "handle shortcut: " + actionCode);
	
	switch (actionCode) {

		case DwtKeyMap.DELETE:
			this.handleDelete();
			break;

		case DwtKeyMap.SELECT_NEXT:
			if (selCount == 1) {
				this._selectAdjacentBubble(true);
			}
			break;

		case DwtKeyMap.SELECT_PREV:
			if (selCount == 1) {
				this._selectAdjacentBubble(false);
			}
			break;

		default:
			return false;
	}

	return true;
};

// Returns an ordered list of bubbles
ZmAddressInputField.prototype._getBubbleList =
function() {

	var list = [];
	var children = this._holder.childNodes;
	for (var i = 0; i < children.length; i++) {
		var id = children[i].id;
		if (id && this._bubble[id]) {
			var bubble = DwtControl.fromElementId(id);
			if (bubble) {
				list.push(bubble);
			}
		}
	}
	
	this._bubbleList.set(list);
	return this._bubbleList;
};

ZmAddressInputField.prototype.getBubbleCount =
function() {
	return this._getBubbleList().getArray().length;
};

// returns the index of the given bubble among all the holder's elements (not just bubbles)
ZmAddressInputField.prototype._getBubbleIndex =
function(bubble) {
	return AjxUtil.indexOf(this._holder.childNodes, bubble.getHtmlElement());
};

// returns the index of the INPUT among all the holder's elements
ZmAddressInputField.prototype._getInputIndex =
function() {
	return AjxUtil.indexOf(this._holder.childNodes, this._input);
};

/**
 * Selects the next or previous bubble relative to the selected one.
 *
 * @param {boolean}			next		if true, select next bubble; otherwise select previous bubble
 */
ZmAddressInputField.prototype._selectAdjacentBubble =
function(next) {

	var sel = this.getSelection();
	var bubble = sel && sel.length && sel[0];
	if (!bubble) { return; }

	var index = this._getBubbleIndex(bubble);
	index = next ? index + 1 : index - 1;
	var children = this._holder.childNodes;
	var el = (index >= 0 && index < children.length) && children[index];
	if (el == this._dragInsertionBar) {
		index = next ? index + 1 : index - 1;
		el = (index >= 0 && index < children.length) && children[index];
	}
	if (el) {
		if (el == this._input) {
			this.setSelected(bubble, false);
			this.focus();
		}
		else {
			var newBubble = DwtControl.fromElement(el);
			if (newBubble) {
				this.setSelected(bubble, false);
				this.setSelected(newBubble, true);
			}
		}
	}
};

/**
 * Returns an ordered list of bubble addresses.
 *
 * @param {boolean}	asObjects	if true, return list of AjxEmailAddress
 */
ZmAddressInputField.prototype.getAddresses =
function(asObjects) {

	var addrs = [];
	var bubbles = this._getBubbleList().getArray();
	var ac = window.parentAppCtxt || window.appCtxt;
	for (var i = 0; i < bubbles.length; i++) {
		var bubble = bubbles[i];
		var addr = bubble.address;
		if (asObjects) {
			var addrObj = AjxEmailAddress.parse(addr) || new AjxEmailAddress("", null, addr);
			if (ac.isExpandableDL(bubble.email) || (bubble.match && bubble.match.isDL)) {
				addrObj.isGroup = true;
				addrObj.canExpand = true;
			}
			addrs.push(addrObj);
		}
		else {
			addrs.push(addr);
		}
	}
	return addrs;
};

ZmAddressInputField._getAddrInputFromEvent =
function(ev) {
	var target = DwtUiEvent.getTarget(ev);
	return target && DwtControl.ALL_BY_ID[target._aifId];
};

/**
 * Since both the input and each of its bubbles has a drop listener, the target object may be
 * either of those object types. Dropping is okay if we're over a different type of input, or if
 * we're reordering bubbles within the same input.
 */
ZmAddressInputField.prototype._dropListener =
function(dragEv) {

	var sel = dragEv.srcData && dragEv.srcData.selection;
	if (!(sel && sel.length)) { return; }

	if (dragEv.action == DwtDropEvent.DRAG_ENTER) {
		DBG.println("aif", "DRAG_ENTER");
		var targetObj = dragEv.uiEvent.dwtObj;
		var targetInput = targetObj.isAddressBubble ? targetObj.addrInput : targetObj;
		var dragBubble = sel[0];
		if (dragBubble.type != this.type) {
			dragEv.doIt = true;
		}
		else if (targetInput._numBubbles <= 1) {
			dragEv.doIt = false;
		}
		if (dragEv.doIt && targetInput._numBubbles >= 1) {
			var idx = targetInput._getIndexFromEvent(dragEv.uiEvent);
			var bubbleIdx = targetInput._getBubbleIndex(dragBubble);
			DBG.println("aif", "idx: " + idx + ", bubbleIdx: " + bubbleIdx);
			if ((dragBubble.type == this.type) && (idx == bubbleIdx || idx == bubbleIdx + 1)) {
				dragEv.doIt = false;
			}
			else {
				this._setInsertionBar(idx);
			}
		}
		if (!dragEv.doIt) {
			this._setInsertionBar(null);
		}
	}
	else if (dragEv.action == DwtDropEvent.DRAG_LEAVE) {
		DBG.println("aif", "DRAG_LEAVE");
		this._setInsertionBar(null);
	}
	else if (dragEv.action == DwtDropEvent.DRAG_DROP) {
		DBG.println("aif", "DRAG_DROP");
		var sourceInput = dragEv.srcData.addrInput;
		var index = this._getInsertionIndex(this._dragInsertionBar);
		for (var i = 0; i < sel.length; i++) {
			var bubble = sel[i];
			var id = bubble.id;
			this.addBubble({bubble:bubble, index:index + i});
			sourceInput.removeBubble(id);
		}
		this._setInsertionBar(null);
	}
};

ZmAddressInputField.prototype._dragBoxListener =
function(ev) {
    // Check if user is using scroll bar rather than trying to drag.
    if (ev && ev.srcControl && this._holder) {
        var scrollWidth = this._holder.scrollWidth;  //returns width w/out scrollbar
        var scrollPos = scrollWidth + Dwt.getLocation(this._holder).x;
        var dBox = ev.srcControl.getDragBox();
        if (dBox) {
            DBG.println("aif", "DRAG_BOX x =" + dBox.getStartX() + " scrollWidth = " + scrollWidth);
            if (dBox.getStartX() > scrollPos) {
                DBG.println("aif", "DRAG_BOX x =" + dBox.getStartX() + " scrollPos = " + scrollPos);
                return false;
            }
        }
    }

	if (ev.action == DwtDragEvent.DRAG_INIT) {
		// okay to draw drag box if we have at least one bubble, and user isn't clicking in
		// the non-empty INPUT (might be trying to select text)
		return (this._numBubbles > 0 && (ev.target != this._input || this._input.value == ""));
	}
	else if (ev.action == DwtDragEvent.DRAG_START) {
		DBG.println("aif", "ZmAddressInputField DRAG_START");
		this.deselectAll();
		this.blur();
	}
	else if (ev.action == DwtDragEvent.DRAG_MOVE) {
//		DBG.println("aif", "ZmAddressInputField DRAG_MOVE");
		var box = this._dragSelectionBox;
		for (var id in this._bubble) {
			var bubble = this._bubble[id];
			var span = bubble.getHtmlElement();
			var sel = Dwt.doOverlap(box, span);
			if (sel != this._bubbleList.isSelected(bubble)) {
				this.setSelected(bubble, sel);
				appCtxt.getKeyboardMgr().grabFocus(bubble);
			}
		}
	}
	else if (ev.action == DwtDragEvent.DRAG_END) {
		DBG.println("aif", "ZmAddressInputField DRAG_END");
		this._bubbleList._checkSelection();
		if (AjxEnv.isWindows && (this.getSelectionCount() == 0)) {
			this.blur();
			this.focus();
		}
	}
};

ZmAddressInputField.prototype._mouseDownListener =
function(ev) {
    // reset mouse event to propagate event to browser (allows focus on input when clicking on holder click)
    ev._stopPropagation = false;
    ev._returnValue = true;
};

// Returns insertion index (among all elements) based on event coordinates
ZmAddressInputField.prototype._getIndexFromEvent =
function(ev) {

	var bubble, w, bx, idx;
	var bubble = (ev.dwtObj && ev.dwtObj.isAddressBubble) ? ev.dwtObj : null;
	if (bubble) {
		w = bubble.getSize().x;
		bx = ev.docX - bubble.getLocation().x;
		idx = this._getBubbleIndex(bubble);	// TODO: cache?
		return (bx > (w / 2)) ? idx + 1 : idx;
	}
	else {
		idx = 0;
		var children = this._holder.childNodes;
		for (var i = 0; i < children.length; i++) {
			var id = children[i].id;
			bubble = id && this._bubble[id];
			if (bubble) {
				w = bubble.getSize().x;
				bx = ev.docX - bubble.getLocation().x;
				if (bx < (w / 2)) {
					return idx;
				}
				else {
					idx++;
				}
			}
			else if (i < (children.length - 1)) {
				idx++;
			}
		}
		return idx;
	}
};

ZmAddressInputField.prototype._setInsertionBar =
function(index) {

	if (index == this._dragInsertionBarIndex) { return; }

	var bar = this._dragInsertionBar;
	if (index != null) {
		bar.style.display = "inline";
		var refElement = this._holder.childNodes[index];
		if (refElement) {
			this._holder.insertBefore(bar, refElement);
			this._dragInsertionBarIndex = index;
		}
	}
	else {
		bar.style.display = "none";
		this._dragInsertionBarIndex = null;
	}
};

ZmAddressInputField.prototype._getInsertionIndex =
function(element) {

	var bubbleIndex = 0;
	var children = this._holder.childNodes;
	for (var i = 0; i < children.length; i++) {
		var el = children[i];
		if (el == element) {
			break;
		}
		else if (el && this._bubble[el.id]) {
			bubbleIndex++;
		}
	}
	return bubbleIndex;
};




/**
 * Creates a bubble that contains an email address.
 * @constructor
 * @class
 * This class represents an object that allows various operations to be performed on an
 * email address within a compose or display context.
 *
 * @param {hash}				params		the hash of parameters:
 * @param {ZmAddressInputField}	parent		parent control
 * @param {string}				id			element ID for the bubble
 * @param {string}				className	CSS class for the bubble
 * @param {string}				address		email address to display in the bubble
 * @param {AjxEmailAddress}		addrObj		email address (alternative form)
 * @param {boolean}				canRemove	if true, an x will be provided to remove the address bubble
 * @param {boolean}				canExpand	if true, a + will be provided to expand the DL address
 * @param {string}				separator	address separator
 *
 * @extends DwtControl
 */
ZmAddressBubble = function(params) {

	params = params || {};
	params.id = this.id = params.id || Dwt.getNextId();
	params.className = params.className || "addrBubble";
	if (params.addClass) {
		params.className = [params.className, params.addClass].join(" ");
	}
	DwtControl.call(this, params);

	this.type = params.type;
	this.isAddressBubble = true;

	var addrInput = this.addrInput = params.addrInput;
	var match = this.match = params.match;
	var addrContent = !params.noParse && (params.address || (match && match.email));
	var addrObj = this.addrObj = params.addrObj || (addrContent && AjxEmailAddress.parse(addrContent));
	this.address = params.address || (addrObj && addrObj.toString());
	this.email = params.email = params.email || (addrObj && addrObj.getAddress()) || "";
	// text search bubbles won't have anything in the "email" field so we need to use "address" for hash lookup
	this.hashKey = this.type === ZmId.SEARCH ? this.address : this.email;
	var ac = window.parentAppCtxt || window.appCtxt;
	this.canExpand = params.canExpand = params.canExpand || ac.isExpandableDL(this.email);
	
	this._createHtml(params);

	this._setEventHdlrs([DwtEvent.ONCLICK, DwtEvent.ONDBLCLICK,
						 DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT,
						 DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEMOVE, DwtEvent.ONMOUSEUP]);
	this.addListener(DwtEvent.ONCLICK, this._clickListener.bind(this));
	this.addListener(DwtEvent.ONDBLCLICK, this._dblClickListener.bind(this));
	this.addListener(DwtEvent.ONMOUSEUP, this._mouseUpListener.bind(this));

	if (addrInput) {
		var dragSrc = new DwtDragSource(Dwt.DND_DROP_MOVE);
		dragSrc.addDragListener(this._dragListener.bind(this));
		this.setDragSource(dragSrc);
	}

	this._evtMgr = new AjxEventMgr();
	this._selEv = new DwtSelectionEvent(true);
};

ZmAddressBubble.prototype = new DwtControl;
ZmAddressBubble.prototype.constructor = ZmAddressBubble;

ZmAddressBubble.prototype.isZmAddressBubble = true;
ZmAddressBubble.prototype.toString = function() { return "ZmAddressBubble"; };
ZmAddressBubble.prototype.isFocusable = true;

ZmAddressBubble.prototype._createElement =
function() {
	return document.createElement("SPAN");
};

ZmAddressBubble.prototype._createHtml =
function(params) {

	var el = this.getHtmlElement();
	el.innerHTML = ZmAddressBubble.getContent(params);
	if (params.parentId) {
		el._aifId = params.parentId;
	}
};

/**
 * Returns HTML for the content of a bubble.
 *
 * @param {hash}				params		the hash of parameters:
 * @param {ZmAddressInputField}	parent		parent control
 * @param {string}				id			element ID for the bubble
 * @param {string}				className	CSS class for the bubble
 * @param {string}				address		email address to display in the bubble
 * @param {AjxEmailAddress}		addrObj		email address (alternative form)
 * @param {boolean}				canRemove	if true, an x will be provided to remove the address bubble
 * @param {boolean}				canExpand	if true, a + will be provided to expand the DL address
 * @param {boolean}				noParse		if true, do not parse content to see if it is an address
 */
ZmAddressBubble.getContent =
function(params) {

	var id = params.id;
	var addrObj = params.addrObj || (!params.noParse && AjxEmailAddress.parse(params.address)) || params.address || ZmMsg.unknown;
	var fullAddress = AjxStringUtil.htmlEncode(addrObj ? addrObj.toString() : params.address);
	var text = AjxStringUtil.htmlEncode(addrObj ? addrObj.toString(appCtxt.get(ZmSetting.SHORT_ADDRESS)) : params.address);

	var expandLinkText = "", removeLinkText = "", addrStyle = "";
	var style = "cursor:pointer;position:absolute;top:2px;";

	if (params.canExpand) {
		var addr = params.email || params.address;
		var expandLinkId = id + "_expand";
		var expandLink = 'ZmAddressBubble.expandBubble("' + id + '","' + addr + '");';
		var expStyle = style + "left:2px;";
		var expandLinkText = AjxImg.getImageHtml("BubbleExpand", expStyle, "id='" + expandLinkId + "' onclick='" + expandLink + "'");
		addrStyle += "padding-left:12px;";
	}

	if (params.canRemove) {
		var removeLinkId = id + "_remove";
		var removeLink = 'ZmAddressInputField.removeBubble("' + id + '");';
		var removeStyle = style + "right:2px;";
		var removeLinkText = AjxImg.getImageHtml("BubbleDelete", removeStyle, "id='" + removeLinkId + "' onclick='" + removeLink + "'");
		addrStyle += "padding-right:12px;";
	}
	
	var html = [], idx = 0;
	var addrStyleText = (params.canExpand || params.canRemove) ? " style='" + addrStyle + "'" : "";
	html[idx++] = "<span" + addrStyleText + ">" + text + " </span>";
	var addrText = html.join("");

	return expandLinkText + addrText + removeLinkText;
};


/**
 * Gets the key map name.
 * 
 * @return	{string}	the key map name
 */
ZmAddressBubble.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_BUTTON;
};

/**
 * Handles a key action event.
 * 
 * @param	{constant}		actionCode		the action code (see {@link DwtKeyMap})
 * @param	{DwtEvent}		ev		the event
 * @return	{boolean}		<code>true</code> if the event is handled; <code>false</code> otherwise
 * @see		DwtKeyMap
 */
ZmAddressBubble.prototype.handleKeyAction = function(actionCode, ev) {

    if (!this.list || (this.addrInput && this.addrInput._editMode)) {
        return true;
    }

	switch (actionCode) {
		case DwtKeyMap.SELECT:
		case DwtKeyMap.SUBMENU:
			this.list._itemActioned(ev, this);
			break;
	}

	return true;
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmAddressBubble.prototype.addSelectionListener =
function(listener) {
	this._evtMgr.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmAddressBubble.prototype.removeSelectionListener =
function(listener) {
	this._evtMgr.removeListener(DwtEvent.SELECTION, listener);
};

ZmAddressBubble.prototype._clickListener =
function(ev) {
	if (this.list && this._dragging == DwtControl._NO_DRAG) {
		this.list._itemClicked(ev, this);
	}
	else if (this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
		DwtUiEvent.copy(this._selEv, ev);
		this._selEv.item = this;
		this._selEv.detail = DwtEvent.ONCLICK;
		this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
	}
};

ZmAddressBubble.prototype._dblClickListener =
function(ev) {
	if (!this.list) { return; }
	this.list._itemDoubleClicked(ev, this);
};

ZmAddressBubble.prototype._mouseUpListener =
function(ev) {
	if (!this.list) { return; }
	if (ev.button == DwtMouseEvent.RIGHT) {
		this.list._itemActioned(ev, this);
	}
};

ZmAddressBubble.prototype._getDragProxy =
function(dragOp) {

	var icon = document.createElement("div");
	icon.className = this._className;
	Dwt.setPosition(icon, Dwt.ABSOLUTE_STYLE);
	var count = this.addrInput.getSelectionCount(this);
	var content;
	if (count == 1) {
		var addrObj = AjxEmailAddress.parse(this.address) || this.address || ZmMsg.unknown;
		content = AjxStringUtil.htmlEncode(addrObj ? addrObj.toString(appCtxt.get(ZmSetting.SHORT_ADDRESS)) : this.address);
	}
	else {
		content = AjxMessageFormat.format(ZmMsg.numAddresses, count);
	}
	icon.innerHTML = content;
	this.shell.getHtmlElement().appendChild(icon);
	Dwt.setZIndex(icon, Dwt.Z_DND);
	return icon;
};

ZmAddressBubble.prototype._dragListener =
function(ev) {
	if (ev.action == DwtDragEvent.SET_DATA) {
		ev.srcData = {selection: this.addrInput.getSelection(this),
					  addrInput: this.addrInput};
	}
};

ZmAddressBubble.prototype._dragOver =
function(ev) {
	this.addrInput._dragOver(ev);
};

/**
 * Gets the tool tip content.
 * 
 * @param	{Object}	ev		the hover event
 * @return	{String}	the tool tip content
 */
ZmAddressBubble.prototype.getToolTipContent =
function(ev) {

	var ttParams = {address:this.addrObj, ev:ev};
	var ttCallback = new AjxCallback(this,
		function(callback) {
			appCtxt.getToolTipMgr().getToolTip(ZmToolTipMgr.PERSON, ttParams, callback);
		});
	return {callback:ttCallback};
};

// Bug 78359 - hack so that shortcuts work even though browser focus is on hidden textarea
ZmAddressBubble.prototype.hasFocus =
function() {
	return true;
};

/**
 * Expands the distribution list address of the bubble with the given ID.
 *
 * @param {string}	bubbleId	ID of bubble
 * @param {string}	email		address to expand
 */
ZmAddressBubble.expandBubble = function(bubbleId, email) {

	var bubble = document.getElementById(bubbleId);
	if (bubble) {
		var parentId = bubble._aifId || ZmAddressInputField.BUBBLE_OBJ_ID[bubbleId];
		var parent = bubble && DwtControl.ALL_BY_ID[parentId];
		if (parent && parent.getEnabled() && parent._aclv) {
			var bubbleObj = DwtControl.fromElementId(bubbleId);
			if (bubbleObj) {
				var loc = bubbleObj.getLocation();
				loc.y += bubbleObj.getSize().y + 2;
				parent._aclv.expandDL({
					email:      email,
					textId:     bubbleObj._htmlElId,
					loc:        loc,
					element:    parent._input
				});
			}
		}
	}
};



/**
 * Creates an empty bubble list.
 * @constructor
 * @class
 * This class manages selection events (click, double-click, and right-click) of a collection of bubbles, since
 * those events are typically meaningful within a group of bubbles. It maintains the visual state of the bubble
 * and notifies any listeners of the selection events. 
 * 
 * @param {hash}				params			hash of params:
 * @param {ZmAddressInputField}	parent			parent
 * @param {string}				normalClass		class for an unselected bubble
 * @param {string}				selClass		class for a selected bubble
 * @param {string}				rightSelClass	class for a right-clicked bubble
 */
ZmAddressBubbleList = function(params) {
	
	params = params || {};
	this.parent = params.parent;
	this._separator = params.separator || AjxEmailAddress.SEPARATOR;
	
	this._normalClass = params.normalClass || "addrBubble";
	this._selClass = params.selClass || this._normalClass + "-" + DwtCssStyle.SELECTED;
	this._actionClass = params.rightSelClass || this._normalClass + "-" + DwtCssStyle.ACTIONED;

	this._evtMgr = new AjxEventMgr();
	this._selEv = new DwtSelectionEvent(true);
	this._actionEv = new DwtListViewActionEvent(true);

	this.reset();
};

ZmAddressBubbleList.prototype.isZmAddressBubbleList = true;
ZmAddressBubbleList.prototype.toString = function() { return "ZmAddressBubbleList"; };

ZmAddressBubbleList.prototype.set =
function(list) {
	
	this._bubbleList = [];
	var selected = {};
	this._numSelected = 0;
	for (var i = 0; i < list.length; i++) {
		var bubble = list[i];
		this._bubbleList.push(bubble);
		if (this._selected[bubble.id]) {
			selected[bubble.id] = true;
			DBG.println("aif", "ZmAddressBubbleList::set - bubble selected: " + bubble.address);
			this._numSelected++;
		}
	}
	this._selected = selected; 
};

ZmAddressBubbleList.prototype.getArray =
function(list) {
	return this._bubbleList;
};

ZmAddressBubbleList.prototype.add =
function(bubble, index) {
	AjxUtil.arrayAdd(this._bubbleList, bubble, index);
	bubble.list = this;
};

ZmAddressBubbleList.prototype.remove =
function(bubble) {
	AjxUtil.arrayRemove(this._bubbleList, bubble);
	bubble.list = null;
	if (this._selected[bubble.id]) {
		this._numSelected--;
		this._selected[bubble.id] = false;
		this._checkSelection();
	}
	if (bubble == this._rightSelBubble) {
		this._rightSelBubble = null;
	}
	bubble.dispose();
};

ZmAddressBubbleList.prototype.clear = function() {
	while (this._bubbleList.length > 0) {
		this.remove(this._bubbleList[this._bubbleList.length - 1]);
	}
};

ZmAddressBubbleList.prototype.getBubble =
function(index) {
	index = index || 0;
	return this._bubbleList[index];
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmAddressBubbleList.prototype.addSelectionListener =
function(listener) {
	this._evtMgr.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmAddressBubbleList.prototype.removeSelectionListener =
function(listener) {
	this._evtMgr.removeListener(DwtEvent.SELECTION, listener);
};

/**
 * Adds an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmAddressBubbleList.prototype.addActionListener =
function(listener) {
	this._evtMgr.addListener(DwtEvent.ACTION, listener);
};

/**
 * Removes an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmAddressBubbleList.prototype.removeActionListener =
function(listener) {
	this._evtMgr.removeListener(DwtEvent.ACTION, listener);
};

ZmAddressBubbleList.prototype._itemClicked =
function(ev, bubble) {

	if (ev.shiftKey) {
		if (this._lastSelectedId) {
			var select = false;
			for (var i = 0, len = this._bubbleList.length; i < len; i++) {
				var b = this._bubbleList[i];
				if (b == bubble || b.id == this._lastSelectedId) {
					if (select) {
						this.setSelected(b, true);
						select = false;
						continue;
					}
					select = !select;
				}
				this.setSelected(b, select);
			}
		}
	}
	else if (ev.ctrlKey || ev.metaKey) {
		this.setSelected(bubble, !this._selected[bubble.id]);
		if (this._selected[bubble.id]) {
			this._lastSelectedId = bubble.id;
		}
	}
	else {
		var wasOnlyOneSelected = ((this.getSelectionCount() == 1) && this._selected[bubble.id]);
		this.deselectAll();
		this.setSelected(bubble, !wasOnlyOneSelected);
		this._lastSelectedId = wasOnlyOneSelected ? null : bubble.id;
	}

	if (this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
		DwtUiEvent.copy(this._selEv, ev);
		this._selEv.item = bubble;
		this._selEv.detail = DwtEvent.ONCLICK;
		this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
	}
};

ZmAddressBubbleList.prototype._itemDoubleClicked =
function(ev, bubble) {

	if (this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
		DwtUiEvent.copy(this._selEv, ev);
		this._selEv.item = bubble;
		this._selEv.detail = DwtEvent.ONDBLCLICK;
		this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
	}
};

ZmAddressBubbleList.prototype._itemActioned =
function(ev, bubble) {

	this._rightSelBubble = bubble;
	bubble.setClassName(this._actionClass);
	if (this._evtMgr.isListenerRegistered(DwtEvent.ACTION)) {
		DwtUiEvent.copy(this._actionEv, ev);
		this._actionEv.item = bubble;
		this._evtMgr.notifyListeners(DwtEvent.ACTION, this._actionEv);
	}
};

/**
 * Sets selection of the given bubble.
 *
 * @param {ZmAddressBubble}	bubble		bubble to select
 * @param {boolean} 		selected	if true, select the bubble, otherwise deselect it
 */
ZmAddressBubbleList.prototype.setSelected =
function(bubble, selected) {

	if (!bubble) { return; }
	if (selected == Boolean(this._selected[bubble.id])) { return; }

	this._selected[bubble.id] = selected;
	bubble.setClassName(selected ? this._selClass : this._normalClass);

	this._numSelected = selected ? this._numSelected + 1 : this._numSelected - 1;
	DBG.println("aif", "**** selected: " + selected + ", " + bubble.email + ", num = " + this._numSelected);
	this._checkSelection();	
};

ZmAddressBubbleList.prototype.isSelected =
function(bubble) {
	return Boolean(bubble && this._selected[bubble.id]);
};

/**
 * Returns a list of the currently selected bubbles. If a bubble has been selected via right-click,
 * but is not part of the current left-click selection, only it will be returned.
 *
 * @param {ZmAddressBubble}	bubble	reference bubble
 */
ZmAddressBubbleList.prototype.getSelection =
function(bubble) {

	var ref = bubble || this._rightSelBubble;
	var refIncluded = false;
	var sel = [];
	for (var i = 0; i < this._bubbleList.length; i++) {
		var bubble = this._bubbleList[i];
		if (this._selected[bubble.id]) {
			sel.push(bubble);
			if (bubble == ref) {
				refIncluded = true;
			}
		}
	}
	sel = (ref && !refIncluded) ? [ref] : sel;
	DBG.println("aif", "getSelection, sel length: " + sel.length);

	return sel;
};

ZmAddressBubbleList.prototype.getSelectionCount =
function(bubble) {
	return bubble ? this.getSelection(bubble).length : this._numSelected;
};

ZmAddressBubbleList.prototype.deselectAll =
function() {
	DBG.println("aif", "deselectAll");
	var sel = this.getSelection();
	for (var i = 0, len = sel.length; i < len; i++) {
		this.setSelected(sel[i], false);
	}
	this._selected = {};
	this._numSelected = 0;
};

ZmAddressBubbleList.prototype.clearRightSelection =
function() {
	this._rightSelBubble = null;
};

ZmAddressBubbleList.prototype.reset =
function(list) {
	this._bubbleList = [];
	this._selected = {};
	this._numSelected = 0;
};

ZmAddressBubbleList.prototype.size =
function() {
	return this._bubbleList.length;
};

ZmAddressBubbleList.prototype.selectAddressText =
function() {
	
	var sel = this.getSelection();
	var addrs = [];
	for (var i = 0; i < sel.length; i++) {
		addrs.push(sel[i].address);
	}
	var textarea = this._getTextarea();
	textarea.value = addrs.join(this._separator) + this._separator;
	textarea.focus();
	textarea.select();
};

ZmAddressBubbleList.prototype._getTextarea =
function() {
	// hidden textarea used for copying address text
	if (!ZmAddressBubbleList._textarea) {
		var el = ZmAddressBubbleList._textarea = document.createElement("textarea");
		el.id = "abcb";	// address bubble clipboard
		el["data-hidden"] = "1";
		appCtxt.getShell().getHtmlElement().appendChild(el);
		Dwt.setPosition(el, Dwt.ABSOLUTE_STYLE);
		Dwt.setLocation(el, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	}
	return ZmAddressBubbleList._textarea;
};

ZmAddressBubbleList.prototype._checkSelection =
function() {

	// don't mess with outside listening if we're selecting via rubber-banding
	if (this.parent && (this.parent._noOutsideListening || this.parent._dragging == DwtControl._DRAGGING)) { return; }

	if (!this._listening && this._numSelected == 1) {
		var omem = appCtxt.getOutsideMouseEventMgr();
		var omemParams = {
			id:					"ZmAddressBubbleList",
			elementId:			null,	// all clicks call our listener
			outsideListener:	this._outsideMouseListener.bind(this),
			noWindowBlur:		appCtxt.get(ZmSetting.IS_DEV_SERVER)
		}
		DBG.println("aif", "START outside listening for bubbles");
		omem.startListening(omemParams);
		this._listening = true;
	}
	else if (this._listening && this._numSelected == 0) {
		var omem = appCtxt.getOutsideMouseEventMgr();
		DBG.println("aif", "STOP outside listening for bubbles");
		var omemParams = {
			id:			"ZmAddressBubbleList",
			elementId:	null
		}		
		omem.stopListening(omemParams);
		this._listening = false;
	}
	this.selectAddressText();
};

ZmAddressBubbleList.prototype._outsideMouseListener =
function(ev, context) {

	// modified clicks control list selection, ignore them
	if (!ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
		this.deselectAll();
	}
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmDLAutocompleteListView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 *
 */

/**
 * Creates a new autocomplete list.
 * @class
 * This class shows the members of an expanded distribution list (DL).
 *
 * @author Conrad Damon
 *
 * @param {Hash}	params			a hash of parameters:
 * @param	{ZmAutocompleteListView}		parent autocomplete list view
 * @param	{AjxCallback}	selectionCallback	the callback into client to notify it that selection from extended DL happened (passed from email.js, and accessed from ZmDLAutocompleteListView.prototype._doUpdate)
 *
 * @extends		ZmAutocompleteListView
 */
ZmDLAutocompleteListView = function(params) {
	params.isFocusable = true;
	ZmAutocompleteListView.call(this, params);
	this._parentAclv = params.parentAclv;
	this._dlScrollDiv = this.getHtmlElement();
	this._selectionCallback = params.selectionCallback;
	this._expandTextId = params.expandTextId;
	Dwt.setHandler(this._dlScrollDiv, DwtEvent.ONSCROLL, ZmDLAutocompleteListView.handleDLScroll);
};

ZmDLAutocompleteListView.prototype = new ZmAutocompleteListView;
ZmDLAutocompleteListView.prototype.constructor = ZmDLAutocompleteListView;

ZmDLAutocompleteListView.prototype.toString =
function() {
	return "ZmDLAutocompleteListView";
};


ZmDLAutocompleteListView.prototype.getKeyMapName = function() {
	return ZmKeyMap.MAP_DL_ADDRESS_LIST;
};

ZmDLAutocompleteListView.prototype.handleKeyAction = function(actionCode, ev) {
	DBG.println("aif", "handle shortcut: " + actionCode);

	switch (actionCode) {
		case DwtKeyMap.SELECT_NEXT:	this._setSelected(ZmAutocompleteListView.NEXT); break;
		case DwtKeyMap.SELECT_PREV:	this._setSelected(ZmAutocompleteListView.PREV); break;
		case DwtKeyMap.ENTER:		this._update();  break;
		case DwtKeyMap.CANCEL:		if (this._parentAclv && this._expandTextId) {
										this._parentAclv._setExpandText(this._expandTextId, false);
									}
									this._popdown();
									break;
		default: return false;
	}
	return true;
};


ZmDLAutocompleteListView.prototype._set =
function(list, contact) {

	this._removeAll();
	this._matches = [];
	this._addMembers(list);

	// add row for selecting all at top of list
	var dl = appCtxt.getApp(ZmApp.CONTACTS).getDL(contact.getEmail());
	var numMembers = dl ? dl.total : list.length;
	var selectId = this._getId("Row", 1);
	if (numMembers != 1) {
		var table = this._getTable();
		var row = table.insertRow(0);
		row.className = this._origClass;
		selectId = row.id = this._selectAllRowId = this._getId("Row", "selectAll");
		var cell = row.insertCell(-1);
		cell.className = "AutocompleteMatchIcon";
		cell.innerHTML = AjxImg.getImageHtml("Blank16");
		cell = row.insertCell(-1);
		var text = numMembers ? ZmMsg.selectAllMembers : ZmMsg.noMembers;
		cell.innerHTML = AjxMessageFormat.format(text, [numMembers]);
	}

	AjxTimedAction.scheduleAction(new AjxTimedAction(this,
		function() {
			this._setSelected(selectId);
		}), 100);
};

ZmDLAutocompleteListView.prototype._addMembers =
function(list) {

	var table = this._getTable();
	var len = list.length;
	for (var i = 0; i < len; i++) {
		var match = list[i];
		this._matches.push(match);
		var rowId = match.id = this._getId("Row", this._matches.length);
		this._addRow(table, match, rowId);
	}
};

ZmDLAutocompleteListView.prototype._addRow =
function(table, match, rowId) {

	if (match && (match.text || match.icon)) {
		this._matchHash[rowId] = match;
		var row = table.insertRow(-1);
		row.className = this._origClass;
		row.id = rowId;
		var cell = row.insertCell(-1);
		cell.className = "AutocompleteMatchIcon";
		if (match.icon) {
			cell.innerHTML = (match.icon.indexOf('Dwt') != -1) ? ["<div class='", match.icon, "'></div>"].join("") :
																  AjxImg.getImageHtml(match.icon);
		} else {
			cell.innerHTML = "&nbsp;";
		}
		cell = row.insertCell(-1);
		cell.innerHTML = match.text || "&nbsp;";
	}
};

ZmDLAutocompleteListView.prototype._update =
function(context, match, ev) {
	
	if (this._selected == this._selectAllRowId) {
		if (!this._matchHash[this._selectAllRowId]) {
			var callback = this._handleResponseGetAllDLMembers.bind(this, ev);
			this._dlContact.getAllDLMembers(callback);
		}
	} else {
		this._doUpdate();
		this.reset(true);
	}
};

ZmDLAutocompleteListView.prototype._handleResponseGetAllDLMembers =
function(ev, result) {

	var mv = this._parentAclv._matchValue;
	var field = (mv instanceof Array) ? mv[0] : mv;
	if (result.list && result.list.length) {
		// see if client wants addresses joined, or one at a time
		if (this._parentAclv._options.massDLComplete) {
			var match = this._matchHash[this._selectAllRowId] = new ZmAutocompleteMatch();
			match[field] = result.list.join(this._parentAclv._separator);
			match.multipleAddresses = true;
			this._doUpdate();
		}
		else {
			var match = new ZmAutocompleteMatch();
			for (var i = 0, len = result.list.length; i < len; i++) {
				match[field] = result.list[i];
				this._doUpdate(match);
			}
		}
	}
	this.reset(true);
};

ZmDLAutocompleteListView.prototype._doUpdate =
function(match) {

	var context = null;
	// so that address will be taken from match
	if (this._parentAclv && this._parentAclv._currentContext) {
		context = this._parentAclv._currentContext;
		context.address = null;
	}
	match = match || this._matchHash[this._selected];
	if (!match) {
		return;
	}

	if (this._selectionCallback) {
		this._selectionCallback(match.fullAddress);
		return;
	}

	var dlBubble = document.getElementById(this._dlBubbleId);
	if (dlBubble && dlBubble._aifId && (!context || context.element._aifId != dlBubble._aifId)) {
		//this is the special case the DL was pre-created with the view. In this case we might have no context.
		// Another possible bug this fixes is if the current context is not in the same input field as the DL we are selecting from.
		var addrInputFld = DwtControl.ALL_BY_ID[dlBubble._aifId];
		if (addrInputFld){ 
			var bubbleParams = {
				address:	match.fullAddress,
				match:		match,
				noFocus:	false,
				addClass:	null,
				noParse:	false
			};
			addrInputFld.addBubble(bubbleParams);
			return;
		}
	}

	this._parentAclv._update(null, match);
};

ZmDLAutocompleteListView.handleDLScroll =
function(ev) {

	var target = DwtUiEvent.getTarget(ev);
	var view = DwtControl.findControl(target);
	var div = view._dlScrollDiv;
	if (div.clientHeight == div.scrollHeight) { return; }
	var contactDL = appCtxt.getApp(ZmApp.CONTACTS).getDL(view._dlContact.getEmail());
	var listSize = view.getDLSize();
	if (contactDL && (contactDL.more || (listSize < contactDL.list.length))) {
		var params = {scrollDiv:	div,
					  rowHeight:	view._rowHeight,
					  threshold:	10,
					  limit:		ZmContact.DL_PAGE_SIZE,
					  listSize:		listSize};
		var needed = ZmListView.getRowsNeeded(params);
		DBG.println("dl", "scroll, items needed: " + needed);
		if (needed) {
			DBG.println("dl", "new offset: " + listSize);
			var respCallback = ZmDLAutocompleteListView._handleResponseDLScroll.bind(null, view);
			view._parentAclv._dataAPI.expandDL(view._dlContact, listSize, respCallback);
		}
	}
};

ZmDLAutocompleteListView._handleResponseDLScroll =
function(view, matches) {
	view._addMembers(matches);
};

ZmDLAutocompleteListView.prototype.getDLSize =
function() {
	return this.size() - 1;
};

// optionally removes the DL address bubble
ZmDLAutocompleteListView.prototype.reset =
function(clearDL) {

	if (clearDL) {
		var dlBubble = document.getElementById(this._dlBubbleId);
		if (dlBubble) {
			var addrInput = DwtControl.ALL_BY_ID[dlBubble._aifId];
			if (addrInput && addrInput.removeBubble) { //it's not always really addrInput - from msg/conv view it's the msg or conv view, (unlike compose view where it's really address input
				addrInput.removeBubble(this._dlBubbleId);
				this._dlBubbleId = null;
			}
		}
	}
	ZmAutocompleteListView.prototype.reset.call(this);
};

ZmDLAutocompleteListView.prototype._popup =
function(loc) {

	if (this.getVisible()) { return; }

	loc = loc || this._getDefaultLoc();
	var x = loc.x;
	var windowSize = this.shell.getSize();
	this.setVisible(true);
	var curSize = this.getSize();
	this.setVisible(false);
	var newX = (x + curSize.x >= windowSize.x) ? windowSize.x - curSize.x : x;
	if (newX != x) {
		var parentSize = this._parentAclv.getSize();
		this._parentAclv.setLocation(windowSize.x - (curSize.x + parentSize.x + 2), Dwt.DEFAULT);
		loc.x = newX;
	}
	ZmAutocompleteListView.prototype._popup.call(this, loc);
	this.focus();
};

ZmDLAutocompleteListView.prototype._popdown =
function() {
	if (this._parentAclv) {
		this._parentAclv._curExpanded = null;
	}
	ZmAutocompleteListView.prototype._popdown.call(this);
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmSearchToolBar")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @class
 * This class represent a search toolbar. The components are some set of: an input field,
 * a search button, a save button, and a button to choose what type of item to search for.
 * 
 * @param {hash}			params		a hash of parameters:
 * @param {DwtComposite}	parent		the parent widget
 * @param {string}			id			an explicit ID to use for the control's HTML element
 * 
 * @extends		DwtComposite
 */
ZmSearchToolBar = function(params) {

	if (arguments.length == 0) { return; }

	params.className = params.className || "ZmSearchToolbar";
	this._button = {};
	DwtToolBar.apply(this, arguments);

	this._origin = ZmId.SEARCH;
	this._searchMenu = null;
};

ZmSearchToolBar.prototype = new DwtToolBar;
ZmSearchToolBar.prototype.constructor = ZmSearchToolBar;

ZmSearchToolBar.prototype.isZmSearchToolBar = true;
ZmSearchToolBar.prototype.toString = function() { return "ZmSearchToolBar"; };
ZmSearchToolBar.prototype.role = 'toolbar';

// Consts


ZmSearchToolBar.TYPES_BUTTON		= "TYPES";
ZmSearchToolBar.SEARCH_BUTTON 		= "SEARCH";
ZmSearchToolBar.SAVE_BUTTON 		= "SAVE";
ZmSearchToolBar.SEARCH_MENU_BUTTON	= ZmSearchToolBar.TYPES_BUTTON;	// back-compatibility

ZmSearchToolBar.MENU_ITEMS 			= [];		// list of menu items
ZmSearchToolBar.SETTING 			= {};		// required setting for menu item to appear
ZmSearchToolBar.MSG_KEY 			= {};		// text for menu item
ZmSearchToolBar.TT_MSG_KEY 			= {};		// tooltip text for menu item
ZmSearchToolBar.ICON 				= {};		// icon for menu item
ZmSearchToolBar.SHARE_ICON			= {};		// icon for shared menu item
ZmSearchToolBar.ID 					= {};		// ID for menu item
ZmSearchToolBar.DISABLE_OFFLINE     = {};       // Disable when offline detected


// Public static methods

/**
 * Defines a menu item to add when the types menu is created. Static so that it can be called before the
 * toolbar has been created.
 * 
 * @param {string}	id			ID of menu item
 * @param {hash}	params		menu item properties
 */
ZmSearchToolBar.addMenuItem =
function(id, params) {

	if (params.msgKey)		   { ZmSearchToolBar.MSG_KEY[id]		 = params.msgKey; }
	if (params.tooltipKey)	   { ZmSearchToolBar.TT_MSG_KEY[id]	 	 = params.tooltipKey; }
	if (params.icon)		   { ZmSearchToolBar.ICON[id]			 = params.icon; }
	if (params.shareIcon)	   { ZmSearchToolBar.SHARE_ICON[id]	 	 = params.shareIcon; }
	if (params.setting)		   { ZmSearchToolBar.SETTING[id]		 = params.setting; }
	if (params.id)			   { ZmSearchToolBar.ID[id]				 = params.id; }
	if (params.disableOffline) { ZmSearchToolBar.DISABLE_OFFLINE[id] = params.disableOffline; }

	if (params.index == null || params.index < 0 || params.index >= ZmSearchToolBar.MENU_ITEMS.length) {
		ZmSearchToolBar.MENU_ITEMS.push(id);
	} else {
		ZmSearchToolBar.MENU_ITEMS.splice(params.index, 0, id);
	}
};


// Public methods

/**
 * Removes a menu item from the types menu.
 * 
 * @param {string}	id			ID of menu item
 */
ZmSearchToolBar.prototype.removeMenuItem =
function(id) {
	
	var menu = this._searchMenu;
	if (menu) {
		var mi = menu.getItemById(ZmOperation.MENUITEM_ID, id);
		if (mi) {
			menu.removeChild(mi);
			mi.dispose();
		}
		this._cleanupSeparators(menu);
	}
};

// Remove unneeded separators
ZmSearchToolBar.prototype._cleanupSeparators =
function(menu) {

	var button = this._button[ZmSearchToolBar.TYPES_BUTTON];
	menu = menu || (button && button.getMenu());
	if (!menu) { return; }

	var items = menu.getItems();
	var toRemove = [];
	for (var i = 0; i < items.length; i++) {
		var mi = items[i];
		if (mi.isSeparator() && (i == 0 || i == items.length - 1 || items[i - 1].isSeparator())) {
			toRemove.push(mi);
		}
	}
	for (var i = 0; i < toRemove.length; i++) {
		var mi = toRemove[i];
		menu.removeChild(mi);
		mi.dispose();
	}
};

ZmSearchToolBar.prototype.getSearchField =
function() {
	return this._searchField.getInputElement();
};

// sets up a function to call when Enter has been pressed
ZmSearchToolBar.prototype.registerEnterCallback =
function(callback) {
	this._enterCallback = callback;
};

ZmSearchToolBar.prototype.addSelectionListener =
function(buttonId, listener) {
	var button = this._button[buttonId];
	if (button) {
		button.addSelectionListener(listener);
	}
};

ZmSearchToolBar.prototype.getButton =
function(buttonId) {
	return this._button[buttonId];
};

ZmSearchToolBar.prototype.getButtons =
function() {
	return AjxUtil.values(this._button);
};

ZmSearchToolBar.prototype.focus = function(item) {

    if (item) {
        // focus is being moved via a shortcut (arrow key)
        return DwtToolBar.prototype.focus.apply(this, arguments);
    }
	else if (this._searchField) {
		this._searchField.focus();
		this._searchField.moveCursorToEnd();
        return this._searchField;
	}
};

ZmSearchToolBar.prototype.blur =
function() {
	if (this._searchField) {
		this._searchField.blur();
	}
};

ZmSearchToolBar.prototype.setEnabled =
function(enable) {
	if (this._searchField) {
		this._searchField.setEnabled(enable);
	}
	for (var buttonId in this._button) {
		this._button[buttonId].setEnabled(enable);
	}
};
ZmSearchToolBar.prototype.setSearchFieldValue =
function(value) {
	if (this._searchField && value != this.getSearchFieldValue()) {
		this._searchField.setValue(value);
	}
};

ZmSearchToolBar.prototype.getSearchFieldValue =
function() {
	return this._searchField ? this._searchField.getValue() : null;
};



// Private methods

ZmSearchToolBar.prototype._handleKeyDown =
function(ev) {
	var key = DwtKeyEvent.getCharCode(ev);
	if (DwtKeyEvent.IS_RETURN[key]) {
		return this._handleEnterKeyPress(ev);
	}
	return true;
};

ZmSearchToolBar.prototype._handleEnterKeyPress =
function(ev) {
	if (this._enterCallback) {
		this._enterCallback.run({
					ev:				ev,
					zimletEvent:	"onKeyPressSearchField",
					origin:			this._origin
				});
	}
	return false;
};

/**
 * Initializes search autocomplete.
 */
ZmSearchToolBar.prototype.initAutocomplete =
function() {
	if (!this._acList) {
		this._acList = new ZmAutocompleteListView(this._getAutocompleteParams());
		this._acList.handle(this.getSearchField());
	}
};

ZmSearchToolBar.prototype._getAutocompleteParams =
function() {
	var params = {
		dataClass:			new ZmSearchAutocomplete(),
		matchValue:			"matchText",
		delims:				[" ", "\t"],
		delimCodes:			[3, 13, 9],
		separator:			" ",
		keyDownCallback:	this._handleKeyDown.bind(this),
		contextId:			this.toString(),
		locationCallback:	this._getAcLocation.bind(this)
	};
	return params;
};

ZmSearchToolBar.prototype.getAutocompleteListView =
function() {
	return this._acList;
};

ZmSearchToolBar.prototype._getAcLocation =
function() {
	var el = this._searchField.getInputElement();
	if (!el) { return {}; }
	
	var elLoc = Dwt.getLocation(el);
	var elSize = Dwt.getSize(el);
	var strWidth = AjxStringUtil.getWidth(el.value);
	if (AjxEnv.isWindows && (AjxEnv.isFirefox || AjxEnv.isSafari || AjxEnv.isChrome) ){
		// FF/Win: fudge factor since string is longer in INPUT than when measured in SPAN
		strWidth = strWidth * 1.2;
	}
	var x = elLoc.x + strWidth;
	var y = elLoc.y + elSize.y;
	DwtPoint.tmp.set(x, y);
	return DwtPoint.tmp;
};




/**
 * Adds a types button and support for a custom search menu item to a search toolbar
 * 
 * @param params
 */
ZmMainSearchToolBar = function(params) {

	if (arguments.length == 0) { return; }

	ZmSearchToolBar.apply(this, arguments);

    this._initialize();

	// setup "include shared" menu item
	var miParams = {
		msgKey:			"searchShared",
		tooltipKey:		"searchShared",
		icon:			"Group",
		setting:		ZmSetting.SHARING_ENABLED,
		id:				ZmId.getMenuItemId(ZmId.SEARCH, ZmId.SEARCH_SHARED),
		disableOffline: true
	};
	ZmSearchToolBar.addMenuItem(ZmId.SEARCH_SHARED, miParams);

	// setup "all accounts" menu item for multi account
	if (appCtxt.multiAccounts) {
		var miParams = {
			msgKey:	"searchAllAccounts",
			icon:	"Globe",
			id:		ZmId.getMenuItemId(ZmId.SEARCH, ZmId.SEARCH_ALL_ACCOUNTS)
		};
		ZmSearchToolBar.addMenuItem(ZmId.SEARCH_ALL_ACCOUNTS, miParams);
	}
};

ZmMainSearchToolBar.prototype = new ZmSearchToolBar;
ZmMainSearchToolBar.prototype.constructor = ZmMainSearchToolBar;

ZmMainSearchToolBar.prototype.isZmMainSearchToolBar = true;
ZmMainSearchToolBar.prototype.toString = function() { return "ZmMainSearchToolBar"; };

ZmMainSearchToolBar.CUSTOM_ITEM_ID		= "CustomSearchItem";	// custom search menu item key
ZmMainSearchToolBar.CUSTOM_BUTTON 		= "CUSTOM";				// button ID

ZmMainSearchToolBar.prototype._initialize = function() {

    var isExternalAccount = appCtxt.isExternalAccount();

	// add "search types" menu
    var firstItem = ZmSearchToolBar.MENU_ITEMS[0];
    var buttonId = ZmId.getButtonId(ZmId.SEARCH, ZmId.SEARCH_MENU);
    var button = this._button[ZmSearchToolBar.TYPES_BUTTON] = new DwtButton({
        parent:		this,
        index:		0,
        id:         buttonId
    });
    button.setImage(ZmSearchToolBar.ICON[firstItem]);
    button.setToolTipContent(ZmMsg[ZmSearchToolBar.TT_MSG_KEY[firstItem]], true);

    var menu = new AjxCallback(this, this._createSearchMenu);
    button.setMenu(menu, false, DwtMenuItem.RADIO_STYLE);
    if (isExternalAccount) {
        button.setEnabled(false);
    }

    // add search box
    var searchBox = this._searchField = new DwtInputField({
        parent:     this,
        hint:       ZmMsg.searchInput,
        label:      ZmMsg.searchInput,
        inputId:    ZmId.SEARCH_INPUTFIELD
    });
    var inputEl = searchBox.getInputElement();
    inputEl.className = "search_input";
    this._searchField._showHint();
    this._searchField.addListener(DwtEvent.ONFOCUS, this._onInputFocus.bind(this));
    this._searchField.addListener(DwtEvent.ONBLUR, this._onInputBlur.bind(this));
    if (isExternalAccount) {
        this._searchField.setEnabled(false);
    }
    searchBox.addListener(DwtEvent.ONFOCUS, this._childFocusListener.bind(this));

    // add search button
    button = this._button[ZmSearchToolBar.SEARCH_BUTTON] = new DwtButton({
        parent:		this,
        className: 	"ZmSearchButton",
        id:         ZmId.getButtonId(ZmId.SEARCH, ZmId.SEARCH_SEARCH)
    });
    button.setImage("Search2");
    button.setToolTipContent(ZmMsg.searchTooltip, true);

    // add save search button if saved-searches enabled
    if (isExternalAccount) {
        if (this._button[ZmSearchToolBar.SEARCH_BUTTON]) {
            this._button[ZmSearchToolBar.SEARCH_BUTTON].setEnabled(false);
        }
    }
};

ZmMainSearchToolBar.prototype._createSearchMenu =
function() {

	var menu = this._searchMenu = new DwtMenu({
				parent:		this._button[ZmSearchToolBar.TYPES_BUTTON],
				className:	"ActionMenu",
				id:			ZmId.getMenuId(ZmId.SEARCH)
			});
	var mi;
	if (this._customSearchMenuItems) {
		for (var i = 0; i < this._customSearchMenuItems.length; i++) {
			var csmi = this._customSearchMenuItems[i];
			this._createCustomSearchMenuItem(menu, csmi.icon, csmi.text, csmi.listener);
		}
	}
	var params = {
		parent:         menu,
		enabled:        true,
		radioGroupId:   0,
		style:          DwtMenuItem.RADIO_STYLE
	};
	for (var i = 0; i < ZmSearchToolBar.MENU_ITEMS.length; i++) {
		var id = ZmSearchToolBar.MENU_ITEMS[i];

		// add separator *before* "shared" menu item
		if (id == ZmId.SEARCH_SHARED) {
			if (ZmSearchToolBar.MENU_ITEMS.length <= 1) { continue; }
			mi = new DwtMenuItem({parent:menu, style:DwtMenuItem.SEPARATOR_STYLE});
		}

		var setting = ZmSearchToolBar.SETTING[id];
		if (setting && !appCtxt.get(setting)) { continue; }

		var isCheckStyle = (id == ZmId.SEARCH_SHARED || id == ZmId.SEARCH_ALL_ACCOUNTS);
		if (isCheckStyle) {
			params.style = DwtMenuItem.CHECK_STYLE;
		}
		params.style = (id == ZmId.SEARCH_SHARED || id == ZmId.SEARCH_ALL_ACCOUNTS)
			? DwtMenuItem.CHECK_STYLE : DwtMenuItem.RADIO_STYLE;
		params.imageInfo = ZmSearchToolBar.ICON[id];
		params.text = ZmMsg[ZmSearchToolBar.MSG_KEY[id]];
		params.id = ZmSearchToolBar.ID[id];
		mi = DwtMenuItem.create(params);
		mi.setData(ZmOperation.MENUITEM_ID, id);
		if (!isCheckStyle) {
			mi.setAttribute('aria-label', ZmMsg[ZmSearchToolBar.TT_MSG_KEY[id]]);
		}
	}
	
	this._checkSharedMenuItem();
	appCtxt.getSettings().getSetting(ZmSetting.SEARCH_INCLUDES_SHARED).addChangeListener(this._checkSharedMenuItem.bind(this));

	appCtxt.getSearchController()._addMenuListeners(menu);
	this._searchMenuCreated = true;

	return menu;
};

ZmMainSearchToolBar.prototype.setOfflineState = function(offline) {
	var button   = this._button[ZmSearchToolBar.TYPES_BUTTON];
	var menu     = button && button.getMenu();
	var numItems = menu.getItemCount();
	for (var i = 0; i < numItems; i++) {
	    var item = menu.getItem(i);
		if (item) {
			var id = item.getData(ZmOperation.MENUITEM_ID);
			if (id && ZmSearchToolBar.DISABLE_OFFLINE[id])  {
				item.setEnabled(!offline);
			}
		}
	}
}

ZmMainSearchToolBar.prototype.getSearchType =
function() {
	var button = this._button[ZmSearchToolBar.TYPES_BUTTON];
	var menu = button && button.getMenu();
    var item = menu ? menu.getSelectedItem() || menu.getItems()[0] : null;
	var data = item ? item.getData(ZmMainSearchToolBar.CUSTOM_ITEM_ID) || item.getData(ZmOperation.MENUITEM_ID) :
					  ZmSearchToolBar.MENU_ITEMS[0];
	return data;
};

ZmMainSearchToolBar.prototype.createCustomSearchBtn =
function(icon, text, listener, id) {

	if (!this._customSearchListener) {
		this._customSearchListener = this._customSearchBtnListener.bind(this);
	}

	// check if custom search should be a button by checking for the Id against the template
	var customSearchBtn = document.getElementById(this._htmlElId + "_customSearchButton");
	if (customSearchBtn) {
		var data = { icon:icon, text:text, listener:listener };
		var button = this._button[ZmSearchToolBar.CUSTOM_BUTTON]
		if (!button) {
			button = this._button[ZmSearchToolBar.CUSTOM_BUTTON] = ZmToolBar.addButton({
						parent:		this,
						tdId:		"_customSearchButton",
						buttonId:	ZmId.getButtonId(ZmId.SEARCH, ZmId.SEARCH_CUSTOM),
						lbl:		text,
						icon:		icon
					});
			button.setData(ZmMainSearchToolBar.CUSTOM_ITEM_ID, data);
			button.addSelectionListener(this._customSearchListener);

			// show the separator now that we've added a custom search button
			var sep = document.getElementById(this._htmlElId + "_customSearchButtonSep");
			if (sep) {
				Dwt.setVisible(sep, true);
			}
		} else {
			var menu = button && button.getMenu();
			var item;
			var params = {
				parent:			menu,
				enabled:		true,
				style:			DwtMenuItem.RADIO_STYLE,
				radioGroupId:	0,
				id:				id
			};
			if (!menu) {
				var btnData = button.getData(ZmMainSearchToolBar.CUSTOM_ITEM_ID);
				menu = new DwtMenu({
							parent:		button,
							className:	"ActionMenu",
							id:			ZmId.getMenuId(ZmId.SEARCH, ZmId.SEARCH_CUSTOM)
						});
				button.setMenu(menu, false, DwtMenuItem.RADIO_STYLE);
				params.imageInfo = btnData.icon;
				params.text = btnData.text;
				item = DwtMenuItem.create(params);
				item.setData(ZmMainSearchToolBar.CUSTOM_ITEM_ID, btnData);
				item.setData(ZmOperation.MENUITEM_ID, ZmId.SEARCH_CUSTOM);
				item.setChecked(true, true);
				item.addSelectionListener(this._customSearchListener);
			}
			params.imageInfo = icon;
			params.text = text;
			item = DwtMenuItem.create(params);
			item.setData(ZmMainSearchToolBar.CUSTOM_ITEM_ID, data);
			item.addSelectionListener(this._customSearchListener);
		}
	} else {
		if (this._searchMenuCreated) {
			var menu = this._button[ZmSearchToolBar.TYPES_BUTTON].getMenu();
			this._createCustomSearchMenuItem(menu, icon, text, listener, id);
		} else {
			if (!this._customSearchMenuItems) {
				this._customSearchMenuItems = [];
			}
			this._customSearchMenuItems.push({icon:icon, text:text, listener:listener, id:id});
		}
	}
};

ZmMainSearchToolBar.prototype._createCustomSearchMenuItem =
function(menu, icon, text, listener, id) {
	var mi = menu.getItem(0);
	var params = {
		parent: menu,
		imageInfo: icon,
		text: text,
		enabled: true,
		style: DwtMenuItem.RADIO_STYLE,
		radioGroupId: 0,
		index: 0,
		id: id
	};
	mi = DwtMenuItem.create(params);
	var data = { icon:icon, text:text, listener:listener };
	mi.setData(ZmMainSearchToolBar.CUSTOM_ITEM_ID, data);
	mi.setData(ZmOperation.MENUITEM_ID, ZmId.SEARCH_CUSTOM);
	mi.addSelectionListener(this._customSearchListener);

	// only add separator if this is the first custom search menu item
	if (!(mi && mi.getData(ZmMainSearchToolBar.CUSTOM_ITEM_ID))) {
		mi = new DwtMenuItem({parent:menu, style:DwtMenuItem.SEPARATOR_STYLE, index:1});
	}
};

ZmMainSearchToolBar.prototype._customSearchBtnListener = 
function(ev) {
	var item = ev.item;
	if (!item) { return; }
	var data = item.getData(ZmMainSearchToolBar.CUSTOM_ITEM_ID);
	if (!data) { return; }
	if (this._customSearchBtn) {
		if (item.isDwtMenuItem) {
			if (ev.detail != DwtMenuItem.CHECKED) { return; }
			this._customSearchBtn.setToolTipContent(data[1]);
			this._customSearchBtn.setData(ZmMainSearchToolBar.CUSTOM_ITEM_ID, data);
		}
		data.listener.run(ev); // call original listener
	} else {
		var button = this._button[ZmSearchToolBar.TYPES_BUTTON];
		button.setToolTipContent(data.text);

		var menu = item.parent;
		var shareMenuItem = menu ? menu.getItemById(ZmOperation.MENUITEM_ID, ZmId.SEARCH_SHARED) : null;
		if (shareMenuItem) {
			shareMenuItem.setChecked(false, true);
			shareMenuItem.setEnabled(false);
		}

		button.setImage(data.icon);
		button.setText(data.text);
	}
};

// Expand INPUT when it gets focus
ZmMainSearchToolBar.prototype._onInputFocus = function(ev) {

	this._setInputExpanded(true);
};

// Collapse INPUT when it loses focus (unless that was due to a click on a search toolbar button)
ZmMainSearchToolBar.prototype._onInputBlur = function(ev) {

	var focusObj = appCtxt.getKeyboardMgr().getFocusObj();
	if (focusObj !== this._button[ZmSearchToolBar.TYPES_BUTTON] && focusObj !== this._button[ZmSearchToolBar.SEARCH_BUTTON] && !this._movingFocus) {
		this._setInputExpanded(false);
	}
    this._movingFocus = false;  // done here since blur handler may be called on a timer
};

// note when we're moving focus within the toolbar so we don't collapse the INPUT
ZmMainSearchToolBar.prototype._moveFocus = function(back) {

    this._movingFocus = true;
    ZmSearchToolBar.prototype._moveFocus.apply(this, arguments);
};

ZmMainSearchToolBar.prototype._setInputExpanded = function(expanded) {

    // Don't collapse input if user just popped up menu (which causes blur on input)
    if (!expanded && this._searchMenu && this._searchMenu.isPoppedUp()) {
        return;
    }

	var input = this._searchField.getInputElement();
	var cls = expanded ? "search_input-expanded" : "search_input";

	if (AjxEnv.isIE9) {
		// bug 83493: IE9 gets the layout wrong on the first try
		setTimeout(function() {
			input.className = cls;
		}, 0);
	} else {
		input.className = cls;
	}
};

ZmMainSearchToolBar.prototype._checkSharedMenuItem =
function() {
	var mi = this._searchMenu && this._searchMenu.getItemById(ZmOperation.MENUITEM_ID, ZmId.SEARCH_SHARED);
	if (mi) {
		mi.setChecked(appCtxt.get(ZmSetting.SEARCH_INCLUDES_SHARED));
	}
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmStatusView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates the status view.
 * @class
 * This class represents the status view.
 * 
 * @param    {DwtControl}    parent        the parent
 * @param    {String}        className     the class name
 * @param    {constant}      posStyle      the position style
 * @param    {String}        id            the id
 * 
 * @extends		DwtControl
 */
ZmStatusView = function(parent, className, posStyle, id) {

    DwtControl.call(this, {parent:parent, className:(className || "ZmStatus"), posStyle:posStyle, id:id});

    this._toast = this._standardToast = new ZmToast(this, ZmId.TOAST);
    this._statusQueue = [];
};

ZmStatusView.prototype = new DwtControl;
ZmStatusView.prototype.constructor = ZmStatusView;


// Constants
/**
 * Defines the "informational" status level.
 */
ZmStatusView.LEVEL_INFO             = 1;    // informational
/**
 * Defines the "warning" status level.
 */
ZmStatusView.LEVEL_WARNING          = 2;    // warning
/**
 * Defines the "critical" status level.
 */
ZmStatusView.LEVEL_CRITICAL         = 3;    // critical

ZmStatusView.MSG_PARAMS = ["msg", "level", "detail", "transitions", "toast", "force", "dismissCallback", "finishCallback"];

// Public methods

ZmStatusView.prototype.toString =
function() {
    return "ZmStatusView";
};

/**
 * Displays a status message.
 * 
 * @param {String}    msg the message
 * @param {constant}    [level]         the level (see {@link ZmStatusView}<code>.LEVEL_</code> constants) 
 * @param {String}    [detail]         the details
 * @param {String}    [transitions] the transitions (see {@link ZmToast})
 * @param {String}    [toast]     the toast control
 * @param {boolean}    [force]        force any displayed toasts out of the way
 * @param {AjxCallback}    [dismissCallback]    callback to run when the toast is dismissed (by another message using [force], or explicitly calling ZmStatusView.prototype.dismiss())
 * @param {AjxCallback}    [finishCallback]     callback to run when the toast finishes its transitions by itself (not when dismissed)
 */
ZmStatusView.prototype.setStatusMsg =
function(params) {
    params = Dwt.getParams(arguments, ZmStatusView.MSG_PARAMS);
    if (typeof params == "string") {
        params = { msg: params };
    }
    var work = {
        msg: params.msg,
        level: params.level || ZmStatusView.LEVEL_INFO,
        detail: params.detail,
        date: new Date(),
        transitions: params.transitions,
        toast: params.toast || this._standardToast,
        dismissCallback: (params.dismissCallback instanceof AjxCallback) ? params.dismissCallback : null,
        finishCallback: (params.finishCallback instanceof AjxCallback) ? params.finishCallback : null,
		dismissed: false
    };

	if (params.force) { // We want to dismiss ALL messages in the queue and display the new message
		for (var i=0; i<this._statusQueue.length; i++) {
			this._statusQueue[i].dismissed = true; // Dismiss all messages in the queue in turn, calling their dismissCallbacks along the way
		}
	}
    // always push so we know one is active
    this._statusQueue.push(work);
    if (!this._toast.isPoppedUp()) {
        this._updateStatusMsg();
    } else if (params.force) {
        this.dismissStatusMsg();
    }
};

ZmStatusView.prototype.nextStatus =
function() {
    if (this._statusQueue.length > 0) {
        this._updateStatusMsg();
        return true;
    }
    return false;
};

ZmStatusView.prototype.dismissStatusMsg =
function(all) {
	if (all) {
		for (var i=0; i<this._statusQueue.length; i++) {
			this._statusQueue[i].dismissed = true; // Dismiss all messages in the queue in turn, calling their dismissCallbacks along the way
		}
	}
    this._toast.dismiss();
};

// Protected methods

ZmStatusView.prototype._updateStatusMsg =
function() {
    var work = this._statusQueue.shift();
    if (!work) { return; }
	if (work.dismissed) { // If preemptively dismissed, just run the callback and proceed to the next msg
		if (work.dismissCallback)
			work.dismissCallback.run();
		this.nextStatus();
	} else {
		this._toast = work.toast;
		this._toast.popup(work);
	}
};


//
// ZmToast
//

/**
 * Creates the "toaster".
 * @class
 * This class represents the "toaster".
 * 
 * @extends	DwtComposite
 */
ZmToast = function(parent, id) {
    if (arguments.length == 0) { return; }

    DwtComposite.call(this, {parent:parent.shell, className:"ZToast", posStyle:Dwt.ABSOLUTE_STYLE, id:id});
    this._statusView = parent;
    this._createHtml();

    this._funcs = {};
    this._funcs["position"] = AjxCallback.simpleClosure(this.__position, this);
    this._funcs["show"] = AjxCallback.simpleClosure(this.__show, this);
    this._funcs["hide"] = AjxCallback.simpleClosure(this.__hide, this);
    this._funcs["pause"] = AjxCallback.simpleClosure(this.__pause, this);
    this._funcs["hold"] = AjxCallback.simpleClosure(this.__hold, this);
    this._funcs["idle"] = AjxCallback.simpleClosure(this.__idle, this);
    this._funcs["fade"] = AjxCallback.simpleClosure(this.__fade, this);
    this._funcs["fade-in"] = this._funcs["fade"];
    this._funcs["fade-out"] = this._funcs["fade"];
    this._funcs["slide"] = AjxCallback.simpleClosure(this.__slide, this);
    this._funcs["slide-in"] = this._funcs["slide"];
    this._funcs["slide-out"] = this._funcs["slide"];
    this._funcs["next"] = AjxCallback.simpleClosure(this.transition, this);
}
ZmToast.prototype = new DwtComposite;

ZmToast.prototype.constructor = ZmToast;
ZmToast.prototype.toString =
function() {
    return "ZmToast";
};

ZmToast.prototype.role = 'alert';
ZmToast.prototype.isFocusable = true;

// Constants
/**
 * Defines the "fade" transition.
 */
ZmToast.FADE = { type: "fade" };
/**
 * Defines the "fade-in" transition.
 */
ZmToast.FADE_IN = { type: "fade-in" };
/**
 * Defines the "fade-out" transition.
 */
ZmToast.FADE_OUT = { type: "fade-out" };
/**
 * Defines the "slide" transition.
 */
ZmToast.SLIDE = { type: "slide" };
/**
 * Defines the "slide-in" transition.
 */
ZmToast.SLIDE_IN = { type: "slide-in" };
/**
 * Defines the "slide-out" transition.
 */
ZmToast.SLIDE_OUT = { type: "slide-out" };
/**
 * Defines the "pause" transition.
 */
ZmToast.PAUSE = { type: "pause" };
/**
 * Defines the "hold" transition.
 */
ZmToast.HOLD = { type: "hold" };
/**
 * Defines the "idle" transition.
 */
ZmToast.IDLE = {type: "idle" };
/**
 * Defines the "show" transition.
 */
ZmToast.SHOW = {type: "show" };

//ZmToast.DEFAULT_TRANSITIONS = [ ZmToast.FADE_IN, ZmToast.PAUSE, ZmToast.FADE_OUT ];
ZmToast.DEFAULT_TRANSITIONS = [ ZmToast.SLIDE_IN, ZmToast.PAUSE, ZmToast.SLIDE_OUT ];

ZmToast.DEFAULT_STATE = {};
ZmToast.DEFAULT_STATE["position"] = { location: "C" }; // center
ZmToast.DEFAULT_STATE["pause"] = { duration: 1200 };
ZmToast.DEFAULT_STATE["hold"] = {};
ZmToast.DEFAULT_STATE["fade"] = { duration: 100, multiplier: 1 };
ZmToast.DEFAULT_STATE["fade-in"] = { start: 0, end: 99, step: 10, duration: 200, multiplier: 1 };
ZmToast.DEFAULT_STATE["fade-out"] = { start: 99, end: 0, step: -10, duration: 200, multiplier: 1 };
ZmToast.DEFAULT_STATE["slide"] = { duration: 100, multiplier: 1 };
ZmToast.DEFAULT_STATE["slide-in"] = { start: -40, end: 0, step: 1, duration: 100, multiplier: 1 };
ZmToast.DEFAULT_STATE["slide-out"] = { start: 0, end: -40, step: -1, duration: 100, multiplier: 1 };

ZmToast.LEVEL_RE = /\b(ZToastCrit|ZToastWarn|ZToastInfo)\b/g;
ZmToast.DISMISSABLE_STATES = [ZmToast.HOLD];

// Data

ZmToast.prototype.TEMPLATE = "share.Widgets#ZToast";


// Public methods

ZmToast.prototype.dispose =
function() {
    this._textEl = null;
    this._iconEl = null;
    this._detailEl = null;
    DwtComposite.prototype.dispose.call(this);
};

ZmToast.prototype.popup =
function(work) {
    this.__clear();
    this._poppedUp = true;
    this._dismissed = false;
    this._dismissCallback = work.dismissCallback;
    this._finishCallback = work.finishCallback;

    var icon, className, label;

    switch (work.level) {
    case ZmStatusView.LEVEL_CRITICAL:
        className = "ZToastCrit";
        icon = "Critical";
        label = AjxMsg.criticalMsg;
        break;

    case ZmStatusView.LEVEL_WARNING:
        className = "ZToastWarn";
        icon = "Warning";
        label = AjxMsg.warningMsg;
        break;

    case ZmStatusView.LEVEL_INFO:
    default:
        className = "ZToastInfo";
        icon = "Success";
        label = AjxMsg.infoMsg;
        break;
    }

    // setup display
    var el = this.getHtmlElement();
    Dwt.delClass(el, ZmToast.LEVEL_RE, className);

    if (this._iconEl) {
        this._iconEl.innerHTML = AjxImg.getImageHtml({
            imageName: icon, altText: label
        });
    }

    if (this._textEl) {
        // we use and add a dedicated SPAN to make sure that we trigger all
        // screen readers
        var span = document.createElement('SPAN');
        span.innerHTML = work.msg || "";

        Dwt.removeChildren(this._textEl);
        this._textEl.appendChild(span);
    }

    // get transitions
    var location = appCtxt.getSkinHint("toast", "location");
    var transitions =
        (work.transitions || appCtxt.getSkinHint("toast", "transitions") ||
         ZmToast.DEFAULT_TRANSITIONS);

    transitions = [].concat( {type:"position", location:location}, transitions, {type:"hide"} );

    // start animation
    this._transitions = transitions;
    this.transition();
};

ZmToast.prototype.popdown =
function() {
    this.__clear();
    this.setLocation(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
    this._poppedUp = false;

    if (!this._dismissed) {
        if (this._finishCallback)
            this._finishCallback.run();
    }

    this._dismissed = false;
};

ZmToast.prototype.isPoppedUp =
function() {
    return this._poppedUp;
};

ZmToast.prototype.transition =
function() {

    if (this._pauseTimer) {
        clearTimeout(this._pauseTimer);
        this._pauseTimer = null;
    }
    if (this._held) {
        this._held = false;
    }

    var transition = this._transitions && this._transitions.shift();
    if (!transition) {
        this._poppedUp = false;
        if (!this._statusView.nextStatus()) {
            this.popdown();
        }
        return;
    }

    var state = this._state = this._createState(transition);

    this.setLocation(state.x, state.y);

    this._funcs[transition.type || "next"]();
};

// Protected methods

ZmToast.prototype._createHtml =
function(templateId) {
    var data = { id: this._htmlElId };
    this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
    this.setZIndex(Dwt.Z_TOAST);
    var el = this.getHtmlElement();

    el.setAttribute('aria-live', 'assertive');
    el.setAttribute('aria-relevant', 'additions');
    el.setAttribute('aria-atomic', true);
};

ZmToast.prototype._createHtmlFromTemplate =
function(templateId, data) {
    DwtComposite.prototype._createHtmlFromTemplate.call(this, templateId, data);
    this._textEl = document.getElementById(data.id+"_text");
    this._iconEl = document.getElementById(data.id+"_icon");
    this._detailEl = document.getElementById(data.id+"_detail");
};

ZmToast.prototype._createState =
function(transition) {
    var state = AjxUtil.createProxy(transition);
    var defaults = ZmToast.DEFAULT_STATE[state.type];
    for (var name in defaults) {
        if (!state[name]) {
            state[name] = defaults[name];
        }
    }

    switch (state.type) {
        case "fade-in":
            this.setOpacity(0);
            this.setLocation(null, 0);
            state.value = state.start;
            break;
        case "fade-out":
        case "fade":
            this.setLocation(null, 0);
            state.value = state.start;
            break;
        case "slide-in":
        case "slide-out":
        case "slide":{
            this.setLocation(null, -36);
            this.setOpacity(100);
            state.value = state.start;
            break;
        }
    }
    return state;
};

// Private methods

ZmToast.prototype.__clear =
function() {
    clearTimeout(this._actionId);
    clearInterval(this._actionId);
    this._actionId = -1;
};

// transition handlers

ZmToast.prototype.__position =
function() {
    var location = this._state.location || "C";
    var containerId = "skin_container_toast"; // Skins may specify an optional element with this id. Toasts will then be placed relative to this element, rather than to the the zshell

    var container = Dwt.byId(containerId) || this.shell.getHtmlElement();
    
    var bsize = Dwt.getSize(container);
    var tsize = this.getSize();

    var x = (bsize.x - tsize.x) / 2;
    var y = (bsize.y - tsize.y) / 2;

    switch (location.toUpperCase()) {
        case 'N': y = 0-tsize.y; break;
        case 'S': y = bsize.y - tsize.y; break;
        case 'E': x = bsize.x - tsize.x; break;
        case 'W': x = 0; break;
        case 'NE': x = bsize.x - tsize.x; y = 0; break;
        case 'NW': x = 0; y = 0; break;
        case 'SE': x = bsize.x - tsize.x; y = bsize.y - tsize.y; break;
        case 'SW': x = 0; y = bsize.y - tsize.y; break;
        case 'C': default: /* nothing to do */ break;
    }

    var offset = Dwt.toWindow(container);
    x += offset.x;
    y += offset.y;
    this.setLocation(x, y);

    this._funcs["next"]();
};

ZmToast.prototype.__show =
function() {
    this.setVisible(true);
    this.setVisibility(true);
    this._funcs["next"]();
};

ZmToast.prototype.__hide =
function() {
    this.setLocation(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
    if (this._textEl) {
		Dwt.removeChildren(this._textEl);
    }
    if (this._iconEl) {
		Dwt.removeChildren(this._iconEl);
    }
    this._funcs["next"]();
};

ZmToast.prototype.__pause =
function() {
    if (this._dismissed && ZmToast.__mayDismiss(ZmToast.PAUSE)) {
        this._funcs["next"]();
    } else {
        this._pauseTimer = setTimeout(this._funcs["next"], this._state.duration);
    }
};


/**
 * Hold the toast in place until dismiss() is called. If dismiss() was already called before this function (ie. during fade/slide in), continue immediately
 */
ZmToast.prototype.__hold =
function() {
    if (this._dismissed && ZmToast.__mayDismiss(ZmToast.HOLD)!=-1) {
        this._funcs["next"]();
    } else {
        this._held = true;
    }
};

ZmToast.__mayDismiss =
function(state) {
    return AjxUtil.indexOf(ZmToast.DISMISSABLE_STATES, state)!=-1;
};

/**
 * Dismiss (continue) a held or paused toast (Given that ZmToast.DISMISSABLE_STATES agrees). If not yet held or paused, those states will be skipped when they occur
 */
ZmToast.prototype.dismiss =
function() {
    if (!this._dismissed && this._poppedUp) {
        var doDismiss = (this._pauseTimer && ZmToast.__mayDismiss(ZmToast.PAUSE)) || 
            (this._held && ZmToast.__mayDismiss(ZmToast.HOLD));
        if (doDismiss) {
            this._funcs["next"]();
        }
        this._dismissed = true;
        if (this._dismissCallback instanceof AjxCallback) {
            this._dismissCallback.run();
        }
    }
};

ZmToast.prototype.__idle =
function() {
    if (!this._idleTimer) {
        this._idleTimer = new DwtIdleTimer(0, new AjxCallback(this, this.__idleCallback));
    } else {
        this._idleTimer.resurrect(0);
    }
};

ZmToast.prototype.__idleCallback =
function(idle) {
    if (!idle) {
        this.transition();
        this._idleTimer.kill();
    }
};

ZmToast.prototype.__move =
function() {
    // TODO
    this._funcs["next"]();
};

ZmToast.prototype.__fade =
function() {
    var opacity = this._state.value;
    var step = this._state.step;

    // NOTE: IE8 and earlier are slow re-rendering when adjusting
    //       opacity. So we try to do it using filters.
    if (AjxEnv.isIE && !AjxEnv.isIE9up) {
        try {
            var el = this.getHtmlElement();
            el.style.visibility = step > 0 ? "hidden" : "visible";

            var duration = this._state.duration / 1000;
            el.style.filter = "progid:DXImageTransform.Microsoft.Fade(duration="+duration+",overlap=1.0)";

            el.filters[0].Apply();
            el.style.visibility = step > 0 ? "visible" : "hidden";
            el.filters[0].Play();
        }
        catch (e) {
            DBG.println("error: "+e);
        }
        setTimeout(this._funcs["next"], 0);
        return;
    }

    var isOver = step > 0 ? opacity >= this._state.end : opacity <= this._state.end;
    if (isOver) {
        opacity = this._state.end;
    }

    this.setOpacity(opacity);

    if (isOver) {
        this.__clear();
        setTimeout(this._funcs["next"], 0);
        return;
    }

    if (this._actionId == -1) {
        var duration = this._state.duration;
        var delta = duration / Math.abs(step);
        this._actionId = setInterval(this._funcs["fade"], delta);
    }

    this._state.value += step;
    this._state.step *= this._state.multiplier;
};

ZmToast.prototype.__slide =
function() {
    var top = this._state.value;
    var step = this._state.step;

    var isOver = step > 0 ? top >= this._state.end : top <= this._state.end;
    if (isOver) {
        top = this._state.end;
    }

    //this.setOpacity(opacity);
    this.setLocation(null, top);
    //el.style.top = top+'px';


    if (isOver) {
        this.__clear();
        setTimeout(this._funcs["next"], 0);
        return;
    }

    if (this._actionId == -1) {
        var duration = this._state.duration;
        var delta = duration / Math.abs(step);
        this._actionId = setInterval(this._funcs["slide"], delta);
    }

    this._state.value += step;
    this._state.step *= this._state.multiplier;
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmTagMenu")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates an empty tag menu.
 * @class
 * This class represents a menu structure of tags that can be added to or removed
 * from item(s). Based on the items passed in when it renders, it presents a 
 * list of tags that can be added (any tag all the items don't already have), and a
 * list of tags that can be removed (tags that any of the items have).
 * <p>
 * Since the content is set every time it is displayed, the tag menu doesn't need
 * a change listener.</p>
 *
 * @param {DwtControl}	parent		the parent widget
 * @param {ZmController}	controller	the owning controller
 * 
 * @extends		ZmPopupMenu
 */
ZmTagMenu = function(parent, controller) {

	// create a menu (though we don't put anything in it yet) so that parent widget shows it has one
	ZmPopupMenu.call(this, parent, null, parent.getHTMLElId() + "|MENU", controller);

	parent.setMenu(this);
	this._addHash = {};
	this._removeHash = {};
	this._evtMgr = new AjxEventMgr();
	this._desiredState = true;
	this._items = null;
	this._dirty = true;

	// Use a delay to make sure our slow popup operation isn't called when someone
	// is just rolling over a menu item to get somewhere else.
	if (parent instanceof DwtMenuItem) {
		parent.setHoverDelay(ZmTagMenu._HOVER_TIME);
	}
};

ZmTagMenu.prototype = new ZmPopupMenu;
ZmTagMenu.prototype.constructor = ZmTagMenu;

ZmTagMenu.KEY_TAG_EVENT		= "_tagEvent_";
ZmTagMenu.KEY_TAG_ADDED		= "_tagAdded_";
ZmTagMenu.MENU_ITEM_ADD_ID	= "tag_add";
ZmTagMenu.MENU_ITEM_REM_ID	= "tag_remove";

ZmTagMenu._HOVER_TIME = 200;

ZmTagMenu.prototype.toString =
function() {
	return "ZmTagMenu";
};

ZmTagMenu.prototype.addSelectionListener = 
function(listener) {
	this._evtMgr.addListener(DwtEvent.SELECTION, listener);
};

ZmTagMenu.prototype.removeSelectionListener = 
function(listener) {
	this._evtMgr.removeListener(DwtEvent.SELECTION, listener);    	
};

ZmTagMenu.prototype.setEnabled =
function(enabled) {
	// If there are no tags, then enable later
	this._desiredState = enabled;
	if (enabled && !this._tagList) { return; }

	this.parent.setEnabled(enabled);
};

// Dynamically set the list of tags that can be added/removed based on the given list of items.
ZmTagMenu.prototype.set =
function(items, tagList) {
	DBG.println(AjxDebug.DBG3, "set tag menu");
	this._tagList = tagList;
	this._items = items;
	this._dirty = true;

	//commented out since in ZmMailMsgCapsuleView.prototype._resetOperations we call resetOperations of the ctrlr before this set. And I don't think this should enable the button anyway - this should be done elsewhere like it is.
	//another option would have been to reorder but I think this one is the safer one.
	//this.parent.setEnabled(true);

	// Turn on the hover delay.
	if (this.parent instanceof DwtMenuItem) {
		this.parent.setHoverDelay(ZmTagMenu._HOVER_TIME);
	}
};

ZmTagMenu.prototype._doPopup =
function(x, y, kbGenerated) {
	if (this._dirty) {
		// reset the menu
		this.removeChildren();

		if (this._tagList) {
			var rootTag = this._tagList.root;
			var addRemove = this._getAddRemove(this._items, rootTag);
			this._render(rootTag, addRemove);
		}
		this._dirty = false;

		// Remove the hover delay to prevent flicker when mousing around.
		if (this.parent instanceof DwtMenuItem) {
			this.parent.setHoverDelay(0);
		}
	}
	ZmPopupMenu.prototype._doPopup.call(this, x, y, kbGenerated);
};


// Given a list of items, produce two lists: one of tags that could be added (any tag
// that the entire list doesn't have), and one of tags that could be removed (any tag
// that any item has).
ZmTagMenu.prototype._getAddRemove = 
function(items, tagList) {
	// find out how many times each tag shows up in the items
	var tagCount = {};
	var tagRemoveHash = {};
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		if (!item.tags) {
			continue;
		}
		for (var j = 0; j < item.tags.length; j++) {
			var tagName = item.tags[j];
			tagCount[tagName] = tagCount[tagName] || 0;
			tagRemoveHash[tagName]  = true;
			//NOTE hasTag and canAddTag are not interchangeable - for Conv it's possible you can both add the tag and remove (if only some messages are tagged)
			if (!item.canAddTag(tagName)) {
				tagCount[tagName] += 1;
			}
		}
	}
	var remove = AjxUtil.keys(tagRemoveHash);

	var add = [];
	// any tag held by fewer than all the items can be added
	var a = tagList.children.getArray();
	for (i = 0; i < a.length; i++) {
		var tag = a[i];
		tagName = tag.name;
		if (!tagCount[tagName] || (tagCount[tagName] < items.length)) {
			add.push(tagName);
		}
	}

	return {add: add, remove: remove};
};

// Create the list of tags that can be added, and the submenu with the list of
// tags that can be removed.
ZmTagMenu.prototype._render =
function(tagList, addRemove) {

	for (var i = 0; i < addRemove.add.length; i++) {
		var tagName = addRemove.add[i];
		this._addNewTag(this, tagName, tagList, true, null, this._addHash);
	}

	if (addRemove.add.length) {
		new DwtMenuItem({parent:this, style:DwtMenuItem.SEPARATOR_STYLE});
	}

	// add static "New Tag" menu item
	var map = appCtxt.getCurrentController() && appCtxt.getCurrentController().getKeyMapName();
	var addid = map ? (map + "_newtag"):this._htmlElId + "|NEWTAG";
	var removeid = map ? (map + "_removetag"):this._htmlElId + "|REMOVETAG";

	var miNew = this._menuItems[ZmTagMenu.MENU_ITEM_ADD_ID] = new DwtMenuItem({parent:this, id: addid});
	miNew.setText(AjxStringUtil.htmlEncode(ZmMsg.newTag));
	miNew.setImage("NewTag");
	miNew.setShortcut(appCtxt.getShortcutHint(this._keyMap, ZmKeyMap.NEW_TAG));
	miNew.setData(ZmTagMenu.KEY_TAG_EVENT, ZmEvent.E_CREATE);
	miNew.addSelectionListener(new AjxListener(this, this._menuItemSelectionListener), 0);
	miNew.setEnabled(!appCtxt.isWebClientOffline());

	// add static "Remove Tag" menu item
	var miRemove = this._menuItems[ZmTagMenu.MENU_ITEM_REM_ID] = new DwtMenuItem({parent:this, id: removeid});
	miRemove.setEnabled(false);
	miRemove.setText(AjxStringUtil.htmlEncode(ZmMsg.removeTag));
	miRemove.setImage("DeleteTag");

	var removeList = addRemove.remove;
	if (removeList.length > 0) {
		miRemove.setEnabled(true);
		var removeMenu = null;
		if (removeList.length > 1) {
			for (i = 0; i < removeList.length; i++) {
				if (!removeMenu) {
					removeMenu = new DwtMenu({parent:miRemove, className:this._className});
					miRemove.setMenu(removeMenu);
                    removeMenu.setHtmlElementId('REMOVE_TAG_MENU_' + this.getHTMLElId());
				}
				var tagName = removeList[i];
                var tagHtmlId = 'Remove_tag_' + i;
				this._addNewTag(removeMenu, tagName, tagList, false, null, this._removeHash, tagHtmlId);
			}
			// if multiple removable tags, offer "Remove All"
			new DwtMenuItem({parent:removeMenu, style:DwtMenuItem.SEPARATOR_STYLE});
			var mi = new DwtMenuItem({parent:removeMenu, id:"REMOVE_ALL_TAGS"});
			mi.setText(ZmMsg.allTags);
			mi.setImage("TagStack");
			mi.setShortcut(appCtxt.getShortcutHint(this._keyMap, ZmKeyMap.UNTAG));
			mi.setData(ZmTagMenu.KEY_TAG_EVENT, ZmEvent.E_REMOVE_ALL);
			mi.setData(Dwt.KEY_OBJECT, removeList);
			mi.addSelectionListener(new AjxListener(this, this._menuItemSelectionListener), 0);
		}
		else {
			var tag = tagList.getByNameOrRemote(removeList[0]);
			miRemove.setData(ZmTagMenu.KEY_TAG_EVENT, ZmEvent.E_TAGS);
			miRemove.setData(ZmTagMenu.KEY_TAG_ADDED, false);
			miRemove.setData(Dwt.KEY_OBJECT, tag);
			miRemove.addSelectionListener(new AjxListener(this, this._menuItemSelectionListener), 0);
		}		

	}
};

ZmTagMenu.tagNameLength = 20;
ZmTagMenu.prototype._addNewTag =
function(menu, newTagName, tagList, add, index, tagHash, tagHtmlId) {
	var newTag = tagList.getByNameOrRemote(newTagName);
	var mi = new DwtMenuItem({parent:menu, index:index, id:tagHtmlId});
    var tagName = AjxStringUtil.clipByLength(newTag.getName(false),ZmTagMenu.tagNameLength);
	var nameText = newTag.notLocal ? AjxMessageFormat.format(ZmMsg.tagNotLocal, tagName) : tagName;
    mi.setText(nameText);
    mi.setImage(newTag.getIconWithColor());
	mi.setData(ZmTagMenu.KEY_TAG_EVENT, ZmEvent.E_TAGS);
	mi.setData(ZmTagMenu.KEY_TAG_ADDED, add);
	mi.setData(Dwt.KEY_OBJECT, newTag);
	mi.addSelectionListener(new AjxListener(this, this._menuItemSelectionListener), 0);
//	mi.setShortcut(appCtxt.getShortcutHint(null, ZmKeyMap.TAG));
	tagHash[newTag.id] = mi;
};

ZmTagMenu.prototype._menuItemSelectionListener =
function(ev) {
	// Only notify if the node is one of our nodes
	if (ev.item.getData(ZmTagMenu.KEY_TAG_EVENT)) {
		this._evtMgr.notifyListeners(DwtEvent.SELECTION, ev);
	}
};

}
if (AjxPackage.define("zimbraMail.share.view.ZmListView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 */

/**
 * Creates a list view.
 * @class
 * A list view presents a list of items as rows with fields (columns).
 *
 * @author Parag Shah
 * @author Conrad Damon
 *
 * @param {Hash}	params		a hash of parameters
 * @param {DwtComposite}	params.parent		the parent widget
 * @param {String}	params.className		the CSS class
 * @param {constant}	params.posStyle		the positioning style
 * @param {String}	params.id			the HTML ID for element
 * @param {Array}	params.headerList	the list of IDs for columns
 * @param {Boolean}	params.noMaximize	if <code>true</code>, all columns are fixed-width (otherwise, one will expand to fill available space)
 * @param {constant}	params.view			the ID of view
 * @param {constant}	params.type			the type of item displayed
 * @param {ZmListController}	params.controller	the owning controller
 * @param {DwtDropTarget}	params.dropTgt		the drop target
 * @param {Boolean}	params.pageless		if <code>true</code>, enlarge page via scroll rather than pagination
 *        
 * @extends		DwtListView
 */
ZmListView = function(params) {

	if (arguments.length == 0) { return; }
	
	params.id = params.id || ZmId.getViewId(params.view);
	DwtListView.call(this, params);

	this.view = params.view;
	this.type = params.type;
	this._controller = params.controller;
	this.setDropTarget(params.dropTgt);

	// create listeners for changes to the list model, folder tree, and tag list
	this._listChangeListener = new AjxListener(this, this._changeListener);
	this._tagListChangeListener = new AjxListener(this, this._tagChangeListener);
	var tagList = appCtxt.getTagTree();
	if (tagList) {
		tagList.addChangeListener(this._tagListChangeListener);
	}
	var folderTree = appCtxt.getFolderTree();
	if (folderTree) {
		this._boundFolderChangeListener =  this._folderChangeListener.bind(this);
		folderTree.addChangeListener(this._boundFolderChangeListener);
	}

	this._handleEventType = {};
	this._handleEventType[this.type] = true;
	this._disallowSelection = {};
	this._disallowSelection[ZmItem.F_FLAG] = true;
	this._disallowSelection[ZmItem.F_MSG_PRIORITY] = true;
	this._selectAllEnabled = false;

	if (params.dropTgt) {
		var args = {container:this._parentEl, threshold:15, amount:5, interval:10, id:params.id};
		this._dndScrollCallback = new AjxCallback(null, DwtControl._dndScrollCallback, [args]);
		this._dndScrollId = params.id;
	}

	this._isPageless = params.pageless;
	if (this._isPageless) {
		Dwt.setHandler(this._getScrollDiv(), DwtEvent.ONSCROLL, ZmListView.handleScroll);
	}
	this._state = {};
};

ZmListView.prototype = new DwtListView;
ZmListView.prototype.constructor = ZmListView;
ZmListView.prototype.isZmListView = true;

ZmListView.prototype.toString =
function() {
	return "ZmListView";
};


// Consts

ZmListView.KEY_ID							= "_keyId";

// column widths
ZmListView.COL_WIDTH_ICON 					= 19;
ZmListView.COL_WIDTH_NARROW_ICON			= 11;

// TD class for fields
ZmListView.FIELD_CLASS = {};
ZmListView.FIELD_CLASS[ZmItem.F_TYPE]		= "ListViewIcon";
ZmListView.FIELD_CLASS[ZmItem.F_FLAG]		= "Flag";
ZmListView.FIELD_CLASS[ZmItem.F_TAG]		= "Tag";
ZmListView.FIELD_CLASS[ZmItem.F_ATTACHMENT]	= "Attach";

ZmListView.ITEM_FLAG_CLICKED 				= DwtListView._LAST_REASON + 1;
ZmListView.DEFAULT_REPLENISH_THRESHOLD		= 0;

ZmListView.COL_JOIN = "|";

ZmListView.CHECKED_IMAGE = "CheckboxChecked";
ZmListView.UNCHECKED_IMAGE = "CheckboxUnchecked";
ZmListView.CHECKED_CLASS = "ImgCheckboxChecked";
ZmListView.UNCHECKED_CLASS = "ImgCheckboxUnchecked";
ZmListView.ITEM_CHECKED_ATT_NAME = "itemChecked";


ZmListView.prototype._getHeaderList = function() {};

/**
 * Gets the controller.
 * 
 * @return	{ZmListController}		the list controller
 */
ZmListView.prototype.getController =
function() {
	return this._controller;
};

ZmListView.prototype.set =
function(list, sortField) {

	this._sortByString = this._controller._currentSearch && this._controller._currentSearch.sortBy;
    //TODO: We need a longer term fix but this is to prevent a sort by that doesn't match our ZmSearch
	//constants and lead to notification issues.
	if (this._sortByString) {
    	this._sortByString = this._sortByString.replace("asc", "Asc").replace("desc", "Desc");// bug 75687
	}

	var settings = appCtxt.getSettings();
	if (!appCtxt.isExternalAccount() && this.view) {
		appCtxt.set(ZmSetting.SORTING_PREF,
					this._sortByString,
					this.view,
					false, //setDefault
					false, //skipNotify
					null, //account
					settings && !settings.persistImplicitSortPrefs(this.view)); //skipImplicit - do not persist
	}

	this.setSelectionHdrCbox(false);

	// bug fix #28595 - in multi-account, reset tag list change listeners
	if (appCtxt.multiAccounts) {
		var tagList = appCtxt.getTagTree();
		if (tagList) {
			tagList.addChangeListener(this._tagListChangeListener);
		}
	}

	if (this._isPageless) {
		if (this._itemsToAdd) {
			if (this._itemsToAdd.length) {
				this.addItems(this._itemsToAdd);
				this._itemsToAdd = null;
			}
		} else {
			var lvList = list;
			if (list && list.isZmList) {
				list.addChangeListener(this._listChangeListener);
				lvList = list.getSubList(0, list.size());
			}
			DwtListView.prototype.set.call(this, lvList, sortField);
		}
		this._setRowHeight();
	} else {
		var subList;
		if (list && list.isZmList) {
			list.addChangeListener(this._listChangeListener);
			subList = list.getSubList(this.offset, this.getLimit());
		} else {
			subList = list;
		}
		DwtListView.prototype.set.call(this, subList, sortField);
	}
	this._rendered = true;

	// check in case there are more items but no scrollbar
	if (this._isPageless) {
		AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._checkItemCount), 1000);
	}
};

ZmListView.prototype.reset =
function() {
	this._rendered = false;
};

ZmListView.prototype.setUI =
function(defaultColumnSort) {
	DwtListView.prototype.setUI.call(this, defaultColumnSort);
	this._resetColWidth();	// reset column width in case scrollbar is set
};

/**
 * Gets the limit value.
 * 
 * @param	{Boolean}	offset		if <code>true</code>, offset
 * @return	{int}	the limit page size
 */
ZmListView.prototype.getLimit =
function(offset) {
	if (this._isPageless) {
		var limit = appCtxt.get(ZmSetting.PAGE_SIZE);
		return offset ? limit : 2 * limit;
	} else {
		return appCtxt.get(ZmSetting.PAGE_SIZE);
	}
};

/**
 * Gets the pageless threshold.
 * 
 * @return	{int}		the pageless threshold
 */
ZmListView.prototype.getPagelessThreshold =
function() {
	return Math.ceil(this.getLimit() / 5);
};

/**
 * Gets the replenish threshold.
 * 
 * @return	{int}	the replenish threshold
 */
ZmListView.prototype.getReplenishThreshold =
function() {
	return ZmListView.DEFAULT_REPLENISH_THRESHOLD;
};

/**
 * Returns the underlying ZmList.
 */
ZmListView.prototype.getItemList =
function() {
	return this._controller && this._controller._list;
};

ZmListView.prototype._changeListener =
function(ev) {

	var item = this._getItemFromEvent(ev);
	if (!item || ev.handled || !this._handleEventType[item.type]) {
		return;
	}

	if (ev.event === ZmEvent.E_TAGS || ev.event === ZmEvent.E_REMOVE_ALL) {
		this._replaceTagImage(item, ZmItem.F_TAG, this._getClasses(ZmItem.F_TAG));
	}

	if (ev.event === ZmEvent.E_FLAGS) {
		var flags = ev.getDetail("flags");
		for (var j = 0; j < flags.length; j++) {
			var flag = flags[j];
			var on = item[ZmItem.FLAG_PROP[flag]];
			if (flag === ZmItem.FLAG_FLAGGED) {
				this._setImage(item, ZmItem.F_FLAG, on ? "FlagRed" : "FlagDis", this._getClasses(ZmItem.F_FLAG));
			}
			else if (flag === ZmItem.FLAG_ATTACH) {
				this._setImage(item, ZmItem.F_ATTACHMENT, on ? "Attachment" : null, this._getClasses(ZmItem.F_ATTACHMENT));
			}
			else if (flag === ZmItem.FLAG_PRIORITY) {
				this._setImage(item, ZmItem.F_MSG_PRIORITY, on ? "Priority" : "PriorityDis", this._getClasses(ZmItem.F_MSG_PRIORITY));
			}
		}
	}

	// Note: move and delete support batch notification mode
	if (ev.event === ZmEvent.E_DELETE || ev.event === ZmEvent.E_MOVE) {
		var items = ev.batchMode ? this._getItemsFromBatchEvent(ev) : [item];
		var needsSort = false;
		for (var i = 0, len = items.length; i < len; i++) {
			var item = items[i];
            var movedHere = (item.type === ZmId.ITEM_CONV) ? item.folders[this._folderId] : item.folderId === this._folderId;
			if (movedHere && ev.event === ZmEvent.E_MOVE) {
				// We've moved the item into this folder
				if (this._getRowIndex(item) === null) { // Not already here
					this.addItem(item);
					// TODO: couldn't we just find the sort index and insert it?
					needsSort = true;
				}
			}
			else {
				// remove the item if the user is working in this view,
				// if we know the item no longer matches the search, or if the item was hard-deleted
				if (ev.event === ZmEvent.E_DELETE || this.view == appCtxt.getCurrentViewId() || this._controller._currentSearch.matches(item) === false) {
					this.removeItem(item, true, ev.batchMode);
					// if we've removed it from the view, we should remove it from the reference
					// list as well so it doesn't get resurrected via replenishment *unless*
					// we're dealing with a canonical list (i.e. contacts)
					var itemList = this.getItemList();
					if (ev.event !== ZmEvent.E_MOVE || !itemList.isCanonical) {
						itemList.remove(item);
					}
				}
			}
		}
		if (needsSort) {
			this._saveState({scroll: true, selection:true, focus: true});
			this._redoSearch(this._restoreState.bind(this, this._state));
		}
		if (ev.batchMode) {
			this._fixAlternation(0);
		}
		this._checkReplenishOnTimer();
		this._controller._resetToolbarOperations();
	}

	this._updateLabelForItem(item);
};

ZmListView.prototype._getItemFromEvent =
function(ev) {
	var item = ev.item;
	if (!item) {
		var items = ev.getDetail("items");
		item = (items && items.length) ? items[0] : null;
	}
	return item;
};

ZmListView.prototype._getItemsFromBatchEvent =
function(ev) {

	if (!ev.batchMode) { return []; }

	var items = ev.items;
	if (!items) {
		items = [];
		var notifs = ev.getDetail("notifs");
		if (notifs && notifs.length) {
			for (var i = 0, len = notifs.length; i < len; i++) {
				var mod = notifs[i];
				items.push(mod.item || appCtxt.cacheGet(mod.id));
			}
		}
	}

	return items;
};

// refreshes the content of the given field for the given item
ZmListView.prototype._updateField =
function(item, field) {
	var fieldId = this._getFieldId(item, field);
	var el = document.getElementById(fieldId);
	if (el) {
		var html = [];
		var colIdx = this._headerHash[field] && this._headerHash[field]._index;
		this._getCellContents(html, 0, item, field, colIdx, new Date());
		//replace the old inner html with the new updated data
		el.innerHTML = $(html.join("")).html();
	}

	this._updateLabelForItem(item);
};

ZmListView.prototype._checkReplenishOnTimer =
function(ev) {
	if (!this.allSelected) {
		if (!this._isPageless) {
			this._controller._app._checkReplenishListView = this;
		} else {
			// Many rows may be removed quickly, so skip unnecessary replenishes
			if (!this._replenishTimedAction) {
				this._replenishTimedAction = new AjxTimedAction(this, this._handleResponseCheckReplenish);
			}
			AjxTimedAction.scheduleAction(this._replenishTimedAction, 10);
		}
	}
};

ZmListView.prototype._checkReplenish =
function(item, forceSelection) {
	var respCallback = new AjxCallback(this, this._handleResponseCheckReplenish, [false, item, forceSelection]);
	this._controller._checkReplenish(respCallback);
};

ZmListView.prototype._handleResponseCheckReplenish =
function(skipSelection, item, forceSelection) {
	if (this.size() == 0) {
		this._controller._handleEmptyList(this);
	} else {
		this._controller._resetNavToolBarButtons();
	}
	if (!skipSelection) {
		this._setNextSelection(item, forceSelection);
	}
};

ZmListView.prototype._folderChangeListener =
function(ev) {
	// make sure this is current list view
	if (appCtxt.getCurrentController() != this._controller) { return; }
	// see if it will be handled by app's postNotify()
	if (this._controller._app._checkReplenishListView == this) { return; }

	var organizers = ev.getDetail("organizers");
	var organizer = (organizers && organizers.length) ? organizers[0] : ev.source;

	var id = organizer.id;
	var fields = ev.getDetail("fields");
	if (ev.event == ZmEvent.E_MODIFY) {
		if (!fields) { return; }
		if (fields[ZmOrganizer.F_TOTAL]) {
			this._controller._resetNavToolBarButtons();
		}
	}
};

ZmListView.prototype._tagChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_TAG) return;

	var fields = ev.getDetail("fields");

	var divs = this._getChildren();
	var tag = ev.getDetail("organizers")[0];
	for (var i = 0; i < divs.length; i++) {
		var item = this.getItemFromElement(divs[i]);
		if (!item || !item.tags || !item.hasTag(tag.name)) {
			continue;
		}
		var updateRequired = false;
		if (ev.event == ZmEvent.E_MODIFY && (fields && (fields[ZmOrganizer.F_COLOR] || fields[ZmOrganizer.F_NAME]))) {
			//rename could change the color (for remote shared items, from the remote gray icon to local color and vice versa)
			updateRequired = item.tags.length == 1;
		}
		else if (ev.event == ZmEvent.E_DELETE) {
			updateRequired = true;
		}
		else if (ev.event == ZmEvent.E_CREATE) {
			//this could affect item if it had a tag not on tag list (remotely created on shared item, either shared by this user or shared to this user)
			updateRequired = true;
		}
		if (updateRequired) {
			this._replaceTagImage(item, ZmItem.F_TAG, this._getClasses(ZmItem.F_TAG));
		}
	}
};

// returns all child divs for this list view
ZmListView.prototype._getChildren =
function() {
	return this._parentEl.childNodes;
};

// Common routines for createItemHtml()

ZmListView.prototype._getRowId =
function(item) {
	return DwtId.getListViewItemId(DwtId.WIDGET_ITEM_FIELD, this._view, item ? item.id : Dwt.getNextId(), ZmItem.F_ITEM_ROW);
};

// Note that images typically get IDs in _getCellContents().
ZmListView.prototype._getCellId =
function(item, field) {
	if (field == ZmItem.F_DATE) {
		return this._getFieldId(item, field);
	} else if (field == ZmItem.F_SELECTION) {
		return this._getFieldId(item, ZmItem.F_SELECTION_CELL);

	} else {
		return DwtListView.prototype._getCellId.apply(this, arguments);
	}
};

ZmListView.prototype._getCellClass =
function(item, field, params) {
	return ZmListView.FIELD_CLASS[field];
};

ZmListView.prototype._getCellContents =
function(htmlArr, idx, item, field, colIdx, params, classes) {
	if (field == ZmItem.F_SELECTION) {
		idx = this._getImageHtml(htmlArr, idx, "CheckboxUnchecked", this._getFieldId(item, field), classes);
	} else if (field == ZmItem.F_TYPE) {
		idx = this._getImageHtml(htmlArr, idx, ZmItem.ICON[item.type], this._getFieldId(item, field), classes);
	} else if (field == ZmItem.F_FLAG) {
		idx = this._getImageHtml(htmlArr, idx, this._getFlagIcon(item.isFlagged), this._getFieldId(item, field), classes);
	} else if (field == ZmItem.F_TAG) {
		idx = this._getImageHtml(htmlArr, idx, item.getTagImageInfo(), this._getFieldId(item, field), classes);
	} else if (field == ZmItem.F_ATTACHMENT) {
		idx = this._getImageHtml(htmlArr, idx, item.hasAttach ? "Attachment" : null, this._getFieldId(item, field), classes);
	} else if (field == ZmItem.F_DATE) {
		htmlArr[idx++] = AjxDateUtil.computeDateStr(params.now || new Date(), item.date);
	} else if (field == ZmItem.F_PRIORITY) {
        var priorityImage = null;
        if (item.isHighPriority) {
            priorityImage = "PriorityHigh_list";
        } else if (item.isLowPriority) {
			priorityImage = "PriorityLow_list";
		}
		if (priorityImage) {
        	idx = this._getImageHtml(htmlArr, idx, priorityImage, this._getFieldId(item, field), classes);
		} else {
			htmlArr[idx++] = "<div id='" + this._getFieldId(item, field) + "' " + AjxUtil.getClassAttr(classes) + "></div>";
		}
	} else {
		idx = DwtListView.prototype._getCellContents.apply(this, arguments);
	}
	return idx;
};

ZmListView.prototype._getImageHtml =
function(htmlArr, idx, imageInfo, id, classes) {
	htmlArr[idx++] = "<div";
	if (id) {
		htmlArr[idx++] = [" id='", id, "' "].join("");
	}
	htmlArr[idx++] = AjxUtil.getClassAttr(classes);
	htmlArr[idx++] = ">";
	htmlArr[idx++] = AjxImg.getImageHtml(imageInfo || "Blank_16");
	htmlArr[idx++] = "</div>";
	return idx;
};

ZmListView.prototype._getClasses =
function(field, classes) {
	if (this.isMultiColumn && this.isMultiColumn() && this._headerHash[field]) {
		classes = classes || [];
		classes = [this._headerHash[field]._cssClass];
	}
	return classes;
};

ZmListView.prototype._setImage =
function(item, field, imageInfo, classes) {
	var cell = this._getElement(item, field);
	if (cell) {
		if (classes) {
			cell.className = AjxUtil.uniq(classes).join(" ");
		}
		cell.innerHTML = AjxImg.getImageHtml(imageInfo || "Blank_16");
	}
};

ZmListView.prototype._replaceTagImage =
function(item, field, classes) {
	this._setImage(item, field, item.getTagImageInfo(), classes);
};

ZmListView.prototype._getFragmentSpan =
function(item) {
	return ["<span class='ZmConvListFragment' aria-hidden='true' id='",
			this._getFieldId(item, ZmItem.F_FRAGMENT),
			"'>", this._getFragmentHtml(item), "</span>"].join("");
};

ZmListView.prototype._getFragmentHtml =
function(item) {
	return [" - ", AjxStringUtil.htmlEncode(item.fragment, true)].join("");
};

ZmListView.prototype._getFlagIcon =
function(isFlagged, isMouseover, disabled) {
	if (!isFlagged && !isMouseover) {
		return "Blank_16";
	} else if (disabled) {
		return "FlagDis";
	} else {
		return "FlagRed";
	}
};

/**
 * Parse the DOM ID to figure out what got clicked. IDs consist of three to five parts
 * joined by the "|" character.
 *
 *		type		type of ID (zli, zlir, zlic, zlif) - see DwtId.WIDGET_ITEM*)
 * 		view		view identifier (eg "TV")
 * 		item ID		usually numeric
 * 		field		field identifier (eg "fg") - see ZmId.FLG_*
 * 		participant	index of participant
 */
ZmListView.prototype._parseId =
function(id) {
	var parts = id.split(DwtId.SEP);
	if (parts && parts.length) {
		return {view:parts[1], item:parts[2], field:parts[3], participant:parts[4]};
	} else {
		return null;
	}
};

ZmListView.prototype._mouseDownAction =
function(ev, div) {
	return !Dwt.ffScrollbarCheck(ev);
};

ZmListView.prototype._mouseUpAction =
function(ev, div) {
	return !Dwt.ffScrollbarCheck(ev);
};

ZmListView.prototype._getField =
function(ev, div) {

	var target = this._getEventTarget(ev);

	var id = target && target.id || div.id;
	if (!id) {
		return null;
	}

	var data = this._data[div.id];
	var type = data.type;
	if (!type || type != DwtListView.TYPE_LIST_ITEM) {
		return null;
	}

	var m = this._parseId(id);
	if (!m || !m.field) {
		return null;
	}
	return m.field;

};


ZmListView.prototype._mouseOutAction =
function(ev, div) {
	DwtListView.prototype._mouseOutAction.call(this, ev, div);

	var field = this._getField(ev, div);
	if (!field) {
		return true;
	}

	if (field == ZmItem.F_FLAG) {
		var item = this.getItemFromElement(div);
		if (!item.isFlagged) {
			var target = this._getEventTarget(ev);
			AjxImg.setImage(target, this._getFlagIcon(item.isFlagged, false), false, false);
			target.className = this._getClasses(field);
		}
	}
	return true;
};


ZmListView.prototype._mouseOverAction =
function(ev, div) {
	DwtListView.prototype._mouseOverAction.call(this, ev, div);

	var field = this._getField(ev, div);
	if (!field) {
		return true;
	}

	if (field === ZmItem.F_FLAG) {
		var item = this.getItemFromElement(div);
		if (!item.isReadOnly() && !item.isFlagged) {
			var target = this._getEventTarget(ev);
			AjxImg.setDisabledImage(target, this._getFlagIcon(item.isFlagged, true), false);
			target.className = this._getClasses(field);
		}
	}
	return true;
};



ZmListView.prototype._doubleClickAction =
function(ev, div) {
	var target = this._getEventTarget(ev);
	var id = target && target.id || div.id;
	if (!id) { return true; }

	var m = this._parseId(id);
	return (!(m && (m.field == ZmItem.F_FLAG)));
};

ZmListView.prototype._itemClicked =
function(clickedEl, ev) {
	if (appCtxt.get(ZmSetting.SHOW_SELECTION_CHECKBOX) && ev.button == DwtMouseEvent.LEFT) {
		if (!ev.shiftKey && !ev.ctrlKey) {
			// get the field being clicked
			var target = this._getEventTarget(ev);
			var id = (target && target.id && target.id.indexOf("AjxImg") == -1) ? target.id : clickedEl.id;
			var m = id ? this._parseId(id) : null;
			if (m && (m.field == ZmItem.F_SELECTION || m.field == ZmItem.F_SELECTION_CELL)) {
				//user clicked on a checkbox
				if (this._selectedItems.size() == 1) {
					var sel = this._selectedItems.get(0);
					var item = this.getItemFromElement(sel);
					var selFieldId = item ? this._getFieldId(item, ZmItem.F_SELECTION) : null;
					var selField = selFieldId ? document.getElementById(selFieldId) : null;
					if (selField && sel == clickedEl) {
						var isChecked = this._getItemData(sel, ZmListView.ITEM_CHECKED_ATT_NAME);
						this._setImage(item, ZmItem.F_SELECTION, isChecked ? ZmListView.UNCHECKED_IMAGE : ZmListView.CHECKED_IMAGE);
						this._setItemData(sel, ZmListView.ITEM_CHECKED_ATT_NAME, !isChecked);
						if (!isChecked) {
							return; //nothing else to do. It's already selected, and was the only selected one. Nothing to remove
						}
					} else {
						if (selField && !this._getItemData(sel, ZmListView.ITEM_CHECKED_ATT_NAME)) {
							this.deselectAll();
							this._markUnselectedViewedItem(true);
						}
					}
				}
				var bContained = this._selectedItems.contains(clickedEl);
				this.setMultiSelection(clickedEl, bContained);
				this._controller._setItemSelectionCountText();
				return;	// do not call base class if "selection" field was clicked
			}
		} else if (ev.shiftKey) {
			// uncheck all selected items first
			this._checkSelectedItems(false);

			// run base class first so we get the finalized list of selected items
			DwtListView.prototype._itemClicked.call(this, clickedEl, ev);

			// recheck new list of selected items
			this._checkSelectedItems(true);

			return;
		}
	}

	DwtListView.prototype._itemClicked.call(this, clickedEl, ev);
};

ZmListView.prototype._columnClicked =
function(clickedCol, ev) {
	DwtListView.prototype._columnClicked.call(this, clickedCol, ev);
	this._checkSelectionColumnClicked(clickedCol, ev);
};

ZmListView.prototype._checkSelectionColumnClicked =
function(clickedCol, ev) {

	if (!appCtxt.get(ZmSetting.SHOW_SELECTION_CHECKBOX)) { return; }

	var list = this.getList();
	var size = list ? list.size() : null;
	if (size > 0) {
		var idx = this._data[clickedCol.id].index;
		var item = this._headerList[idx];
		if (item && (item._field == ZmItem.F_SELECTION)) {
			var hdrId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ICON, this._view, item._field);
			var hdrDiv = document.getElementById(hdrId);
			if (hdrDiv) {
				if (hdrDiv.className == ZmListView.CHECKED_CLASS) {
					if (ev.shiftKey && !this.allSelected) {
						this.selectAll(ev.shiftKey);
					} else {
						this.deselectAll();
						hdrDiv.className = ZmListView.UNCHECKED_CLASS;
					}
				} else {
					this.allSelected = false;
					hdrDiv.className = ZmListView.CHECKED_CLASS;
					this.selectAll(ev.shiftKey);
				}
			}
		}
		this._controller._resetToolbarOperations();
	}
};

ZmListView.prototype.handleKeyAction =
function(actionCode, ev) {
	var rv = DwtListView.prototype.handleKeyAction.call(this, actionCode, ev);

	if (actionCode == DwtKeyMap.SELECT_ALL) {
		this._controller._resetToolbarOperations();
	}

	return rv;
};

ZmListView.prototype.setMultiSelection =
function(clickedEl, bContained, ev) {
	if (ev && ev.ctrlKey && this._selectedItems.size() == 1) {
		this._checkSelectedItems(true);
	}

	// call base class
	DwtListView.prototype.setMultiSelection.call(this, clickedEl, bContained);

	this.setSelectionCbox(clickedEl, bContained);
	this.setSelectionHdrCbox(this._isAllChecked());

	// reset toolbar operations LAST
	this._controller._resetToolbarOperations();
};

/**
 * check whether all items in the list are checked
 * @return {Boolean} true if all items are checked
 */
ZmListView.prototype._isAllChecked = 
function() {
	var list = this.getList();
	return (list && (this.getSelection().length == list.size()));
};


/**
 * Sets the selection checkbox.
 * 
 * @param	{Element}	obj		the item element object
 * @param	{Boolean}	bContained		(not used)
 * 
 */
ZmListView.prototype.setSelectionCbox =
function(obj, bContained) {
	if (!obj) { return; }

	var item = obj.tagName ? this.getItemFromElement(obj) : obj;
	var selFieldId = item ? this._getFieldId(item, ZmItem.F_SELECTION) : null;
	var selField = selFieldId ? document.getElementById(selFieldId) : null;
	if (selField) {
		this._setImage(item, ZmItem.F_SELECTION, bContained ? ZmListView.UNCHECKED_IMAGE : ZmListView.CHECKED_IMAGE);
		this._setItemData(this._getElFromItem(item), ZmListView.ITEM_CHECKED_ATT_NAME, !bContained);
	}
};

/**
 * Sets the selection header checkbox.
 * 
 * @param	{Boolean}	check		if <code>true</code>, check the header checkbox
 */
ZmListView.prototype.setSelectionHdrCbox =
function(check) {
	var col = this._headerHash ? this._headerHash[ZmItem.F_SELECTION] : null;
	var hdrId = col ? DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ICON, this._view, col._field) : null;
	var hdrDiv = hdrId ? document.getElementById(hdrId) : null;
	if (hdrDiv) {
		hdrDiv.className = check
			? ZmListView.CHECKED_CLASS
			: ZmListView.UNCHECKED_CLASS;
	}
};

/**
 * Sets the selected items.
 * 
 * @param	{Array}	selectedArray		an array of {Element} objects to select
 * @param	{boolean}	dontCheck		do not check the selected item. (special case. see ZmListView.prototype._restoreState)
 */
ZmListView.prototype.setSelectedItems =
function(selectedArray, dontCheck) {
	DwtListView.prototype.setSelectedItems.call(this, selectedArray);

	if (!dontCheck && appCtxt.get(ZmSetting.SHOW_SELECTION_CHECKBOX)) {
		this._checkSelectedItems(true, true);
	}
};

/**
 * Selects all items.
 * 
 * @param	{Boolean}	allResults		if <code>true</code>, set all search selected
 */
ZmListView.prototype.selectAll =
function(allResults) {

	DwtListView.prototype.selectAll.apply(this, arguments);

	if (this._selectAllEnabled) {
		var curResult = this._controller._activeSearch;
		if (curResult && curResult.getAttribute("more")) {

			var list = this.getList(),
				type = this.type,
				countKey = 'type' + AjxStringUtil.capitalize(ZmItem.MSG_KEY[type]),
				typeText = AjxMessageFormat.format(ZmMsg[countKey], list ? list.size() : 2),
				shortcut = appCtxt.getShortcutHint(null, ZmKeyMap.SELECT_ALL),
				args = [list ? list.size() : ZmMsg.all, typeText, shortcut, "ZmListView.selectAllResults()"],
				toastMsg = AjxMessageFormat.format(ZmMsg.allPageSelected, args);

			if (allResults) {
				this.allSelected = true;
				toastMsg = ZmMsg.allSearchSelected;
			}
			appCtxt.setStatusMsg(toastMsg);
		}

		var sel = this._selectedItems.getArray();
		for (var i = 0; i < sel.length; i++) {
			this.setSelectionCbox(sel[i], false);
		}
	}
};

// Handle click of link in toast
ZmListView.selectAllResults =
function() {
	var ctlr = appCtxt.getCurrentController();
	var view = ctlr && ctlr.getListView();
	if (view && view.selectAll) {
		view.selectAll(true);
	}
};

/**
 * Deselects all items.
 * 
 */
ZmListView.prototype.deselectAll =
function() {

	this.allSelected = false;
	if (appCtxt.get(ZmSetting.SHOW_SELECTION_CHECKBOX)) {
		this._checkSelectedItems(false);
		var hdrId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ICON, this._view, ZmItem.F_SELECTION);
		var hdrDiv = document.getElementById(hdrId);
		if (hdrDiv) {
			hdrDiv.className = ZmListView.UNCHECKED_CLASS;
		}
		var sel = this._selectedItems.getArray();
		for (var i=0; i<sel.length; i++) {
			this.setSelectionCbox(sel[i], true);
		}
	}

	DwtListView.prototype.deselectAll.call(this);
};

ZmListView.prototype._checkSelectedItems =
function(check) {
	var sel = this.getSelection();
	for (var i = 0; i < sel.length; i++) {
		this.setSelectionCbox(sel[i], !check);
	}

	var list = this.getList();
	var size = list && list.size();
	this.setSelectionHdrCbox(size && sel.length == size);
};

ZmListView.prototype._setNoResultsHtml =
function() {
	DwtListView.prototype._setNoResultsHtml.call(this);
	this.setSelectionHdrCbox(false);
	this._rendered = true;
};

/**
 * override to call _resetToolbarOperations since we change the selection.
 * @private
 */
ZmListView.prototype._clearRightSel =
function() {
	DwtListView.prototype._clearRightSel.call(this);
	this._controller._resetToolbarOperations();
};


/*
 get sort menu for views that provide a right-click sort by menu in single-column view (currently mail and briefcase)
 */
ZmListView.prototype._getSortMenu = function (sortFields, defaultSortField, parent) {

	// create an action menu for the header list
	var menu = new ZmPopupMenu(parent || this, null, Dwt.getNextId("SORT_MENU_"));
	var actionListener = this._sortMenuListener.bind(this);

	for (var i = 0; i < sortFields.length; i++) {
		var column = sortFields[i];
		var fieldName = ZmMsg[column.msg];
		var mi = menu.createMenuItem(column.field, {
			text:   parent && parent.isDwtMenuItem ? fieldName : AjxMessageFormat.format(ZmMsg.arrangeBy, fieldName),
			style:  DwtMenuItem.RADIO_STYLE
		});
		if (column.field == defaultSortField) {
			mi.setChecked(true, true);
		}
		mi.setData(ZmListView.KEY_ID, column.field);
		menu.addSelectionListener(column.field, actionListener);
	}

	return menu;
};

/*
listener used by views that provide a right-click sort by menu in single-column view (currently mail and briefcase)
 */
ZmListView.prototype._sortMenuListener =
function(ev) {
	var column;
	if (this.isMultiColumn()) { //this can happen when called from the view menu, that now, for accessibility reasons, includes the sort, for both reading pane on right and at the bottom.
		var sortField = ev && ev.item && ev.item.getData(ZmOperation.MENUITEM_ID);
		column = this._headerHash[sortField];
	}
	else {
		column = this._headerHash[ZmItem.F_SORTED_BY];
		var cell = document.getElementById(DwtId.getListViewHdrId(DwtId.WIDGET_HDR_LABEL, this._view, column._field));
		if (cell) {
	        var text = ev.item.getText();
	        cell.innerHTML = text && text.replace(ZmMsg.sortBy, ZmMsg.sortedBy);
		}
		column._sortable = ev.item.getData(ZmListView.KEY_ID);
	}
	this._bSortAsc = (column._sortable === this._currentSortColId) ? !this._bSortAsc : this._isDefaultSortAscending(column);
	this._sortColumn(column, this._bSortAsc);
};

ZmListView.prototype._getActionMenuForColHeader = function(force, parent, context) {

	var menu;
	if (!this._colHeaderActionMenu || force) {
		// create an action menu for the header list
		menu = new ZmPopupMenu(parent || this);
		var actionListener = this._colHeaderActionListener.bind(this);
		for (var i = 0; i < this._headerList.length; i++) {
			var hCol = this._headerList[i];
			// lets not allow columns w/ relative width to be removed (for now) - it messes stuff up
			if (hCol._width) {
				var id = ZmId.getMenuItemId([ this._view, context ].join("_"), hCol._field);
				var mi = menu.createMenuItem(id, {text:hCol._name, style:DwtMenuItem.CHECK_STYLE});
				mi.setData(ZmListView.KEY_ID, hCol._id);
				mi.setChecked(hCol._visible, true);
                if (hCol._noRemove) {
					mi.setEnabled(false);
				}
				menu.addSelectionListener(id, actionListener);
			}
		}
	}

	return menu;
};

ZmListView.prototype._colHeaderActionListener =
function(ev) {

	var menuItemId = ev.item.getData(ZmListView.KEY_ID);

	for (var i = 0; i < this._headerList.length; i++) {
		var col = this._headerList[i];
		if (col._id == menuItemId) {
			col._visible = !col._visible;
			break;
		}
	}

	this._relayout();
};

/**
 * Gets the tool tip content.
 * 
 * @param	{Object}	ev		the hover event
 * @return	{String}	the tool tip content
 */
ZmListView.prototype.getToolTipContent = function(ev) {

	var div = this.getTargetItemDiv(ev);
	if (!div) {
        return "";
    }
	var target = Dwt.findAncestor(this._getEventTarget(ev), "id"),
	    id = (target && target.id) || div.id;

	if (!id) {
        return "";
    }

	// check if we're hovering over a column header
	var data = this._data[div.id];
	var type = data.type;
	var tooltip;
	if (type && type == DwtListView.TYPE_HEADER_ITEM) {
		var itemIdx = data.index;
		var field = this._headerList[itemIdx]._field;
		tooltip = this._getHeaderToolTip(field, itemIdx);
	}
    else {
		var match = this._parseId(id);
		if (match && match.field) {
			var item = this.getItemFromElement(div);
			var params = {field:match.field, item:item, ev:ev, div:div, match:match};
			tooltip = this._getToolTip(params);
		}
	}

	return tooltip;
};

ZmListView.prototype.getTooltipBase =
function(hoverEv) {
	return hoverEv ? DwtUiEvent.getTargetWithProp(hoverEv.object, "id") : DwtListView.prototype.getTooltipBase.apply(this, arguments);
};

ZmListView.prototype._getHeaderToolTip =
function(field, itemIdx, isOutboundFolder) {

	var tooltip = null;
	var sortable = this._headerList[itemIdx]._sortable;
	if (field == ZmItem.F_SELECTION) {
		tooltip = ZmMsg.selectionColumn;
	} else if (field == ZmItem.F_FLAG) {
        tooltip = ZmMsg.flagHeaderToolTip;
    } else if (field == ZmItem.F_PRIORITY){
        tooltip = ZmMsg.priorityHeaderTooltip;
    } else if (field == ZmItem.F_TAG) {
        tooltip = ZmMsg.tag;
    } else if (field == ZmItem.F_ATTACHMENT) {
        tooltip = ZmMsg.attachmentHeaderToolTip;
    } else if (field == ZmItem.F_SUBJECT) {
        tooltip = sortable ? ZmMsg.sortBySubject : ZmMsg.subject;
    } else if (field == ZmItem.F_DATE) {
		if (sortable) {
			if (isOutboundFolder) {
				tooltip = (this._folderId == ZmFolder.ID_DRAFTS) ? ZmMsg.sortByLastSaved : ZmMsg.sortBySent;
			} else {
				tooltip = ZmMsg.sortByReceived;
			}
		} else {
			tooltip = ZmMsg.date;
		}
    } else if (field == ZmItem.F_FROM) {
        tooltip = sortable ? isOutboundFolder ? ZmMsg.sortByTo : ZmMsg.sortByFrom : isOutboundFolder ? ZmMsg.to : ZmMsg.from ;
    } else if (field == ZmItem.F_SIZE){
        tooltip = sortable ? ZmMsg.sortBySize : ZmMsg.sizeToolTip;
	} else if (field == ZmItem.F_ACCOUNT) {
		tooltip = ZmMsg.account;
    } else if (field == ZmItem.F_FOLDER) {
        tooltip = ZmMsg.folder;
    } else if (field == ZmItem.F_MSG_PRIORITY) {
		tooltip = ZmMsg.messagePriority
	} 
    
    return tooltip;
};

/**
 * @param params		[hash]			hash of params:
 *        field			[constant]		column ID
 *        item			[ZmItem]*		underlying item
 *        ev			[DwtEvent]*		mouseover event
 *        div			[Element]*		row div
 *        match			[hash]*			fields from div ID
 *        callback		[AjxCallback]*	callback (in case tooltip content retrieval is async)
 *        
 * @private
 */
ZmListView.prototype._getToolTip =
function(params) {
    var tooltip, field = params.field, item = params.item, div = params.div;
	if (field == ZmItem.F_FLAG) {
		return null; //no tooltip for the flag
    } else if (field == ZmItem.F_PRIORITY) {
        if (item.isHighPriority) {
            tooltip = ZmMsg.highPriorityTooltip;
        } else if (item.isLowPriority) {
            tooltip = ZmMsg.lowPriorityTooltip;
        }
    } else if (field == ZmItem.F_TAG) {
        tooltip = this._getTagToolTip(item);
    } else if (field == ZmItem.F_ATTACHMENT) {
        // disable att tooltip for now, we only get att info once msg is loaded
        // tooltip = this._getAttachmentToolTip(item);
    } else if (div && (field == ZmItem.F_DATE)) {
        tooltip = this._getDateToolTip(item, div);
    }
    return tooltip;
};

/*
 * Get the list of fields for the accessibility label. Normally, this
 * corresponds to the header columns.
 *
 * @protected
 */
ZmListView.prototype._getLabelFieldList =
function() {
	var headers = this._getHeaderList();

	if (headers) {
		return AjxUtil.map(headers, function(header) {
			return header._field;
		});
	}
};

/*
 * Get the accessibility label corresponding to the given field.
 *
 * @protected
 */
ZmListView.prototype._getLabelForField =
function(item, field) {
	var tooltip = this._getToolTip({ item: item, field: field });
	// TODO: fix for tooltips that are callbacks (such as for appts)
	return AjxStringUtil.stripTags(tooltip);
};

ZmListView.prototype._updateLabelForItem =
function(item) {
	var fields = this._getLabelFieldList();
	var itemel = this._getElFromItem(item);

	if (!item || !fields || !itemel) {
		return;
	}

	var buf = [];

	for (var i = 0; i < fields.length; i++) {
		var label = this._getLabelForField(item, fields[i]);

		if (label) {
			buf.push(label);
		}
	}

	if (buf.length > 0) {
		itemel.setAttribute('aria-label', buf.join(', '));
	} else {
		itemel.removeAttribute('aria-label');
	}
};

ZmListView.prototype._getTagToolTip =
function(item) {
	if (!item) { return; }
	var numTags = item.tags && item.tags.length;
	if (!numTags) { return; }
	var tagList = appCtxt.getAccountTagList(item);
	var tags = item.tags;
	var html = [];
	var idx = 0;
    for (var i = 0; i < numTags; i++) {
		var tag = tagList.getByNameOrRemote(tags[i]);
        if (!tag) { continue; }        
		var nameText = tag.notLocal ? AjxMessageFormat.format(ZmMsg.tagNotLocal, tag.name) : tag.name;
        html[idx++] = "<table><tr><td>";
		html[idx++] = AjxImg.getImageHtml(tag.getIconWithColor());
		html[idx++] = "</td><td valign='middle'>";
		html[idx++] = AjxStringUtil.htmlEncode(nameText);
		html[idx++] = "</td></tr></table>";
	}
	return html.join("");
};

ZmListView.prototype._getAttachmentToolTip =
function(item) {
	var tooltip = null;
	var atts = item && item.attachments ? item.attachments : [];
	if (atts.length == 1) {
		var info = ZmMimeTable.getInfo(atts[0].ct);
		tooltip = info ? info.desc : null;
	} else if (atts.length > 1) {
		tooltip = AjxMessageFormat.format(ZmMsg.multipleAttachmentsTooltip, [atts.length]);
	}
	return tooltip;
};

ZmListView.prototype._getDateToolTip =
function(item, div) {
	div._dateStr = div._dateStr || this._getDateToolTipText(item.date);
	return div._dateStr;
};

ZmListView.prototype._getDateToolTipText =
function(date, prefix) {
	if (!date) { return ""; }
	var dateStr = [];
	var i = 0;
	dateStr[i++] = prefix;
	var dateFormatter = AjxDateFormat.getDateTimeInstance(AjxDateFormat.FULL, AjxDateFormat.MEDIUM);
	dateStr[i++] = dateFormatter.format(new Date(date));
	var delta = AjxDateUtil.computeDateDelta(date);
	if (delta) {
		dateStr[i++] = "<br><center><span style='white-space:nowrap'>(";
		dateStr[i++] = delta;
		dateStr[i++] = ")</span></center>";
	}
	return dateStr.join("");
};

/*
* Add a few properties to the list event for the listener to pick up.
*/
ZmListView.prototype._setListEvent =
function (ev, listEv, clickedEl) {
	DwtListView.prototype._setListEvent.call(this, ev, listEv, clickedEl);
	var target = this._getEventTarget(ev);
	var id = (target && target.id && target.id.indexOf("AjxImg") == -1) ? target.id : clickedEl.id;
	if (!id) return false; // don't notify listeners

	var m = this._parseId(id);
	if (ev.button == DwtMouseEvent.LEFT) {
		this._selEv.field = m ? m.field : null;
	} else if (ev.button == DwtMouseEvent.RIGHT) {
		this._actionEv.field = m ? m.field : null;
		if (m && m.field) {
			if (m.field == ZmItem.F_PARTICIPANT) {
				var item = this.getItemFromElement(clickedEl);
				this._actionEv.detail = item.participants ? item.participants.get(m.participant) : null;
			}
		}
	}
	return true;
};

ZmListView.prototype._allowLeftSelection =
function(clickedEl, ev, button) {
	// We only care about mouse events
	if (!(ev instanceof DwtMouseEvent)) { return true; }
	var target = this._getEventTarget(ev);
	var id = (target && target.id && target.id.indexOf("AjxImg") == -1) ? target.id : clickedEl.id;
	var data = this._data[clickedEl.id];
	var type = data.type;
	if (id && type && type == DwtListView.TYPE_LIST_ITEM) {
		var m = this._parseId(id);
		if (m && m.field) {
			return this._allowFieldSelection(m.item, m.field);
		}
	}
	return true;
};

ZmListView.prototype._allowFieldSelection =
function(id, field) {
	return (!this._disallowSelection[field]);
};

ZmListView.prototype._redoSearch =
function(callback) {
	var search = this._controller._currentSearch;
	if (!search) {
		return;
	}
	var sel = this.getSelection();
	var selItem = sel && sel[0];
	var changes = {
		isRedo: true,
		selectedItem: selItem
	};
	appCtxt.getSearchController().redoSearch(search, false, changes, callback);
};

ZmListView.prototype._sortColumn = function(columnItem, bSortAsc, callback) {

	// change the sort preference for this view in the settings
	var sortBy;
	switch (columnItem._sortable) {
		case ZmItem.F_FROM:		    sortBy = bSortAsc ? ZmSearch.NAME_ASC : ZmSearch.NAME_DESC; break;
        case ZmItem.F_TO:           sortBy = bSortAsc ? ZmSearch.RCPT_ASC : ZmSearch.RCPT_DESC; break;
		case ZmItem.F_NAME:		    sortBy = bSortAsc ? ZmSearch.SUBJ_ASC : ZmSearch.SUBJ_DESC; break; //used for Briefcase only now. SUBJ is mappaed to the filename of the document on the server side
		case ZmItem.F_SUBJECT:	    sortBy = bSortAsc ? ZmSearch.SUBJ_ASC : ZmSearch.SUBJ_DESC;	break;
		case ZmItem.F_DATE:		    sortBy = bSortAsc ? ZmSearch.DATE_ASC : ZmSearch.DATE_DESC;	break;
		case ZmItem.F_SIZE:		    sortBy = bSortAsc ? ZmSearch.SIZE_ASC : ZmSearch.SIZE_DESC;	break;
        case ZmItem.F_FLAG:		    sortBy = bSortAsc ? ZmSearch.FLAG_ASC : ZmSearch.FLAG_DESC;	break;
        case ZmItem.F_ATTACHMENT:   sortBy = bSortAsc ? ZmSearch.ATTACH_ASC : ZmSearch.ATTACH_DESC; break;
		case ZmItem.F_READ:		    sortBy = bSortAsc ? ZmSearch.READ_ASC : ZmSearch.READ_DESC;	break;
        case ZmItem.F_PRIORITY:     sortBy = bSortAsc ? ZmSearch.PRIORITY_ASC : ZmSearch.PRIORITY_DESC; break;
		case ZmItem.F_SORTED_BY:    sortBy = bSortAsc ? ZmSearch.DATE_ASC : ZmSearch.DATE_DESC;	break;
	}

	if (sortBy) {
		this._currentSortColId = columnItem._sortable;
		//special case - switching from read/unread to another sort column - remove it from the query, so users are not confused that they still see only unread messages after clicking on another sort column.
		if (columnItem._sortable != ZmItem.F_READ && (this._sortByString == ZmSearch.READ_ASC || this._sortByString == ZmSearch.READ_DESC)) {
			var controller = this._controller;
			var query = controller.getSearchString();
			if (query) {
				 controller.setSearchString(AjxStringUtil.trim(query.replace("is:unread", "")));
			}
		}
		this._sortByString = sortBy;
		var skipFirstNotify = this._folderId ? true : false; //just making it explicit boolean
        if (!appCtxt.isExternalAccount()) {
			var settings = appCtxt.getSettings();
           	appCtxt.set(ZmSetting.SORTING_PREF,
					   sortBy,
					   this.view,
					   false, //setDefault
					   skipFirstNotify, //skipNotify
					   null, //account
					   settings && !settings.persistImplicitSortPrefs(this.view)); //skipImplicit
            if (this._folderId) {
                appCtxt.set(ZmSetting.SORTING_PREF, sortBy, this._folderId);
            }
        }
		if (!this._isMultiColumn) {
			this._setSortedColStyle(columnItem._id);
		}
	}
	if (callback) {
		callback.run();
	}
};

ZmListView.prototype._setNextSelection =
function(item, forceSelection) {
	// set the next appropriate selected item
	if (this.firstSelIndex < 0) {
		this.firstSelIndex = 0;
	}
	if (this._list && !item) {
		item = this._list.get(this.firstSelIndex) || this._list.getLast();
    }
	if (item) {
		this.setSelection(item, false, forceSelection);
	}
};

ZmListView.prototype._relayout =
function() {
	DwtListView.prototype._relayout.call(this);
	this._checkColumns();
};

ZmListView.prototype._checkColumns =
function() {
	var numCols = this._headerList.length;
	var fields = [];
	for (var i = 0; i < numCols; i++) {
		var headerCol = this._headerList[i];
		// bug 43540: always skip account header since its a multi-account only
		// column and we don't want it to sync
		if (headerCol && headerCol._field != ZmItem.F_ACCOUNT) {
			fields.push(headerCol._field + (headerCol._visible ? "" : "*"));
		}
	}
	var value = fields.join(ZmListView.COL_JOIN);
	value = (value == this._defaultCols) ? "" : value;
    if (!appCtxt.isExternalAccount() && !this._controller.isSearchResults) {
	    appCtxt.set(ZmSetting.LIST_VIEW_COLUMNS, value, appCtxt.getViewTypeFromId(this.view));
    }

	this._colHeaderActionMenu = this._getActionMenuForColHeader(true); // re-create action menu so order is correct
};

/**
 * Scroll-based paging. Make sure we have at least one page of items below the visible list.
 * 
 * @param ev
 */
ZmListView.handleScroll =
function(ev) {
	var target = DwtUiEvent.getTarget(ev);
	var lv = DwtControl.findControl(target);
	if (lv) {
		lv._checkItemCount();
	}
};

/**
 * Figure out if we should fetch some more items, based on where the scroll is. Our goal is to have
 * a certain number available below the bottom of the visible view.
 */
ZmListView.prototype._checkItemCount =
function() {
	var itemsNeeded = this._getItemsNeeded();
	if (itemsNeeded) {
		this._controller._paginate(this._view, true, null, itemsNeeded);
	}
};

/**
 * Figure out how many items we need to fetch to maintain a decent number
 * below the fold. Nonstandard list views may override.
 */
ZmListView.prototype._getItemsNeeded =
function(skipMoreCheck) {

	if (!skipMoreCheck) {
		var itemList = this.getItemList();
		if (!(itemList && itemList.hasMore()) || !this._list) { return 0; }
	}
	if (!this._rendered || !this._rowHeight) { return 0; }

	DBG.println(AjxDebug.DBG2, "List view: checking item count");

	var sbCallback = new AjxCallback(null, AjxTimedAction.scheduleAction, [new AjxTimedAction(this, this._resetColWidth), 100]);
	var params = {scrollDiv:	this._getScrollDiv(),
				  rowHeight:	this._rowHeight,
				  threshold:	this.getPagelessThreshold(),
				  limit:		this.getLimit(1),
				  listSize:		this._list.size(),
				  sbCallback:	sbCallback};
	return ZmListView.getRowsNeeded(params);
};

ZmListView.prototype._getScrollDiv =
function() {
	return this._parentEl;
};

ZmListView.getRowsNeeded =
function(params) {

	var div = params.scrollDiv;
	var sh = div.scrollHeight, st = div.scrollTop, rh = params.rowHeight;

	// view (porthole) height - everything measured relative to its top
	// prefer clientHeight since (like scrollHeight) it doesn't include borders
	var h = div.clientHeight || Dwt.getSize(div).y;

	// where we'd like bottom of list view to be (with extra hidden items at bottom)
	var target = h + (params.threshold * rh);

	// where bottom of list view is (including hidden items)
	var bottom = sh - st;

	if (bottom == h) {
		// handle cases where there's no scrollbar, but we have more items (eg tall browser, or replenishment)
		bottom = (params.listSize * rh) - st;
		if (st == 0 && params.sbCallback) {
			// give list view a chance to fix width since it may be getting a scrollbar
			params.sbCallback.run();
		}
	}

	var rowsNeeded = 0;
	if (bottom < target) {
		// buffer below visible bottom of list view is not full
		rowsNeeded = Math.max(Math.floor((target - bottom) / rh), params.limit);
	}
	return rowsNeeded;
};

ZmListView.prototype._sizeChildren =
function(height) {
	if (DwtListView.prototype._sizeChildren.apply(this, arguments)) {
		this._checkItemCount();
	}
};

// Allow list view classes to override type used in nav text. Return null to say "items".
ZmListView.prototype._getItemCountType =
function() {
	return this.type;
};

/**
 * Checks if the given item is in this view's list. Note that the view's list may
 * be only part of the controller's list (the currently visible page).
 *
 * @param {String|ZmItem}	item		the item ID, or item to check for
 * @return	{Boolean}	<code>true</code> if the item is in the list
 */
ZmListView.prototype.hasItem =
function(item) {

	var id = (typeof item == "string") ? item : item && item.id;
	if (id && this._list) {
		var a = this._list.getArray();
		for (var i = 0, len = a.length; i < len; i++) {
			var item = a[i];
			if (item && item.id == id) {
				return true;
			}
		}
	}
	return false;
};

/**
 * The following methods allow a list view to maintain state after it has
 * been rerendered. State may include such elements as: which items are selected,
 * focus, scroll position, etc.
 *
 * @private
 * @param {hash}		params		hash of parameters:
 * @param {boolean}		selection	if true, preserve selection
 * @param {boolean}		focus		if true, preserve focus
 * @param {boolean}		scroll		if true, preserve scroll position
 */
ZmListView.prototype._saveState =
function(params) {

	var s = this._state = {};
	params = params || {};
	if (params.selection) {
		s.selected = this.getSelection();
		if (s.selected.length == 1) {
			//still a special case for now till we rewrite this thing.
			var el = this._getElFromItem(s.selected[0]); //terribly ugly, get back to the html element so i can have access to the item data
			s.singleItemChecked = this._getItemData(el, ZmListView.ITEM_CHECKED_ATT_NAME);
		}
	}
	if (params.focus) {
		s.focused = this.hasFocus();
		s.anchorItem = this._kbAnchor && this.getItemFromElement(this._kbAnchor);
	}
	if (params.scroll) {
		s.rowHeight = this._rowHeight;
		s.scrollTop = this._listDiv.scrollTop;
	}
};

ZmListView.prototype._restoreState =
function(state) {

	var s = state || this._state;
	if (s.selected && s.selected.length) {
		var dontCheck = s.selected.length == 1 && !s.singleItemChecked;
		this.setSelectedItems(s.selected, dontCheck);
	}
	if (s.anchorItem) {
		var el = this._getElFromItem(s.anchorItem);
		if (el) {
			this._setKbFocusElement(el);
		}
	}
	if (s.focused) {
		this.focus();
	}
	// restore scroll position based on row height ratio
	if (s.rowHeight) {
		this._listDiv.scrollTop = s.scrollTop * (this._rowHeight / s.rowHeight);
	}
	this._state = {};
};

ZmListView.prototype._renderList =
function(list, noResultsOk, doAdd) {
    var group = this._group;
    if (!group) {
        return DwtListView.prototype._renderList.call(this, list, noResultsOk, doAdd);
    }
	if (list instanceof AjxVector && list.size()) {
		var now = new Date();
		var size = list.size();
		var htmlArr = [];
        var section;
        var headerDiv;
		for (var i = 0; i < size; i++) {
			var item = list.get(i);
			var div = this._createItemHtml(item, {now:now}, !doAdd, i);
			if (div) {
				if (div instanceof Array) {
					for (var j = 0; j < div.length; j++){
                        section = group.addMsgToSection(item, div[j]);
                        if (group.getSectionSize(section) == 1){
                            headerDiv = this._getSectionHeaderDiv(group, section);
                            this._addRow(headerDiv);
                        }
						this._addRow(div[j]);
					}
				} else if (div.tagName || doAdd) {
                    section = group.addMsgToSection(item, div);
                    if (group.getSectionSize(section) == 1){
                        headerDiv = this._getSectionHeaderDiv(group, section);
                        this._addRow(headerDiv);
                    }
                    this._addRow(div);
				} else {
                    group.addMsgToSection(item, div);
				}
			}
		}
		if (group && !doAdd) {
			group.resetSectionHeaders();
			htmlArr.push(group.getAllSections(this._bSortAsc));
		}

		if (htmlArr.length && !doAdd) {
			this._parentEl.innerHTML = htmlArr.join("");
		}
	} else if (!noResultsOk) {
		this._setNoResultsHtml();
	}

};

ZmListView.prototype._addRow =
function(row, index) {
	DwtListView.prototype._addRow.apply(this, arguments);

	this._updateLabelForItem(this.getItemFromElement(row));
};

ZmListView.prototype._itemAdded = function(item) {
    item.refCount++;
};

ZmListView.prototype._getSectionHeaderDiv =
function(group, section) {
    if (group && section) {
        var headerDiv = document.createElement("div");
        var sectionTitle = group.getSectionTitle(section);
        var html = group.getSectionHeader(sectionTitle);
        headerDiv.innerHTML = html;
        return headerDiv.firstChild;
    }
};

ZmListView.prototype.deactivate =
function() {
	this._controller.inactive = true;
};

ZmListView.prototype._getEventTarget =
function(ev) {
	var target = ev && ev.target;
	if (target && (target.nodeName === "IMG" || (target.className && target.className.match(/\bImg/)))) {
		return target.parentNode;
	}
	return target;
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmOverviewContainer")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates an overview container.
 * @constructor
 * @class
 * Creates a header tree item for an account if mailbox has multiple accounts
 * configured. For each account header, a {@link ZmOverview} is added a child. If mailbox
 * only has one account configured, no account header is created and the
 * {@link ZmOverview} is added as a child of the container.
 *
 * @param	{Hash}	params		a hash of parameters
 * @author Parag Shah
 */
ZmOverviewContainer = function(params) {
	if (arguments.length == 0) { return; }

	params.className = params.className || "ZmOverviewContainer";
	params.id = params.id || ZmId.getOverviewContainerId(params.containerId);
	DwtTree.call(this, params);

	this.setScrollStyle(params.scroll || Dwt.SCROLL_Y);

	this.containerId = params.containerId;
	this._appName = params.appName;
	this._controller = params.controller;
	this._headerItems = {};
	this._overview = {};

	// add listeners
	this.addSelectionListener(new AjxListener(this, this._treeViewListener));
	this.addTreeListener(new AjxListener(this, this._treeListener));
};

ZmOverviewContainer.prototype = new DwtTree;
ZmOverviewContainer.prototype.constructor = ZmOverviewContainer;

ZmOverviewContainer.prototype.toString =
function() {
	return "ZmOverviewContainer";
};

/**
 * Initializes the overview container.
 * 
 * @param	{Hash}	params		a hash of parameters
 */
ZmOverviewContainer.prototype.initialize =
function(params) {
	// overload
};

/**
 * Gets the overview.
 * 
 * @param	{String}	overviewId		the overview id
 * @return	{ZmOverview}		the overview
 */
ZmOverviewContainer.prototype.getOverview =
function(overviewId) {
	return this._overview[overviewId];
};

/**
 * Gets the overviews.
 * 
 * @return	{Array}	an array of {ZmOverview} objects
 */
ZmOverviewContainer.prototype.getOverviews =
function() {
	return this._overview;
};

/**
 * Gets the header item.
 * 
 * 
 */
ZmOverviewContainer.prototype.getHeaderItem =
function() {
	// overload
};

/**
 * Gets the selected overview.
 * 
 * @return	{ZmOverview}	the overview
 */
ZmOverviewContainer.prototype.getSelected =
function() {
	var selected;
	for (var i in this._overview) {
		selected = this._overview[i].getSelected();
		if (selected) {
			return selected;
		}
	}
};

/**
 * Deselects all tree views for each overview in this container
 *
 * @param exception		[ZmOverview]*	If set, this overview is skipped during deselection
 */
ZmOverviewContainer.prototype.deselectAll =
function(exception) {
	DwtTree.prototype.deselectAll.call(this);
	this._deselectAllTreeViews(exception);
};

/**
 * Sets the overview trees.
 * 
 * @param	{Array}		treeIds		an array of tree ids
 */
ZmOverviewContainer.prototype.setOverviewTrees =
function(treeIds) {
	for (var i in this._overview) {
		this._overview[i].set(treeIds);
	}
};

/**
 * Resets the operations.
 * 
 * 
 */
ZmOverviewContainer.prototype.resetOperations =
function(parent, acctId) {
	// overload me
};

ZmOverviewContainer.prototype._treeViewListener =
function(ev) {
	// overload
};

ZmOverviewContainer.prototype._treeListener =
function(ev) {
	// overload
};

ZmOverviewContainer.prototype._initializeActionMenu =
function(account) {
	// overload
};

ZmOverviewContainer.prototype._getActionMenu =
function(ev) {
	if (this._actionMenu instanceof AjxCallback) {
		var callback = this._actionMenu;
		this._actionMenu = callback.run();
	}
	return this._actionMenu;
};

ZmOverviewContainer.prototype._createActionMenu =
function(parent, menuItems, account) {
	// overload
};

ZmOverviewContainer.prototype._actionMenuListener =
function(ev) {
	// overload
};

/**
 * Deselects any selection for each overview this container is managing.
 *
 * @param exception		[ZmOverview]*	If set, deselects all overviews except this one.
 */
ZmOverviewContainer.prototype._deselectAllTreeViews =
function(exception) {
	// make sure none of the other items in the other overviews are selected
	for (var i in this._overview) {
		var overview = this._overview[i];
		if (exception && exception == overview ) { continue; }

		var trees = overview._treeHash;
		for (var j in trees) {
			if (trees[j].getSelectionCount() > 0) {
				trees[j].deselectAll();
				break;
			}
		}
	}
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmAccountOverviewContainer")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates an overview container for a multi-account mailbox.
 * @class
 * Creates a header tree item for an account if mailbox has multiple accounts
 * configured. For each account header, a {@link ZmOverview} is added a child. If mailbox
 * only has one account configured, no account header is created and the
 * {@link ZmOverview} is added as a child of the container.
 *
 * @param	{Hash}	params		a hash of parameters
 * 
 * @author Parag Shah
 */
ZmAccountOverviewContainer = function(params) {
	if (arguments.length == 0) { return; }

	ZmOverviewContainer.call(this, params);

	this._vFolderTreeItemMap = {};
	this._settingChangeListener = new AjxListener(this, this._handleSettingChange);

	var mouseListener = new AjxListener(this, this._mouseListener);
	this.addListener(DwtEvent.ONMOUSEDOWN, mouseListener);
	this.addListener(DwtEvent.ONMOUSEUP, mouseListener);
};

ZmAccountOverviewContainer.prototype = new ZmOverviewContainer;
ZmAccountOverviewContainer.prototype.constructor = ZmAccountOverviewContainer;


// Consts
ZmAccountOverviewContainer.VIRTUAL_FOLDERS = [
	ZmFolder.ID_INBOX,
	ZmFolder.ID_SENT,
	ZmFolder.ID_DRAFTS,
	ZmFolder.ID_SPAM,
	ZmFolder.ID_OUTBOX,
	ZmFolder.ID_TRASH
];


// Public methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmAccountOverviewContainer.prototype.toString =
function() {
	return "ZmAccountOverviewContainer";
};

ZmAccountOverviewContainer.prototype.getHeaderItem =
function(account) {
	return account && this._headerItems[account.id];
};

/**
 * Expands the given account only (collapses all other accounts).
 *
 * @param {ZmAccount}	account		the account to expand
 */
ZmAccountOverviewContainer.prototype.expandAccountOnly =
function(account) {
	if (!account) {
		account = appCtxt.getActiveAccount();
	}

	for (var i in this._headerItems) {
		this._headerItems[i].setExpanded((i == account.id), false, false);
	}
};

ZmAccountOverviewContainer.prototype.getSelected =
function() {
	var selected = ZmOverviewContainer.prototype.getSelected.call(this);

	if (!selected) {
		selected = this.getSelection()[0];
		var account = selected && appCtxt.accountList.getAccount(selected.getData(Dwt.KEY_ID));
		var tree = account && appCtxt.getFolderTree(account);
		return tree && tree.root;
	}

	return selected;
};

/**
 * Initializes the account overview.
 * 
 * @param	{Hash}	params		a hash of parameters
 * 
 */
ZmAccountOverviewContainer.prototype.initialize =
function(params) {

	var header, acct;
	var accounts = appCtxt.accountList.visibleAccounts;
	var showAllMailboxes = (appCtxt.isOffline && this._appName == ZmApp.MAIL && (accounts.length > 2));
	var showBackgroundColor = showAllMailboxes;
	var mainAcct = appCtxt.accountList.mainAccount;
	var origOmit = params.omit;

	for (var i = 0; i < accounts.length; i++) {
		acct = accounts[i];
		// skip the main account in offline mode since we'll add it at the end
		if (appCtxt.isOffline && acct.isMain && this._appName != ZmApp.PREFERENCES) { continue; }
		if (!acct.active) { continue; }

		 params.omit = {};

		if (acct.type == ZmAccount.TYPE_POP) {
			params.omit[ZmFolder.ID_SPAM]   = true;
			params.omit[ZmFolder.ID_OUTBOX] = true;
		}

        if(params.overviewId && !params.isAppOverview) {
            var overviewId = params.overviewId.split(":")[1];
            if(overviewId && (overviewId == "ZmNewOrganizerDialog")){
                params.omit[ZmFolder.ID_DRAFTS] = true;
            }
        }

		this._addAccount(params, acct, showBackgroundColor, null, "account" + i);

		header = this.getHeaderItem(acct);
		if (header) {
			this._setupHeader(header, acct);
		}

		this.updateAccountInfo(acct, true, true);

		showBackgroundColor = !showBackgroundColor;
	}

	// add "All Mailboxes"
	skip = origOmit && origOmit[ZmOrganizer.ID_ALL_MAILBOXES];
	if (showAllMailboxes && !skip) {
		var text = ZmMsg[ZmFolder.MSG_KEY[ZmOrganizer.ID_ALL_MAILBOXES]];
		var hdrText = appCtxt.get(ZmSetting.OFFLINE_ALL_MAILBOXES_TREE_OPEN)
			? text : this._getFolderLabel(ZmOrganizer.ID_INBOX, text);
		var params1 = {
			parent: this,
			text: hdrText,
			imageInfo: "AccountAll"
		};
		var showAllMboxes = appCtxt.get(ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES);
		var allTi = this._allMailboxesTreeHeader = new DwtTreeItem(params1);
		allTi.setData(Dwt.KEY_ID, ZmOrganizer.ID_ALL_MAILBOXES);
		allTi.addClassName("ZmOverviewGlobalInbox");
		allTi._initialize(0, true);
		allTi.setVisible(showAllMboxes);
		allTi.__origText = text;
		if (showAllMboxes) {
			this.highlightAllMboxes();
		}

		var setting = appCtxt.getSettings(mainAcct).getSetting(ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES);
		setting.addChangeListener(this._settingChangeListener);

		var folders = ZmAccountOverviewContainer.VIRTUAL_FOLDERS;
		for (var i = 0; i < folders.length; i++) {
			var folderId = folders[i];

			// add virtual system folders
			params1 = {
				parent: allTi,
				text: this._getFolderLabel(folderId, ZmMsg[ZmFolder.MSG_KEY[folderId]]),
				imageInfo: ZmFolder.ICON[folderId]
			};
			var ti = this._vFolderTreeItemMap[folderId] = new DwtTreeItem(params1);
			ti.setData(Dwt.KEY_ID, folderId);
			ti.addClassName("DwtTreeItemChildDiv");
			ti._initialize(null, true);
			ti.setToolTipContent(appCtxt.accountList.getTooltipForVirtualFolder(folderId));
		}

		// add global searches
		params1 = {
			parent: allTi,
			text: ZmMsg.globalSearches,
			imageInfo: "SearchFolder"
		};
		var searchTi = this._searchTreeHeader = new DwtTreeItem(params1);
		searchTi.addClassName("DwtTreeItemChildDiv");
		searchTi._initialize(null, true);
		searchTi.__isSearch = true;

		var root = appCtxt.getById(ZmOrganizer.ID_ROOT, mainAcct);
		var searchFolders = root.getByType(ZmOrganizer.SEARCH);
		for (var i = 0; i < searchFolders.length; i++) {
			var folder = searchFolders[i];
			if (folder.id != ZmOrganizer.ID_ALL_MAILBOXES &&
				folder.isOfflineGlobalSearch)
			{
				this.addSearchFolder(folder);
			}
		}
		searchTi.setVisible(searchTi.getItemCount() > 0);

		// bug #43734 - set expand/collapse state based on user's pref
		if (appCtxt.get(ZmSetting.OFFLINE_SAVED_SEARCHES_TREE_OPEN)) {
			searchTi.setExpanded(true, null, true);
		}
		if (appCtxt.get(ZmSetting.OFFLINE_ALL_MAILBOXES_TREE_OPEN)) {
			allTi.setExpanded(true, null, true);
		}
	}

	// add the "local" account last
	if (appCtxt.isOffline) {
		var params2 = AjxUtil.hashCopy(params);
		params2.omit = {};

		if (this._appName != ZmApp.PREFERENCES) {
			this._addAccount(params2, mainAcct, showBackgroundColor, "ZmOverviewLocalHeader", "LocalFolders");

			header = this.getHeaderItem(mainAcct);
			header.setExpanded(appCtxt.get(ZmSetting.ACCOUNT_TREE_OPEN, null, mainAcct));

			this.updateAccountInfo(mainAcct, false, true);
		}
		else {
			var params3 = {
				parent: this,
				text: mainAcct.getDisplayName(),
				imageInfo: mainAcct.getIcon()
			};
			var localPrefTi = new DwtTreeItem(params3);
			localPrefTi._initialize(null, true);

			var globalPrefOverviewId = appCtxt.getOverviewId(this.containerId, mainAcct);
			var tv = this._overview[globalPrefOverviewId].getTreeView(ZmOrganizer.PREF_PAGE);
			var importExportTi = tv.getTreeItemById("PREF_PAGE_IMPORT_EXPORT");

			tv.getHeaderItem().removeChild(importExportTi);
			localPrefTi._addItem(importExportTi);
			importExportTi.addClassName("DwtTreeItemChildDiv");
			localPrefTi.setExpanded(true, null, true);
		}
	}

	// add zimlets at the end of all overviews
	var skip = params.omit && params.omit[ZmOrganizer.ID_ZIMLET];

	if (!appCtxt.inStartup && !skip && appCtxt.getZimletMgr().getPanelZimlets().length == 0) {
		skip = true;
	}

	if (!skip) {
		AjxDispatcher.require("Zimlet");
	}

	if (!skip && window[ZmOverviewController.CONTROLLER[ZmOrganizer.ZIMLET]] &&
		this._appName != ZmApp.PREFERENCES)
	{
		var headerLabel = ZmOrganizer.LABEL[ZmOrganizer.ZIMLET];
		var headerDataId = params.overviewId = appCtxt.getOverviewId([this.containerId, headerLabel], null);
		var headerParams = {
			label: ZmMsg[headerLabel],
			icon: "Zimlet",
			dataId: headerDataId,
			className: "ZmOverviewZimletHeader"
		};
		params.overviewTrees = [ZmOrganizer.ZIMLET];

		this._addSection(headerParams, null, params);

		var header = this._headerItems[headerDataId];
		if (header) {
			header.__isZimlet = true;
			header.setExpanded(appCtxt.get(ZmSetting.ZIMLET_TREE_OPEN, null, mainAcct));
		}
	}

	this._initializeActionMenu();
};

/**
 * Adds a search folder.
 * 
 * @param	{ZmFolder}		folder		the folder
 */
ZmAccountOverviewContainer.prototype.addSearchFolder =
function(folder) {
	if (!this._searchTreeHeader) { return; }

	var params = {
		parent: this._searchTreeHeader,
		text: folder.getName(),
		imageInfo: folder.getIcon()
	};
	var ti = new DwtTreeItem(params);
	ti.setData(Dwt.KEY_ID, folder);
	ti._initialize(null, true);

	if (!this._searchTreeHeader.getVisible()) {
		this._searchTreeHeader.setVisible(true);
	}
};

/**
 * Sets/updates the account-level status icon next to account name tree header.
 * This only applies to app-based overview containers (i.e. not dialogs). Also resets the
 * tooltip for the account header tree item.
 *
 * @param {ZmZimbraAccount}	account		the account to update status icon for
 * @param	{Boolean}	updateStatus	if <code>true</code>, update the status
 * @param	{Boolean}	updateTooltip	if <code>true</code>, update the tool tip
 */
ZmAccountOverviewContainer.prototype.updateAccountInfo =
function(account, updateStatus, updateTooltip) {
	// check if appName is a real app (and not a dialog) before setting the account status
	var hi = appCtxt.getApp(this._appName) && this.getHeaderItem(account);
	if (hi) {
		if (updateStatus) {
			var html = (account.status == ZmZimbraAccount.STATUS_RUNNING)
				? ("<img src='/img/animated/ImgSpinner.gif' width=16 height=16 border=0>")
				: (AjxImg.getImageHtml(account.getStatusIcon()));

			if (hi._extraCell) {
				hi._extraCell.innerHTML = (html || "");
			}
            if (appCtxt.isOffline && account.status == ZmZimbraAccount.STATUS_AUTHFAIL) {
                var dialog = appCtxt.getPasswordChangeDialog();
                dialog.popup(account);
            }
		}

		if (updateTooltip || updateStatus) {
			hi.setToolTipContent(account.getToolTip());
		}
	}
};

/**
 * Updates the label.
 * 
 * @param	{ZmOrganizer}	organizer		the organizer
 */
ZmAccountOverviewContainer.prototype.updateLabel =
function(organizer) {
	// update account header if necessary
	if (organizer.nId == ZmOrganizer.ID_INBOX) {
		var acct = organizer.getAccount();
		var header = this.getHeaderItem(acct);
		if (header && !header.getExpanded()) {
			header.setText(this._getAccountHeaderLabel(acct));
		}
	}

	// update virtual folder label
	var ti = this._vFolderTreeItemMap[organizer.nId];
	if (ti) {
		ti.setText(this._getFolderLabel(organizer.nId, organizer.name));
		if (organizer.nId == ZmOrganizer.ID_INBOX &&
			!this._allMailboxesTreeHeader.getExpanded())
		{
			var text = this._getFolderLabel(organizer.nId, this._allMailboxesTreeHeader.__origText);
			this._allMailboxesTreeHeader.setText(text);
		}
	}
};

/**
 * Updates the tool tip.
 * 
 * @param	{String}	folderId		the folder id
 * 
 */
ZmAccountOverviewContainer.prototype.updateTooltip =
function(folderId) {
	var ti = this._allMailboxesTreeHeader && this._vFolderTreeItemMap[folderId];
	if (ti) {
		ti.setToolTipContent(appCtxt.accountList.getTooltipForVirtualFolder(folderId));
	}
};

ZmAccountOverviewContainer.prototype.resetOperations =
function(parent, data) {

	var emptyFolderOp = parent.getOp(ZmOperation.EMPTY_FOLDER);

	if (data instanceof ZmSearchFolder) {
		parent.getOp(ZmOperation.MARK_ALL_READ).setVisible(false);
		emptyFolderOp.setVisible(false);
		parent.getOp(this._newOp).setVisible(false);
		if (appCtxt.isOffline) {
			parent.getOp(ZmOperation.SYNC).setVisible(false);
		}
		parent.getOp(ZmOperation.DELETE).setVisible(true);
		return;
	}

	var acct = appCtxt.accountList.getAccount(data);
	var isAcctType = (acct || data == ZmOrganizer.ID_ALL_MAILBOXES);

	parent.getOp(ZmOperation.MARK_ALL_READ).setVisible(!isAcctType);
	emptyFolderOp.setVisible(false);
	parent.getOp(this._newOp).setVisible(isAcctType && data != ZmOrganizer.ID_ALL_MAILBOXES);
	if (appCtxt.isOffline) {
		parent.getOp(ZmOperation.SYNC).setVisible(isAcctType && (!acct || (acct && !acct.isMain)));
	}
	parent.getOp(ZmOperation.DELETE).setVisible(false);

	if (isAcctType) {
		parent.enable(this._newOp, true); 
		parent.enable(ZmOperation.SYNC, (!acct || (acct && !acct.isMain)));
	} else {
		// reset mark all based on a "friendly" hack ;)
		var markAllEnabled = false;
		if (data != ZmOrganizer.ID_OUTBOX && data != ZmFolder.ID_DRAFTS &&
			this._actionedHeaderItem.getText().indexOf("bold") != -1)
		{
			markAllEnabled = true;
		}
		parent.enable(ZmOperation.MARK_ALL_READ, markAllEnabled);

		// reset empty "folder" based on Trash/Junk
		if (data == ZmOrganizer.ID_TRASH || data == ZmOrganizer.ID_SPAM) {
			var text = (data == ZmOrganizer.ID_TRASH) ? ZmMsg.emptyTrash : ZmMsg.emptyJunk;
			emptyFolderOp.setText(text);
			emptyFolderOp.setVisible(true);
			parent.enable(ZmOperation.EMPTY_FOLDER, !this._isFolderEmpty(data));
		}
	}
};

// HACK - when the overview container for mail is initially created, zimlet
// data has yet to be parsed so we remove the zimlet section after zimlet load
// if there are no panel zimlets.
ZmAccountOverviewContainer.prototype.removeZimletSection =
function() {
	var headerLabel = ZmOrganizer.LABEL[ZmOrganizer.ZIMLET];
	var headerDataId = appCtxt.getOverviewId([this.containerId, headerLabel], null);
	var header = this._headerItems[headerDataId];
	if (header) {
		this.removeChild(header);
	}
};

ZmAccountOverviewContainer.prototype.highlightAllMboxes =
function() {
	this.deselectAll();
	this.setSelection(this._allMailboxesTreeHeader, true);
};

ZmAccountOverviewContainer.prototype._addAccount =
function(params, account, showBackgroundColor, headerClassName, predictableId) {
	params.overviewId = appCtxt.getOverviewId(this.containerId, account);
	params.account = account;	// tree controller might need reference to account

	// only show sections for apps that are supported unless this is prefs app
	var app = appCtxt.getApp(this._appName);
	var isSupported = (!app || (app && appCtxt.get(ZmApp.SETTING[this._appName], null, account)));

	if (this._appName == ZmApp.PREFERENCES || isSupported) {
		var omit = params.omitPerAcct
			? params.omitPerAcct[account.id] : params.omit;

		var headerLabel, headerIcon;
		if (this._appName == ZmApp.PREFERENCES && account.isMain && appCtxt.isOffline) {
			headerLabel = ZmMsg.allAccounts;
			headerIcon = "AccountAll";
		} else {
			headerLabel = account.getDisplayName();
			if (!appCtxt.isFamilyMbox) {
				headerIcon = account.getIcon()
			}
		}

		var headerParams = {
			label: headerLabel,
			icon: headerIcon,
			dataId: account.id,
			className: headerClassName,
			predictableId: predictableId
		};

		this._addSection(headerParams, omit, params, showBackgroundColor);
	}

	var setting = appCtxt.getSettings(account).getSetting(ZmSetting.QUOTA_USED);
	setting.addChangeListener(this._settingChangeListener);
};

ZmAccountOverviewContainer.prototype._addSection =
function(headerParams, omit, overviewParams, showBackgroundColor) {
	// create a top-level section header
	var params = {
		parent: this,
		text:			headerParams.label,
		imageInfo:		headerParams.icon,
		selectable:		overviewParams.selectable,
		className:		headerParams.className,
		id:				this.getHTMLElId() + "__" + (headerParams.predictableId || headerParams.dataId) + "__SECTION"
	};
	var header = this._headerItems[headerParams.dataId] = new DwtTreeItem(params);
	header.setData(Dwt.KEY_ID, headerParams.dataId);
	header.setScrollStyle(Dwt.CLIP);
	header._initialize(null, true, true);
	header.addClassName(showBackgroundColor ? "ZmOverviewSectionHilite" : "ZmOverviewSection");

	// reset some params for child overviews
	overviewParams.id = ZmId.getOverviewId(overviewParams.overviewId);
	overviewParams.parent = header;
	overviewParams.scroll = Dwt.CLIP;
	overviewParams.posStyle = Dwt.STATIC_STYLE;

	// next, create an overview for this account and add it to the account header
	var ov = this._controller._overview[overviewParams.overviewId] = this._overview[overviewParams.overviewId] = new ZmOverview(overviewParams, this._controller);
	header._dndScrollCallback = this._overview._dndScrollCallback,
	header._dndScrollId = this._overview._scrollableContainerId,
	header._addItem(ov, null, true);

	// finally set treeviews for this overview
	var treeIds = overviewParams.overviewTrees || overviewParams.treeIds;
	ov.set(treeIds, omit);
};

ZmAccountOverviewContainer.prototype._setupHeader =
function(header, acct) {
	// always expand header in prefs app, otherwise follow implicit user pref
	if (this._appName == ZmApp.PREFERENCES) {
		header.setExpanded(true, false, true);
		header.enableSelection(false);
	} else {
		var isExpanded = appCtxt.get(ZmSetting.ACCOUNT_TREE_OPEN, null, acct);
		header.setExpanded(isExpanded);
		if (!isExpanded) {
			header.setText(this._getAccountHeaderLabel(acct));
		}
	}

	// add onclick support
	if (header._extraCell) {
		header._extraCell.onclick = AjxCallback.simpleClosure(this._handleStatusClick, this, acct);
	}

	// add DnD support
	var dropTgt = this._controller.getTreeController(ZmOrganizer.FOLDER).getDropTarget();
	var root = ZmOrganizer.getSystemId(ZmOrganizer.ID_ROOT, acct);
	header.setDropTarget(dropTgt);
	header.setData(Dwt.KEY_OBJECT, appCtxt.getById(root));
};

/**
 * Iterates all visible account and checks whether folder for each account is
 * empty. Used by "All Mailboxes" to determine whether a virtual folder needs
 * to be disabled or not when right-clicked.
 *
 * @param folderId		[String]		Normalized folder ID (should not be fully qualified)
 */
ZmAccountOverviewContainer.prototype._isFolderEmpty =
function(folderId) {
	var accounts = appCtxt.accountList.visibleAccounts;
	for (var i = 0; i < accounts.length; i++) {
		var folder = appCtxt.getById(ZmOrganizer.getSystemId(folderId, accounts[i]));
		if (folder && folder.numTotal > 0) {
			return false;
		}
	}

	return true;
};

ZmAccountOverviewContainer.prototype._syncAccount =
function(dialog, account) {
	dialog.popdown();
	account.sync();
};

ZmAccountOverviewContainer.prototype._treeViewListener =
function(ev) {
	if (ev.detail != DwtTree.ITEM_ACTIONED &&
		ev.detail != DwtTree.ITEM_SELECTED &&
		ev.detail != DwtTree.ITEM_DBL_CLICKED)
	{
		return;
	}

	var item = this._actionedHeaderItem = ev.item;

	// do nothing if zimlet/search is clicked
	if (item && (item.__isZimlet || item.__isSearch)) { return; }

	var data = item && item.getData(Dwt.KEY_ID);

	if (ev.detail == DwtTree.ITEM_ACTIONED && appCtxt.getApp(this._appName)) {	// right click
		var actionMenu = this._getActionMenu(data);
		if (actionMenu) {
			this.resetOperations(actionMenu, data);
			actionMenu.popup(0, ev.docX, ev.docY);
		}
	}
	else if ((ev.detail == DwtTree.ITEM_SELECTED) && item) {					// left click
		// if calendar/prefs app, do nothing
		if (this._appName == ZmApp.CALENDAR ||
			this._appName == ZmApp.PREFERENCES)
		{
			return;
		}

		this._deselectAllTreeViews();

		// this avoids processing clicks in dialogs etc.
		if (!ZmApp.NAME[this._appName]) { return; }

		// if an account header item was clicked, run the default search for it
		if (data) {
			var sc = appCtxt.getSearchController();

			var account = appCtxt.accountList.getAccount(data);
			if (account) {
				// bug 41196 - turn off new mail notifier if inactive account header clicked
				if (appCtxt.isOffline && account.inNewMailMode) {
					account.inNewMailMode = false;
					var allContainers = appCtxt.getOverviewController()._overviewContainer;
					for (var i in allContainers) {
						allContainers[i].updateAccountInfo(account, true, true);
					}
				}

				// don't process click if user clicked on error status icon
				if ((ev.target.parentNode == ev.item._extraCell) && account.isError()) {
					return;
				}

				sc.searchAllAccounts = false;
				appCtxt.accountList.setActiveAccount(account);

				if (appCtxt.isOffline && account.hasNotSynced() && !account.__syncAsked) {
					account.__syncAsked = true;

					var dialog = appCtxt.getYesNoMsgDialog();
					dialog.registerCallback(DwtDialog.YES_BUTTON, this._syncAccount, this, [dialog, account]);
					dialog.setMessage(ZmMsg.neverSyncedAsk, DwtMessageDialog.INFO_STYLE);
					dialog.popup();
				}

				var fid = ZmOrganizer.DEFAULT_FOLDER[ZmApp.ORGANIZER[this._appName]];
				var folder = appCtxt.getById(ZmOrganizer.getSystemId(fid, account));

				// briefcase is not a ZmFolder so let's skip for now
				if (!(folder instanceof ZmFolder)) { return; }

				var defaultSortBy = (this._appName == ZmApp.TASKS)
					? ZmSearch.DUE_DATE_DESC : ZmSearch.DATE_DESC;

				var params = {
					query: folder.createQuery(),
					getHtml: appCtxt.get(ZmSetting.VIEW_AS_HTML),
					searchFor: (ZmApp.DEFAULT_SEARCH[this._appName]),
					sortBy: ((sc.currentSearch && folder.nId == sc.currentSearch.folderId) ? null : defaultSortBy),
					accountName: (account && account.name),
					noUpdateOverview: true
				};
			} else {
				var main = appCtxt.accountList.mainAccount;
				sc.resetSearchAllAccounts();
				sc.searchAllAccounts = true;

				if (data instanceof ZmSearchFolder) {
					params = {
						searchAllAccounts: true,
						accountName: main.name,
						getHtml: appCtxt.get(ZmSetting.VIEW_AS_HTML),
						noUpdateOverview: true
					};
					sc.redoSearch(data.search, false, params);
					return;
				}
				if (data == ZmOrganizer.ID_ALL_MAILBOXES) {
					data = ZmFolder.ID_INBOX;
				}

				params = {
					queryHint: appCtxt.accountList.generateQuery(data),
					folderId: null,
					getHtml: appCtxt.get(ZmSetting.VIEW_AS_HTML, null, main),
					searchFor: (ZmApp.DEFAULT_SEARCH[this._appName]),
					sortBy: ZmSearch.DATE_DESC,
					accountName: main.name,
					noUpdateOverview: true
				};
			}

			sc.search(params);
		}
	} else {																	// double click
		// handle double click?
	}
};

ZmAccountOverviewContainer.prototype._treeListener =
function(ev) {
	if (ev.detail != DwtTree.ITEM_COLLAPSED &&
		ev.detail != DwtTree.ITEM_EXPANDED)
	{
		return;
	}

	var header = ev.item;
	var expanded = ev.detail == DwtTree.ITEM_EXPANDED;

	var acct;
	if (header) {
		if (header.__isSearch) {
			appCtxt.set(ZmSetting.OFFLINE_SAVED_SEARCHES_TREE_OPEN, expanded);
			return;
		}

		var data = header.getData(Dwt.KEY_ID);
		if (data == ZmOrganizer.ID_ALL_MAILBOXES) {
			var text = expanded
				? header.__origText
				: this._getFolderLabel(ZmOrganizer.ID_INBOX, header.__origText);
			header.setText(text);

			// bug #43734 - remember expand/collapse state
			appCtxt.set(ZmSetting.OFFLINE_ALL_MAILBOXES_TREE_OPEN, expanded);

			return;
		}

		acct = header.__isZimlet
			? appCtxt.accountList.mainAccount
			: appCtxt.accountList.getAccount(data);
	}

	if (acct && appCtxt.getCurrentAppName() != ZmApp.PREFERENCES) {
		if (!appCtxt.inStartup) {
            // set account as active when account tree is opened/closed
            appCtxt.accountList.setActiveAccount(acct);
			appCtxt.set(ZmSetting.ACCOUNT_TREE_OPEN, expanded, null, null, null, acct);
		}

		if (!header.__isZimlet) {
			var text = expanded
				? acct.getDisplayName()
				: this._getAccountHeaderLabel(acct);
			header.setText(text);
		}
	}
};

ZmAccountOverviewContainer.prototype._mouseListener =
function(ev) {
	return !Dwt.ffScrollbarCheck(ev);
};

ZmAccountOverviewContainer.prototype._handleSettingChange =
function(ev) {
	if (ev.type != ZmEvent.S_SETTING) { return; }

	var setting = ev.source;

	if (setting.id == ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES) {
		var isVisible = setting.getValue();
		this._allMailboxesTreeHeader.setVisible(isVisible);
		if (!isVisible) {
			if (appCtxt.getActiveAccount().isMain) {
				appCtxt.accountList.setActiveAccount(appCtxt.accountList.defaultAccount);
			}
			appCtxt.getSearchController().searchAllAccounts = false;
			appCtxt.getApp(ZmApp.MAIL).mailSearch();
		} else {
			this._deselect(this._allMailboxesTreeHeader);
		}
	}
	else if (setting.id == ZmSetting.QUOTA_USED) {
		this.updateAccountInfo(ev.getDetails().account, false, true);
	}
};

ZmAccountOverviewContainer.prototype._getAccountHeaderLabel =
function(acct, header) {
	var inboxId = (this._appName == ZmApp.MAIL)
		? ZmOrganizer.getSystemId(ZmOrganizer.ID_INBOX, acct, true) : null;
	var inbox = inboxId && appCtxt.getById(inboxId);
	if (inbox && inbox.numUnread > 0) {
		var name = AjxMessageFormat.format(ZmMsg.folderUnread, [acct.getDisplayName(), inbox.numUnread]);
		return (["<span style='font-weight:bold;'>", name, "</span>"].join(""));
	}

	return acct.getDisplayName();
};

ZmAccountOverviewContainer.prototype._getFolderLabel =
function(folderId, label) {
	var checkUnread = (folderId != ZmFolder.ID_DRAFTS && folderId != ZmFolder.ID_OUTBOX);
	var count = appCtxt.accountList.getItemCount(folderId, checkUnread);
	if (count > 0) {
		var name = AjxMessageFormat.format(ZmMsg.folderUnread, [label, count]);
		return (["<span style='font-weight:bold;'>", name, "</span>"].join(""));
	}

	return label;
};

ZmAccountOverviewContainer.prototype._initializeActionMenu =
function() {
	if (!this._actionMenu) {
		var orgType = ZmApp.ORGANIZER[this._appName];
		this._newOp = ZmOrganizer.NEW_OP[orgType];

		var ops = [this._newOp];
		if (appCtxt.isOffline) {
			ops.push(ZmOperation.SYNC);
		}
		ops.push(ZmOperation.MARK_ALL_READ,
				ZmOperation.EMPTY_FOLDER,
				ZmOperation.DELETE);

		this._actionMenu = new AjxCallback(this, this._createActionMenu, [ops]);
	}
};

ZmAccountOverviewContainer.prototype._createActionMenu =
function(menuItems) {
	var listener = new AjxListener(this, this._actionMenuListener);
	var actionMenu = new ZmActionMenu({parent:appCtxt.getShell(), menuItems:menuItems});
	menuItems = actionMenu.opList;
	for (var i = 0; i < menuItems.length; i++) {
		var mi = actionMenu.getItem(i);
		var op = menuItems[i];
		if (op == ZmOperation.SYNC) {
			mi.setText(ZmMsg.sendReceive);
		}
		actionMenu.addSelectionListener(op, listener);
	}

	actionMenu.addPopdownListener(new AjxListener(this, this._menuPopdownActionListener));

	return actionMenu;
};

ZmAccountOverviewContainer.prototype._menuPopdownActionListener =
function() {
	this._actionedHeaderItem._setActioned(false);
};

ZmAccountOverviewContainer.prototype._actionMenuListener =
function(ev) {
	var opId = ev.item.getData(ZmOperation.KEY_ID);
	var data = this._actionedHeaderItem.getData(Dwt.KEY_ID);

	if (opId == this._newOp) {
		var treeId = ZmApp.ORGANIZER[this._appName];
		var tc = this._controller.getTreeController(treeId, true);
		if (tc) {
			tc._actionedOrganizer = null;
			var account = appCtxt.accountList.getAccount(data);
			tc._actionedOrganizer = appCtxt.getFolderTree(account).root;
			tc._newListener(ev, account);
		}
	}
	else if (opId == ZmOperation.SYNC) {
		if (data == ZmOrganizer.ID_ALL_MAILBOXES) {
			appCtxt.accountList.syncAll();
		} else {
			var account = appCtxt.accountList.getAccount(data);
			if (account) {
				account.sync();
			}
		}
	}
	else if (opId == ZmOperation.MARK_ALL_READ) {
		this._doAction(data, opId);
	}
	else if (opId == ZmOperation.EMPTY_FOLDER) {
		this._confirmEmptyAction(data, opId);
	}
	else if (opId == ZmOperation.DELETE) {
		data._delete();
		var parent = this._actionedHeaderItem.parent;
		parent.removeChild(this._actionedHeaderItem); // HACK: just nuke it
		parent.setVisible(parent.getItemCount() > 0);
	}
};

ZmAccountOverviewContainer.prototype._confirmEmptyAction =
function(data, opId) {
	var dialog = appCtxt.getOkCancelMsgDialog();
	dialog.reset();
	dialog.registerCallback(DwtDialog.OK_BUTTON, this._emptyCallback, this, [dialog, data, opId]);

	var msg = (data == ZmFolder.ID_TRASH)
		? ZmMsg.confirmEmptyTrashFolder
		: (AjxMessageFormat.format(ZmMsg.confirmEmptyFolder, ZmMsg[ZmFolder.MSG_KEY[data]]));

	dialog.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
	dialog.popup();
};

ZmAccountOverviewContainer.prototype._emptyCallback =
function(dialog, folderId, opId) {
	dialog.popdown();
	this._doAction(folderId, opId);
};

ZmAccountOverviewContainer.prototype._doAction =
function(folderId, opId) {
	var bc = new ZmBatchCommand(true, appCtxt.accountList.mainAccount.name);

	var accounts = appCtxt.accountList.visibleAccounts;
	for (var i = 0; i < accounts.length; i++) {
		var account = accounts[i];
		if (account.isMain) { continue; }

		var fid = ZmOrganizer.getSystemId(folderId, account);
		var folder = appCtxt.getById(fid);
		if (folder) {
			if (opId == ZmOperation.MARK_ALL_READ) {
				folder.markAllRead(bc);
			} else {
				folder.empty(null, bc);
			}
			bc.curId++;
		}
	}

	bc.run();
	if (appCtxt.isOffline) {
		appCtxt.getApp(ZmApp.MAIL).clearNewMailBadge();
	}
};

ZmAccountOverviewContainer.prototype._handleStatusClick =
function(account, ev) {

    if(!account.isError()) {
        return;
    } else if (appCtxt.isOffline && (account.status == ZmZimbraAccount.STATUS_AUTHFAIL)) {
        var dialog = appCtxt.getPasswordChangeDialog();
        dialog.popup(account);
    } else {
        account.showErrorMessage();
    }
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmOverview")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines an overview, which holds tree views.
 *
 */

/**
 * @class
 * Creates an overview. An overview is a {@link DwtComposite} that holds tree views.
 * 
 * @author Conrad Damon
 *
 * @param {Hash}	params 				a hash of parameters
 * @param	{String}	params.id 	the id for the HTML element
 * @param	{String}	params.overviewId 	the overview id
 * @param	{String}	params.containerId 	the overview container id (multi-account)
 * @param	{Array}	params.treeIds an array of organizer types that may be displayed in this overview
 * @param	{ZmZimbraAccount}	params.account		the account this overview belongs to
 * @param	{DwtControl}	params.parent			the containing widget
 * @param	{String}	params.overviewClass		the class name for overview DIV
 * @param	{constant}	params.posStyle				the positioning style for overview DIV
 * @param	{constant}	params.scroll				the scrolling style for overview DIV
 * @param	{Boolean}	params.selectionSupported <code>true</code> left-click selection is supported
 * @param	{Boolean}	params.actionSupported		<code>true</code> if right-click action menus are supported
 * @param	{Boolean}	params.dndSupported			<code>true</code> if drag-and-drop is supported
 * @param	{String}	params.headerClass			the class name for header item
 * @param	{Boolean}	params.showUnread			if <code>true</code>, unread counts will be shown
 * @param	{Boolean}	params.showNewButtons		if <code>true</code>, tree headers may have buttons for creating new organizers
 * @param	{constant}	params.treeStyle			the default display style for tree views
 * @param	{Boolean}	params.isCheckedByDefault	the default state for "checked" display style
 * @param	{Boolean}	params.noTooltips			if <code>true</code>, do not show toolt ips for tree items
 * @param	{Boolean}	params.skipImplicit			if <code>true</code>, do not save implicit prefs of expanded/collapsed node status for this overview (see ZmDialog.prototype._setOverview)
 * @param	{Boolean}	params.dynamicWidth			if <code>true</code>, the width is dynamic, i.e. the width is auto instead of fixed. Used for ZmDolderChooser so far.
 * @param {ZmOverviewController}	controller			the overview controller
 * 
 * @extends	DwtComposite
 */
ZmOverview = function(params, controller) {

	var overviewClass = params.overviewClass ? params.overviewClass : "ZmOverview";
	params.id = params.id || ZmId.getOverviewId(params.overviewId);
	DwtComposite.call(this, {parent:params.parent, className:overviewClass, posStyle:params.posStyle, id:params.id});

	this._controller = controller;

	this.setScrollStyle(params.scroll || Dwt.SCROLL_Y);

	this.overviewId			= params.overviewId;
	this.containerId		= params.containerId;
	this.account			= params.account;
	this.selectionSupported	= params.selectionSupported;
	this.actionSupported	= params.actionSupported;
	this.dynamicWidth		= params.dynamicWidth;
	this.dndSupported		= params.dndSupported;
	this.headerClass		= params.headerClass;
	this.showUnread			= params.showUnread;
	this.showNewButtons		= params.showNewButtons;
	this.treeStyle			= params.treeStyle;
	this.isCheckedByDefault = params.isCheckedByDefault;
	this.noTooltips			= params.noTooltips;
	this.isAppOverview		= params.isAppOverview;
	this.skipImplicit 		= params.skipImplicit;
	this.appName            = params.appName;

	this._treeIds			= [];
	this._treeHash			= {};
	this._treeParents		= {};

	// Create a parent div for each overview tree.
	var doc = document;
	var element = this.getHtmlElement();
	if (params.treeIds) {
		for (var i = 0, count = params.treeIds.length; i < count; i++) {
			var div = doc.createElement("DIV");
			var treeId = params.treeIds[i];
			this._treeParents[treeId] = div.id = [this.overviewId, treeId].join("-parent-");
			element.appendChild(div);
		}
	}

	if (this.dndSupported) {
		this._scrollableContainerId = this.containerId || this.overviewId;
		var container = this.containerId ? document.getElementById(this.containerId) : this.getHtmlElement();
		var params = {container:container, threshold:15, amount:5, interval:10, id:this._scrollableContainerId};
		this._dndScrollCallback = new AjxCallback(null, DwtControl._dndScrollCallback, [params]);
	}

	this.setAttribute('aria-label', ZmMsg.overviewLabel);

    // Let overview be a single tab stop, then manage focus among items using arrow keys
    this.tabGroupMember = this;
};

ZmOverview.prototype = new DwtComposite;
ZmOverview.prototype.constructor = ZmOverview;

ZmOverview.prototype.isZmOverview = true;
ZmOverview.prototype.toString = function() { return "ZmOverview"; };

ZmOverview.prototype.role = "navigation";


/**
 * Gets the parent element for the given tree id.
 * 
 * @param	{String}	treeId		the tree id
 * @return	{Object}	the tree parent element
 */
ZmOverview.prototype.getTreeParent =
function(treeId) {
	return this._treeParents[treeId];
};

/**
 * Displays the given list of tree views in this overview.
 *
 * @param {Array}	treeIds		an array of organizer ids
 * @param {Hash}	omit		the hash of organizer ids to ignore
 */
ZmOverview.prototype.set =
function(treeIds, omit) {
	if (treeIds && treeIds.length) {
		for (var i = 0; i < treeIds.length; i++) {
			this.setTreeView(treeIds[i], omit);
		}
	}
};

/**
 * Sets the given tree view. Its tree controller is responsible for using the appropriate
 * data tree to populate the tree view. The tree controller will be lazily created if
 * necessary. The tree view is cleared before it is set. The tree view inherits options
 * from this overview.
 * 
 * @param {String}	treeId	the organizer ID
 * @param {Hash}	omit	a hash of organizer ids to ignore
 */
ZmOverview.prototype.setTreeView = function(treeId, omit) {

	if (!appCtxt.checkPrecondition(ZmOrganizer.PRECONDITION[treeId])) {
		return;
	}

	AjxDispatcher.require(ZmOrganizer.ORG_PACKAGE[treeId]);
	var treeController = this._controller.getTreeController(treeId);
	if (!treeController) { return; }
	if (this._treeHash[treeId]) {
		treeController.clearTreeView(this.overviewId);
	} else {
		this._treeIds.push(treeId);
	}
	var params = {
		overviewId:		this.overviewId,
		omit:			omit,
		showUnread:		this.showUnread,
		account:		this.account
	};
	this._treeHash[treeId] = treeController.show(params); // render tree view
};

ZmOverview.prototype.clearChangeListener = function(treeIds) {
	// Added for the attachMail zimlet, operating in a child window.  This clears the listeners added to
	// the parent window trees (which causes problems in IE when the child window closes).  See Bugs
	// 99453 and 99913
	for (var i = 0; i < treeIds.length; i++) {
		var treeController = this._controller.getTreeController(treeIds[i]);
		var changeListener = treeController._getTreeChangeListener();
		if (changeListener) {
			var folderTree = appCtxt.getFolderTree();
			if (folderTree) {
				folderTree.removeChangeListener(changeListener);
			}
		}
	}
}

/**
 * Gets the tree view.
 * 
 * @param	{String}	treeId		the tree id
 * @return	{Object}	the tree view
 */
ZmOverview.prototype.getTreeView =
function(treeId) {
	return this._treeHash[treeId];
};

/**
 * Gets the tree views.
 * 
 * @return	{Array}	an array of tree ids
 */
ZmOverview.prototype.getTreeViews =
function() {
	return this._treeIds;
};

/**
 * Searches the tree views for the tree item whose data object has the given ID and type.
 * 
 * @param {int}	id			the id to look for
 * @param {constant}	type			the item must also have this type
 * @return	{Object}	the item or <code>null</code> if not found
 */
ZmOverview.prototype.getTreeItemById =
function(id, type) {
	if (!id) { return null; }
	for (var i = 0; i < this._treeIds.length; i++) {
		var treeView = this._treeHash[this._treeIds[i]];
		if (treeView) {
			var item = treeView.getTreeItemById && treeView.getTreeItemById(id);
			if (item && (!type || (this._treeIds[i] == type))) {
				return item;
			}
		}
	}
	return null;
};

/**
* Returns the first selected item within this overview.
* 
* @param	{Boolean}	typeOnly	if <code>true</code>, return the type only
* @return	{Object}	the item (or type if <code>typeOnly</code>) or <code>null</code> if not found
*/
ZmOverview.prototype.getSelected =
function(typeOnly) {
	for (var i = 0; i < this._treeIds.length; i++) {
		var treeView = this._treeHash[this._treeIds[i]];
		if (treeView) {
			var item = treeView.getSelected();
			if (item) {
				return typeOnly ? treeView.type : item;
			} // otherwise continue with other treeviews to look for selected item
		}
	}
	return null;
};

ZmOverview.prototype.deselectAllTreeViews =
function() {
	for (var i = 0; i < this._treeIds.length; i++) {
		var treeView = this._treeHash[this._treeIds[i]];
		if (treeView) {
			treeView.deselectAll();
		}
	}
};


/**
 * Selects the item with the given ID within the given tree in this overview.
 *
 * @param {String}	id	the item id
 * @param {constant}	type	the tree type
 */
ZmOverview.prototype.setSelected =
function(id, type) {
	var ti, treeView;
	if (type) {
		treeView = this._treeHash[type];
		ti = treeView && treeView.getTreeItemById(id);
	} else {
		for (var type in this._treeHash) {
			treeView = this._treeHash[type];
			ti = treeView && treeView.getTreeItemById(id);
			if (ti) { break; }
		}
	}

	if (ti && (this._selectedTreeItem != ti)) {
		treeView.setSelected(id, true, true);
	}
	this.itemSelected(ti);
};

/**
 * Given a tree item, de-selects all items in the overview's
 * other tree views, enforcing single selection within the overview.
 * Passing a null argument will clear selection in all tree views.
 *
 * @param {DwtTreeItem}	treeItem		the tree item
 */
ZmOverview.prototype.itemSelected =
function(treeItem) {
	if (appCtxt.multiAccounts && treeItem) {
		var name = this.overviewId.substring(0, this.overviewId.indexOf(":"));
		var container = this._controller.getOverviewContainer(name);
		if (container) {
			container.deselectAll(this);
		}
	}

	if (this._selectedTreeItem && (this._selectedTreeItem._tree != (treeItem && treeItem._tree))) {
		this._selectedTreeItem._tree.deselectAll();
	}

	this._selectedTreeItem = treeItem;
};

/**
 * Clears the tree views.
 */
ZmOverview.prototype.clear =
function() {
	for (var i = 0; i < this._treeIds.length; i++) {
		var treeId = this._treeIds[i];
		if (this._treeHash[treeId]) {
			var treeController = this._controller.getTreeController(treeId);
			treeController.clearTreeView(this.overviewId);
			delete this._treeHash[treeId];
		}
	}
};

ZmOverview.prototype.clearSelection =
function() {
	if (this._selectedTreeItem) {
		this._selectedTreeItem._tree.deselectAll();
	}
};

/**
 * @private
 */
ZmOverview.prototype._initialize =
function() {
	// do nothing. 
	// - called by DwtTreeItem b/c it thinks its adding another tree item
};

/**
 * @private
 */
ZmOverview.prototype.focus = function() {

	var item = this._selectedTreeItem;
	if (!item) {
		var tree = this._treeHash[this._treeIds[0]];
		if (tree) {
			item = tree._getNextTreeItem(true);
		}
	}

    if (item) {
        item.focus();
        item._tree.setSelection(item, false, true);
        return item;
    }
};

/**
 * @private
 */
ZmOverview.prototype.blur = function() {

	var item = this._selectedTreeItem;
	if (item) {
		item._blur();
	}
};

/**
 * Returns the next/previous selectable tree item within this overview, starting with the
 * tree immediately after/before the given one. Used to handle tree item selection that
 * spans trees.
 *
 * @param {Boolean}	next		if <code>true</code>, look for next item as opposed to previous item
 * @param {ZmTreeView}	tree		the tree that we are just leaving
 *
 * @private
 */
ZmOverview.prototype._getNextTreeItem =
function(next, tree) {

	for (var i = 0; i < this._treeIds.length; i++) {
		if (this._treeHash[this._treeIds[i]] == tree) {
			break;
		}
	}

	var nextItem = null;
	var idx = next ? i + 1 : i - 1;
	tree = this._treeHash[this._treeIds[idx]];
	while (tree) {
		nextItem = DwtTree.prototype._getNextTreeItem.call(tree, next);
		if (nextItem) {
			break;
		}
		idx = next ? idx + 1 : idx - 1;
		tree = this._treeHash[this._treeIds[idx]];
	}

	return nextItem;
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmTreeView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates an empty tree view.
 * @class
 * This class displays data in a tree structure.
 *
 * @author Conrad Damon
 * 
 * @param {Hash}	params				the hash of parameters
 * @param {DwtControl}	params.parent				the tree's parent widget
 * @param {constant}	params.type				the organizer type
 * @param {String}	params.className				the CSS class
 * @param {constant}	params.posStyle				the positioning style
 * @param {constant}	params.overviewId			theoverview ID
 * @param {String}	params.headerClass			the CSS class for header item
 * @param {DwtDragSource}	params.dragSrc				the drag source
 * @param {DwtDropTarget}	params.dropTgt				the drop target
 * @param {constant}	params.treeStyle				tree style (see {@link DwtTree})
 * @param {Boolean}	params.isCheckedByDefault	sets the default state of "checked" tree style
 * @param {Hash}	params.allowedTypes			a hash of org types this tree may display
 * @param {Hash}	params.allowedSubTypes		a hash of org types this tree may display below top level
 * @param {boolean}    params.actionSupported     (default to value from Overview if not passed)
 *
 * @extends		DwtTree
 */
ZmTreeView = function(params) {

	if (arguments.length == 0) { return; }

	DwtTree.call(this, {
		parent: params.parent,
		parentElement: params.parentElement,
		style: params.treeStyle,
		isCheckedByDefault: params.isCheckedByDefault,
		className: (params.className || "OverviewTree"),
		posStyle: params.posStyle,
		id: params.id
	});

	this._headerClass = params.headerClass || "overviewHeader";
	this.overviewId = params.overviewId;
	this.type = params.type;
	this.allowedTypes = params.allowedTypes;
	this.allowedSubTypes = params.allowedSubTypes;

	this._overview = appCtxt.getOverviewController().getOverview(this.overviewId);
	
	this._dragSrc = params.dragSrc;
	this._dropTgt = params.dropTgt;

	this.actionSupported = params.actionSupported !== undefined
							? params.actionSupported
							: this._overview.actionSupported;

	this.dynamicWidth = this._overview.dynamicWidth;

	this._dataTree = null;
	this._treeItemHash  = {};	// map organizer to its corresponding tree item by ID
	this._idToOrganizer = {};	// map DwtControl htmlElId to the organizer for external Drag and Drop

};

ZmTreeView.KEY_TYPE	= "_type_";
ZmTreeView.KEY_ID	= "_treeId_";

// compare functions for each type
ZmTreeView.COMPARE_FUNC = {};

// add space after the following items
ZmTreeView.ADD_SEP = {};
ZmTreeView.ADD_SEP[ZmFolder.ID_TRASH] = true;

ZmTreeView.MAX_ITEMS = 50;

// Static methods

/**
 * Finds the correct position for an organizer within a node, given
 * a sort function.
 *
 * @param {DwtTreeItem}	node			the node under which organizer is to be added
 * @param {ZmOrganizer}	organizer		the organizer
 * @param {function}	sortFunction	the function for comparing two organizers
 * @return	{int}	the index
 */
ZmTreeView.getSortIndex =
function(node, organizer, sortFunction) {
	if (!sortFunction) return null;
	var cnt = node.getItemCount();
	var children = node.getItems();
	for (var i = 0; i < children.length; i++) {
		if (children[i]._isSeparator) continue;
		var child = children[i].getData(Dwt.KEY_OBJECT);
		if (!child) continue;
		var test = sortFunction(organizer, child);
		if (test == -1) {
			return i;
		}
	}
	return i;
};

ZmTreeView.prototype = new DwtTree;
ZmTreeView.prototype.constructor = ZmTreeView;

// Public methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmTreeView.prototype.toString = 
function() {
	return "ZmTreeView";
};


/**
 * Populates the tree view with the given data and displays it.
 *
 * @param {Hash}	params		a hash of parameters
 * @param   {ZmTree}	params.dataTree		data in tree form
 * @param	{Boolean}	params.showUnread	if <code>true</code>, show unread counts
 * @param	{Hash}	params.omit			a hash of organizer IDs to ignore
 * @param	{Hash}	params.include		a hash of organizer IDs to include
 * @param	{Boolean}	params.omitParents	if <code>true</code>, do NOT insert parent nodes as needed
 * @param	{Hash}	params.searchTypes	the types of saved searches to show
 * @param	{Boolean}	params.noTooltips	if <code>true</code>, don't show tooltips for tree items
 * @param	{Boolean}	params.collapsed		if <code>true</code>, initially leave the root collapsed 
 * @param 	{Hash}          params.optButton        a hash of data for showing a options button in the item: image, tooltip, callback
 */
ZmTreeView.prototype.set =
function(params) {
	this._showUnread = params.showUnread;
	this._dataTree = params.dataTree;
	this._optButton = params.optButton;

	this.clearItems();

	// create header item
	var root = this._dataTree.root;
	var isMultiAcctSubHeader = (appCtxt.multiAccounts && (this.type == ZmOrganizer.SEARCH || this.type == ZmOrganizer.TAG));
	var imageInfo = this._getHeaderTreeItemImage();
	var ti = this._headerItem = new DwtHeaderTreeItem({
		parent:				this,
		className:			isMultiAcctSubHeader ? "DwtTreeItem" : this._headerClass,
		imageInfo:			imageInfo,
		id:					ZmId.getTreeItemId(this.overviewId, null, this.type),
		optButton:			params.optButton,
		dndScrollCallback:	this._overview && this._overview._dndScrollCallback,
		dndScrollId:		this._overview && this._overview._scrollableContainerId
	});
	ti._isHeader = true;
	var name = ZmMsg[ZmOrganizer.LABEL[this.type]];
	if (name) {
		ti.setText(name);
	}
	ti.setData(Dwt.KEY_ID, root.id);
	ti.setData(Dwt.KEY_OBJECT, root);
	ti.setData(ZmTreeView.KEY_ID, this.overviewId);
	ti.setData(ZmTreeView.KEY_TYPE, this.type);
	if (this._dropTgt) {
		ti.setDropTarget(this._dropTgt);
	}
	this._treeItemHash[root.id] = ti;
	ti.getHtmlElement().style.overflow = "hidden";
	// render the root item's children (ie everything else)
	params.treeNode = ti;
	params.organizer = root;
	this._render(params);
	ti.setExpanded(!params.collapsed, null, true);

	if (!appCtxt.multiAccounts) {
		this.addSeparator();
	}


	if (appCtxt.getSkinHint("noOverviewHeaders") ||
		this._hideHeaderTreeItem())
	{
		ti.setVisible(false, true);
	}
};

/**
 * Gets the tree item that represents the organizer with the given ID.
 *
 * @param {int}		id		an organizer ID
 * @return	{DwtTreeItem}		the item
 */
ZmTreeView.prototype.getTreeItemById =
function(id) {
	return this._treeItemHash[id];
};

/**
 * Gets the tree view's header node.
 * 
 * @return	{DwtHeaderTreeItem}		the item
 */
ZmTreeView.prototype.getHeaderItem =
function() {
	return this._headerItem;
};

/**
 * Gets the currently selected organizer(s). If tree view is checkbox style,
 * return value is an {Array} otherwise, a single {DwtTreeItem} object is returned.
 * 
 * @return	{Array|DwtTreeItem}		the selected item(s)
 */
ZmTreeView.prototype.getSelected =
function() {
	if (this.isCheckedStyle) {
		var selected = [];
		// bug #44805 - iterate thru the entire tree item hash in case there are
		// more than one header items in the tree view (e.g. Imap accounts)
		for (var i in this._treeItemHash) {
			var ti = this._treeItemHash[i];
			if (ti && ti.getChecked()) {
				selected.push(ti.getData(Dwt.KEY_OBJECT));
			}
		}
		return selected;
	} else {
		return (this.getSelectionCount() != 1)
			? null : this.getSelection()[0].getData(Dwt.KEY_OBJECT);
	}
};

/**
 * Selects the tree item for the given organizer.
 *
 * @param {ZmOrganizer}	organizer		the organizer to select, or its ID
 * @param {Boolean}	skipNotify	if <code>true</code>, skip notifications
 * @param {Boolean}	noFocus		if <code>true</code>, select item but don't set focus to it
 */
ZmTreeView.prototype.setSelected =
function(organizer, skipNotify, noFocus) {
	var id = ZmOrganizer.getSystemId((organizer instanceof ZmOrganizer) ? organizer.id : organizer);
	if (!id || !this._treeItemHash[id]) { return; }
	this.setSelection(this._treeItemHash[id], skipNotify, false, noFocus);
};


// Private and protected methods

/**
 * Draws the children of the given node.
 *
 * @param params		[hash]			hash of params:
 *        treeNode		[DwtTreeItem]	current node
 *        organizer		[ZmOrganizer]	its organizer
 *        omit			[Object]*		hash of system folder IDs to ignore	
 *        include		[object]*		hash of system folder IDs to include
 *        showOrphans	[boolean]*		if true, show parent chain of any
 * 										folder of this type, as well as the folder
 *        searchTypes	[hash]*			types of saved searches to show
 *        noTooltips	[boolean]*		if true, don't show tooltips for tree items
 *        startPos		[int]*			start rendering this far into list of children
 * 
 * TODO: Add logic to support display of folders that are not normally allowed in
 * 		this tree, but that have children (orphans) of an allowed type
 * TODO: Only sort folders we're showing (requires two passes).
 * 
 * @private
 */
ZmTreeView.prototype._render =
function(params) {

	params.omit = params.omit || {};
	this._setOmit(params.omit, params.dataTree);

	var org = params.organizer;
	var children = org.children.getArray();
	if (org.isDataSource(ZmAccount.TYPE_IMAP)) {
		children.sort(ZmImapAccount.sortCompare);
	} else if (ZmTreeView.COMPARE_FUNC[this.type]) {
		if (appCtxt.isOffline && this.type == ZmOrganizer.SEARCH) {
			var local = [];
			for (var j = 0; j < children.length; j++) {
				var child = children[j];
				if (child && child.type == ZmOrganizer.SEARCH && !child.isOfflineGlobalSearch) {
					local.push(child);
				}
			}
			children = local;
		}
		// IE loses type info on the children array - the props are there and it can be iterated,
		// but a function call like sort() blows up. So create an array local to child win.
		if (appCtxt.isChildWindow && AjxEnv.isIE) {
			var children1 = [];
			for (var i = 0, len = children.length; i < len; i++) {
				children1.push(children[i]);
			}
			children = children1;
		}
		children.sort(eval(ZmTreeView.COMPARE_FUNC[this.type]));
	}
	DBG.println(AjxDebug.DBG3, "Render: " + org.name + ": " + children.length);
	var addSep = true;
	var numItems = 0;
	var len = children.length;
    if (params.startPos === undefined && params.lastRenderedFolder ){
        for (var i = 0, len = children.length; i < len; i++) {
            if (params.lastRenderedFolder == children[i] ){
               params.startPos = i + 1; // Next to lastRenderedFolder
               break;
            }
        }
        DBG.println(AjxDebug.DBG1, "load remaining folders: " + params.startPos);
    }
	for (var i = params.startPos || 0; i < len; i++) {
		var child = children[i];
		if (!child || (params.omit && params.omit[child.nId])) { continue; }
		if (!(params.include && params.include[child.nId])) {
			if (!this._isAllowed(org, child)) {
				if (params.omitParents) continue;
				var proxy = AjxUtil.createProxy(params);
				proxy.treeNode = null;
				proxy.organizer = child;
				this._render(proxy);
				continue;
			}
		}

		if (child.numTotal == 0 && (child.nId == ZmFolder.ID_SYNC_FAILURES)) {
			continue;
		}

		var parentNode = params.treeNode;
		var account = appCtxt.multiAccounts && child.getAccount();

		// bug: 43067 - reparent calendars for caldav-based accounts
		if (account && account.isCalDavBased() &&
			child.parent.nId == ZmOrganizer.ID_CALENDAR)
		{
			parentNode = parentNode.parent;
		}

		// if there's a large number of folders to display, make user click on special placeholder
		// to display remainder; we then display them MAX_ITEMS at a time
		if (numItems >= ZmTreeView.MAX_ITEMS) {
			if (params.startPos) {
				// render next chunk
				params.startPos = i;
				params.len = (params.startPos + ZmTreeView.MAX_ITEMS >= len) ? len : 0;	// hint that we're done
				this._showRemainingFolders(params);
				return;
			} else if (numItems >= ZmTreeView.MAX_ITEMS * 2) {
				// add placeholder tree item "Show remaining folders"
				var orgs = ZmMsg[ZmOrganizer.LABEL[this.type]].toLowerCase();
				var name = AjxMessageFormat.format(ZmMsg.showRemainingFolders, orgs);
				child = new ZmFolder({id:ZmFolder.ID_LOAD_FOLDERS, name:name, parent:org});
				child._tooltip = AjxMessageFormat.format(ZmMsg.showRemainingFoldersTooltip, [(children.length - i), orgs]);
				var ti = this._addNew(parentNode, child);
				ti.enableSelection(true);
				if (this.isCheckedStyle) {
					ti.showCheckBox(false);
				}
                params.lastRenderedFolder  = children[i - 1];
				params.showRemainingFoldersNode = ti;
				child._showFoldersCallback = new AjxCallback(this, this._showRemainingFolders, [params]);
				if (this._dragSrc) {
					// Bug 55763 - expand placeholder on hover; replacing the _dragHover function is the easiest way, if a bit hacky
					ti._dragHover = this._showRemainingFolders.bind(this, params);
				}

				return;
			}
		}

		// NOTE: Separates public and shared folders
		if ((org.nId == ZmOrganizer.ID_ROOT) && child.link && addSep) {
			params.treeNode.addSeparator();
			addSep = false;
		}
		this._addNew(parentNode, child, null, params.noTooltips, params.omit);
		numItems++;
	}
};

ZmTreeView.prototype._setOmit =
function(omit, dataTree) {
	for (var id in ZmFolder.HIDE_ID) {
		omit[id] = true;
	}
	//note - the dataTree thing was in the previous code so I keep it, but seems all the ZmFolder.HIDE_NAME code is commented out, so
	//not sure it's still needed.
	dataTree = this.type !== ZmOrganizer.VOICE && dataTree;
	if (!dataTree) {
		return;
	}
	for (var name in ZmFolder.HIDE_NAME) {
		var folder = dataTree.getByName(name);
		if (folder) {
			omit[folder.id] = true;
		}
	}
};

/**
 * a bit complicated and hard to explain - We should only allow (render on this view)
 * a child of an "allowedSubTypes", if all its ancestors are allowed all the way to the root ("Folders"), meaning
 * it has an ancestor that is of the allowedTypes (but is not the root)
 * e.g.
 * allowed:
 * Folders-->folder1--->searchFolder1
 * Folders--->folder1--->folder2--->folder3--->searchFolder1
 *
 * not allowed:
 * Folders-->searchFolder1
 * Folders-->searchFolder1--->searchFolder2
 *
 * @param org
 * @param child
 * @returns {*}
 * @private
 */
ZmTreeView.prototype._isAllowed =
function(org, child) {

	if (!org) { //could happen, for example the Zimlets root doesn't have a parent.
		return true; //seems returning true in this case works... what a mess.
	}

	// Within the Searches tree, only show saved searches that return a type that belongs to this app
	if (this.type === ZmOrganizer.SEARCH && child.type === ZmOrganizer.SEARCH && this._overview.appName) {
		var searchTypes = child.search.types && child.search.types.getArray();
		if (!searchTypes || searchTypes.length === 0) {
			searchTypes = [ ZmItem.MSG ];   // search with no types defaults to "message"
		}
		var common = AjxUtil.intersection(searchTypes,
			ZmApp.SEARCH_TYPES[this._overview.appName] ||  ZmApp.SEARCH_TYPES[appCtxt.getCurrentAppName()]);
		if (common.length === 0) {
			return false;
		}
	}

	if (org.nId == ZmOrganizer.ID_ROOT) {
		return this.allowedTypes[child.type];
	}

	//org is not root
	if (this.allowedTypes[child.type]) {
		return true; //optimization, end the recursion if we find a non root allowed ancestor.
	}

	if (this.allowedSubTypes[child.type]) {
		return this._isAllowed(org.parent, org); //go up parent to see if eventually it's allowed.
	}

	return false;
};

/**
 * Adds a tree item node for the given organizer to the tree, and then adds its children.
 *
 * @param parentNode	[DwtTreeItem]	node under which to add the new one
 * @param organizer		[ZmOrganizer]	organizer for the new node
 * @param index			[int]*			position at which to add the new node
 * @param noTooltips	[boolean]*		if true, don't show tooltips for tree items
 * @param omit			[Object]*		hash of system folder IDs to ignore
 * 
 * @private
 */
ZmTreeView.prototype._addNew =
function(parentNode, organizer, index, noTooltips, omit) {
	var ti;
	var parentControlId;
	// check if we're adding a datasource folder
	var dsColl = (organizer.type == ZmOrganizer.FOLDER) && appCtxt.getDataSourceCollection();
	var dss = dsColl && dsColl.getByFolderId(organizer.nId);
	var ds = (dss && dss.length > 0) ? dss[0] : null;

	if (ds && ds.type == ZmAccount.TYPE_IMAP) {
		var cname = appCtxt.isFamilyMbox ? null : this._headerClass;
		ti = new DwtHeaderTreeItem({
			parent:this,
			text:organizer.getName(),
			className:cname
		});
	} else {
		// create parent chain
		if (!parentNode) {
			var stack = [];
			var parentOrganizer = organizer.parent;
			if (parentOrganizer) {
				while ((parentNode = this.getTreeItemById(parentOrganizer.id)) == null) {
					stack.push(parentOrganizer);
					parentOrganizer = parentOrganizer.parent;
				}
			}
			while (parentOrganizer = stack.pop()) {
				parentNode = this.getTreeItemById(parentOrganizer.parent.id);
				parentControlId = ZmId.getTreeItemId(this.overviewId, parentOrganizer.id);
				parentNode = new DwtTreeItem({
					parent:					parentNode,
					text:					parentOrganizer.getName(),
					imageInfo:				parentOrganizer.getIconWithColor(),
					forceNotifySelection:	true,
					arrowDisabled:			!this.actionSupported,
					dynamicWidth:			this.dynamicWidth,
					dndScrollCallback:		this._overview && this._overview._dndScrollCallback,
					dndScrollId:			this._overview && this._overview._scrollableContainerId,
					id:						parentControlId
				});
				parentNode.setData(Dwt.KEY_ID, parentOrganizer.id);
				parentNode.setData(Dwt.KEY_OBJECT, parentOrganizer);
				parentNode.setData(ZmTreeView.KEY_ID, this.overviewId);
				parentNode.setData(ZmTreeView.KEY_TYPE, parentOrganizer.type);
				this._treeItemHash[parentOrganizer.id] = parentNode;
				this._idToOrganizer[parentControlId] = parentOrganizer.id;
			}
		}
		var params = {
			parent:				parentNode,
			index:				index,
			text:				organizer.getName(this._showUnread),
			arrowDisabled:		!this.actionSupported,
			dynamicWidth:		this.dynamicWidth,
			dndScrollCallback:	this._overview && this._overview._dndScrollCallback,
			dndScrollId:		this._overview && this._overview._scrollableContainerId,
			imageInfo:			organizer.getIconWithColor(),
			id:					ZmId.getTreeItemId(this.overviewId, organizer.id)
		};
		// now add item
		ti = new DwtTreeItem(params);
		this._idToOrganizer[params.id] = organizer.id;
	}

	if (appCtxt.multiAccounts &&
		(organizer.type == ZmOrganizer.SEARCH ||
		 organizer.type == ZmOrganizer.TAG))
	{
		ti.addClassName("DwtTreeItemChildDiv");
	}

	ti.setDndText(organizer.getName());
	ti.setData(Dwt.KEY_ID, organizer.id);
	ti.setData(Dwt.KEY_OBJECT, organizer);
	ti.setData(ZmTreeView.KEY_ID, this.overviewId);
	ti.setData(ZmTreeView.KEY_TYPE, organizer.type);
	if (!noTooltips) {
		var tooltip = organizer.getToolTip();
		if (tooltip) {
			ti.setToolTipContent(tooltip);
		}
	}
	if (this._dragSrc) {
		ti.setDragSource(this._dragSrc);
	}
	if (this._dropTgt) {
		ti.setDropTarget(this._dropTgt);
	}
	this._treeItemHash[organizer.id] = ti;

	if (ZmTreeView.ADD_SEP[organizer.nId]) {
		parentNode.addSeparator();
	}

	// recursively add children
	if (organizer.children && organizer.children.size()) {
		this._render({treeNode:ti, organizer:organizer, omit:omit});
	}

	if (ds && ds.type == ZmAccount.TYPE_IMAP) {
		ti.setExpanded(!appCtxt.get(ZmSetting.COLLAPSE_IMAP_TREES));
	}

	return ti;
};


/**
 * Gets the data (an organizer) from the tree item nearest the one
 * associated with the given ID.
 *
 * @param {int}	id	an organizer ID
 * @return	{Object}	the data or <code>null</code> for none
 */
ZmTreeView.prototype.getNextData =
function(id) {
	var treeItem = this.getTreeItemById(id);
	if(!treeItem || !treeItem.parent) { return null; }

	while (treeItem && treeItem.parent) {
		var parentN = treeItem.parent;
		if (!(parentN instanceof DwtTreeItem)) {
			return null;
		}
		var treeItems = parentN.getItems();
		var result = null;
		if (treeItems && treeItems.length > 1) {
			for(var i = 0; i < treeItems.length; i++) { 
				var tmp = treeItems[i];
				if (tmp == treeItem) {
					var nextData = this.findNext(treeItem, treeItems, i);
					if (nextData) { return nextData; }
					var prevData = this.findPrev(treeItem, treeItems, i);
					if (prevData) {	return prevData; }
				}
			}
		}
		treeItem = treeItem.parent;
	}
	return null;
};

ZmTreeView.prototype.findNext =
function(treeItem, treeItems, i) {
	for (var j = i + 1; j < treeItems.length; j++) {
		var next = treeItems[j];
		if (next && next.getData) {
			return next.getData(Dwt.KEY_OBJECT);
		}
	}
	return null;
};

ZmTreeView.prototype.findPrev =
function(treeItem, treeItems, i) {
	for (var j = i - 1; j >= 0; j--) {
		var prev = treeItems[j];
		if (prev && prev.getData) {
			return prev.getData(Dwt.KEY_OBJECT);
		}
	}
	return null;
};

/**
 * Renders a chunk of tree items, using a timer so that the browser doesn't get overloaded.
 * 
 * @param params	[hash]		hash of params (see _render)
 * 
 * @private
 */
ZmTreeView.prototype._showRemainingFolders =
function(params) {

	if (params.showRemainingFoldersNode){
		params.showRemainingFoldersNode.dispose();
	}

	AjxTimedAction.scheduleAction(new AjxTimedAction(this,
		function() {
			this._render(params);
			if (params.len) {
				var orgs = ZmMsg[ZmOrganizer.LABEL[this.type]].toLowerCase();
				appCtxt.setStatusMsg(AjxMessageFormat.format(ZmMsg.foldersShown, [params.len, orgs]));
				params.len = 0;
			}
		}), 100);
};

ZmTreeView.prototype._getNextTreeItem =
function(next) {
	var nextItem = DwtTree.prototype._getNextTreeItem.apply(this, arguments);
	return nextItem || (this._overview && this._overview._getNextTreeItem(next, this));
};

ZmTreeView.prototype._getFirstTreeItem =
function() {
	if (!this._overview) {
		return DwtTree.prototype._getFirstTreeItem.call(tree);
	}

	var treeids = this._overview.getTreeViews();
	var tree = this._overview.getTreeView(treeids[0]);
	return tree && DwtTree.prototype._getFirstTreeItem.call(tree);
};

ZmTreeView.prototype._getLastTreeItem =
function() {
	if (!this._overview) {
		return DwtTree.prototype._getLastTreeItem.call(tree);
	}

	var treeids = this._overview.getTreeViews();
	var tree = this._overview.getTreeView(treeids[treeids.length - 1]);
	return tree && DwtTree.prototype._getLastTreeItem.call(tree);
};

ZmTreeView.prototype._hideHeaderTreeItem =
function() {
	return (appCtxt.multiAccounts && appCtxt.accountList.size() > 1 &&
			(this.type == ZmOrganizer.FOLDER ||
			 this.type == ZmOrganizer.ADDRBOOK ||
			 this.type == ZmOrganizer.CALENDAR ||
			 this.type == ZmOrganizer.TASKS ||
			 this.type == ZmOrganizer.BRIEFCASE ||
			 this.type == ZmOrganizer.PREF_PAGE ||
			 this.type == ZmOrganizer.ZIMLET));
};

ZmTreeView.prototype._getHeaderTreeItemImage =
function() {
	if (appCtxt.multiAccounts) {
		if (this.type == ZmOrganizer.SEARCH)	{ return "SearchFolder"; }
		if (this.type == ZmOrganizer.TAG)		{ return "TagStack"; }
	}
	return null;
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmColorMenu")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @param {hash} params Constructor parameters.
 * @param {DwtComposite} params.parent Parent control.
 * @param {string} params.image Item image to display next to each color choice.
 * @param {boolean} params.hideNone True to hide the "None" option.
 * @param {boolean} params.hideNoFill True to hide the no-fill/use-default option.
 */
ZmColorMenu = function(params) {
    if (arguments.length == 0) return;
    params.className = params.className || "ZmColorMenu DwtMenu";
    DwtMenu.call(this, params);
    this._hideNone = params.hideNone;
    this._hideNoFill = params.hideNoFill;
    this.setImage(params.image);
    this._populateMenu();
};
ZmColorMenu.prototype = new DwtMenu;
ZmColorMenu.prototype.constructor = ZmColorMenu;

ZmColorMenu.prototype.toString = function() {
    return "ZmColorMenu";
};

//
// Constants
//

ZmColorMenu.__KEY_COLOR = "color";

//
// Public methods
//

ZmColorMenu.prototype.setImage = function(image) {
    if (this._image != image) {
        this._image = image;
        var children = this.getChildren();
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            var color = child.getData(ZmColorMenu.__KEY_COLOR);
			var displayColor = color || ZmOrganizer.COLOR_VALUES[ZmOrganizer.ORG_DEFAULT_COLOR]; //default to gray
            var icon = [image, displayColor].join(",color=");
            child.setImage(icon);
        }
    }
};
ZmColorMenu.prototype.getImage = function() {
    return this._image;
};

ZmColorMenu.prototype.getTextForColor = function(color) {
    color = String(color).toLowerCase();
    if (!color.match(/^#/)) color = ZmOrganizer.COLOR_VALUES[color];
    var children = this.getChildren();
    for (var i = 0; i < children.length; i++) {
        var mi = children[i];
        if (mi.getData(ZmColorMenu.__KEY_COLOR) == color) {
            return mi.getText();
        }
    }
    return ZmMsg.custom;
};

ZmColorMenu.prototype.showMoreColors = function() {
    if (this.parent && this.parent.getMenu() == this) {
        var menu = this.parent.getMenu();
        var moreMenu = this._getMoreColorMenu();
        this.parent.setMenu(moreMenu);
        if (menu.isPoppedUp()) {
            var loc = menu.getLocation();
            menu.popdown();
            moreMenu.popup(0, loc.x, loc.y);
        }
        else {
            this.parent.popup();
        }
    }
};

ZmColorMenu.prototype.showLessColors = function() {
    if (this.parent && this.parent.getMenu() != this) {
        var menu = this.parent.getMenu();
        this.parent.setMenu(this);
        if (menu.isPoppedUp()) {
            var loc = menu.getLocation();
            menu.popdown();
            this.popup(0, loc.x, loc.y);
        }
        else {
            this.parent.popup();
        }
    }
};

//
// DwtMenu methods
//

ZmColorMenu.prototype.addSelectionListener = function(listener) {
    DwtMenu.prototype.addSelectionListener.apply(this, arguments);
    this._getMoreColorMenu().addSelectionListener(listener);
};
ZmColorMenu.prototype.removeSelectionListener = function(listener) {
    DwtMenu.prototype.removeSelectionListener.apply(this, arguments);
    this._getMoreColorMenu().removeSelectionListener(listener);
};

//
// Protected methods
//

ZmColorMenu.prototype._populateMenu = function() {
    var list = ZmOrganizer.COLOR_VALUES;
    for (var id = 0; id < list.length; id++) {
        var color = ZmOrganizer.COLOR_VALUES[id];
        if (!color && this._hideNone) continue;
		var displayColor = color || ZmOrganizer.COLOR_VALUES[ZmOrganizer.ORG_DEFAULT_COLOR]; //default to gray
        var image = this._image ? [this._image, displayColor].join(",color=") : null;
        var text = ZmOrganizer.COLOR_TEXT[id];
        var menuItemId = "COLOR_" + id;
        var menuItem = new DwtMenuItem({parent:this, id:menuItemId});
        menuItem.setImage(image);
        menuItem.setText(text);
        menuItem.setData(ZmOperation.MENUITEM_ID, id);
        menuItem.setData(ZmColorMenu.__KEY_COLOR, color);
    }
    var callback = new AjxCallback(this, this.showMoreColors); 
    var showMoreItem = new ZmColorMenuItem({parent:this,callback:callback, id:"SHOW_MORE_ITEMS"});
    showMoreItem.setText(ZmMsg.colorsShowMore);
};

ZmColorMenu.prototype._getMoreColorMenu = function() {
    if (!this._moreMenu) {
        var callback = new AjxCallback(this, this.showLessColors);
        this._moreMenu = new ZmMoreColorMenu({parent:this.parent,callback:callback,hideNoFill:this._hideNoFill});
    }
    return this._moreMenu;
};

//
// Classes
//

ZmMoreColorMenu = function(params) {
    params.style = DwtMenu.COLOR_PICKER_STYLE;
    DwtMenu.call(this, params);
    this._colorPicker = new DwtColorPicker({parent:this,hideNoFill:params.hideNoFill});
    this._colorPicker.getData = this.__DwtColorPicker_getData; // HACK
    var showLessItem = new ZmColorMenuItem({parent:this,callback:params.callback});
    showLessItem.setText(ZmMsg.colorsShowLess);
};
ZmMoreColorMenu.prototype = new DwtMenu;
ZmMoreColorMenu.prototype.constructor = ZmMoreColorMenu;

ZmMoreColorMenu.prototype.toString = function() {
    return "ZmMoreColorMenu";
};

/**
 * <strong>Note:</strong>
 * This method is run in the context of the color picker!
 *
 * @private
 */
ZmMoreColorMenu.prototype.__DwtColorPicker_getData = function(key) {
    // HACK: This is to fake the color picker as a menu item whose
    // HACK: id is the selected color.
    if (key == ZmOperation.MENUITEM_ID) {
        return this.getInputColor();
    }
    return DwtColorPicker.prototype.getData.apply(this, arguments);
};

ZmMoreColorMenu.prototype.setDefaultColor = function(color) {
    this._colorPicker.setDefaultColor(color);
}

/**
 * A custom menu item class for the "More colors..." and
 * "Fewer colors..." options which should not leave space for
 * an image next to the text. A sub-class is also needed so
 * that we can avoid the default handling of the item click.
 *
 * @param params
 */
ZmColorMenuItem = function(params) {
    DwtMenuItem.call(this, params);
    this.callback = params.callback;
    // HACK: This is needed because we no-op the add/removeSelectionListener
    // HACK: methods so that external people can't register listeners but we
    // HACK: still want to handle a true selection to call the callback.
    DwtMenuItem.prototype.addSelectionListener.call(this, new AjxListener(this, this.__handleItemSelect));
};
ZmColorMenuItem.prototype = new DwtMenuItem;
ZmColorMenuItem.prototype.constructor = ZmColorMenuItem;

ZmColorMenuItem.prototype.toString = function() {
    return "ZmColorMenuItem";
};

ZmColorMenuItem.prototype.TEMPLATE = "zimbra.Widgets#ZmColorMenuItem";

// DwtMenuItem methods

ZmColorMenuItem.prototype.addSelectionListener = function() {}; // no-op
ZmColorMenuItem.prototype.removeSelectionListener = function() {}; // no-op

ZmColorMenuItem.prototype.__handleItemSelect = function() {
    if (this.callback) {
        this.callback.run();
    }
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmColorButton")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmColorButton = function(params) {

    if (arguments.length == 0) {
	    return;
    }

    DwtButton.call(this, params);
    var menu = new ZmColorMenu({parent:this,hideNone:params.hideNone});
    menu.addSelectionListener(new AjxListener(this, this._handleSelection));
    this.setMenu(menu);
    this._colorMenu = menu;
	this._labelId = params.labelId;
};

ZmColorButton.prototype = new DwtButton;
ZmColorButton.prototype.constructor = ZmColorButton;

ZmColorButton.prototype.isZmColorButton = true;
ZmColorButton.prototype.toString = function() { return "ZmColorButton"; };

//
// Public methods
//

ZmColorButton.prototype.setImage = function(image, skipMenu) {
    DwtButton.prototype.setImage.apply(this, arguments);
    if (!skipMenu) {
        this._colorMenu.setImage(image);
    }
};

ZmColorButton.prototype.setValue = function(color) {

	var standardColorCode = ZmOrganizer.getStandardColorNumber(color),
		colorMenuItemId;

	if (standardColorCode !== -1) {
		this._color = standardColorCode;
		colorMenuItemId = 'COLOR_' + standardColorCode;
	}
	else {
        this._color = color;
	}
    var image = this.getImage();
    if (image) {
        image = image.replace(/,.*$/, "");
		var displayColor = this._color || ZmOrganizer.COLOR_VALUES[ZmOrganizer.ORG_DEFAULT_COLOR]; //default to gray
        this.setImage([image, this._color].join(",color="), true);
    }
    this.setText(this._colorMenu.getTextForColor(this._color));

	if (colorMenuItemId) {
		this.removeAttribute('aria-label');
		this.setAttribute('aria-labelledby', [ this._labelId, colorMenuItemId ].join(' '));
	}
};


ZmColorButton.prototype.getValue = function() {
    return this._color;
};

//
// Protected methods
//

ZmColorButton.prototype._handleSelection = function(evt) {
    this.setValue(evt.item.getData(ZmOperation.MENUITEM_ID)); 
};
}

if (AjxPackage.define("zimbraMail.share.view.dialog.ZmDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains a dialog.
 * 
 */

/**
 * Creates a dialog.
 * @class
 * This class is a base class for miscellaneous organizer-related dialogs. An instance
 * of this class can be re-used to show different overviews.
 *
 * @author Conrad Damon
 *
 * @param {Hash}	params		a hash of parameters
 * @param	{DwtControl}	params.parent		the parent widget
 * @param	{DwtMsgDialog}	params.msgDialog		the message dialog
 * @param	{String}	params.className		the CSS class name
 * @param	{String}	params.title		the dialog title
 * @param	{Array|constant}	params.standardButtons		an array of standard buttons to include. Defaults to {@link DwtDialog.OK_BUTTON} and {@link DwtDialog.CANCEL_BUTTON}.
 * @param	{Array}	params.extraButtons		a list of {@link DwtDialog_ButtonDescriptor} objects describing custom buttons to add to the dialog
 * @param	{DwtControl}	params.view				the dialog contents
 * 
 * @extends	DwtDialog
 */
ZmDialog = function(params) {
	if (arguments.length == 0) { return; }

	DwtDialog.call(this, params);

	if (!params.view) {
		this.setContent(this._contentHtml());
	}

	if (this._button[DwtDialog.OK_BUTTON]) {
		this.setButtonListener(DwtDialog.OK_BUTTON, new AjxListener(this, this._okButtonListener));
	}

	this._overview = {};
	this._opc = appCtxt.getOverviewController();

	this._baseTabGroupSize = this._tabGroup.size();
};

ZmDialog.prototype = new DwtDialog;
ZmDialog.prototype.constructor = ZmDialog;

ZmDialog.prototype.isZmDialog = true;
ZmDialog.prototype.toString = function() { return "ZmDialog"; };

/**
 * @private
 */
ZmDialog.prototype._contentHtml =
function() {
	return "";
};

/**
 * Sets the view for this dialog.
 * 
 * @param	{DwtComposite}		newView		the view
 * @param	{Boolean}		noReset		if <code>true</code>, do not reset the dialog; <code>false</code> otherwise
 */
ZmDialog.prototype.setView =
function(newView, noReset) {
	this.reset();
	if (newView) {
        var contentDiv = this._getContentDiv();
        var el = newView.getHtmlElement();
		contentDiv.parentNode.replaceChild(el, contentDiv);
		this._contentDiv = el;
	}
};

ZmDialog.prototype.popup =
function() {
	// Bug 38281: for multiuse dialogs, we need to re-add the discretionary
	// tab stops to the base list (the dialog buttons)
	this._tabGroup.__members._array.splice(this._baseTabGroupSize);
	this._tabGroup.addMember(this._getTabGroupMembers());

	DwtDialog.prototype.popup.call(this);
	if (this._focusElement) {
		appCtxt.getKeyboardMgr().grabFocus(this._focusElement);	
	}
};

ZmDialog.prototype.reset =
function() {
	if (this._nameField) {
		this._nameField.value = "";
	}
	DwtDialog.prototype.reset.call(this);
};

/**
 * @private
 */
ZmDialog.prototype._okButtonListener =
function() {
	this.popdown();
};

/**
 * @private
 */
ZmDialog.prototype._setNameField =
function(fieldId) {
	this._nameField = this._focusElement = document.getElementById(fieldId);
	if (this._enterListener) {
		this.addEnterListener(new AjxListener(this, this._enterListener));
	}
};

/**
 * Displays the given list of tree views in an overview, creating it if
 * necessary, and appends the overview to an element in the dialog. Since
 * dialogs may be reused, it is possible that it will display different
 * overviews. That is handled by making sure that only the current overview is
 * visible.
 * 
 * @param params		[hash]				hash of params:
 *        treeIds		[array]				list of tree views to show
 *        omit			[hash]				IDs of organizers to exclude
 *        fieldId		[string]			DOM ID of element that contains overview
 *        overviewId	[string]*			ID for the overview
 *        noRootSelect	[boolean]*			if true, don't make root tree item(s) selectable
 * @param forceSingle	[boolean]*			if true, don't make multi-account overviews
 * @private
 */
ZmDialog.prototype._setOverview =
function(params, forceSingle) {

	// when in multi-account mode, hide the old overview since we don't know
	// whether we want to show an overview container or just a single-account overview.
	if (appCtxt.multiAccounts) {
		var oldOverview = this._opc.getOverviewContainer(this._curOverviewId) ||
						  this._opc.getOverview(this._curOverviewId);

		if (oldOverview) {
			oldOverview.setVisible(false);
		}
	}

	// multi-account uses overview container
	if (appCtxt.multiAccounts && !forceSingle) {
		// use overviewId as the containerId; container will assign overviewId's
		var containerId = this._curOverviewId = params.overviewId;
		var ovContainer = this._opc.getOverviewContainer(containerId);
		if (!ovContainer) {
			var overviewParams = {
				overviewClass:	"dialogOverviewContainer",
				headerClass:	"DwtTreeItem",
				noTooltips:		true,
				treeStyle:		params.treeStyle,
				treeIds:		params.treeIds,
				overviewTrees:	params.overviewTrees,
				omit:			params.omit,
				omitPerAcct:	params.omitPerAcct,
				selectable:		params.selectable
			};
			var containerParams = {
				appName: params.appName,
				containerId: containerId
			};
			ovContainer = this._opc.createOverviewContainer(containerParams, overviewParams);
			ovContainer.setSize(Dwt.DEFAULT, "200");
			document.getElementById(params.fieldId).appendChild(ovContainer.getHtmlElement());
		}

		// make overview container visible
		ovContainer.setVisible(true);

		return ovContainer;
	}

	// single-account overview handling
	var overviewId = this._curOverviewId = params.overviewId;
	var overview = this._opc.getOverview(overviewId);
	if (!overview) {
		var ovParams = {
			overviewId:		overviewId,
			overviewClass:	params.overviewClass || "dialogOverview",
			headerClass:	"DwtTreeItem",
			noTooltips:		true,
			treeStyle:		params.treeStyle,
			dynamicWidth:	params.dynamicWidth,
			treeIds:		params.treeIds,
			account:		((appCtxt.multiAccounts && params.forceSingle) ? appCtxt.getActiveAccount() : (params.account || appCtxt.getActiveAccount())),
			skipImplicit: 	true,
			appName:        params.appName
		};
		overview = this._overview[overviewId] = this._opc.createOverview(ovParams);
		this._renderOverview(overview, params.treeIds, params.omit, params.noRootSelect);
		document.getElementById(params.fieldId).appendChild(overview.getHtmlElement());
	}
	else {
		//this might change between clients so have to update this.
		this._setRootSelection(overview, params.treeIds, params.noRootSelect);
	}

	this._makeOverviewVisible(overviewId);

	return overview;
};

/**
 * @private
 */
ZmDialog.prototype._makeOverviewVisible =
function(overviewId) {
	for (var id in this._overview) {
		this._overview[id].setVisible(id == overviewId);
	}
};

/**
 * Renders the tree views in the overview, and makes the header items
 * selectable (since they can generally be targets of whatever action the dialog
 * is facilitating).
 * 
 * @param overview		[ZmOverview]		the overview
 * @param treeIds		[array]				list of tree views to show
 * @param omit			[hash]*				IDs of organizers to exclude
 * @param noRootSelect	[boolean]*			if true, don't make root tree item(s) selectable
 * @private
 */
ZmDialog.prototype._renderOverview =
function(overview, treeIds, omit, noRootSelect) {
	overview.set(treeIds, omit);
	this._setRootSelection(overview, treeIds, noRootSelect);
};

ZmDialog.prototype._setRootSelection =
function(overview, treeIds, noRootSelect) {
	for (var i = 0; i < treeIds.length; i++) {
		var treeView = overview.getTreeView(treeIds[i]);
		var hi = treeView && treeView.getHeaderItem();
		if (hi) {
			hi.enableSelection(!noRootSelect);
		}
	}
};


/**
 * @private
 */
ZmDialog.prototype._getOverview =
function() {
	return this._overview[this._curOverviewId];
};

/**
 * @private
 */
ZmDialog.prototype._getInputFields =
function() {
	return (this._nameField) ? [this._nameField] : null;
};

/**
 * @private
 */
ZmDialog.prototype._showError =
function(msg, loc) {
	var nLoc = loc || (new DwtPoint(this.getLocation().x + 50, this.getLocation().y + 100));
	var msgDialog = appCtxt.getMsgDialog();

	msgDialog.reset();
    msgDialog.setMessage(AjxStringUtil.htmlEncode(msg), DwtMessageDialog.CRITICAL_STYLE);
	msgDialog.popup(nLoc);
};

/**
 * @private
 */
ZmDialog.prototype._getTabGroupMembers =
function() {
	return this._nameField ? [ this._nameField ] : [];
};
}
if (AjxPackage.define("zimbraMail.share.view.dialog.ZmTimeDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */
/**
 * Creates a generic time picker dialog
 * @constructor
 * @class
 * 
 * @extends		ZmDialog
 * 
 */
ZmTimeDialog = function(params) {
	params.id = Dwt.getNextId("ZmTimeDialog_");
	ZmDialog.call(this, params);
	var html = AjxTemplate.expand("share.Dialogs#ZmTimeDialog", {id: this._htmlElId, description: ZmMsg.sendLaterDescription, label: ZmMsg.time});
	this.setContent(html);
	this.setTitle(ZmMsg.sendLaterTitle);
	this._createDwtObjects();
};

ZmTimeDialog.prototype = new ZmDialog;
ZmTimeDialog.prototype.constructor = ZmTimeDialog;

// Public

ZmTimeDialog.prototype.toString = 
function() {
	return "ZmTimeDialog";
};

ZmTimeDialog.prototype.initialize = 
function() {
	// Init Date / time picker
	var now = new Date();
	this._dateField.value = AjxDateUtil.simpleComputeDateStr(now);
	this.showTimeFields(true);
	this._timeSelect.set(now);

	// Init Timezone picker
	var options = AjxTimezone.getAbbreviatedZoneChoices();
	var serverIdMap = {};
	var serverId;
	if (options.length != this._tzCount) {
		this._tzCount = options.length;
		this._tzoneSelect.clearOptions();
		for (var i = 0; i < options.length; i++) {
			if (!options[i].autoDetected) {
				serverId = options[i].value;
				serverIdMap[serverId] = true;
				this._tzoneSelect.addOption(options[i]);
			}
		}
	}
	this.autoSelectTimezone();
};



ZmTimeDialog.prototype.isValid = 
function() {
	return true;
};

ZmTimeDialog.prototype.isDirty = 
function() {
	return true;
};

ZmTimeDialog.prototype.getValue =
function() {
	var date = this._timeSelect.getValue(AjxDateUtil.simpleParseDateStr(this._dateField.value));
	var timezone = this._tzoneSelect.getValue();
	return {date: date, timezone: timezone};
}

ZmTimeDialog.prototype.isValidDateStr =
function() {
    return AjxDateUtil.isValidSimpleDateStr(this._dateField.value);
};

ZmTimeDialog.prototype.popup =
function() {
	this.initialize();
	ZmDialog.prototype.popup.call(this);
	if (!this._tabGroupComplete) {
		var members = [this._dateField, this._dateButton, this._timeSelect.getInputField(), this._tzoneSelect];
		for (var i = 0; i < members.length; i++) {
			this._tabGroup.addMember(members[i], i);
		}
		this._tabGroupComplete = true;
	}
	this._tabGroup.setFocusMember(this._dateField);
};

// Private / protected methods

ZmTimeDialog.prototype._createDwtObjects =
function() {

	var dateButtonListener = new AjxListener(this, this._dateButtonListener);
	var dateCalSelectionListener = new AjxListener(this, this._dateCalSelectionListener);

	this._dateButton = this.createMiniCalButton(this._htmlElId + "_miniCal", dateButtonListener, dateCalSelectionListener);

	// create selects for Time section
	var timeSelectListener = new AjxListener(this, this._timeChangeListener);
	
	this._timeSelect = new DwtTimeInput(this, DwtTimeInput.START);
	this._timeSelect.addChangeListener(timeSelectListener);
	this._timeSelect.reparentHtmlElement(this._htmlElId + "_time");

	this._dateField = Dwt.byId(this._htmlElId + "_date");

	this._tzoneSelect = new DwtSelect({parent:this, parentElement: (this._htmlElId + "_tzSelect"), layout:DwtMenu.LAYOUT_SCROLL, maxRows: 7, id: Dwt.getNextId("TimeZoneSelect_")});
};

ZmTimeDialog.prototype.showTimeFields = 
function(show) {
	Dwt.setVisibility(this._timeSelect.getHtmlElement(), show);
};

// Listeners

ZmTimeDialog.prototype._dateButtonListener = 
function(ev) {
	var calDate = AjxDateUtil.simpleParseDateStr(this._dateField.value);

	// if date was input by user and its foobar, reset to today's date
	if (calDate === null || isNaN(calDate)) {
		calDate = new Date();
		var field = this._dateField;
		field.value = AjxDateUtil.simpleComputeDateStr(calDate);
	}

	// always reset the date to current field's date
	var menu = ev.item.getMenu();
	var cal = menu.getItem(0);
	cal.setDate(calDate, true);
	ev.item.popup();
};

ZmTimeDialog.prototype._dateCalSelectionListener = 
function(ev) {
	var parentButton = ev.item.parent.parent;

	// do some error correction... maybe we can optimize this?
	var sd = AjxDateUtil.simpleParseDateStr(this._dateField.value);
	var newDate = AjxDateUtil.simpleComputeDateStr(ev.detail);

	// change the start/end date if they mismatch
	if (parentButton == this._dateButton) {
		this._dateField.value = newDate;
	}
};

ZmTimeDialog.prototype.createMiniCalButton =
function(buttonId, dateButtonListener, dateCalSelectionListener) {
	// create button
	var dateButton = new DwtButton({parent:this});
	dateButton.addDropDownSelectionListener(dateButtonListener);
	dateButton.setData(Dwt.KEY_ID, buttonId);
	if (AjxEnv.isIE) {
		dateButton.setSize("20");
	}

	// create menu for button
	var calMenu = new DwtMenu({parent:dateButton, style:DwtMenu.CALENDAR_PICKER_STYLE});
	calMenu.setSize("150");
	calMenu._table.width = "100%";
	dateButton.setMenu(calMenu, true);

	// create mini cal for menu for button
	var cal = new DwtCalendar({parent:calMenu});
	cal.setData(Dwt.KEY_ID, buttonId);
	cal.setSkipNotifyOnPage(true);
	var fdow = appCtxt.get(ZmSetting.CAL_FIRST_DAY_OF_WEEK) || 0;
	cal.setFirstDayOfWeek(fdow);
	cal.addSelectionListener(dateCalSelectionListener);
	// add settings change listener on mini cal in case first day of week setting changes
	// safety check since this is static code (may not have loaded calendar)
	var fdowSetting = appCtxt.getSettings().getSetting(ZmSetting.CAL_FIRST_DAY_OF_WEEK);
	if (fdowSetting) {
		var listener = new AjxListener(null, ZmCalendarApp._settingChangeListener, cal);
		fdowSetting.addChangeListener(listener);
	}

	// reparent and cleanup
	dateButton.reparentHtmlElement(buttonId);
	delete buttonId;

	return dateButton;
};

ZmTimeDialog.prototype.autoSelectTimezone =
function() {
	if (AjxTimezone.DEFAULT_RULE.autoDetected) {

		var cRule = AjxTimezone.DEFAULT_RULE;
		var standardOffsetMatch, daylightOffsetMatch, transMatch;

		for (var i in AjxTimezone.MATCHING_RULES) {
			var rule = AjxTimezone.MATCHING_RULES[i];
			if (rule.autoDetected) continue;
			if (rule.standard.offset == cRule.standard.offset) {

				if (!standardOffsetMatch)
					standardOffsetMatch = rule.serverId;

				var isDayLightOffsetMatching = (cRule.daylight && rule.daylight && (rule.daylight.offset == cRule.daylight.offset));

				if(isDayLightOffsetMatching) {
					if (!daylightOffsetMatch)
						daylightOffsetMatch = rule.serverId;
					var isTransYearMatching = (rule.daylight.trans[0] == cRule.daylight.trans[0]);
					var isTransMonthMatching = (rule.daylight.trans[1] == cRule.daylight.trans[1]);
					if (isTransYearMatching && isTransMonthMatching && !transMatch)
						transMatch = rule.serverId;
				}
			}
		}
		//select closest matching timezone
		var serverId = transMatch ? transMatch : (daylightOffsetMatch || standardOffsetMatch);
		if (serverId) this._tzoneSelect.setSelectedValue(serverId);
	} else {
		var tz = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
		this._tzoneSelect.setSelectedValue(tz);
	}
};
}
if (AjxPackage.define("zimbraMail.share.view.dialog.ZmNewOrganizerDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates a new organizer dialog.
 * @class
 * This class represents a new organizer dialog.
 * 
 * @param	{DwtControl}	parent		the parent
 * @param	{String}	className		the class name
 * @param	{String}	title		the title
 * @param	{constant}	type		the organizer type
 * 
 * @extends		ZmDialog
 */
ZmNewOrganizerDialog = function(parent, className, title, type, extraButtons) {
	if (arguments.length == 0) return;

	this._organizerType = type;
	ZmDialog.call(this, {parent:parent, className:className, title:title, id:"CreateNewFolderDialog", extraButtons: extraButtons});
	this._setupControls();
};

ZmNewOrganizerDialog.prototype = new ZmDialog;
ZmNewOrganizerDialog.prototype.constructor = ZmNewOrganizerDialog;

ZmNewOrganizerDialog.prototype.isZmNewOrganizerDialog = true;
ZmNewOrganizerDialog.prototype.toString = function() { return "ZmNewOrganizerDialog"; };

//override the following if needed
ZmNewOrganizerDialog.prototype._folderLocationLabel = ZmMsg.newFolderParent;
ZmNewOrganizerDialog.prototype._folderNameAlreadyExistsMsg = ZmMsg.errorAlreadyExists;

// Public methods

/**
 * Pops-up the dialog.
 * 
 * @param {ZmOrganizer|hash}	params      popup parameters
 * @param	{ZmAccount}	account		the account
 */
ZmNewOrganizerDialog.prototype.popup =
function(params, account) {

	params = params || {};
    var folder = params instanceof ZmOrganizer ? params : (params && params.organizer);

	var parentLabelCell = document.getElementById(this._htmlElId + '_parentLabel');
	var parentValueCell = document.getElementById(this._htmlElId + '_parentValue');
	this._parentFolder = null;

	// if the user has already implicitly selected a parent folder, don't show overview
	if (folder && folder.id != ZmOrganizer.ID_ROOT) {
		this._parentFolder = folder;
		this._makeOverviewVisible();    // hide all overviews
		if (parentLabelCell) {
			parentLabelCell.colSpan = 1;
			parentLabelCell.innerHTML = ZmMsg.parentFolderLabel;
			parentValueCell.innerHTML = folder.getName();
		}
	}
	else {
		if (this._folderTreeCellId) {
			if (parentLabelCell) {
				parentLabelCell.innerHTML = this._folderLocationLabel;
				parentLabelCell.colSpan = 2;
				parentValueCell.innerHTML = '';
			}
			var overviewParams = {
				appName:		params.appName,
				overviewId:		this.toString() + (params.appName || ""),
				treeIds:		this._treeIds,
				omit:			this._omit,
				fieldId:		this._folderTreeCellId,
				overviewTrees:	[this._organizerType],
	            treeStyle:      this._treeStyle
			};
			var overview = this._setOverview(overviewParams);
			overview.removeAttribute('aria-label');
			overview.setAttribute('aria-labelledby', this._htmlElId + '_parentLabel');

			if (this._folderTreeView) {
				// bug #18533 - always make sure header item is visible in "New" dialog
				this._folderTreeView.getHeaderItem().setVisible(true, true);

				if (!folder || this._omit[folder.nId] || folder.nId == ZmOrganizer.ID_ROOT) {
					folder = appCtxt.getFolderTree().root; //default to root if no folder passed, the folder is omitted from the overview. (I don't get the last option, but it was there so I keep it - it's already root)
				}
				var ti = this._folderTreeView.getTreeItemById(folder.id);
				if (ti) {
					this._folderTreeView.setSelection(ti, true, null, true);
				}
				if (folder.nId == ZmOrganizer.ID_ROOT) {
					var sid = ZmOrganizer.getSystemId(folder.id);
					var ti = this._folderTreeView.getTreeItemById(sid);
					if (ti) {
						ti.setExpanded(true);
					}
				}
			}
		}
	}

    if (this._colorSelect) {
        var defaultColorCode = ZmOrganizer.DEFAULT_COLOR[this._organizerType],
            defaultColor = ZmOrganizer.COLOR_VALUES[defaultColorCode],
            colorMenu = this._colorSelect.getMenu(),
            moreColorMenu;
        if(colorMenu) {
            moreColorMenu = (colorMenu.toString() == "ZmMoreColorMenu") ? colorMenu : colorMenu._getMoreColorMenu();
            if(moreColorMenu) moreColorMenu.setDefaultColor(defaultColor);
        }

        var icon = null;
        var orgType = this._organizerType;
        var orgClass = ZmOrganizer.ORG_CLASS[orgType];
        if (orgClass) {
			//to fix bug 55320 - got rid of the calling getIcon on the prototype hack - that caused isRemote to set _isRemote on the prototype thus causing every object to have it by default set.
            //bug 55491: pass tmp. organizer id to make sure this._isRemote is not true by default.
			var sample = new window[orgClass]({id:Dwt.getNextId()}); //get a sample object just for the icon
			icon = sample.getIcon();
        }

        this._colorSelect.setImage(icon);
        this._colorSelect.setValue(ZmOrganizer.DEFAULT_COLOR[orgType]);
    }

	var ovContainer = appCtxt.multiAccounts && this._opc.getOverviewContainer(this.toString());
	if (ovContainer) {
		if (!folder || (folder && folder.nId == ZmOrganizer.ID_ROOT)) {
			var acct = account || appCtxt.getActiveAccount();
			ovContainer.setSelection(ovContainer.getHeaderItem(acct));
		} else {
			var overviewId = appCtxt.getOverviewId(this.toString(), account);
			var overview = ovContainer.getOverview(overviewId);
			var treeView = overview && overview.getTreeView(this._organizerType);
			if (treeView) {
				ovContainer.deselectAll();
				var ti = treeView.getTreeItemById(folder.id);
				treeView.setSelection(ti);
			}
		}

		ovContainer.expandAccountOnly(account);
	}

	ZmDialog.prototype.popup.call(this);
};

/**
 * Resets the dialog.
 * 
 * @param	{ZmAccount}	account		the account
 */
ZmNewOrganizerDialog.prototype.reset = function(account) {

	ZmDialog.prototype.reset.apply(this, arguments);

	if (this._remoteCheckboxField) {
		this._remoteCheckboxField.checked = false;
		var urlRow = document.getElementById(this._remoteCheckboxFieldId + "URLrow");
		if (urlRow) {
			urlRow.style.display = "none";
		}
	}

	if (this._urlField) {
		this._urlField.value = "";
		this._urlField.noTab = true;
	}

	if (appCtxt.multiAccounts) {
		this._account = account;
	} else {
		this._account = null;
	}
};


//
// Protected methods
//

ZmNewOrganizerDialog.prototype._getRemoteLabel =
function() {
	return ZmMsg.subscribeToFeed;
};

// create html

ZmNewOrganizerDialog.prototype._contentHtml = 
function() {
	var html = [];
	var idx = 0;
	html[idx++] = "<table class='ChooserDialog ZPropertySheet' cellspacing='6' >";
	idx = this._createStandardContentHtml(html, idx);
	idx = this._createExtraContentHtml(html, idx);
	html[idx++] = "</table>";
	return html.join("");
};

ZmNewOrganizerDialog.prototype._createStandardContentHtml =
function(html, idx) {
	idx = this._createNameContentHtml(html, idx);
	if (this._organizerType != ZmOrganizer.FOLDER || (this._organizerType == ZmOrganizer.FOLDER && appCtxt.get(ZmSetting.MAIL_FOLDER_COLORS_ENABLED))) {
		idx = this._createColorContentHtml(html, idx);
	}
	return idx;
};

ZmNewOrganizerDialog.prototype._createNameContentHtml =
function(html, idx) {
	this._nameFieldId = this._htmlElId + "_name";
	html[idx++] = AjxTemplate.expand("share.Dialogs#ZmNewOrgDialogName", {id:this._htmlElId});
	return idx;
};

ZmNewOrganizerDialog.prototype._createColorContentHtml =
function(html, idx) {
	this._colorSelectId = this._htmlElId + "_colorSelect";
	html[idx++] = AjxTemplate.expand("share.Dialogs#ZmNewOrgDialogColor", {id:this._htmlElId});
	return idx;
};

ZmNewOrganizerDialog.prototype._createExtraContentHtml =
function(html, idx) {
	idx = this._createRemoteContentHtml(html, idx);
	idx = this._createFolderContentHtml(html, idx);
	return idx;
};

ZmNewOrganizerDialog.prototype._createRemoteContentHtml = function(html, idx) {

	this._remoteCheckboxFieldId = this._htmlElId + "_remote";

	var subs = {
		id: this._htmlElId,
		remoteLabel: this._getRemoteLabel()
	};
	html[idx++] = AjxTemplate.expand("share.Dialogs#ZmNewOrgDialogRemote", subs);
	return idx;
};

ZmNewOrganizerDialog.prototype._createFolderContentHtml =
function(html, idx) {
	this._folderTreeCellId = this._htmlElId + "_folderTree";
	html[idx++] = AjxTemplate.expand("share.Dialogs#ZmNewOrgDialogFolder", {id:this._htmlElId});
	return idx;
};

// setup dwt controls

ZmNewOrganizerDialog.prototype._setupControls =
function() {
	this._setupStandardControls();
	this._setupExtraControls();
};

ZmNewOrganizerDialog.prototype._setupStandardControls =
function() {
	this._setupNameControl();
	this._setupColorControl();
};

ZmNewOrganizerDialog.prototype._setupNameControl =
function() {
	this._setNameField(this._nameFieldId);
};

ZmNewOrganizerDialog.prototype._setupColorControl =
function() {
    var el = document.getElementById(this._colorSelectId);
	this._colorSelect = new ZmColorButton({
		parent:         this,
		parentElement:  el,
		labelId:        this._htmlElId + '_lblColor'
	});
};

ZmNewOrganizerDialog.prototype._setupExtraControls =
function() {
	this._setupRemoteControl();
	this._setupFolderControl();
};

ZmNewOrganizerDialog.prototype._setupRemoteControl =
function() {
	this._remoteCheckboxField = document.getElementById(this._remoteCheckboxFieldId);
	if (this._remoteCheckboxField) {
		this._urlField = document.getElementById(this._remoteCheckboxFieldId + "URLfield");
		Dwt.setHandler(this._remoteCheckboxField, DwtEvent.ONCLICK, this._handleCheckbox.bind(this));
	}
};

ZmNewOrganizerDialog.prototype._setupFolderControl =
function() {
	if (!this._folderTreeCellId) { return; }
	
	this._treeIds = [this._organizerType];

	this._omit = {};
	this._omit[ZmFolder.ID_SPAM] = true;
	this._omit[ZmFolder.ID_DRAFTS] = true;
	this._omit[ZmFolder.ID_SYNC_FAILURES] = true;
	this._omit[ZmFolder.ID_OUTBOX] = true;

	//Bug#68799: no special handling needed for sync issues folder
	/*var folderTree = appCtxt.getFolderTree();
	var syncIssuesFolder = folderTree ? folderTree.getByName(ZmFolder.SYNC_ISSUES) : null;
	if (syncIssuesFolder) {
		this._omit[syncIssuesFolder.id] = true;
	}*/
	this._omit[ZmOrganizer.ID_ZIMLET] = true;
};

// other

ZmNewOrganizerDialog.prototype._renderOverview =
function(overview, treeIds, omit, noRootSelect) {
	this._setupFolderControl();	// reset in case we changed accounts (family mailbox)
	ZmDialog.prototype._renderOverview.apply(this, arguments);
	this._folderTreeView = overview.getTreeView(this._organizerType);
};

ZmNewOrganizerDialog.prototype._getOverviewOrOverviewContainer =
function() {
	if (appCtxt.multiAccounts) {
		return this._opc.getOverviewContainer(this.toString());
	}
	return this._opc.getOverview(this._curOverviewId);

};


/** 
 * Checks the input for validity and returns the following array of values:
 * <ul>
 * <li> parentFolder
 * <li> name
 * <li> color
 * <li> URL
 * </ul>
 */
ZmNewOrganizerDialog.prototype._getFolderData =
function() {
	// make sure a parent was selected
	var ov = this._getOverviewOrOverviewContainer();

	var parentFolder = this._parentFolder || (ov && ov.getSelected()) || appCtxt.getFolderTree(this._account).root;

	if (this._isGlobalSearch) {
		//special case for global search (only possible if this is ZmNewSearchDialog
		parentFolder = appCtxt.getById(ZmOrganizer.ID_ROOT);
	}

	// check name for presence and validity
	var name = AjxStringUtil.trim(this._nameField.value);
	var msg = ZmFolder.checkName(name, parentFolder);

	// make sure parent doesn't already have a child by this name
	if (!msg && parentFolder.hasChild(name)) {
        var folderType = appCtxt.getFolderTree(appCtxt.getActiveAccount()).getFolderTypeByName(name);
		msg = AjxMessageFormat.format(this._folderNameAlreadyExistsMsg, [name,ZmMsg[folderType.toLowerCase()]]);
	}

	var color = null;
	if (!msg && this._colorSelectId) {
		color = this._colorSelect.getValue();
	}

	var url = null;
	if (!msg && this._remoteCheckboxField) {
		url = this._remoteCheckboxField.checked ? this._urlField.value : null;
		if (url || url != null) {
			msg = ZmOrganizer.checkUrl(url);
		}
	}

	if (!msg && parentFolder.disallowSubFolder) {
		msg = AjxMessageFormat.format(ZmMsg.errorSubFolderNotAllowed, parentFolder.name);
	}

    if (msg) {
        return this._showError(msg);
    }

	var account = appCtxt.multiAccounts ? parentFolder.getAccount() : null;
	var params = {l:parentFolder.id, name:name, color:color, url:url, account:account};
    if (String(color).match(/^#/)) {
        params.rgb = color;
        delete params.color;
    }
    return params;
};

ZmNewOrganizerDialog.prototype._getTabGroupMembers =
function() {
	var list = [this._nameField];
	if (this._colorSelect) {
		list.push(this._colorSelect);
	}
	if (this._remoteCheckboxField) {
		list.push(this._remoteCheckboxField);
		if (this._urlField) {
			list.push(this._urlField);
		}
	}
	if (this._overview[this._curOverviewId]) {
		list.push(this._overview[this._curOverviewId]);
	}
	return list;
};

// dwt event listeners

ZmNewOrganizerDialog.prototype._okButtonListener =
function(ev) {
	var results = this._getFolderData();
	if (results) {
		DwtDialog.prototype._buttonListener.call(this, ev, results);
	}
};

ZmNewOrganizerDialog.prototype._enterListener =
function(ev) {
	var results = this._getFolderData();
	if (results) {
		this._runEnterCallback(results);
	}
};


// html event handlers

ZmNewOrganizerDialog.prototype._handleCheckbox = function(event) {

	event = event || window.event;
	var target = DwtUiEvent.getTarget(event);
	var urlRow = document.getElementById(target.id + "URLrow");
	urlRow.style.display = target.checked ? (AjxEnv.isIE ? "block" : "table-row") : "none";
	if (this._urlField) {
		if (target.checked) {
			this._urlField.focus();
		}
		this._urlField.noTab = !target.checked;
	}
};

ZmNewOrganizerDialog.prototype.setRemoteURL =
function(url) {
    this._remoteCheckboxField.checked = true;
    this._urlField.value = url;
    var urlRow = document.getElementById(this._remoteCheckboxFieldId + "URLrow");
	var urlField= document.getElementById(this._remoteCheckboxFieldId + "URLfield");
	urlRow.style.display = AjxEnv.isIE ? "block" : "table-row";

};
}
if (AjxPackage.define("zimbraMail.share.view.dialog.ZmAttachDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates an attachment dialog.
 * @class
 * This class represents an attachment dialog.
 * 
 * @param	{DwtControl}	shell		the parent
 * @param	{String}	className		the class name
 * 
 * @extends		DwtDialog
 */
ZmAttachDialog = function(shell, className) {

	className = className || "ZmAttachDialog";
	DwtDialog.call(this, {parent:shell, className:className, title:ZmMsg.attachFile});

	// Initialize
	this._createBaseHtml();

	// Ok and Cancel Actions
	this._defaultCancelCallback = new AjxCallback(this, this._defaultCancelListener);
	this._cancelListener = null;

	this._defaultOkCallback = new AjxCallback(this, this._defaultOkListener);
	this._okListener = null;

	this.setButtonListener(DwtDialog.CANCEL_BUTTON, new AjxListener(this, function() {
		this._cancelButtonListener();
	}));

	this.setButtonListener(DwtDialog.OK_BUTTON, new AjxListener(this, function() {
		this._okButtonListener();
	}));


	var okButton = this.getButton(DwtDialog.OK_BUTTON);
	okButton.setText(ZmMsg.attach);

};

ZmAttachDialog.prototype = new DwtDialog;
ZmAttachDialog.prototype.constructor = ZmAttachDialog;

/**
 * Defines the "briefcase" tab key.
 */
ZmAttachDialog.TABKEY_BRIEFCASE		= "BRIEFCASE";

//Listeners

/**
 * Adds a cancel button listener.
 * 
 * @param	{constant}		tabKey		the tab key (see <code>TABKEY_</code> constants)
 * @param	{AjxListener|AjxCallback}	cancelCallbackOrListener		the listener
 */
ZmAttachDialog.prototype.setCancelListener =
function(cancelCallbackOrListener) {
	if (cancelCallbackOrListener &&
		(cancelCallbackOrListener instanceof AjxListener ||
		 cancelCallbackOrListener instanceof AjxCallback))
	{
		this._cancelListener = cancelCallbackOrListener;
	}
};


ZmAttachDialog.prototype._defaultCancelListener =
function() {
	this.popdown();
};

ZmAttachDialog.prototype._cancelButtonListener =
function() {
	if (this._cancelListener) {
		this._cancelListener.run();
	} else {
		this._defaultCancelCallback.run();
	}
};

/**
 * Adds a OK button listener.
 * 
 * @param	{constant}		tabKey		the tab key (see <code>TABKEY_</code> constants)
 * @param	{AjxListener|AjxCallback}	cancelCallbackOrListener		the listener
 */
ZmAttachDialog.prototype.setOkListener =
function(okCallbackOrListener) {
	if (okCallbackOrListener &&
		(okCallbackOrListener instanceof AjxListener ||
		 okCallbackOrListener instanceof AjxCallback))
	{
		this._okListener = okCallbackOrListener;
	}
};

ZmAttachDialog.prototype._defaultOkListener =
function() {
	this.popdown();
};

ZmAttachDialog.prototype._okButtonListener =
function() {

    var okButton = this.getButton(DwtDialog.OK_BUTTON);
    okButton.setEnabled(false);

	if (this._okListener) {
		this._okListener.run(this);
	} else {
		this._defaultOkCallback.run();
	}
    
     okButton.setEnabled(true);
};

// Create HTML Container
ZmAttachDialog.prototype._createBaseHtml =
function() {
	this._baseContainerView = new DwtComposite({parent:this, className:"ZmAttachDialog-container"});
	this._initializeTabView(this._baseContainerView);
	this.setView(this._baseContainerView);
};

ZmAttachDialog.prototype._initializeTabView =
function(view) {
    this._setAttachmentSizeSection(view);
	this._setInlineOptionSection(view);
    this._setMsgSection(view);
	this._setFooterSection(view);
};

/**
 * @private
 */
ZmAttachDialog.prototype.stateChangeListener =
function(ev) {
	// Reset Inline Options Here
	this._resetInlineOption();
};


ZmAttachDialog.prototype._setAttachmentSizeSection =
function(view) {
	var div = document.createElement("div");
	div.className = "ZmAttachDialog-note";
    var attSize = AjxUtil.formatSize(appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT) || 0, true)
	div.innerHTML = AjxMessageFormat.format(ZmMsg.attachmentLimitMsg, attSize);
	view.getHtmlElement().appendChild(div);
};

ZmAttachDialog.prototype._setMsgSection =
function(view) {
	var div = document.createElement("div");
	div.className = "ZmAttachDialog-footer";
	div.id = Dwt.getNextId();
	view.getHtmlElement().appendChild(div);
	this._msgDiv = document.getElementById(div.id);
};

ZmAttachDialog.prototype._setFooterSection =
function(view) {
	var div = document.createElement("div");
	div.className = "ZmAttachDialog-footer";
	div.id = Dwt.getNextId();
	view.getHtmlElement().appendChild(div);

	this._footer = document.getElementById(div.id);
};

/**
 * Sets the footer content.
 * 
 * @param	{String}	html		the HTML footer content
 */
ZmAttachDialog.prototype.setFooter =
function(html) {
	if (typeof html == "string") {
		this._footer.innerHTML = html;
	} else {
		this._footer.appendChild(html);
	}
};

//Called when AjxEnv.supportsHTML5File is false

ZmAttachDialog.prototype.submitAttachmentFile =
function(view) {
    this.upload(this._uploadCallback, view.uploadForm);
};

ZmAttachDialog.prototype.cancelUploadFiles =
function() {
	// Fix this, as this needs feature request like AjxPost.getRequestId()
	// We need to cancel actual request, but for now just close the window
	this._cancelUpload = true;
	this._defaultCancelListener();
};

ZmAttachDialog.prototype.setUploadCallback =
function(callback) {
	this._uploadCallback = callback;
};

ZmAttachDialog.prototype.getUploadCallback =
function() {
	return this._uploadCallback;
};

/**
 * Uploads the attachments.
 * 
 * @param	{AjxCallback}		callback		the callback
 * @param	{Object}			uploadForm		the upload form
 */
ZmAttachDialog.prototype.upload =
function(callback, uploadForm) {
	if (!callback) {
		callback = false;
	}
	this.setButtonEnabled(DwtDialog.OK_BUTTON, false);
	this.setButtonEnabled(DwtDialog.CANCEL_BUTTON, true);
	this.setFooter(ZmMsg.attachingFiles);
	this._cancelUpload = false;
	this._processUpload(callback, uploadForm);
};

ZmAttachDialog.prototype._processUpload =
function(callback, uploadForm) {
	var ajxCallback = new AjxCallback(this, this._uploadDoneCallback, [callback]);
	var um = appCtxt.getUploadManager();
	window._uploadManager = um;

	try {
		um.execute(ajxCallback, uploadForm);
	} catch (ex) {
		ajxCallback.run();
	}
};

ZmAttachDialog.prototype._uploadDoneCallback =
function(callback, status, attId) {
	if (this._cancelUpload) { return; }

	this.setButtonEnabled(DwtDialog.CANCEL_BUTTON, true);

	if (status == AjxPost.SC_OK) {
		this.setFooter(ZmMsg.attachingFilesDone);
		if (callback) {
			callback.run(status, attId);
		}
	} else if (status == AjxPost.SC_UNAUTHORIZED) {
		// auth failed during att upload - let user relogin, continue with compose action
		var ex = new AjxException("401 response during attachment upload", ZmCsfeException.SVC_AUTH_EXPIRED);
		appCtxt.getAppController()._handleException(ex, {continueCallback:callback});
	} else {
		// bug fix #2131 - handle errors during attachment upload.
		appCtxt.getAppController().popupUploadErrorDialog(ZmItem.MSG, status);
		this.setFooter(ZmMsg.attachingFilesError);
	}

	this.setButtonEnabled(DwtDialog.OK_BUTTON, true);
};

ZmAttachDialog.prototype.removePrevAttDialogContent =
function(contentDiv) {
    var elementNode =  contentDiv && contentDiv.firstChild;
    if (elementNode && elementNode.className == "DwtComposite" ){
        contentDiv.removeChild(elementNode);
    }
};


ZmAttachDialog.prototype.getBriefcaseView =
function(){

    this.removePrevAttDialogContent(this._getContentDiv().firstChild);
    this.setTitle(ZmMsg.attachFile);

	if (!this._briefcaseView) {
		AjxDispatcher.require(["BriefcaseCore", "Briefcase"]);
		this._briefcaseView = new ZmBriefcaseTabView(this);
	}

    this._briefcaseView.reparentHtmlElement(this._getContentDiv().childNodes[0], 0);
    var okCallback = new AjxCallback(this._briefcaseView, this._briefcaseView.uploadFiles);
    this.setOkListener(okCallback);
    this.setCancelListener((new AjxCallback(this,this.cancelUploadFiles)));


	return this._briefcaseView;
};

// Inline Option for attachment Dialog.
ZmAttachDialog.prototype._setInlineOptionSection =
function(view){
	var div = document.createElement("div");
	div.className = "ZmAttachDialog-inline";
	div.id = Dwt.getNextId();
	view.getHtmlElement().appendChild(div);

	this._inlineOption = document.getElementById(div.id);
};

ZmAttachDialog.prototype.enableInlineOption =
function(enable) {
	if (enable) {
		var inlineCheckboxId = this._htmlElId + "_inlineCheckbox";
		this._inlineOption.setAttribute("option", "inline");
		this._inlineOption.innerHTML = [
			"<input type='checkbox' name='inlineimages' id='",
			inlineCheckboxId,
			"'> <label for='",
			inlineCheckboxId,
			"'>",
			ZmMsg.inlineAttachmentOption,
			"</label>"
		].join("");
		this._tabGroup.addMember(this._inlineOption.getElementsByTagName('input')[0],0);
	} else {
		this._inlineOption.innerHTML = "";
	}
};

ZmAttachDialog.prototype._resetInlineOption =
function() {
	var inlineOption = document.getElementById(this._htmlElId+"_inlineCheckbox");
	if (inlineOption) {
		inlineOption.checked = false;
	}
};

ZmAttachDialog.prototype.isInline =
function() {
	var inlineOption = document.getElementById(this._htmlElId+"_inlineCheckbox");
	return (inlineOption && inlineOption.checked);
};

ZmAttachDialog.prototype.setInline =
function(checked) {
	var inlineOption = document.getElementById(this._htmlElId+"_inlineCheckbox");

	if (inlineOption)
		inlineOption.checked = checked;
};


/**
 * Attachment Upload View
 *
 * @param parent
 * @param className
 * @param posStyle
 *
 * @class
 * @private
 */
ZmAttachDialog.prototype.getMyComputerView =
function(){
    var newElm = false;
    this.removePrevAttDialogContent(this._getContentDiv().firstChild);
    this.setTitle(ZmMsg.attachFile);

	if (!this._myComputerView) {
		this._myComputerView = new ZmMyComputerTabViewPage(this);
        newElm = true;
	}

    this._myComputerView.reparentHtmlElement(this._getContentDiv().childNodes[0], 0);

    if (!newElm) {
        this._myComputerView.resetAttachments()
    }

    var okCallback = new AjxCallback(this, this.submitAttachmentFile,[this._myComputerView]);
    this.setOkListener(okCallback);
    this.setCancelListener((new AjxCallback(this,this.cancelUploadFiles)));

	return this._myComputerView;
};


ZmMyComputerTabViewPage = function(parent, className, posStyle) {
	if (arguments.length == 0) { return; }

	DwtComposite.call(this, parent, className, Dwt.STATIC_STYLE);
    this._createHtml();
    this.showMe();
	this.setScrollStyle(Dwt.SCROLL);
};

ZmMyComputerTabViewPage.prototype = new DwtComposite;
ZmMyComputerTabViewPage.prototype.constructor = ZmMyComputerTabViewPage;

ZmMyComputerTabViewPage.SHOW_NO_ATTACHMENTS	= 5;
ZmMyComputerTabViewPage.MAX_NO_ATTACHMENTS	= 10;
ZmMyComputerTabViewPage.UPLOAD_FIELD_NAME	= "_attFile_";


ZmMyComputerTabViewPage.prototype.showMe =
function() {
	this.resetAttachments();
	this.setSize(Dwt.DEFAULT, "240");
	this._focusAttEl();
};

ZmMyComputerTabViewPage.prototype.hideMe =
function() {
	DwtTabViewPage.prototype.hideMe.call(this);
};

// Create UI for MyComputer
ZmMyComputerTabViewPage.prototype._createHtml =
function() {

	var subs = {
		id: this._htmlElId,
		uri: (appCtxt.get(ZmSetting.CSFE_ATTACHMENT_UPLOAD_URI) + "?fmt=extended")
	};
	this.setContent(AjxTemplate.expand("share.Dialogs#ZmAttachDialog-MyComputerTab", subs));

	this.attachmentTable = document.getElementById(this._htmlElId+"_attachmentTable");
	this.uploadForm = document.getElementById(this._htmlElId+"_uploadForm");
	this.attachmentButtonTable = document.getElementById(this._htmlElId+"_attachmentButtonTable");

	this._addAttachmentFieldButton();
	this._attachCount = 0;
};

// Attachments
ZmMyComputerTabViewPage.prototype._addAttachmentField =
function() {
	if (this._attachCount >= ZmMyComputerTabViewPage.MAX_NO_ATTACHMENTS) { return; }

	this._attachCount++;

	var row = this.attachmentTable.insertRow(-1);
	var cell = row.insertCell(-1);
	var fieldId = Dwt.getNextId();

	var subs = {
		id: fieldId,
		uploadName: ZmMyComputerTabViewPage.UPLOAD_FIELD_NAME
	};
	cell.innerHTML = AjxTemplate.expand("share.Dialogs#ZmAttachDialog-MyComputerTab-AddAttachment", subs);

	var removeEl = document.getElementById(fieldId+"_remove");   
	removeEl.onclick = AjxCallback.simpleClosure(this._removeAttachmentField, this, row);

    var inputId = fieldId+"_input";
	if (this._focusElId == -1) {
		this._focusElId = inputId;
	}    
    var inputEl = document.getElementById(inputId);
    var sizeEl = document.getElementById(fieldId+"_size");

    //HTML5
    if(AjxEnv.supportsHTML5File){
        Dwt.setHandler(inputEl, "onchange", AjxCallback.simpleClosure(this._handleFileSize, this, inputEl, sizeEl));
    }

	// trap key presses in IE for input field so we can ignore ENTER key (bug 961)
	if (AjxEnv.isIE) {
		inputEl.onkeydown = AjxCallback.simpleClosure(this._handleKeys, this);
	}
};

ZmMyComputerTabViewPage.prototype._handleFileSize =
function(inputEl, sizeEl){

    var files = inputEl.files;
    if(!files) return;

    var sizeStr = [], className, totalSize =0;
    for(var i=0; i<files.length;i++){
        var file = files[i];
        var size = file.size || file.fileSize /*Safari*/ || 0;
        if ((-1 /* means unlimited */ != appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT)) &&
            (size > appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT))) {
            className = "RedC";
        }
        totalSize += size;
    }

    if(sizeEl) {
        sizeEl.innerHTML = "  ("+AjxUtil.formatSize(totalSize, true)+")";
        if(className)
            Dwt.addClass(sizeEl, "RedC");
        else
            Dwt.delClass(sizeEl, "RedC");
    }
};



ZmMyComputerTabViewPage.prototype._removeAttachmentField =
function(row) {
	this.attachmentTable.deleteRow(row.rowIndex);
	this._attachCount--;

	if (this._attachCount == 0) {
		this._addAttachmentField();
	}
};

ZmMyComputerTabViewPage.prototype._addAttachmentFieldButton =
function() {
	var row = this.attachmentButtonTable.insertRow(-1);
	var cell = row.insertCell(-1);

	var button = new DwtButton({parent:this, parentElement:cell});
	button.setText(ZmMsg.addMoreAttachments);
	button.addSelectionListener(new AjxListener(this, this._addAttachmentField));
};

ZmMyComputerTabViewPage.prototype.gotAttachments =
function() {
	var atts = document.getElementsByName(ZmMyComputerTabViewPage.UPLOAD_FIELD_NAME);

	for (var i = 0; i < atts.length; i++)
		if (atts[i].value.length) {
			return true;
		}
	return false;
};

ZmMyComputerTabViewPage.prototype.resetAttachments =
function() {
	// CleanUp
	this._cleanTable(this.attachmentTable);
	this._attachCount = 0;
	if (ZmMyComputerTabViewPage.SHOW_NO_ATTACHMENTS > ZmMyComputerTabViewPage.MAX_NO_ATTACHMENTS) {
		ZmMyComputerTabViewPage.SHOW_NO_ATTACHMENTS = ZmMyComputerTabViewPage.MAX_NO_ATTACHMENTS;
	}

	// Re-initialize UI
	this._focusElId = -1;
	var row = this.attachmentTable.insertRow(-1);
	var cell = row.insertCell(-1);
	cell.appendChild(document.createElement("br"));
	cell.appendChild(document.createElement("br"));

	for (var i = 0; i < ZmMyComputerTabViewPage.SHOW_NO_ATTACHMENTS; i++) {
		this._addAttachmentField();
	}
	delete i;
};

ZmMyComputerTabViewPage.prototype._focusAttEl =
function() {
	var el = document.getElementById(this._focusElId);
	if (el) el.focus();
};

// Utilities
ZmMyComputerTabViewPage.prototype._cleanTable =
function(table) {
	if (!table || !table.rows) { return; }
	while (table.rows.length > 0) {
		table.deleteRow(0);
	}
};

ZmMyComputerTabViewPage.prototype._handleKeys =
function(ev) {
	var key = DwtKeyEvent.getCharCode(ev);
	return !DwtKeyEvent.IS_RETURN[key];
};

ZmMyComputerTabViewPage.prototype._validateFileSize =
function(){

    var atts = document.getElementsByName(ZmMyComputerTabViewPage.UPLOAD_FIELD_NAME);
    var file, size;
	for (var i = 0; i < atts.length; i++){
        file = atts[i].files;
        if(!file || file.length == 0) continue;
        for(var j=0; j<file.length;j++){
            var f = file[j];
            size = f.size || f.fileSize /*Safari*/;
            if ((-1 /* means unlimited */ != appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT)) &&
                (size > appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT))) {
                return false;
            }
        }
    }
	return true;
};

ZmMyComputerTabViewPage.prototype.validate =
function(){
    var status, errorMsg;
    if(AjxEnv.supportsHTML5File){
        status = this._validateFileSize();
        errorMsg = AjxMessageFormat.format(ZmMsg.attachmentSizeError, AjxUtil.formatSize(appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT)));
    }else{
        status = true;
    }

    return {status: status, error:errorMsg};
};
}
if (AjxPackage.define("zimbraMail.share.view.dialog.ZmQuickAddDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates a generic quick add dialog (which basically mean it has different 
 * than regular dialogs). Dialogs always hang off the main shell since their stacking order
 * is managed through z-index. See "dwt.Widgets#DwtSemiModalDialog" template.
 * @class
 * This class represents a modal dialog which has at least a title and the 
 * standard buttons (OK/Cancel) and widgets (i.e. buttons, etc) as necessary.
 * 
 * @author Parag Shah
 * 
 * @param {DwtComposite}	parent				the parent widget (the shell)
 * @param {String}	title				a title for the dialog
 * @param {Array}	standardButtons		a list of standard button IDs (default is [{@link DwtDialog.OK_BUTTON}, {@link DwtDialog.CANCEL_BUTTON}])
 * @param {Array}	extraButtons 		any extra buttons to be added in addition to the standard ones
 * @param {Object}	loc				where to popup (optional)
 * 
 * @extends		DwtDialog
 */
ZmQuickAddDialog = function(parent, title, standardButtons, extraButtons, loc) {
	if (arguments.length == 0) return;

	DwtDialog.call(this, {parent:parent, title:title, standardButtons:standardButtons,
						  extraButtons:extraButtons, loc:loc});
};

ZmQuickAddDialog.prototype = new DwtDialog;
ZmQuickAddDialog.prototype.constructor = ZmQuickAddDialog;

ZmQuickAddDialog.prototype.toString =
function() {
	return "ZmQuickAddDialog";
};

//
// Data
//

ZmQuickAddDialog.prototype.TEMPLATE = "dwt.Widgets#DwtSemiModalDialog";

//
// Public methods
//

/**
 * Adds a selection listener.
 * 
 * @param	{String}		buttonId		the button id
 * @param	{AjxListener}	listener		the listener
 */
ZmQuickAddDialog.prototype.addSelectionListener = 
function(buttonId, listener) {
	this._button[buttonId].addSelectionListener(listener);
};
}

if (AjxPackage.define("zimbraMail.share.view.htmlEditor.ZmHtmlEditor")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * HTML editor which wraps TinyMCE
 *
 * @param {Hash}		params				a hash of parameters:
 * @param {constant}	posStyle				new message, reply, forward, or an invite action
 * @param {Object}		content
 * @param {constant}	mode
 * @param {Boolean}		withAce
 * @param {Boolean}		parentElement
 * @param {String}		textAreaId
 * @param {Function}	attachmentCallback		callback to create image attachment
 * @param {Function}	pasteCallback			callback invoked when data is pasted and uploaded to the server
 * @param {Function}	initCallback			callback invoked when the editor is fully initialized
 *
 * @author Satish S
 * @private
 */
ZmHtmlEditor = function() {
	if (arguments.length == 0) { return; }

	var params = Dwt.getParams(arguments, ZmHtmlEditor.PARAMS);

	if (!params.className) {
		params.className = 'ZmHtmlEditor';
	}

	if (!params.id) {
		params.id = Dwt.getNextId('ZmHtmlEditor');
	}

    DwtControl.call(this, params);

	this.isTinyMCE = window.isTinyMCE;
	this._mode = params.mode;
	this._hasFocus = {};
	this._bodyTextAreaId = params.textAreaId || this.getHTMLElId() + '_body';
	this._iFrameId = this._bodyTextAreaId + "_ifr";
	this._initCallbacks = [];
	this._attachmentCallback = params.attachmentCallback;
	this._pasteCallback = params.pasteCallback;
	this._onContentInitializeCallbacks = []
	this.initTinyMCEEditor(params);
    this._ignoreWords = {};
	this._classCount = 0;

    if (params.initCallback)
        this._initCallbacks.push(params.initCallback);

    var settings = appCtxt.getSettings();
    var listener = new AjxListener(this, this._settingChangeListener);
    settings.getSetting(ZmSetting.COMPOSE_INIT_FONT_COLOR).addChangeListener(listener);
    settings.getSetting(ZmSetting.COMPOSE_INIT_FONT_FAMILY).addChangeListener(listener);
    settings.getSetting(ZmSetting.COMPOSE_INIT_FONT_SIZE).addChangeListener(listener);
    settings.getSetting(ZmSetting.COMPOSE_INIT_DIRECTION).addChangeListener(listener);
    settings.getSetting(ZmSetting.SHOW_COMPOSE_DIRECTION_BUTTONS).addChangeListener(listener);

	this.addControlListener(this._resetSize.bind(this));

	this.addListener(DwtEvent.ONFOCUS, this._onFocus.bind(this));
	this.addListener(DwtEvent.ONBLUR, this._onBlur.bind(this));
};

ZmHtmlEditor.PARAMS = [
	'parent',
	'posStyle',
	'content',
	'mode',
	'withAce',
	'parentElement',
	'textAreaId',
	'attachmentCallback',
	'initCallback'
];

ZmHtmlEditor.prototype = new DwtControl();
ZmHtmlEditor.prototype.constructor = ZmHtmlEditor;

ZmHtmlEditor.prototype.isZmHtmlEditor = true;
ZmHtmlEditor.prototype.isInputControl = true;
ZmHtmlEditor.prototype.toString = function() { return "ZmHtmlEditor"; };

ZmHtmlEditor.TINY_MCE_PATH = "/js/ajax/3rdparty/tinymce";

// used as a data key (mostly for menu items)
ZmHtmlEditor.VALUE = "value";

ZmHtmlEditor._INITDELAY = 50;

ZmHtmlEditor._containerDivId = "zimbraEditorContainer";

ZmHtmlEditor.prototype.getEditor =
function() {
	return  (window.tinyMCE) ? tinyMCE.get(this._bodyTextAreaId) : null;
};

ZmHtmlEditor.prototype.getBodyFieldId =
function() {
	if (this._mode == Dwt.HTML) {
		var editor = this.getEditor();
		return editor ? this._iFrameId : this._bodyTextAreaId;
	}

	return this._bodyTextAreaId;
};

ZmHtmlEditor.prototype.getBodyField =
function() {
	return document.getElementById(this.getBodyFieldId());
};

ZmHtmlEditor.prototype._resetSize =
function() {
	var field = this.getContentField();

	if (this._resetSizeAction) {
		clearTimeout(this._resetSizeAction);
		this._resetSizeAction = null;
	}

	if (field) {
		var bounds = this.boundsForChild(field);
		Dwt.setSize(field, bounds.width, bounds.height);
	}

	var editor = this.getEditor();

	if (!editor || !editor.getContentAreaContainer() || !editor.getBody()) {
		if (this.getVisible()) {
			this._resetSizeAction =
				setTimeout(ZmHtmlEditor.prototype._resetSize.bind(this), 100);
		}
		return;
	}

	var iframe = Dwt.byId(this._iFrameId);
	var bounds = this.boundsForChild(iframe);
	var x = bounds.width, y = bounds.height;

    //Subtracting editor toolbar heights
    AjxUtil.foreach(Dwt.byClassName('mce-toolbar-grp',
                                    editor.getContainer()),
                    function(elem) {
                        y -= Dwt.getSize(elem).y;
                    });

    // on Firefox, the toolbar is detected as unreasonably large during load;
    // so start the timer for small sizes -- even in small windows, the toolbar
    // should never be more than ~110px tall
    if (bounds.height - y > 200) {
        this._resetSizeAction =
            setTimeout(ZmHtmlEditor.prototype._resetSize.bind(this), 100);
        return;
    }

    //Subtracting spellcheckmodediv height
    var spellCheckModeDiv = this._spellCheckModeDivId && document.getElementById(this._spellCheckModeDivId);
    if (spellCheckModeDiv && spellCheckModeDiv.style.display !== "none") {
        y = y - Dwt.getSize(spellCheckModeDiv).y;
    }

	if (isNaN(x) || x < 0 || isNaN(y) || y < 0) {
		if (this.getVisible()) {
			this._resetSizeAction =
				setTimeout(ZmHtmlEditor.prototype._resetSize.bind(this), 100);
		}
		return;
	}

	Dwt.setSize(iframe, Math.max(0, x), Math.max(0, y));

	var body = editor.getBody();
	var bounds =
		Dwt.insetBounds(Dwt.insetBounds({x: 0, y: 0, width: x, height: y},
		                                Dwt.getMargins(body)),
		                Dwt.getInsets(body));

	Dwt.setSize(body, Math.max(0, bounds.width), Math.max(0, bounds.height));
};

ZmHtmlEditor.prototype.focus =
function(editor) {
    var currentObj = this,
        bodyField;

   if (currentObj._mode === Dwt.HTML) {
        editor = editor || currentObj.getEditor();
        if (currentObj._editorInitialized && editor) {
            editor.focus();
            currentObj.setFocusStatus(true);
            editor.getWin().scrollTo(0,0);
        }
    }
    else {
        bodyField = currentObj.getContentField();
        if (bodyField) {
            bodyField.focus();
            currentObj.setFocusStatus(true, true);
        }
    }
};

/**
 * @param	{Boolean}	keepModeDiv	if <code>true</code>, _spellCheckModeDiv is not removed
 */
ZmHtmlEditor.prototype.getTextVersion = function (convertor, keepModeDiv) {
    this.discardMisspelledWords(keepModeDiv);
    return this._mode === Dwt.HTML
        ? this._convertHtml2Text(convertor)
        : this.getContentField().value;
};

ZmHtmlEditor.prototype._focus = function() {
	if (this._mode === Dwt.HTML && this.getEditor()) {
		this.getEditor().focus();
	}
};

/**
 * Returns the content of the editor.
 * 
 * @param {boolean}		insertFontStyle		if true, add surrounding DIV with font settings
 * @param {boolean}		onlyInnerContent	if true, do not surround with HTML and BODY
 */
ZmHtmlEditor.prototype.getContent =
function(addDivContainer, onlyInnerContent) {

    this.discardMisspelledWords();
    
	var field = this.getContentField();

	var content = "";
	if (this._mode == Dwt.HTML) {
		var editor = this.getEditor(),
            content1 = "";
        if (editor) {
            content1 = editor.save({ format:"raw", set_dirty: false });
        }
        else {
            content1 = field.value || "";
        }
        if (content1 && (/\S+/.test(AjxStringUtil.convertHtml2Text(content1)) || content1.match(/<img/i)) ) {
			content = this._embedHtmlContent(content1, addDivContainer, onlyInnerContent, this._classCount);
		}
	}
	else {
		if (/\S+/.test(field.value)) {
			content = field.value;
		}
	}

	return content;
};

ZmHtmlEditor.prototype._embedHtmlContent =
function(html, addDivContainer, onlyInnerContent, classCount) {

	html = html || "";
	if (addDivContainer) {
		if (classCount) {
			var editor = this.getEditor();
			var document = editor.getDoc();
			var containerEl = document.getElementById(ZmHtmlEditor._containerDivId);
			if (containerEl) {
				// Leave the previous container in place and update its
				// class (used for classCount)
				containerEl.setAttribute("class", classCount.toString());
				// Set to zero, so an additional classCount is not added in the new container
				classCount = 0;
			}
		}
		html = ZmHtmlEditor._addDivContainer(html, classCount);
	}
	return onlyInnerContent ? html : [ "<html><body>", html, "</body></html>" ].join("");
};
ZmHtmlEditor._embedHtmlContent = ZmHtmlEditor.prototype._embedHtmlContent;

ZmHtmlEditor._addDivContainer =
function(html, classCount) {
	return ZmHtmlEditor._getDivContainerPrefix(classCount) + html + ZmHtmlEditor._getDivContainerSuffix();
};

ZmHtmlEditor._getDivContainerPrefix =
function(classCount) {
	var recordClassCount = !!classCount;
	var a = [], i = 0;
	a[i++] = '<div ';
	if (recordClassCount) {
		a[i++] = 'id="' + ZmHtmlEditor._containerDivId + '" ';
	}
	a[i++] = 'style="font-family: ';
	a[i++] = appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_FAMILY);
	a[i++] = '; font-size: ';
	a[i++] = appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_SIZE);
	a[i++] = '; color: ';
	a[i++] = appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_COLOR);
	a[i++] = '"';
    if (appCtxt.get(ZmSetting.COMPOSE_INIT_DIRECTION) === ZmSetting.RTL) {
        a[i++] = ' dir="' + ZmSetting.RTL + '"';
    }
	// Cheat; Store the classCount (used for mapping excel classes to unique ids) in a class attribute.
	// Otherwise, if stored in a non-standard attribute, it gets stripped by the server defanger.
	if (recordClassCount) {
		a[i++] = ' class=' + classCount.toString() + ' '
	}
    a[i++] = ">";
	return a.join("");
};

ZmHtmlEditor._getDivContainerSuffix =
function() {
	return "</div>";
};

/*
 If editor is not initialized and mode is HTML, tinymce will automatically initialize the editor with the content in textarea
 */
ZmHtmlEditor.prototype.setContent = function (content) {
    if (this._mode === Dwt.HTML && this._editorInitialized) {
		var ed = this.getEditor();
        ed.setContent(content, {format:'raw'});
		this._setContentStyles(ed);
    } else {
        this.getContentField().value = content;
    }
    this._ignoreWords = {};
};

ZmHtmlEditor.prototype._setContentStyles = function(ed) {
    var document = ed.getDoc();

	// First, get the number of classes already added via paste; Only exists if this was retrieved from the server
	// (otherwise, use the in-memory this._classCount).  This is used to create unique class names for styles
	// imported on an Excel paste
	var containerDiv = document.getElementById(ZmHtmlEditor._containerDivId);
	if (containerDiv && containerDiv.hasAttribute("class")) {
		// Cheated - stored classCount in class, since non-standard attributes will be stripped by the
		// server html defanger.
		this._classCount = parseInt(containerDiv.getAttribute("class"));
		if (isNaN(this._classCount)) {
			this._classCount = 0;
		}
	}

	// Next, move all style nodes to be children of the body, otherwise when adding a style to the body, any subnode
	// style nodes will be deleted!
	var dom      = ed.dom;
	var body     = document.body;
	var styles   = dom.select("style", body);
	var parentNode;
	for (var i = 0; i < styles.length; i++) {
		parentNode = styles[i].parentNode;
		if (parentNode.tagName.toLowerCase() != 'body') {
			parentNode.removeChild(styles[i]);
			body.insertBefore(styles[i], body.childNodes[0]);
		}
	}
}

ZmHtmlEditor.prototype.reEnableDesignMode =
function() {
	// tinyMCE doesn't need to handle this
};

ZmHtmlEditor.prototype.getMode =
function() {
	return this._mode;
};

ZmHtmlEditor.prototype.isHtmlModeInited =
function() {
	return Boolean(this.getEditor());
};

ZmHtmlEditor.prototype._convertHtml2Text = function (convertor) {
    var editor = this.getEditor(),
        body;
    if (editor) {
        body = editor.getBody();
        if (body) {
            return (AjxStringUtil.convertHtml2Text(body, convertor, true));
        }
    }
    return "";
};

ZmHtmlEditor.prototype.moveCaretToTop =
function(offset) {
	if (this._mode == Dwt.TEXT) {
		var control = this.getContentField();
		control.scrollTop = 0;
		if (control.createTextRange) { // IE
			var range = control.createTextRange();
			if (offset) {
				range.move('character', offset);
			}
			else {
				range.collapse(true);
			}
			range.select();
		} else if (control.setSelectionRange) { // FF
			offset = offset || 0;
            //If display is none firefox will throw the following error
            //Error: Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [nsIDOMHTMLTextAreaElement.setSelectionRange]
            //checking offsetHeight to check whether it is rendered or not
            if (control.offsetHeight) {
                control.setSelectionRange(offset, offset);
            }
		}
	} else {
		this._moveCaretToTopHtml(true, offset);
	}
};

ZmHtmlEditor.prototype._moveCaretToTopHtml =
function(tryOnTimer, offset) {
	var editor = this.getEditor();
	var body = editor && editor.getDoc().body;
	var success = false;
	if (AjxEnv.isIE) {
		if (body) {
			var range = body.createTextRange();
			if (offset) {
				range.move('character', offset);
			} else {
				range.collapse(true);
			}
			success = true;
		}
	} else {
		var selection = editor && editor.selection ? editor.selection.getSel() : "";
		if (selection) {
            if (offset) { // if we get an offset, use it as character count into text node
                var target = body.firstChild;
                while (target) {
                    if (offset === 0) {
                        selection.collapse(target, offset);
                        break;
                    }
                    if (target.nodeName === "#text") {
                        var textLength = target.length;
                        if (offset > textLength) {
                            offset = offset - textLength;
                        } else {
                            selection.collapse(target, offset);
                            break;
                        }
                    } else if (target.nodeName === "BR") {//text.length is also including \n count. so if there is br reduce offset by 1
                        offset = offset - 1;
                    }
                    target = target.nextSibling;
                }
            }
            else {
                selection.collapse(body, 0);
            }
          success = true;
        }
	}

	if (success) {
		editor.focus();
	} else if (tryOnTimer) {
		if (editor) {
			var action = new AjxTimedAction(this, this._moveCaretToTopHtml);
			AjxTimedAction.scheduleAction(action, ZmHtmlEditor._INITDELAY + 1);
		} else {
			var cb = ZmHtmlEditor.prototype._moveCaretToTopHtml;
			this._initCallbacks.push(cb.bind(this, tryOnTimer, offset));
		}
	}
};

ZmHtmlEditor.prototype.hasFocus =
function() {
	return Boolean(this._hasFocus[this._mode]);
};

/*ZmSignature editor contains getIframeDoc method dont want to break the existing code*/
ZmHtmlEditor.prototype._getIframeDoc = ZmHtmlEditor.prototype.getIframeDoc =
function() {
	var editor = this.getEditor();
	return editor ? editor.getDoc() : null;
};

ZmHtmlEditor.prototype._getIframeWin =
function() {
	var editor = this.getEditor();
	return editor ? editor.getWin() : null;
};

ZmHtmlEditor.prototype.clear =
function() {
	var editor = this.getEditor();
	if (editor && this._editorInitialized) {
		editor.undoManager && editor.undoManager.clear();
		this.clearDirty();
	}
	var textField = this.getContentField();
	if (!textField) {
		return;
	}

	//If HTML editor is not initialized and the current mode is HTML, then HTML editor is currently getting initialized. Text area should not be replaced at this time, as this will make the TinyMCE JavaScript reference empty for the text area.
	if (!this.isHtmlModeInited() && this.getMode() === Dwt.HTML) {
		return;
	}
	var textEl = textField.cloneNode(false);
	textField.parentNode.replaceChild(textEl, textField);//To clear undo/redo queue of textarea
	//cloning and replacing node will remove event handlers and hence adding it once again
	Dwt.setHandler(textEl, DwtEvent.ONFOCUS, this._onTextareaFocus.bind(this, true, true));
	Dwt.setHandler(textEl, DwtEvent.ONBLUR, this.setFocusStatus.bind(this, false, true));
    Dwt.setHandler(textEl, DwtEvent.ONKEYDOWN, this._handleTextareaKeyEvent.bind(this));
	if (editor) {
		// TinyMCE internally stored textarea element reference as targetElm which is lost after the above operation. Once targetElm is undefined TinyMCE will try to get the element using it's id.
		editor.targetElm = null;
	}
};

ZmHtmlEditor.prototype.initTinyMCEEditor = function(params) {

	var htmlEl = this.getHtmlElement();
	//textarea on which html editor is constructed
	var id = this._bodyTextAreaId;
	var textEl = document.createElement("textarea");
	textEl.setAttribute("id", id);
	textEl.setAttribute("name", id);
	textEl.setAttribute("aria-label", ZmMsg.composeBody);
    if( appCtxt.get(ZmSetting.COMPOSE_INIT_DIRECTION) === ZmSetting.RTL ){
        textEl.setAttribute("dir", ZmSetting.RTL);
    }
	textEl.className = "ZmHtmlEditorTextArea";
    if ( params.content !== null ) {
        textEl.value = params.content;
    }
	if (this._mode === Dwt.HTML) {
		//If the mode is HTML set the text area display as none. After editor is rendered with the content, TinyMCE editor's show method will be called for displaying the editor on the post render event.
		Dwt.setVisible(textEl, false);
	}
	htmlEl.appendChild(textEl);
	this._textAreaId = id;

    Dwt.setHandler(textEl, DwtEvent.ONFOCUS, this._onTextareaFocus.bind(this, true, true));
    Dwt.setHandler(textEl, DwtEvent.ONBLUR, this.setFocusStatus.bind(this, false, true));
    Dwt.setHandler(textEl, DwtEvent.ONKEYDOWN, this._handleTextareaKeyEvent.bind(this));

	if (!window.tinyMCE) {
        window.tinyMCEPreInit = {};
        window.tinyMCEPreInit.suffix = '';
        window.tinyMCEPreInit.base = appContextPath + ZmHtmlEditor.TINY_MCE_PATH; // SET PATH TO TINYMCE HERE
        // Tell TinyMCE that the page has already been loaded
        window.tinyMCE_GZ = {};
        window.tinyMCE_GZ.loaded = true;

		var callback = this.initEditorManager.bind(this, id, params.autoFocus);
        AjxDispatcher.require(["TinyMCE"], true, callback);
	} else {
		this.initEditorManager(id, params.autoFocus);
	}
};

ZmHtmlEditor.prototype.addOnContentInitializedListener =
function(callback) {
	this._onContentInitializeCallbacks.push(callback);
};

ZmHtmlEditor.prototype.clearOnContentInitializedListeners =
function() {
	this._onContentInitializeCallback = null;
};

ZmHtmlEditor.prototype._handleEditorKeyEvent = function(ev) {

	var ed = this.getEditor(),
	    retVal = true;

    if (DwtKeyboardMgr.isPossibleInputShortcut(ev) || (ev.keyCode === DwtKeyEvent.KEY_TAB && (ev.shiftKey || !appCtxt.get(ZmSetting.TAB_IN_EDITOR)))) {
        // pass to keyboard mgr for kb nav
        retVal = DwtKeyboardMgr.__keyDownHdlr(ev);
    }
    else if (DwtKeyEvent.IS_RETURN[ev.keyCode]) { // enter key
        var parent,
            selection,
            startContainer,
            editorDom,
            uniqueId,
            blockquote,
            nextSibling,
            divElement,
            splitElement;

        if (ev.shiftKey) {
            return;
        }

        selection = ed.selection;
        parent = startContainer = selection.getRng(true).startContainer;
        if (!startContainer) {
            return;
        }

        editorDom = ed.dom;
        //Gets all parent block elements
        blockquote = editorDom.getParents(startContainer, "blockquote", ed.getBody());
        if (!blockquote) {
            return;
        }

        blockquote = blockquote.pop();//Gets the last blockquote element
        if (!blockquote || !blockquote.style.borderLeft) {//Checking blockquote left border for verifying it is reply blockquote
            return;
        }

        uniqueId = editorDom.uniqueId();
        ed.undoManager.add();
        try {
            selection.setContent("<div id='" + uniqueId + "'><br></div>");
        }
        catch (e) {
            return;
        }

        divElement = ed.getDoc().getElementById(uniqueId);
        if (divElement) {
            divElement.removeAttribute("id");
        }
        else {
            return;
        }

        nextSibling = divElement.nextSibling;
        if (nextSibling && nextSibling.nodeName === "BR") {
            nextSibling.parentNode.removeChild(nextSibling);
        }

        try {
            splitElement = editorDom.split(blockquote, divElement);
            if (splitElement) {
                selection.select(splitElement);
                selection.collapse(true);
                ev.preventDefault();
            }
        }
        catch (e) {
        }
    }
    else if (ZmHtmlEditor.isEditorTab(ev)) {
        ed.execCommand('mceInsertContent', false, '&emsp;');
        DwtUiEvent.setBehaviour(ev, true, false);
        return false;
    }


    if (window.DwtIdleTimer) {
		DwtIdleTimer.resetIdle();
	}

	if (window.onkeydown) {
		window.onkeydown.call(this);
	}
	
	return retVal;
};

// Text mode key event handler
ZmHtmlEditor.prototype._handleTextareaKeyEvent = function(ev) {

    if (ZmHtmlEditor.isEditorTab(ev)) {
        Dwt.insertText(this.getContentField(), '\t');
        DwtUiEvent.setBehaviour(ev, true, false);
        return false;
    }
    return true;
};

//Notifies mousedown event in tinymce editor to ZCS
ZmHtmlEditor.prototype._handleEditorMouseDownEvent =
function(ev) {
    DwtOutsideMouseEventMgr.forwardEvent(ev);
};

ZmHtmlEditor.prototype.onLoadContent =
function(ev) {
	if (this._onContentInitializeCallbacks) {
		AjxDebug.println(AjxDebug.REPLY, "ZmHtmlEditor::onLoadContent - run callbacks");
		AjxUtil.foreach(this._onContentInitializeCallbacks,
		                function(fn) { fn.run() });
	}
};

ZmHtmlEditor.prototype.setFocusStatus =
function(hasFocus, isTextModeFocus) {
	var mode = isTextModeFocus ? Dwt.TEXT : Dwt.HTML;
	this._hasFocus[mode] = hasFocus;

	Dwt.condClass(this.getHtmlElement(), hasFocus, DwtControl.FOCUSED);

	if (!isTextModeFocus) {
		Dwt.condClass(this.getEditor().getBody(), hasFocus,
		              'mce-active-editor', 'mce-inactive-editor');
	}
};

ZmHtmlEditor.prototype._onTextareaFocus = function() {

    this.setFocusStatus(true, true);
    appCtxt.getKeyboardMgr().updateFocus(this.getContentField());
};

ZmHtmlEditor.prototype.initEditorManager =
function(id, autoFocus) {

	var obj = this;

    if (!window.tinyMCE) {//some problem in loading TinyMCE files
        return;
    }

	var urlParts = AjxStringUtil.parseURL(location.href);

	//important: tinymce doesn't handle url parsing well when loaded from REST URL - override baseURL/baseURI to fix this
	tinymce.baseURL = appContextPath + ZmHtmlEditor.TINY_MCE_PATH;

	if (tinymce.EditorManager) {
		tinymce.EditorManager.baseURI = new tinymce.util.URI(urlParts.protocol + "://" + urlParts.authority + tinymce.baseURL);
	}

	if (tinymce.dom) {
		tinymce.DOM = new tinymce.dom.DOMUtils(document, {process_html : 0});
	}

	if (tinymce.dom && tinymce.dom.Event) {
		tinymce.dom.Event.domLoaded = true;
	}

	var toolbarbuttons = [
		'fontselect fontsizeselect formatselect |',
		'bold italic underline strikethrough removeformat |',
		'forecolor backcolor |',
		'outdent indent bullist numlist blockquote |',
		'alignleft aligncenter alignright alignjustify |',
		this._attachmentCallback ? 'zimage' : 'image',
		'link zemoticons charmap hr table |',
		appCtxt.get(ZmSetting.SHOW_COMPOSE_DIRECTION_BUTTONS) ? 'ltr rtl |' : '',
		'undo redo |',
		'pastetext code'
	];

	// NB: contextmenu plugin deliberately omitted; it's confusing
	var plugins = [
		"zemoticons",
		"table", "directionality", "textcolor", "lists", "advlist",
		"link", "hr", "charmap", "code", "image"
	];

	if (this._attachmentCallback) {
		tinymce.PluginManager.add('zimage', function(editor) {
			editor.addButton('zimage', {
                icon: 'image',
                tooltip: ZmMsg.insertImage,
                onclick: obj._attachmentCallback,
                stateSelector: 'img:not([data-mce-object])'
			});
		});

		plugins.push('zimage');
	}

    var fonts = [];
	var KEYS = [ "fontFamilyIntl", "fontFamilyBase" ];
	var i, j, key, value, name;
	for (j = 0; j < KEYS.length; j++) {
		for (i = 1; value = AjxMsg[KEYS[j]+i+".css"]; i++) {
			if (value.match(/^#+$/)) break;
			value = value.replace(/,\s/g,",");
			name = AjxMsg[KEYS[j]+i+".display"];
			fonts.push(name+"="+value);
		}
	}

	if (!autoFocus) {
		// if !true, Set to false in case undefined
		autoFocus = false;
	}
    var tinyMCEInitObj = {
        // General options
		mode :  (this._mode == Dwt.HTML)? "exact" : "none",
		theme: 'modern',
		auto_focus: autoFocus,
		elements:  id,
        plugins : plugins.join(' '),
		toolbar: toolbarbuttons.join(' '),
		toolbar_items_size: 'small',
		statusbar: false,
		menubar: false,
		ie7_compat: false,
		object_resizing : true,
        font_formats : fonts.join(";"),
        fontsize_formats : AjxMsg.fontSizes || '',
		convert_urls : false,
		verify_html : false,
		browser_spellcheck : true,
        content_css : appContextPath + '/css/tinymce-content.css?v=' + cacheKillerVersion,
        dialog_type : "modal",
        forced_root_block : "div",
        width: "100%",
        height: "auto",
        visual: false,
        language: tinyMCE.getlanguage(appCtxt.get(ZmSetting.LOCALE_NAME)),
        directionality : appCtxt.get(ZmSetting.COMPOSE_INIT_DIRECTION),
        paste_retain_style_properties : "all",
		paste_data_images: false,
        paste_remove_styles_if_webkit : false,
        table_default_attributes: { cellpadding: '3px', border: '1px' },
        table_default_styles: { width: '90%', tableLayout: 'fixed' },
		setup : function(ed) {
            ed.on('LoadContent', obj.onLoadContent.bind(obj));
            ed.on('PostRender', obj.onPostRender.bind(obj));
            ed.on('init', obj.onInit.bind(obj));
            ed.on('keydown', obj._handleEditorKeyEvent.bind(obj));
            ed.on('MouseDown', obj._handleEditorMouseDownEvent.bind(obj));
            ed.on('paste', obj.onPaste.bind(obj));
            ed.on('PastePostProcess', obj.pastePostProcess.bind(obj));
            ed.on('BeforeExecCommand', obj.onBeforeExecCommand.bind(obj));

            ed.on('contextmenu', obj._handleEditorEvent.bind(obj));
            ed.on('mouseup', obj._handleEditorEvent.bind(obj));
        }
    };

	tinyMCE.init(tinyMCEInitObj);
	this._editor = this.getEditor();
};

ZmHtmlEditor.prototype.onPaste = function(ev) {
    if (!this._pasteCallback)
        return;

    var items = ((ev.clipboardData &&
                  (ev.clipboardData.items || ev.clipboardData.files)) ||
                 (window.clipboardData && clipboardData.files)),
        item = items && items[0],
        file, name, type,
        view;

	if (item && item.getAsFile) {
		file = item.getAsFile();
		name = file && file.fileName;
		type = file && file.type;
	} else if (item && item.type) {
		file = item;
		name = file.name;
		type = file.type;
	}

	if (file) {
		ev.stopPropagation();
		ev.preventDefault();
		var headers = {
			"Cache-Control": "no-cache",
			"X-Requested-With": "XMLHttpRequest",
			"Content-Type": type,
			//For paste from clipboard filename is undefined
			"Content-Disposition": 'attachment; filename="' + (name ? AjxUtil.convertToEntities(name) : ev.timeStamp || new Date().getTime()) + '"'
		};
		var url = (appCtxt.get(ZmSetting.CSFE_ATTACHMENT_UPLOAD_URI) +
				   "?fmt=extended,raw");

		var fn = AjxRpc.invoke.bind(AjxRpc, file, url, headers,
		                            this._handlePasteUpload.bind(this),
		                            AjxRpcRequest.HTTP_POST);

		// IE11 appears to disallow AJAX requests within the event handler
		if (AjxEnv.isTrident) {
			setTimeout(fn, 0);
		} else {
			fn();
		}
    }  else  {
		var clipboardContent = this.getClipboardContent(ev);
		if (this.hasContentType(clipboardContent, 'text/html')) {
			var content = clipboardContent['text/html'];
			if (content) {
				this.pasteHtml(content);
				ev.stopPropagation();
				ev.preventDefault();
			}
		}
	}
};

ZmHtmlEditor.prototype.getDataTransferItems = function(dataTransfer) {
	var data = {};

	if (dataTransfer) {
		// Use old WebKit/IE API
		if (dataTransfer.getData) {
			var legacyText = dataTransfer.getData('Text');
			if (legacyText && legacyText.length > 0) {
				data['text/plain'] = legacyText;
			}
		}

		if (dataTransfer.types) {
			for (var i = 0; i < dataTransfer.types.length; i++) {
				var contentType = dataTransfer.types[i];
				data[contentType] = dataTransfer.getData(contentType);
			}
		}
	}

	return data;
};


ZmHtmlEditor.prototype.hasContentType = function(clipboardContent, mimeType) {
	return mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
};

ZmHtmlEditor.prototype.getClipboardContent = function(clipboardEvent) {
	return this.getDataTransferItems(clipboardEvent.clipboardData || this.getEditor().getDoc().dataTransfer);
};


ZmHtmlEditor.prototype.pasteHtml = function(html) {
	var ed = this.getEditor();
	var args, dom = ed.dom;

	var document = ed.getDoc();
	var numOriginalStyleSheets = document.styleSheets ? document.styleSheets.length : 0;
	var styleSheets    = document.styleSheets;

	// We need to attach the element to the DOM so Sizzle selectors work on the contents
	var tempBody = dom.add(ed.getBody(), 'div', {style: 'display:none'}, html);
	args = ed.fire('PastePostProcess', {node: tempBody});
	html = args.node.innerHTML;

	var styleNodes = [];
	if (!args.isDefaultPrevented()) {
		var re;
		for (var i = numOriginalStyleSheets; i < styleSheets.length; i++) {
			// Access and update the stylesheet class names, to insure no collisions
			var stylesheet = styleSheets[i];
			var updates = this._getPastedClassUpdates(stylesheet);
			var styleHtml = stylesheet.ownerNode.innerHTML;
			for (var selectorText in updates) {
				// Replace the non-unique Excel class names with unique new ones in style html and pasted content html.
				var newSelectorText = updates[selectorText];
				re = new RegExp(selectorText.substring(1), 'g');
				html = html.replace(re, newSelectorText.substring(1));
				styleHtml = styleHtml.replace(selectorText, newSelectorText);
			}
			// Excel .5pt line doesn't display in Chrome - use a 1pt line.  Somewhat fragile (Assuming width is the
			// first attribute for border, following the ':'), but need to do so that we only replace a standalone .5pt
			re = new RegExp(":.5pt", 'g');
			styleHtml = styleHtml.replace(re, ":1pt");
			// Microsoft special, just use 'black'
			re = new RegExp("windowtext", 'g');
			styleHtml = styleHtml.replace(re, "black");

			// Create a new style node and record it; it will be added below to the body with the new content
			var styleNode = document.createElement('style');
			styleNode.type = "text/css";
			var scoped = document.createAttribute("scoped");
			styleNode.setAttributeNode(scoped);
			styleNode.innerHTML = styleHtml;
			styleNodes.push(styleNode);
		}
	}

	dom.remove(tempBody);

	if (!args.isDefaultPrevented()) {
		var body = document.body;
		for (var i = 0; i < styleNodes.length; i++) {
			// Insert the styles into the body.  Modern browsers support this (even though its not strictly valid), and
			// the 'scoped' attribute added above means that future browsers should treat it as valid.
			body.insertBefore(styleNodes[i], body.childNodes[0]);
		}
		ed.insertContent(html, {merge: ed.settings.paste_merge_formats !== false});
	}
};

ZmHtmlEditor.prototype._getPastedClassUpdates = function(styleSheet) {
    var cssRules = styleSheet.cssRules;
	var updates = {};
	if (cssRules) {
		for (var i = 0; i < cssRules.length; i++) {
			var selectorText = cssRules[i].selectorText;
			// Excel class definitions (for now) start with ".xl", but this tries to be a little less specific (and fragile).
			// Convert the Excel class names (which may be duplicated with each paste) to unique class names, so that
			// later paste formatting doesn't step on previous formatting.
			if (selectorText && selectorText.indexOf(".") == 0) {
				// Create a new unique class name that will be used instead
				var newSelectorText = ".zimbra" + (++this._classCount).toString();
				updates[selectorText] = newSelectorText;
			}
		}
	}
	// Return a map of { oldClassName : newClassName }
	return updates;
}

ZmHtmlEditor.prototype._handlePasteUpload = function(r) {
	if (r && r.success) {
		var resp = eval("["+r.text+"]");
		if(resp.length === 3) {
			resp[2].clipboardPaste = true;
		}
		this._pasteCallback(resp);
	}
};


ZmHtmlEditor.prototype.onPostRender = function(ev) {
	var ed = this.getEditor();

    ed.dom.setStyles(ed.getBody(), {"font-family" : appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_FAMILY),
                                    "font-size"   : appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_SIZE),
                                    "color"       : appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_COLOR)
                                   });
	//Shows the editor and hides any textarea/div that the editor is supposed to replace.
	ed.show();
    this._resetSize();
};

ZmHtmlEditor.prototype.onInit = function(ev) {

	var ed = this.getEditor();
    var obj = this,
        tinymceEvent = tinymce.dom.Event,
        doc = ed.getDoc(),
        win = ed.getWin(),
        view = obj.parent;

    obj.setFocusStatus(false);

    ed.on('focus', function(e) {
        DBG.println(AjxDebug.FOCUS, "EDITOR got focus");
		appCtxt.getKeyboardMgr().updateFocus(obj._getIframeDoc().body);
        obj.setFocusStatus(true);
    });
    ed.on('blur', function(e) {
        obj.setFocusStatus(false);
    });
    // Sets up the a range for the current ins point or selection. This is IE only because the iFrame can
    // easily lose focus (e.g. by clicking on a button in the toolbar) and we need to be able to get back
    // to the correct insertion point/selection.
    // Here we are registering this dedicated event to store the bookmark which will fire when focus moves outside the editor
    if(AjxEnv.isIE){
        tinymceEvent.bind(doc, 'beforedeactivate', function(e) {
            if(ed.windowManager){
                ed.windowManager.bookmark = ed.selection.getBookmark(1);
            }
        });
    }

    // must be assigned on init, to ensure that our handlers are called after
    // in TinyMCE's in 'FormatControls.js'.
    ed.on('nodeChange', obj.onNodeChange.bind(obj));

    ed.on('open', ZmHtmlEditor.onPopupOpen);
    if (view && view.toString() === "ZmComposeView" && ZmDragAndDrop.isSupported()) {
        var dnd = view._dnd;
        tinymceEvent.bind(doc, 'dragenter', this._onDragEnter.bind(this));
        tinymceEvent.bind(doc, 'dragleave', this._onDragLeave.bind(this));
        tinymceEvent.bind(doc, 'dragover', this._onDragOver.bind(this, dnd));
        tinymceEvent.bind(doc, 'drop', this._onDrop.bind(this, dnd));
    }

	this._overrideTinyMCEMethods();

    obj._editorInitialized = true;

	// Access the content stored in the textArea (if any)
	var contentField = this.getContentField();
	var content =  contentField.value;
	contentField.value = "";
	// Use our setContent to set up the content using the 'raw' format, which preserves styling
	this.setContent(content);

	this._resetSize();
	this._setupTabGroup();

	var iframe = Dwt.getElement(this._iFrameId);
	if (iframe) {
		Dwt.addClass(iframe, 'ZmHtmlEditorIFrame');
		iframe.setAttribute('title', ZmMsg.htmlEditorTitle);
		var body = this._getIframeDoc().body;
		if (body) {
			body.setAttribute('aria-label', ZmMsg.composeBody);
		}
	}

    AjxUtil.foreach(this._initCallbacks, function(fn) { fn.run() });
};

ZmHtmlEditor.prototype._onFocus = function() {
	var editor = this.getEditor();

	if (this._mode === Dwt.HTML && editor) {
		editor.fire('focus', {focusedEditor: editor});
	}
};

ZmHtmlEditor.prototype._onBlur = function() {
	var editor = this.getEditor();

	if (this._mode === Dwt.HTML && editor) {
		editor.fire('blur', {focusedEditor: null});
	}
};


ZmHtmlEditor.prototype.__getEditorControl = function(type, tooltip) {
	// This method provides a naive emulation of the control manager offered in
	// TinyMCE 3.x. We assume that there's only one control of a given type
	// with a given tooltip in the entire TinyMCE control hierarchy. Hopefully,
	// this heuristic won't prove too fragile.
	var ed = this.getEditor();

	function finditem(item) {
		// the tooltip in settings appears constant and unlocalized
		if (item.type === type && item.settings.tooltip === tooltip)
			return item;

		if (typeof item.items === 'function') {
			var items = item.items();

			for (var i = 0; i < items.length; i++) {
				var r = finditem(items[i]);
				if (r)
					return r;
			}
		}

		if (typeof item.menu === 'object') {
			return finditem(item.menu);
		}
	};

	return ed ? finditem(ed.theme.panel) : null;
};

ZmHtmlEditor.prototype.onNodeChange = function(event) {
	// Firefox fires NodeChange events whether the editor is visible or not
	if (this._mode !== Dwt.HTML) {
		return;
	}

	// update the font size box -- TinyMCE only checks for it on SPANs
	var fontsizebtn = this.__getEditorControl('listbox', 'Font Sizes');
	var found = false;

	var normalize = function(v) {
		return Math.round(DwtCssStyle.asPixelCount(v));
	};

	for (var i = 0; !found && i < event.parents.length; i++) {
		var element = event.parents[i];
		if (element.nodeType === Node.ELEMENT_NODE) {
			var fontsize = normalize(DwtCssStyle.getProperty(element, 'font-size'));
			if (fontsize !== -1) {
				for (var j = 0; !found && j < fontsizebtn._values.length; j++) {
					var value = fontsizebtn._values[j].value;

					if (normalize(value) === fontsize) {
						fontsizebtn.value(value);
						found = true;
					}
				}
			}
		}
	}

	// update the font family box -- TinyMCE only checks for it on SPANs
	var fontfamilybtn = this.__getEditorControl('listbox', 'Font Family');
	var found = false;

	var normalize = function(v) {
		return v.replace(/,\s+/g, ',').replace(/[\'\"]/g, '');
	};

	for (var i = 0; !found && i < event.parents.length; i++) {
		var element = event.parents[i];
		if (element.nodeType === Node.ELEMENT_NODE) {
			var fontfamily = normalize(DwtCssStyle.getProperty(element, 'font-family'));
			for (var j = 0; !found && j < fontfamilybtn._values.length; j++) {
				var value = fontfamilybtn._values[j].value;

				if (normalize(value) === fontfamily) {
					fontfamilybtn.value(value);
					found = true;
				}
			}
		}
	}
};


/*
**   TinyMCE will fire onBeforeExecCommand before executing all commands
 */
ZmHtmlEditor.prototype.onBeforeExecCommand = function(ev) {
    if (ev.command === "mceImage") {
        this.onBeforeInsertImage(ev);
    }
    else if (ev.command === "mceRepaint") { //img src modified
        this.onBeforeRepaint(ev);
    }
};

ZmHtmlEditor.prototype.onBeforeInsertImage = function(ev) {
    var element = ev.target.selection.getNode();
    if (element && element.nodeName === "IMG") {
        element.setAttribute("data-mce-src", element.src);
        element.setAttribute("data-mce-zsrc", element.src);//To find out whether src is modified or not set a dummy attribute
    }
};

ZmHtmlEditor.prototype.onBeforeRepaint = function(ev) {
    var element = ev.target.selection.getNode();
    if (element && element.nodeName === "IMG") {
        if (element.src !== element.getAttribute("data-mce-zsrc")) {
            element.removeAttribute("dfsrc");
        }
        element.removeAttribute("data-mce-zsrc");
    }
};

ZmHtmlEditor.prototype._onDragEnter = function() {
    Dwt.addClass(Dwt.getElement(this._iFrameId), "DropTarget");
};

ZmHtmlEditor.prototype._onDragLeave = function() {
    Dwt.delClass(Dwt.getElement(this._iFrameId), "DropTarget");
};

ZmHtmlEditor.prototype._onDragOver = function(dnd, ev) {
    dnd._onDragOver(ev);
};

ZmHtmlEditor.prototype._onDrop = function(dnd, ev) {
    dnd._onDrop(ev, true);
    Dwt.delClass(Dwt.getElement(this._iFrameId), "DropTarget");
};

ZmHtmlEditor.prototype.setMode = function (mode, convert, convertor) {

    this.discardMisspelledWords();
    if (mode === this._mode || (mode !== Dwt.HTML && mode !== Dwt.TEXT)) {
        return;
    }
    this._mode = mode;
	var textarea = this.getContentField();
    if (mode === Dwt.HTML) {
        if (convert) {
            textarea.value = AjxStringUtil.convertToHtml(textarea.value, true);
        }
        if (this._editorInitialized) {
	        // tinymce will automatically toggle the editor and set the corresponding content.
            tinyMCE.execCommand('mceToggleEditor', false, this._bodyTextAreaId);
        }
        else {
            //switching from plain text to html using tinymces mceToggleEditor method is always
            // using the last editor creation setting. Due to this current ZmHtmlEditor object
            // always point to last ZmHtmlEditor object. Hence initializing the tinymce editor
            // again for the first time when mode is switched from plain text to html.
            this.initEditorManager(this._bodyTextAreaId);
        }
    } else {
        if (convert) {
            var content;
            if (this._editorInitialized) {
                content = this._convertHtml2Text(convertor);
            }
            else {
                content = AjxStringUtil.convertHtml2Text(textarea.value);
            }
        }
        if (this._editorInitialized) {
	        //tinymce will automatically toggles the editor and sets the corresponding content.
            tinyMCE.execCommand('mceToggleEditor', false, this._bodyTextAreaId);
        }
        if (convert) {
            //tinymce will set html content directly in textarea. Resetting the content after removing the html tags.
            this.setContent(content);
        }

        Dwt.setVisible(textarea, true);
    }

	textarea = this.getContentField();
	textarea.setAttribute('aria-hidden', !Dwt.getVisible(textarea));

    this._setupTabGroup();
    this._resetSize();
};

ZmHtmlEditor.prototype.getContentField =
function() {
	return document.getElementById(this._bodyTextAreaId);
};

ZmHtmlEditor.prototype.insertImage =
function(src, dontExecCommand, width, height, dfsrc) {
	// We can have a situation where:
	//   Paste plugin does a createPasteBin, creating a marker element that it uses
	//   We upload a pasted image.
	//   The upload completes, and we do a SaveDraft. It calls insertImage.
	//   A timeout function from the plugin executes before or after insertImage, and calls removePasteBin.
	//
	//   InsertImage executes. If the pasteBin has not been removed when we try to insert the image, it interferes with
	//   tinyMCE insertion.  No image is inserted in the editor body, and we end up with an attachment
	//    bubble instead.
	var  pasteBinClone;
	var ed = this.getEditor();

	// *** Begin code copied from Paste Plugin Clipboard.js, removePasteBin
	while ((pasteBinClone = ed.dom.get('mcepastebin'))) {
		ed.dom.remove(pasteBinClone);
		ed.dom.unbind(pasteBinClone);
	}
	// *** End copied code from removePasteBin

	var html = [];
	var idx= 0 ;

	html[idx++] = "<img";
	html[idx++] = " src='";
	html[idx++] = src;
	html[idx++] = "'";

    if ( dfsrc != null) {
        html[idx++] = " dfsrc='";
        html[idx++] = dfsrc;
	    html[idx++] = "'";
    }
	if (width != null) {
		html[idx++] = " width='" + width + "'";
	}
	if (height != null) {
		html[idx++] = " height='" + height + "'";
	}
	html[idx++] = ">";


    ed.focus();

	//tinymce modifies the source when using mceInsertContent
    //ed.execCommand('mceInsertContent', false, html.join(""), {skip_undo : 1});
    ed.execCommand('mceInsertRawHTML', false, html.join(""), {skip_undo : 1});
};

ZmHtmlEditor.prototype.replaceImage =
function(id, src){
    var doc = this.getEditor().getDoc();
    if(doc){
        var img = doc.getElementById(id);
        if( img && img.getAttribute("data-zim-uri") === id ){
            img.src = src;
            img.removeAttribute("id");
            img.removeAttribute("data-mce-src");
            img.removeAttribute("data-zim-uri");
        }
    }
};

/*
This function will replace all the img elements matching src
 */
ZmHtmlEditor.prototype.replaceImageSrc =
function(src, newsrc){
	var doc = this.getEditor().getDoc();
	if(doc){
		var images = doc.getElementsByTagName('img');
		if (images && images.length > 0) {
			AjxUtil.foreach(images,function(img) {
				try {
					var imgsrc = img && img.src;
				} catch(e) {
					//IE8 throws invalid pointer exception for src attribute when src is a data uri
					return;
				}
				if (imgsrc && imgsrc == src) {
					img.src = newsrc;
					img.removeAttribute("id");
					img.removeAttribute("data-mce-src");
					img.removeAttribute("data-zim-uri");
				}
			});
		}
	}
};

ZmHtmlEditor.prototype.addCSSForDefaultFontSize =
function(editor) {
	var selectorText = "body,td,pre";
	var ruleText = [
			"font-family:", appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_FAMILY),";",
			"font-size:", appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_SIZE),";",
			"color:", appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_COLOR),";"
	].join("");
	var doc = editor ? editor.getDoc() : null;
	if (doc) {
		this.insertDefaultCSS(doc, selectorText, ruleText);
	}
};

ZmHtmlEditor.prototype.insertDefaultCSS =
function(doc, selectorText, ruleText) {
	var sheet, styleElement;
	if (doc.createStyleSheet) {
		sheet = doc.createStyleSheet();
	} else {
		styleElement = doc.createElement("style");
		doc.getElementsByTagName("head")[0].appendChild(styleElement);
		sheet = styleElement.styleSheet ? styleElement.styleSheet : styleElement.sheet;
	}

	if (!sheet && styleElement) {
		//remove braces
		ruleText = ruleText.replace(/^\{?([^\}])/, "$1");
		styleElement.innerHTML = selectorText + ruleText;
	} else if (sheet.addRule) {
		//remove braces
		ruleText = ruleText.replace(/^\{?([^\}])/, "$1");
		DBG.println("ruleText:" + ruleText + ",selector:" + selectorText);
		sheet.addRule(selectorText, ruleText);
	} else if (sheet.insertRule) {
		//need braces
		if (!/^\{[^\}]*\}$/.test(ruleText)) ruleText = "{" + ruleText + "}";
		sheet.insertRule(selectorText + " " + ruleText, sheet.cssRules.length);
	}
};

ZmHtmlEditor.prototype.resetSpellCheck =
function() {
	//todo: remove this when spellcheck is disabled
	this.discardMisspelledWords();
	this._spellCheckHideModeDiv();
};

/**SpellCheck modules**/

ZmHtmlEditor.prototype.checkMisspelledWords =
function(callback, onExitCallback, errCallback){
	var text = this.getTextVersion();
	if (/\S/.test(text)) {
		AjxDispatcher.require("Extras");
		this._spellChecker = new ZmSpellChecker(this);
		this._spellCheck = null;
		this._spellCheckSuggestionListenerObj = new AjxListener(this, this._spellCheckSuggestionListener);
		if (!this.onExitSpellChecker) {
			this.onExitSpellChecker = onExitCallback;
		}
		var params = {
			text: text,
			ignore: AjxUtil.keys(this._ignoreWords).join()
		};
		this._spellChecker.check(params, callback, errCallback);
		return true;
	}

	return false;
};

ZmHtmlEditor.prototype.spellCheck =
function(callback, keepModeDiv) {
	var text = this.getTextVersion(null, keepModeDiv);

	if (/\S/.test(text)) {
		AjxDispatcher.require("Extras");
		this._spellChecker = new ZmSpellChecker(this);
		this._spellCheck = null;
		this._spellCheckSuggestionListenerObj = new AjxListener(this, this._spellCheckSuggestionListener);
		if (!this.onExitSpellChecker) {
			this.onExitSpellChecker = callback;
		}
        var params = {
			text: text,
			ignore: AjxUtil.keys(this._ignoreWords).join()
		};
		this._spellChecker.check(params, new AjxCallback(this, this._spellCheckCallback));
		return true;
	}

	return false;
};

ZmHtmlEditor.prototype._spellCheckCallback =
function(words) {
    // Remove the below comment for hard coded spell check response for development
    //words = {"misspelled":[{"word":"onee","suggestions":"one,nee,knee,once,ones,one's"},{"word":"twoo","suggestions":"two,too,woo,twos,two's"},{"word":"fourrr","suggestions":"Fourier,furor,furry,firer,fuhrer,fore,furrier,four,furrow,fora,fury,fours,ferry,foray,flurry,four's"}],"available":true};
	var wordsFound = false;

	if (words && words.available) {
		var misspelled = words.misspelled;
		if (misspelled == null || misspelled.length == 0) {
			appCtxt.setStatusMsg(ZmMsg.noMisspellingsFound, ZmStatusView.LEVEL_INFO);
			this._spellCheckHideModeDiv();
		} else {
			var msg = AjxMessageFormat.format(ZmMsg.misspellingsResult, misspelled.length);
			appCtxt.setStatusMsg(msg, ZmStatusView.LEVEL_WARNING);

			this.highlightMisspelledWords(misspelled);
			wordsFound = true;
		}
	} else {
		appCtxt.setStatusMsg(ZmMsg.spellCheckUnavailable, ZmStatusView.LEVEL_CRITICAL);
	}

	if (AjxEnv.isGeckoBased && this._mode == Dwt.HTML) {
		setTimeout(AjxCallback.simpleClosure(this.focus, this), 10);
	}

	if (this.onExitSpellChecker) {
		this.onExitSpellChecker.run(wordsFound);
	}
};

ZmHtmlEditor.prototype._spellCheckSuggestionListener =
function(ev) {
	var self = this;
	var item = ev.item;
	var orig = item.getData("orig");
	if (!orig) { return; }

	var val = item.getData(ZmHtmlEditor.VALUE);
	var plainText = this._mode == Dwt.TEXT;
	var fixall = item.getData("fixall");
	var doc = plainText ? document : this._getIframeDoc();
	var span = doc.getElementById(item.getData("spanId"));
	var action = item.getData(ZmOperation.MENUITEM_ID);
	switch (action) {
		case "ignore":
			val = orig;
			this._ignoreWords[val] = true;
//			if (fixall) {
				// TODO: visually "correct" all of them
//			}
			break;
		case "add":
			val = orig;
			// add word to user's personal dictionary
			var soapDoc = AjxSoapDoc.create("ModifyPrefsRequest", "urn:zimbraAccount");
			var prefEl = soapDoc.set("pref", val);
			prefEl.setAttribute("name", "+zimbraPrefSpellIgnoreWord");
			var params = {
				soapDoc: soapDoc,
				asyncMode: true,
				callback: new AjxCallback(appCtxt, appCtxt.setStatusMsg, [ZmMsg.wordAddedToDictionary])
			};
			appCtxt.getAppController().sendRequest(params);
			this._ignoreWords[val] = true;
			break;
		default: break;
	}

	if (plainText && val == null) {
		this._editWord(fixall, span);
	}
	else {
		var spanEls = fixall ? this._spellCheck.wordIds[orig] : span;
		this._editWordFix(spanEls, val);
	}
    
	this._handleSpellCheckerEvents(null);
};

ZmHtmlEditor.prototype._getEditorDocument = function() {
	var plainText = this._mode == Dwt.TEXT;
	return plainText ? document : this._getIframeDoc();
};

ZmHtmlEditor.prototype._editWord = function(fixall, spanEl) {
	// edit clicked
	var doc = this._getEditorDocument();
	var input = doc.createElement("input");
	input.type = "text";
	input.value = AjxUtil.getInnerText(spanEl);
	input.className = "SpellCheckInputField";
	input.style.left = spanEl.offsetLeft - 2 + "px";
	input.style.top = spanEl.offsetTop - 2 + "px";
	input.style.width = spanEl.offsetWidth + 4 + "px";
	var div = doc.getElementById(this._spellCheckDivId);
	var scrollTop = div.scrollTop;
	div.appendChild(input);
	div.scrollTop = scrollTop; // this gets resetted when we add an input field (at least Gecko)
	input.setAttribute("autocomplete", "off");
	input.focus();
	if (!AjxEnv.isGeckoBased)
		input.select();
	else
		input.setSelectionRange(0, input.value.length);
	var inputListener = AjxCallback.simpleClosure(this._editWordHandler, this, fixall, spanEl);
	input.onblur = inputListener;
	input.onkeydown = inputListener;
};

ZmHtmlEditor.prototype._editWordHandler = function(fixall, spanEl, ev) {
	// the event gets lost after 20 milliseconds so we need
	// to save the following :(
	setTimeout(AjxCallback.simpleClosure(this._editWordHandler2, this, fixall, spanEl, ev), 20);
};
ZmHtmlEditor.prototype._editWordHandler2 = function(fixall, spanEl, ev) {
	ev = DwtUiEvent.getEvent(ev);
	var evType = ev.type;
	var evKeyCode = ev.keyCode;
	var evCtrlKey = ev.ctrlKey;
	var input = DwtUiEvent.getTarget(ev);
	var keyEvent = /key/.test(evType);
	var removeInput = true;
	if (/blur/.test(evType) || (keyEvent && DwtKeyEvent.IS_RETURN[evKeyCode])) {
		if (evCtrlKey)
			fixall =! fixall;
		var orig = AjxUtil.getInnerText(spanEl);
		var spanEls = fixall ? this._spellCheck.wordIds[orig] : spanEl;
		this._editWordFix(spanEls, input.value);
	} else if (keyEvent && evKeyCode === DwtKeyEvent.KEY_ESCAPE) {
		this._editWordFix(spanEl, AjxUtil.getInnerText(spanEl));
	} else {
		removeInput = false;
	}
	if (removeInput) {
		input.onblur = null;
		input.onkeydown = null;
		if (input.parentNode) {
			input.parentNode.removeChild(input);
		}
	}
	this._handleSpellCheckerEvents(null);
};

ZmHtmlEditor.prototype._editWordFix = function(spanEls, value) {
	spanEls = spanEls instanceof Array ? spanEls : [ spanEls ];
	var doc = this._getEditorDocument();
	for (var i = spanEls.length - 1; i >= 0; i--) {
		var spanEl = spanEls[i];
		if (typeof spanEl == "string") {
			spanEl = doc.getElementById(spanEl);
		}
		if (spanEl) {
			spanEl.innerHTML = value;
		}
	}
};

ZmHtmlEditor.prototype._getParentElement =
function() {
	var ed = this.getEditor();
	if (ed.selection) {
		return ed.selection.getNode();
	} else {
		var doc = this._getIframeDoc();
		return doc ? doc.body : null;
	}
};

ZmHtmlEditor.prototype._handleSpellCheckerEvents =
function(ev) {
	var plainText = this._mode == Dwt.TEXT;
	var p = plainText ? (ev ? DwtUiEvent.getTarget(ev) : null) : this._getParentElement(),
		span, ids, i, suggestions,
		self = this,
		sc = this._spellCheck,
		doc = plainText ? document : this._getIframeDoc(),
		modified = false,
		word = "";
	if (ev && /^span$/i.test(p.tagName) && /ZM-SPELLCHECK/.test(p.className)) {
		// stuff.
		word = p.getAttribute("word");
		// FIXME: not sure this is OK.
		window.status = "Suggestions: " + sc.suggestions[word].join(", ");
		modified = word != AjxUtil.getInnerText(p);
	}

	// <FIXME: there's plenty of room for optimization here>
	ids = sc.spanIds;
	for (i in ids) {
		span = doc.getElementById(i);
		if (span) {
			if (ids[i] != AjxUtil.getInnerText(span) || this._ignoreWords[ids[i]])
				span.className = "ZM-SPELLCHECK-FIXED";
			else if (ids[i] == word)
				span.className = "ZM-SPELLCHECK-MISSPELLED2";
			else
				span.className = "ZM-SPELLCHECK-MISSPELLED";
		}
	}
	// </FIXME>

	// Dismiss the menu if it is present AND:
	//   - we have no event, OR
	//   - it's a mouse(down|up) event, OR
	//   - it's a KEY event AND there's no word under the caret, OR the word was modified.
	// I know, it's ugly.
	if (sc.menu &&
		(!ev || ( /click|mousedown|mouseup|contextmenu/.test(ev.type)
			  || ( /key/.test(ev.type)
			   && (!word || modified) )
			)))
	{
		sc.menu.dispose();
		sc.menu = null;
		window.status = "";
	}
	// but that's even uglier:
	if (ev && word && (suggestions = sc.suggestions[word]) &&
		(/mouseup|contextmenu/i.test(ev.type) ||
		 (plainText && /(click|mousedown|contextmenu)/i.test(ev.type))) && 
		(word == AjxUtil.getInnerText(p) && !this._ignoreWords[word]))
	{
		sc.menu = this._spellCheckCreateMenu(this.parent, 0, suggestions, word, p.id, modified);
		var pos, ms = sc.menu.getSize(), ws = this.shell.getSize();
		if (!plainText) {
			// bug fix #5857 - use Dwt.toWindow instead of Dwt.getLocation so we can turn off dontIncScrollTop
			pos = Dwt.toWindow(document.getElementById(this._iFrameId), 0, 0, null, true);
			var pos2 = Dwt.toWindow(p, 0, 0, null, true);
			pos.x += pos2.x
				- (doc.documentElement.scrollLeft || doc.body.scrollLeft);
			pos.y += pos2.y
				- (doc.documentElement.scrollTop || doc.body.scrollTop);
		} else {
			// bug fix #5857
			pos = Dwt.toWindow(p, 0, 0, null, true);
			var div = document.getElementById(this._spellCheckDivId);
			pos.x -= div.scrollLeft;
			pos.y -= div.scrollTop;
		}
		pos.y += p.offsetHeight;
		// let's make sure we look nice, shall we.
		if (pos.y + ms.y > ws.y)
			pos.y -= ms.y + p.offsetHeight;
		sc.menu.popup(0, pos.x, pos.y);
		ev._stopPropagation = true;
		ev._returnValue = false;
		return false;
	}
};

ZmHtmlEditor.prototype._spellCheckCreateMenu = function(parent, fixall, suggestions, word, spanId, modified) {
    
	var menu = new ZmPopupMenu(parent);
//	menu.dontStealFocus();

	if (modified) {
		var txt = "<b>" + word + "</b>";
		this._spellCheckCreateMenuItem(menu, "orig", {text:txt}, fixall, word, word, spanId);
	}

	if (suggestions.length > 0) {
		for (var i = 0; i < suggestions.length; ++i) {
			this._spellCheckCreateMenuItem(
				menu, "sug-"+i, {text:suggestions[i], className: ""},
				fixall, suggestions[i], word, spanId
			);
		}
		if (!(parent instanceof DwtMenuItem) && this._spellCheck.wordIds[word].length > 1) {
			if (!this._replaceAllFormatter) {
				this._replaceAllFormatter = new AjxMessageFormat(ZmMsg.replaceAllMenu);
			}
			var txt = "<i>"+this._replaceAllFormatter.format(this._spellCheck.wordIds[word].length)+"</i>";
			var item = menu.createMenuItem("fixall", {text:txt});
			var submenu = this._spellCheckCreateMenu(item, 1, suggestions, word, spanId, modified);
			item.setMenu(submenu);
		}
	}
	else {
		var item = this._spellCheckCreateMenuItem(menu, "noop", {text:ZmMsg.noSuggestions}, fixall, "", word, spanId);
		item.setEnabled(false);
		this._spellCheckCreateMenuItem(menu, "clear", {text:"<i>"+ZmMsg.clearText+"</i>" }, fixall, "", word, spanId);
	}

    var plainText = this._mode == Dwt.TEXT;
    if (!fixall || plainText) {
        menu.createSeparator();
    }

	if (plainText) {
		// in plain text mode we want to be able to edit misspelled words
		var txt = fixall ? ZmMsg.editAll : ZmMsg.edit;
		this._spellCheckCreateMenuItem(menu, "edit", {text:txt}, fixall, null, word, spanId);
	}

	if (!fixall) {
		this._spellCheckCreateMenuItem(menu, "ignore", {text:ZmMsg.ignoreWord}, 0, null, word, spanId);
//		this._spellCheckCreateMenuItem(menu, "ignore", {text:ZmMsg.ignoreWordAll}, 1, null, word, spanId);
	}

	if (!fixall && appCtxt.get(ZmSetting.SPELL_CHECK_ADD_WORD_ENABLED)) {
		this._spellCheckCreateMenuItem(menu, "add", {text:ZmMsg.addWord}, fixall, null, word, spanId);
	}

	return menu;
};

ZmHtmlEditor.prototype._spellCheckCreateMenuItem =
function(menu, id, params, fixall, value, word, spanId, listener) {
	if (params.className == null) {
		params.className = "ZMenuItem ZmSpellMenuItem";
	}
	var item = menu.createMenuItem(id, params);
	item.setData("fixall", fixall);
	item.setData("value", value);
	item.setData("orig", word);
	item.setData("spanId", spanId);
	item.addSelectionListener(listener || this._spellCheckSuggestionListenerObj);
	return item;
};

ZmHtmlEditor.prototype.discardMisspelledWords =
function(keepModeDiv) {
	if (!this._spellCheck) { return; }

    var size = this.getSize();
	if (this._mode == Dwt.HTML) {
		var doc = this._getIframeDoc();
		doc.body.style.display = "none";

		var p = null;
		var spanIds = this._spellCheck.spanIds;
		for (var i in spanIds) {
			var span = doc.getElementById(i);
			if (!span) continue;

			p = span.parentNode;
			while (span.firstChild) {
				p.insertBefore(span.firstChild, span);
			}
			p.removeChild(span);
		}

		if (!AjxEnv.isIE) {
			doc.body.normalize(); // IE crashes here.
		} else {
			doc.body.innerHTML = doc.body.innerHTML; // WTF.
		}

		// remove the spell check styles
		p = doc.getElementById("ZM-SPELLCHECK-STYLE");
		if (p) {
			p.parentNode.removeChild(p);
		}

		doc.body.style.display = "";
		this._unregisterEditorEventHandler(doc, "contextmenu");
        size.y = size.y - (keepModeDiv ? 0 : 2);
	} else if (this._spellCheckDivId != null) {
		var div = document.getElementById(this._spellCheckDivId);
		var scrollTop = div.scrollTop;
		var textArea = document.getElementById(this._textAreaId);
		// bug: 41760 - HACK. Convert the nbsps back to spaces since Gecko seems
		// to return control characters for HTML entities.
		if (AjxEnv.isGeckoBased) {
			div.innerHTML = AjxStringUtil.htmlDecode(div.innerHTML, true);
		}
		textArea.value = AjxUtil.getInnerText(div);

		// avoid mem. leaks, hopefully
		div.onclick = null;
		div.oncontextmenu = null;
		div.onmousedown = null;
		div.parentNode.removeChild(div);
		textArea.style.display = "";
		textArea.scrollTop = scrollTop;
        size.y = size.y + (keepModeDiv ? 2 : 0);
	}

	this._spellCheckDivId = this._spellCheck = null;
	window.status = "";

	if (!keepModeDiv) {
		this._spellCheckHideModeDiv();
	}

	if (this.onExitSpellChecker) {
		this.onExitSpellChecker.run();
	}
    this._resetSize();
};

ZmHtmlEditor.prototype._spellCheckShowModeDiv =
function() {
	var size = this.getSize();

	if (!this._spellCheckModeDivId) {
		var div = document.createElement("div");
		div.className = "SpellCheckModeDiv";
		div.id = this._spellCheckModeDivId = Dwt.getNextId();
		var html = new Array();
		var i = 0;
		html[i++] = "<table border=0 cellpadding=0 cellspacing=0><tr><td style='width:25'>";
		html[i++] = AjxImg.getImageHtml("SpellCheck");
		html[i++] = "</td><td style='white-space:nowrap'><span class='SpellCheckLink'>";
		html[i++] = ZmMsg.resumeEditing;
		html[i++] = "</span> | <span class='SpellCheckLink'>";
		html[i++] = ZmMsg.checkAgain;
		html[i++] = "</span></td></tr></table>";
		div.innerHTML = html.join("");

		//var editable = document.getElementById((this._spellCheckDivId || this.getBodyFieldId()));
		//editable.parentNode.insertBefore(div, editable);
		var container = this.getHtmlElement();
		container.insertBefore(div, container.firstChild);

		var el = div.getElementsByTagName("span");
		Dwt.associateElementWithObject(el[0], this);
		Dwt.setHandler(el[0], "onclick", ZmHtmlEditor._spellCheckResumeEditing);
		Dwt.associateElementWithObject(el[1], this);
		Dwt.setHandler(el[1], "onclick", ZmHtmlEditor._spellCheckAgain);
	}
	else {
		document.getElementById(this._spellCheckModeDivId).style.display = "";
	}
    this._resetSize();
};

ZmHtmlEditor._spellCheckResumeEditing =
function() {
	var editor = Dwt.getObjectFromElement(this);
	editor.discardMisspelledWords();
    editor.focus();
};

ZmHtmlEditor._spellCheckAgain =
function() {
    Dwt.getObjectFromElement(this).spellCheck(null, true);
};


ZmHtmlEditor.prototype._spellCheckHideModeDiv =
function() {
	var size = this.getSize();
	if (this._spellCheckModeDivId) {
		document.getElementById(this._spellCheckModeDivId).style.display = "none";
	}
    this._resetSize();
};

ZmHtmlEditor.prototype.highlightMisspelledWords =
function(words, keepModeDiv) {
	this.discardMisspelledWords(keepModeDiv);

	var word, style, doc, body, self = this,
		spanIds     = {},
		wordIds     = {},
		regexp      = [ "([^A-Za-z0-9']|^)(" ],
		suggestions = {};

	// preparations: initialize some variables that we then save in
	// this._spellCheck (the current spell checker context).
	for (var i = 0; i < words.length; ++i) {
		word = words[i].word;
		if (!suggestions[word]) {
			i && regexp.push("|");
			regexp.push(word);
			var a = words[i].suggestions.split(/\s*,\s*/);
			if (!a[a.length-1])
				a.pop();
			suggestions[word] = a;
			if (suggestions[word].length > 5)
				suggestions[word].length = 5;
		}
	}
	regexp.push(")([^A-Za-z0-9']|$)");
	regexp = new RegExp(regexp.join(""), "gm");

	function hiliteWords(text, textWhiteSpace) {
		text = textWhiteSpace
			? AjxStringUtil.convertToHtml(text)
			: AjxStringUtil.htmlEncode(text);

		var m;

		regexp.lastIndex = 0;
		while (m = regexp.exec(text)) {
			var str = m[0];
			var prefix = m[1];
			var word = m[2];
			var suffix = m[3];

			var id = Dwt.getNextId();
			spanIds[id] = word;
			if (!wordIds[word])
				wordIds[word] = [];
			wordIds[word].push(id);

			var repl = [
				prefix,
				'<span word="',
				word, '" id="', id, '" class="ZM-SPELLCHECK-MISSPELLED">',
				word, '</span>',
				suffix
				].join("");
			text = [
				text.substr(0, m.index),
				repl,
				text.substr(m.index + str.length)
			].join("");

			// All this crap necessary because the suffix
			// must be taken into account at the next
			// match and JS regexps don't have look-ahead
			// constructs (except \b, which sucks).  Oh well.
			regexp.lastIndex = m.index + repl.length - suffix.length;
		}
		return text;
	};

	var doc;

	// having the data, this function will parse the DOM and replace
	// occurrences of the misspelled words with <span
	// class="ZM-SPELLCHECK-MISSPELLED">word</span>
	rec = function(node) {
		switch (node.nodeType) {
			case 1: /* ELEMENT */
				for (var i = node.firstChild; i; i = rec(i)) {}
				node = node.nextSibling;
				break;
			case 3: /* TEXT */
				if (!/[^\s\xA0]/.test(node.data)) {
					node = node.nextSibling;
					break;
				}
				// for correct handling of whitespace we should
				// not mess ourselves with leading/trailing
				// whitespace, thus we save it in 2 text nodes.
				var a = null, b = null;

				var result = /^[\s\xA0]+/.exec(node.data);
				if (result) {
					// a will contain the leading space
					a = node;
					node = node.splitText(result[0].length);
				}
				result = /[\s\xA0]+$/.exec(node.data);
				if (result) {
					// and b will contain the trailing space
					b = node.splitText(node.data.length - result[0].length);
				}

				var text = hiliteWords(node.data, false);
				text = text.replace(/^ +/, "&nbsp;").replace(/ +$/, "&nbsp;");
				var div = doc.createElement("div");
				div.innerHTML = text;

				// restore whitespace now
				if (a) {
					div.insertBefore(a, div.firstChild);
				}
				if (b) {
					div.appendChild(b);
				}

				var p = node.parentNode;
				while (div.firstChild) {
					p.insertBefore(div.firstChild, node);
				}
				div = node.nextSibling;
				p.removeChild(node);
				node = div;
				break;
			default :
				node = node.nextSibling;
		}
		return node;
	};

	if (this._mode == Dwt.HTML) {
		// HTML mode; See the "else" branch for the TEXT mode--code differs
		// quite a lot.  We should probably implement separate functions as
		// this already becomes long.

		doc = this._getIframeDoc();
		body = doc.body;

		// load the spell check styles, if not already there.
		this._loadExternalStyle("/css/spellcheck.css");

		body.style.display = "none";	// seems to have a good impact on speed,
										// since we may modify a lot of the DOM
		if (!AjxEnv.isIE) {
			body.normalize();
		} else {
			body.innerHTML = body.innerHTML;
		}
		rec(body);
		if (!AjxEnv.isIE) {
			body.normalize();
		} else {
			body.innerHTML = body.innerHTML;
		}
		body.style.display = ""; // redisplay the body
	}
	else { // TEXT mode
		var textArea = document.getElementById(this._textAreaId);
		var scrollTop = textArea.scrollTop;
		var size = Dwt.getSize(textArea);
		textArea.style.display = "none";
		var div = document.createElement("div");
		div.className = "TextSpellChecker";
		this._spellCheckDivId = div.id = Dwt.getNextId();
		div.style.overflow = "auto";
		if (!AjxEnv.isIE) {
			// FIXME: we substract borders/padding here.  this sucks.
			size.x -= 4;
			size.y -= 6;
		}
		div.style.height = size.y + "px";

		div.innerHTML = AjxStringUtil.convertToHtml(this.getContent());
		doc = document;
		rec(div);

		textArea.parentNode.insertBefore(div, textArea);
		div.scrollTop = scrollTop;
		div.oncontextmenu = div.onclick
			= function(ev) { self._handleSpellCheckerEvents(ev || window.event); };
	}

	this._spellCheckShowModeDiv();

	// save the spell checker context
	this._spellCheck = {
		suggestions: suggestions,
		spanIds: spanIds,
		wordIds: wordIds
	};
};

/**
 * Returns true if editor content is spell checked
 */
ZmHtmlEditor.prototype.isSpellCheckMode = function() {
    return Boolean( this._spellCheck );
};

ZmHtmlEditor.prototype._loadExternalStyle =
function(path) {
	var doc = this._getIframeDoc();
	// check if already loaded
	var style = doc.getElementById(path);
	if (!style) {
		style = doc.createElement("link");
		style.id = path;
		style.rel = "stylesheet";
		style.type = "text/css";
		var style_url = appContextPath + path + "?v=" + cacheKillerVersion;
		if (AjxEnv.isGeckoBased || AjxEnv.isSafari) {
			style_url = document.baseURI.replace(
					/^(https?:\x2f\x2f[^\x2f]+).*$/, "$1") + style_url;
		}
		style.href = style_url;
		var head = doc.getElementsByTagName("head")[0];
		if (!head) {
			head = doc.createElement("head");
			var docEl = doc.documentElement;
			if (docEl) {
				docEl.insertBefore(head, docEl.firstChild);
			}
		}
		head.appendChild(style);
	}
};

ZmHtmlEditor.prototype._registerEditorEventHandler = function(iFrameDoc, name) {

	if (iFrameDoc.attachEvent) {
		iFrameDoc.attachEvent("on" + name, this.__eventClosure);
	}
    else if (iFrameDoc.addEventListener) {
		iFrameDoc.addEventListener(name, this.__eventClosure, true);
	}
};

ZmHtmlEditor.prototype._unregisterEditorEventHandler = function(iFrameDoc, name) {

	if (iFrameDoc.detachEvent) {
		iFrameDoc.detachEvent("on" + name, this.__eventClosure);
	}
    else if (iFrameDoc.removeEventListener) {
		iFrameDoc.removeEventListener(name, this.__eventClosure, true);
	}
};

ZmHtmlEditor.prototype.__eventClosure =
function(ev) {
	this._handleEditorEvent(AjxEnv.isIE ? this._getIframeWin().event : ev);
	return tinymce.dom.Event.cancel(ev);
};


ZmHtmlEditor.prototype._handleEditorEvent =
function(ev) {
	var ed = this.getEditor();
	var retVal = true;

	var self = this;

	var target = ev.srcElement || ev.target; //in FF we get ev.target and not ev.srcElement.
	if (this._spellCheck && target && target.id in this._spellCheck.spanIds) {
		var dw;
		// This probably sucks.
		if (/mouse|context|click|select/i.test(ev.type)) {
			dw = new DwtMouseEvent(true);
		} else {
			dw = new DwtUiEvent(true);
		}
		dw.setFromDhtmlEvent(ev);
		this._TIMER_spell = setTimeout(function() {
			self._handleSpellCheckerEvents(dw);
			this._TIMER_spell = null;
		}, 100);
		ev.stopImmediatePropagation();
		ev.stopPropagation();
		ev.preventDefault();
		return tinymce.dom.Event.cancel(ev);
	}

	return retVal;
};

ZmHtmlEditor.prototype._getSelection =
function() {
	if (AjxEnv.isIE) {
		return this._getIframeDoc().selection;
	} else {
		return this._getIframeWin().getSelection();
	}
};

/*
 * Returns toolbar row of tinymce
 *
 *  @param {Number}	Toolbar Row Number 1,2
 *  @param {object}	tinymce editor
 *  @return	{Toolbar HTML Element}
 */
ZmHtmlEditor.prototype.getToolbar =
function(number, editor) {
    var controlManager,
        toolbar;

    editor = editor || this.getEditor();
    if (editor && number) {
        controlManager = editor.controlManager;
        if (controlManager) {
            toolbar = controlManager.get("toolbar"+number);
            if (toolbar && toolbar.id) {
                return document.getElementById(toolbar.id);
            }
        }
    }
};

/*
 *  Returns toolbar button of tinymce
 *
 *  @param {String}	button name
 *  @param {object}	tinymce editor
 *  @return	{Toolbar Button HTML Element}
 */
ZmHtmlEditor.prototype.getToolbarButton =
function(buttonName, editor) {
    var controlManager,
        toolbarButton;

    if (editor && buttonName) {
        controlManager = editor.controlManager;
        if (controlManager) {
            toolbarButton = controlManager.get(buttonName);
            if (toolbarButton && toolbarButton.id) {
                return document.getElementById(toolbarButton.id);
            }
        }
    }
};

/*
 *  Inserting image for signature
 */
ZmHtmlEditor.prototype.insertImageDoc =
function(file) {
    var src = file.rest;
    if (!src) { return; }
    var path = appCtxt.get(ZmSetting.REST_URL) + ZmFolder.SEP;
    var dfsrc = file.docpath;
    if (dfsrc && dfsrc.indexOf("doc:") == 0) {
        var url = [path, dfsrc.substring(4)].join('');
        src = AjxStringUtil.fixCrossDomainReference(url, false, true);
    }
    this.insertImage(src, null, null, null, dfsrc);
};

/*
 *  Insert image callback
 */
ZmHtmlEditor.prototype._imageUploaded = function(folder, fileNames, files) {

	for (var i = 0; i < files.length; i++) {
		var file = files[i];
		var path = appCtxt.get(ZmSetting.REST_URL) + ZmFolder.SEP;
		var docPath = folder.getRestUrl() + ZmFolder.SEP + file.name;
		file.docpath = ["doc:", docPath.substr(docPath.indexOf(path) + path.length)].join("");
		file.rest = folder.getRestUrl() + ZmFolder.SEP + AjxStringUtil.urlComponentEncode(file.name);

		this.insertImageDoc(file);
	}

	//note - it's always one file so far even though the code above support a more than one item array.
	//toast so the user understands uploading an image result in it being in the briefcase.
	appCtxt.setStatusMsg(ZmMsg.imageUploadedToBriefcase);

};

/**
 * This will be fired before every popup open
 *
 * @param {windowManager} tinymce window manager for popups
 * @param {popupWindow}	contains tinymce popup info or popup DOM Window
 *
 */
ZmHtmlEditor.onPopupOpen = function(windowManager, popupWindow) {
    if (!popupWindow) {
        return;
    }
    if (popupWindow.resizable) {
        popupWindow.resizable = 0;
    }

    var popupIframe = popupWindow.frameElement,
        popupIframeLoad;

    if (popupIframe && popupIframe.src && popupIframe.src.match("/table.htm")) {//Table dialog
        popupIframeLoad = function(popupWindow, popupIframe) {
            var doc,align,width;
            if (popupWindow.action === "insert") {//Insert Table Action
                doc = popupWindow.document;
                if (doc) {
                    align = doc.getElementById("align");
                    width = doc.getElementById("width");
                    align && (align.value = "center");
                    width && (width.value = "90%");
                }
            }
            if (this._popupIframeLoad) {
                popupIframe.detachEvent("onload", this._popupIframeLoad);
                delete this._popupIframeLoad;
            }
            else {
                popupIframe.onload = null;
            }
        };

        if (popupIframe.attachEvent) {
            this._popupIframeLoad = popupIframeLoad.bind(this, popupWindow, popupIframe);
            popupIframe.attachEvent("onload", this._popupIframeLoad);
        }
        else {
            popupIframe.onload = popupIframeLoad.bind(this, popupWindow, popupIframe);
        }
    }
};

/**
 * Returns true if editor content is modified
 */
ZmHtmlEditor.prototype.isDirty = function(){
    if( this._mode === Dwt.HTML ){
        var editor = this.getEditor();
        if (editor) {
            return editor.isDirty();
        }
    }
    return false;
};

/**
 * Mark the editor content as unmodified; e.g. as freshly saved.
 */
ZmHtmlEditor.prototype.clearDirty = function(){
	var ed = this.getEditor();
    if (ed) {
        this.getEditor().isNotDirty = true;
    }
};

/**
 * Listen for change in fontfamily, fontsize, fontcolor, direction and showing compose direction buttons preference and update the corresponding one.
 */
ZmHtmlEditor.prototype._settingChangeListener = function(ev) {
    if (ev.type != ZmEvent.S_SETTING) { return; }

    var id = ev.source.id,
        editor,
        body,
        textArea,
        direction,
        showDirectionButtons,
        ltrButton;

    if (id === ZmSetting.COMPOSE_INIT_DIRECTION) {
        textArea = this.getContentField();
        direction = appCtxt.get(ZmSetting.COMPOSE_INIT_DIRECTION);
        if (direction === ZmSetting.RTL) {
            textArea.setAttribute("dir", ZmSetting.RTL);
        }
        else{
            textArea.removeAttribute("dir");
        }
    }

    editor = this.getEditor();
    body = editor ? editor.getBody() : null;
    if(!body)
        return;

    if (id === ZmSetting.COMPOSE_INIT_FONT_FAMILY) {
        body.style.fontFamily = appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_FAMILY);
    }
    else if (id === ZmSetting.COMPOSE_INIT_FONT_SIZE) {
        body.style.fontSize = appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_SIZE);
    }
    else if (id === ZmSetting.COMPOSE_INIT_FONT_COLOR) {
        body.style.color = appCtxt.get(ZmSetting.COMPOSE_INIT_FONT_COLOR);
    }
    else if (id === ZmSetting.SHOW_COMPOSE_DIRECTION_BUTTONS) {
        showDirectionButtons = appCtxt.get(ZmSetting.SHOW_COMPOSE_DIRECTION_BUTTONS);
        ltrButton = this.getToolbarButton("ltr", editor).parentNode;
        if (ltrButton) {
            Dwt.setVisible(ltrButton, showDirectionButtons);
            Dwt.setVisible(ltrButton.previousSibling, showDirectionButtons);
        }
        Dwt.setVisible(this.getToolbarButton("rtl", editor).parentNode, showDirectionButtons);
    }
    else if (id === ZmSetting.COMPOSE_INIT_DIRECTION) {
        if (direction === ZmSetting.RTL) {
            body.dir = ZmSetting.RTL;
        }
        else{
            body.removeAttribute("dir");
        }
    }
    editor.nodeChanged && editor.nodeChanged();//update the toolbar state
};

/**
 * This will be fired after every tinymce menu open. Listen for outside events happening in ZCS
 *
 * @param {menu} tinymce menu object
 */
ZmHtmlEditor.onShowMenu =
function(menu) {
    if (menu && menu._visible) {
        var omemParams = {
            id:					"ZmHtmlEditor" + menu._id,
            elementId:			menu._id,
            outsideListener:	menu.hide.bind(menu)
        };
        appCtxt.getOutsideMouseEventMgr().startListening(omemParams);
    }
};

/**
 * This will be fired after every tinymce menu hide. Removing the outside event listener registered in onShowMenu
 *
 * @param {menu} tinymce menu object
 */
ZmHtmlEditor.onHideMenu =
function(menu) {
    if (menu && !menu._visible) {
        var omemParams = {
            id:					"ZmHtmlEditor" + menu._id,
            elementId:			menu._id
        };
        appCtxt.getOutsideMouseEventMgr().stopListening(omemParams);
    }
};

/*
 * TinyMCE paste Callback function to execute after the contents has been converted into a DOM structure.
 */
ZmHtmlEditor.prototype.pastePostProcess =
function(ev) {
	if (!ev || !ev.node || !ev.target || ev.node.children.length === 0) {
		return;
	}

	var editor = ev.target, tables = editor.dom.select("TABLE", ev.node);

	// Add a border to all tables in the pasted content
	for (var i = 0; i < tables.length; i++) {
		var table = tables[i];
		// set the table border as 1 if it is 0 or unset
		if (table && (table.border === "0" || table.border === "")) {
			table.border = 1;
		}
	}

	// does any child have a 'float' style?
	var hasFloats = editor.dom.select('*', ev.node).some(function(node) {
		return node.style['float'];
	});

	// If the pasted content contains a table then append a DIV so
	// that focus can be set outside the table, and to prevent any floats from
	// overlapping other elements
	if (hasFloats || tables.length > 0) {
		var div = editor.getDoc().createElement("DIV");
		div.style.clear = 'both';
		ev.node.appendChild(div);
	}

	// Find all paragraphs in the pasted content and set the margin to 0
	var paragraphs = editor.dom.select("p", ev.node);

	for (var i = 0; i < paragraphs.length; i++) {
		editor.dom.setStyle(paragraphs[i], "margin", "0");
	}
};

ZmHtmlEditor.prototype._getTabGroup = function() {
	if (!this.__tabGroup) {
		this.__tabGroup = new DwtTabGroup(this.toString());
	}
	return this.__tabGroup;
};

ZmHtmlEditor.prototype.getTabGroupMember = function() {
	var tabGroup = this._getTabGroup();
	this._setupTabGroup(tabGroup);

	return tabGroup;
};

/**
 * Set up the editor tab group. This is done by having a separate tab group for each compose mode: one for HTML, one
 * for TEXT. The current one will be attached to the main tab group. We rebuild the tab group each time to avoid all kinds of issues
 *
 * @private
 */
ZmHtmlEditor.prototype._setupTabGroup = function(mainTabGroup) {

	var mode = this.getMode();
	mainTabGroup = mainTabGroup || this._getTabGroup();

	mainTabGroup.removeAllMembers();
	var modeTabGroup = new DwtTabGroup(this.toString() + '-' + mode);
	if (mode === Dwt.HTML) {
		// tab group for HTML has first toolbar button and IFRAME
		var firstbutton = this.__getEditorControl('listbox', 'Font Family');
		if (firstbutton) {
			modeTabGroup.addMember(firstbutton.getEl());
		}
		var iframe = this._getIframeDoc();
		if (iframe) { //iframe not avail first time this is called. But it's fixed subsequently
			modeTabGroup.addMember(iframe.body);
		}
	}
	else {
		// tab group for TEXT has the TEXTAREA
		modeTabGroup.addMember(this.getContentField());
	}
	mainTabGroup.addMember(modeTabGroup);
};

/**
 Overriding TinyMCE's default show and hide methods of floatpanel and panelbutton. Notifying ZmHtmlEditor about the menu's show and hide events (useful for hiding the menu when mousdedown event happens outside the editor)
 **/
ZmHtmlEditor.prototype._overrideTinyMCEMethods = function() {
	var tinymceUI = tinymce.ui;
	if (!tinymceUI) {
		return;
	}

	var floatPanelPrototype = tinymceUI.FloatPanel && tinymceUI.FloatPanel.prototype;
	if (floatPanelPrototype) {

		var tinyMCEShow = floatPanelPrototype.show;
		floatPanelPrototype.show = function() {
			tinyMCEShow.apply(this, arguments);
			ZmHtmlEditor.onShowMenu(this);
		};

		var tinyMCEHide = floatPanelPrototype.hide;
		floatPanelPrototype.hide = function() {
			tinyMCEHide.apply(this, arguments);
			ZmHtmlEditor.onHideMenu(this);
		};
	}

	var panelButtonPrototype = tinymceUI.PanelButton && tinymceUI.PanelButton.prototype;
	if (panelButtonPrototype) {
		var tinyMCEShowPanel = panelButtonPrototype.showPanel;
		panelButtonPrototype.showPanel = function() {
			var isPanelExist = this.panel;
			tinyMCEShowPanel.apply(this, arguments);
			//when isPanelExist is true, floatPanelPrototype.show method will be called which will call ZmHtmlEditor.onShowMenu method.
			if (!isPanelExist) {
				ZmHtmlEditor.onShowMenu(this.panel);
			}
		}
	}
};

// Returns true if the user is inserting a Tab into the editor (rather than moving focus)
ZmHtmlEditor.isEditorTab = function(ev) {

    return appCtxt.get(ZmSetting.TAB_IN_EDITOR) && ev && ev.keyCode === DwtKeyEvent.KEY_TAB && !ev.shiftKey && !DwtKeyMapMgr.hasModifier(ev);
};
}
if (AjxPackage.define("zimbraMail.share.view.ZmDragAndDrop")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Drag and Drop Event handler
 *
 * @author Hem Aravind
 *
 * @private
 */

ZmDragAndDrop = function(parent) {
    this._view = parent;
    this._controller = parent._controller;
    this._element = parent.getHtmlElement();
    this._initialize();
};

ZmDragAndDrop.prototype.constructor = ZmDragAndDrop;

/**
* @return	{boolean}	true if drag and drop is supported
*/
ZmDragAndDrop.isSupported = function() {

    //Refer https://github.com/Modernizr/Modernizr/issues/57#issuecomment-4187079 Drag and Drop support
    var div = document.createElement('div'),
        dragSupport = (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div)),
        isSupported = dragSupport && !!window.FileReader;

    if (AjxEnv.isSafari4up && dragSupport) {
        isSupported = true;
    }

    ZmDragAndDrop.isSupported = function() {
        return isSupported;
    };

    if (isSupported) {
        ZmDragAndDrop.MESSAGE_SIZE_LIMIT = appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT);
        ZmDragAndDrop.ATTACHMENT_URL = appCtxt.get(ZmSetting.CSFE_ATTACHMENT_UPLOAD_URI)+"?fmt=extended,raw";
    }

    return ZmDragAndDrop.isSupported();
};

/**
 * @return	{boolean} 	true if attachment size exceeded and shows the warning dialog
 */
ZmDragAndDrop.isAttachmentSizeExceeded = function(files, showDialog) {
    var j,
        filesLength,
		size,
        file;

    if (!files) {
        return false;
    }

    for (j = 0 , size = 0, filesLength = files.length; j < filesLength; j++) {
        file = files[j];
        if (file) {
			//Check the total size of the files we upload this time (we don't know the previously uploaded files total size so we do the best we can).
			//NOTE - we compare to the MTA message size limit since there's no limit on specific attachments.
            size += file.size || file.fileSize /*Safari*/ || 0;
            //Showing Error dialog if the attachment size is exceeded
            if ((-1 /* means unlimited */ != ZmDragAndDrop.MESSAGE_SIZE_LIMIT) &&
                (size > ZmDragAndDrop.MESSAGE_SIZE_LIMIT)) {
                if (showDialog) {
                    var msgDlg = appCtxt.getMsgDialog();
                    var errorMsg = AjxMessageFormat.format(ZmMsg.attachmentSizeError, AjxUtil.formatSize(ZmDragAndDrop.MESSAGE_SIZE_LIMIT));
                    msgDlg.setMessage(errorMsg, DwtMessageDialog.WARNING_STYLE);
                    msgDlg.popup();
                }
                return true;
            }
        }
    }
    return false;
};

ZmDragAndDrop.prototype._initialize = function () {
	if (!ZmDragAndDrop.isSupported() && this._element && this._element.id) {
		var tooltip = document.getElementById(this._element.id + ZmId.CMP_DND_TOOLTIP);
		if (tooltip) {
			tooltip.style.display = "none";
			tooltip.innerHTML = "";
		}
	}
    if (!this._view || !this._controller || !this._element || !ZmDragAndDrop.isSupported()) {
        return;
    }
    this._addHandlers(this._element);
    this._dndTooltipEl = document.getElementById(this._element.id + ZmId.CMP_DND_TOOLTIP);
    this._setToolTip();
};

ZmDragAndDrop.prototype._addHandlers = function(el) {
    Dwt.setHandler(el,"ondragover",this._onDragOver.bind(this));
    Dwt.setHandler(el,"ondrop", this._onDrop.bind(this));
};

ZmDragAndDrop.prototype._setToolTip = function(){
    if (!this._dndTooltipEl) {
        return;
    }
    if (this._view._attachCount > 0 || this._dndFilesLength > 0){
        this._dndTooltipEl.style.display = "none";
        this._dndTooltipEl.innerHTML = "";
    } else {
        this._dndTooltipEl.innerHTML = ZmMsg.dndTooltip;
        this._dndTooltipEl.style.display = "block";
    }
};

ZmDragAndDrop.prototype._onDragOver = function(ev) {
    ZmDragAndDrop._stopEvent(ev);
};

ZmDragAndDrop.prototype._onDrop = function(ev, isEditorDND) {
    var dt,
        files,
        file,
        j,
        filesLength;

    if (!ev || (this._view && this._view._disableAttachments === true) ) {
        return;
    }

    dt = ev.dataTransfer;
    if (!dt) {
        return;
    }

    files = dt.files;
    if (!files || !files.length) {
        return;
    }

    ZmDragAndDrop._stopEvent(ev);

	//just re-use code from the my computer option as it should be exactly the same case from now on.
	this._view._submitMyComputerAttachments(files, null, isEditorDND, ev);
};

ZmDragAndDrop._stopEvent = function(ev) {
	if (!ZmDragAndDrop.containFiles(ev)) {
		return;
	}
	if (ev.preventDefault) {
		ev.preventDefault();
	}
	if (ev.stopPropagation) {
		ev.stopPropagation();
	}
};

ZmDragAndDrop.containFiles =
function(ev, type) {
	var typesArray = ev && ev.dataTransfer && ev.dataTransfer.types;
    if (!typesArray) {
		return false;
	}
	type = type || "Files";
	for (var i = 0; i < typesArray.length; i++) {
		if (typesArray[i] === type) {
			return true;
		}
	}
	return false;
};
}

if (AjxPackage.define("zimbraMail.share.controller.ZmController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines an application controller.
 *
 */

/**
 * Creates a controller. 
 * @class
 * This class represents an application controller.
 * 
 * @param	{DwtShell}		container		the application container
 * @param	{ZmApp}			app				the application
 * @param	{constant}		type			type of controller (typically a view type)				
 * @param	{string}		sessionId		the session id
 */
ZmController = function(container, app, type, sessionId) {

	if (arguments.length == 0) { return; }

	this.setCurrentViewType(this.getDefaultViewType());
	this.setCurrentViewId(this.getDefaultViewType());
	if (sessionId) {
		this.setSessionId(sessionId, type);
	}
	
	this._container = container;
	this._app = app;
		
	this._shell = appCtxt.getShell();
	this._appViews = {};
	
	this._authenticating = false;
	this.isHidden = (sessionId == ZmApp.HIDDEN_SESSION);
	this._elementsToHide = null;
};

ZmController.prototype.isZmController = true;
ZmController.prototype.toString = function() { return "ZmController"; };


ZmController.SESSION_ID_SEP = "-";

// Abstract methods

ZmController.prototype._setView = function() {};

/**
 * Returns the default view type
 */
ZmController.getDefaultViewType = function() {};	// needed by ZmApp::getSessionController
ZmController.prototype.getDefaultViewType = function() {};

// _defaultView is DEPRECATED in 8.0
ZmController.prototype._defaultView = ZmController.prototype.getDefaultViewType;



// Public methods

/**
 * Gets the session ID.
 * 
 * @return	{string}	the session ID
 */
ZmController.prototype.getSessionId =
function() {
	return this._sessionId;
};

/**
 * Sets the session id, view id, and tab id (using the type and session id).
 * Controller for a view that shows up in a tab within the app chooser bar.
 * Examples include compose, send confirmation, and msg view.
 *
 * @param {string}						sessionId					the session id
 * @param {string}						type						the type
 * @param {ZmSearchResultsController}	searchResultsController		owning controller
 */
ZmController.prototype.setSessionId =
function(sessionId, type) {

	this._sessionId = sessionId;
	if (type) {
		this.setCurrentViewType(type);
		this.setCurrentViewId(sessionId ? [type, sessionId].join(ZmController.SESSION_ID_SEP) : type);
		this.tabId = sessionId ? ["tab", this.getCurrentViewId()].join("_") : "";
	}
	
	// this.sessionId and this.viewId are DEPRECATED in 8.0;
	// use getSessionId() and getCurrentViewId() instead
	this.sessionId = this._sessionId;
	this.viewId = this.getCurrentViewId();
};

/**
 * Gets the current view type.
 * 
 * @return	{constant}			the view type
 */
ZmController.prototype.getCurrentViewType =
function(viewType) {
	return this._currentViewType;
};
// _getViewType is DEPRECATED in 8.0
ZmController.prototype._getViewType = ZmController.prototype.getCurrentViewType;

/**
 * Sets the current view type.
 * 
 * @param	{constant}	viewType		the view type
 */
ZmController.prototype.setCurrentViewType =
function(viewType) {
	this._currentViewType = viewType;
};

/**
 * Gets the current view ID.
 * 
 * @return	{DwtComposite}	the view Id
 */
ZmController.prototype.getCurrentViewId =
function() {
	return this._currentViewIdOverride || this._currentViewId;
};

/**
 * Sets the current view ID.
 * 
 * @param	{string}	viewId		the view ID
 */
ZmController.prototype.setCurrentViewId =
function(viewId) {
	this._currentViewId = viewId;
	
	// this._currentView is DEPRECATED in 8.0; use getCurrentViewId() instead
	this._currentView = this._currentViewId;
};

/**
 * Gets the application.
 * 
 * @return	{ZmApp}		the application
 */
ZmController.prototype.getApp = function() {
	return this._app;
};

/**
 * return the view elements. Currently a toolbar, app content, and "new" button.
 * 
 * @param view (optional if provided toolbar)
 * @param appContentView
 * @param toolbar (used only if view param is null)
 *
 */
ZmController.prototype.getViewElements =
function(view, appContentView, toolbar) {
	var elements = {};
	toolbar = toolbar || this._toolbar[view];
	elements[ZmAppViewMgr.C_TOOLBAR_TOP] = toolbar;
	elements[ZmAppViewMgr.C_APP_CONTENT] = appContentView;

	return elements;
};

/**
 * Pops-up the error dialog.
 * 
 * @param	{String}	msg		the error msg
 * @param	{ZmCsfeException}	ex		the exception
 * @param	{Boolean}	noExecReset		(not used)
 * @param	{Boolean}	hideReportButton		if <code>true</code>, hide the "Send error report" button
 * @param	{Boolean}	expanded		if <code>true</code>, contents are expanded by default
 */
ZmController.prototype.popupErrorDialog = 
function(msg, ex, noExecReset, hideReportButton, expanded, noEncoding) {
	// popup alert
	var errorDialog = appCtxt.getErrorDialog();
	var detailStr = "";
	if (typeof ex == "string") {
		// in case an Error makes it here
		detailStr = ex;
	} else if (ex instanceof Object) {
		ex.msg = ex.msg || msg;
		var fields = ["method", "msg", "code", "detail", "trace", "request",
					"fileName", "lineNumber", "message", "name", "stack" ];
		var html = [], i = 0;
		html[i++] = "<table>";
		for (var j = 0; j < fields.length; j++) {
			var fld = fields[j];
			var value = AjxStringUtil.htmlEncode(ex[fld]);
			if (value) {
				if (fld == "request") {
					value = ["<pre>", value, "</pre>"].join("");
					var msgDiv = document.getElementById(errorDialog._msgCellId);
					if (msgDiv) {
						msgDiv.className = "DwtMsgDialog-wide";
					}
				}
				html[i++] = ["<tr><td valign='top'>", fields[j], ":</td><td valign='top'>", value, "</td></tr>"].join("");
			}
		}
		html[i++] = "</table>";
		detailStr = html.join("");
	}
	errorDialog.registerCallback(DwtDialog.OK_BUTTON, this._errorDialogCallback, this);
	if (!noEncoding) {
		msg = AjxStringUtil.htmlEncode(msg);
	}
	errorDialog.setMessage(msg, detailStr, DwtMessageDialog.CRITICAL_STYLE, ZmMsg.zimbraTitle);
	errorDialog.popup(null, hideReportButton);
	if (expanded)
		errorDialog.showDetail();
};

/**
 * Pops-up an error dialog describing an upload error.
 *
 * @param	{constant}	type		the type of the uploaded item, e.g. <code>ZmItem.MSG</code>.
 * @param	{Number}	respCode		the HTTP reponse status code
 * @param	{String}	extraMsg		optional message to append to the status
 */
ZmController.prototype.popupUploadErrorDialog =
function(type, respCode, extraMsg) {
    var warngDlg = appCtxt.getMsgDialog();
    var style = DwtMessageDialog.CRITICAL_STYLE;
    var msg = this.createErrorMessage(type, respCode, extraMsg);
	if (msg.length > 0) {
		warngDlg.setMessage(msg, style);
		warngDlg.popup();
	}
};

ZmController.prototype.createErrorMessage = function(type, respCode, extraMsg) {
	var msg = "";

	switch (respCode) {
		case AjxPost.SC_OK:
			break;

		case AjxPost.SC_REQUEST_ENTITY_TOO_LARGE:
			var basemsg =
				type && ZmMsg['attachmentSizeError_' + type] ||
					ZmMsg.attachmentSizeError;
			var sizelimit =
				AjxUtil.formatSize(appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT));
			msg = AjxMessageFormat.format(basemsg, sizelimit);
			break;

		default:
			var basemsg =
				type && ZmMsg['errorAttachment_' + type] ||
					ZmMsg.errorAttachment;
			msg = AjxMessageFormat.format(basemsg, respCode || AjxPost.SC_NO_CONTENT);
			break;
	}

	if ((msg.length > 0) && extraMsg) {
		msg += '<br /><br />';
		msg += extraMsg;
	}
	return msg;
};

ZmController.handleScriptError =
function(ex, debugWindowOnly) {

	var text = [];
	var eol = "<br/>";
	if (ex) {
		var msg = ZmMsg.scriptError + ": " + ex.message;
		var m = ex.fileName && ex.fileName.match(/(\w+\.js)/);
		if (m && m.length) {
			msg += " - " + m[1] + ":" + ex.lineNumber;
		}
		if (ex.fileName)	{ text.push("File: " + ex.fileName); }
		if (ex.lineNumber)	{ text.push("Line: " + ex.lineNumber); }
		if (ex.name)		{ text.push("Error: " + ex.name); }
		if (ex.stack)		{ text.push("Stack: " + ex.stack.replace("\n", eol, "g")); }
	}
	var content = text.join(eol);
	var errorMsg = [msg, content].join(eol + eol);
	if (debugWindowOnly) {
		// Display the error in the debug window
		DBG.println(AjxDebug.DBG1, errorMsg);
	} else {
		// Record the error in a log buffer and display a script error popup
		AjxDebug.println(AjxDebug.EXCEPTION, errorMsg);
		appCtxt.getAppController().popupErrorDialog(msg, content, null, false, true);
	}
};

/**
 * Gets the key map name.
 * 
 * @return	{String}	the key map name
 */
ZmController.prototype.getKeyMapName =
function() {
	return ZmKeyMap.MAP_GLOBAL;
};

/**
 * Handles the key action.
 * 
 * @param	{constant}		actionCode		the action code
 * @return	{Boolean}	<code>true</code> if the key action is handled
 * 
 * @see		ZmApp.ACTION_CODES_R
 * @see		ZmKeyMap
 */
ZmController.prototype.handleKeyAction =
function(actionCode, ev) {
	DBG.println(AjxDebug.DBG3, "ZmController.handleKeyAction");
	
	// tab navigation shortcut
	var tabView = this.getTabView ? this.getTabView() : null;
	if (tabView && tabView.handleKeyAction(actionCode)) {
		return true;
	}

	// shortcuts tied directly to operations
    var isExternalAccount = appCtxt.isExternalAccount();
	var app = ZmApp.ACTION_CODES_R[actionCode];
	if (app) {
		var op = ZmApp.ACTION_CODES[actionCode];
		if (op) {
            if (isExternalAccount) { return true; }
			appCtxt.getApp(app).handleOp(op);
			return true;
		}
	}

    switch (actionCode) {

		case ZmKeyMap.NEW: {
            if (isExternalAccount) { break; }
			// find default "New" action code for current app
			app = appCtxt.getCurrentAppName();
			var newActionCode = ZmApp.NEW_ACTION_CODE[app];
			if (newActionCode) {
				var op = ZmApp.ACTION_CODES[newActionCode];
				if (op) {
					appCtxt.getApp(app).handleOp(op);
					return true;
				}
			}
			break;
		}

		case ZmKeyMap.NEW_FOLDER:
		case ZmKeyMap.NEW_TAG:
            if (isExternalAccount || appCtxt.isWebClientOffline()) { break; }
			var op = ZmApp.ACTION_CODES[actionCode];
			if (op) {
				this._newListener(null, op);
			}
			break;

	    case ZmKeyMap.NEW_SEARCH: {
		    appCtxt.getSearchController().openNewSearchTab();
		    break;
	    }

		case ZmKeyMap.SAVED_SEARCH:
            if (isExternalAccount) { break; }
			var searches = appCtxt.getFolderTree().getByType(ZmOrganizer.SEARCH);
			if (searches && searches.length > 0) {
				var dlg = appCtxt.getChooseFolderDialog();
				// include app name in ID so we have one overview per app to show only its saved searches
				var params = {treeIds:		[ZmOrganizer.SEARCH],
							  overviewId:	dlg.getOverviewId(ZmOrganizer.SEARCH, this._app._name),
							  appName:      this._app._name,
							  title:		ZmMsg.selectSearch};
				ZmController.showDialog(dlg, new AjxCallback(null, ZmController._searchSelectionCallback, [dlg]), params);
			}
			break;

		case ZmKeyMap.VISIT:
			var dlg = appCtxt.getChooseFolderDialog();
			var orgType = ZmApp.ORGANIZER[this._app._name] || ZmOrganizer.FOLDER;
			var params = {treeIds:		[orgType],
						  overviewId:	dlg.getOverviewId(ZmOrganizer.APP[orgType]),
						  appName:		this._app._name,
						  noRootSelect: true,
						  title:		AjxMessageFormat.format(ZmMsg.goToFolder, ZmMsg[ZmOrganizer.MSG_KEY[orgType]])};
			ZmController.showDialog(dlg, new AjxCallback(null, ZmController._visitOrgCallback, [dlg, orgType]), params);
			break;

		case ZmKeyMap.VISIT_TAG:
			if (appCtxt.getTagTree().size() > 0) {
				var dlg = appCtxt.getPickTagDialog();
				ZmController.showDialog(dlg, new AjxCallback(null, ZmController._visitOrgCallback, [dlg, ZmOrganizer.TAG]));
			}
			break;

		default:
			return false;
	}
	return true;
};

/**
 * @private
 */
ZmController._searchSelectionCallback =
function(dialog, searchFolder) {
	if (searchFolder) {
		appCtxt.getSearchController().redoSearch(searchFolder.search);
	}
	dialog.popdown();
};

/**
 * @private
 */
ZmController._visitOrgCallback =
function(dialog, orgType, org) {
	if (org) {
		var tc = appCtxt.getOverviewController().getTreeController(orgType);
		if (tc && tc._itemClicked) {
			tc._itemClicked(org);
		}
	}
	dialog.popdown();
};

/**
 * Checks if shortcuts for the given map are supported for this view. For example, given the map
 * "tabView", a controller that creates a tab view would return <code>true</code>.
 *
 * @param {String}	map		the name of a map (see {@link DwtKeyMap})
 * @return	{Boolean}		<code>true</code> if shortcuts are supported
 */
ZmController.prototype.mapSupported =
function(map) {
	return false;
};

/**
 * @private
 */
ZmController.prototype._newListener =
function(ev, op) {
	switch (op) {
		// new organizers
		case ZmOperation.NEW_FOLDER: {
			// note that this shortcut only happens if mail app is around - it means "new mail folder"
			ZmController.showDialog(appCtxt.getNewFolderDialog(), this.getNewFolderCallback());
			break;
		}
		case ZmOperation.NEW_TAG: {
			if (!this._newTagCb) {
				this._newTagCb = new AjxCallback(this, this._newTagCallback);
			}
			ZmController.showDialog(appCtxt.getNewTagDialog(), this._newTagCb);
			break;
		}
	}
};

/**
 * @private
 */
ZmController.prototype._newFolderCallback =
function(parent, name, color, url) {
	// REVISIT: Do we really want to close the dialog before we
	//          know if the create succeeds or fails?
	var dialog = appCtxt.getNewFolderDialog();
	dialog.popdown();

	var oc = appCtxt.getOverviewController();
	oc.getTreeController(ZmOrganizer.FOLDER)._doCreate(parent, name, color, url);
};

/**
 * @private
 */
ZmController.prototype._newTagCallback =
function(params) {
	appCtxt.getNewTagDialog().popdown();
	var oc = appCtxt.getOverviewController();
	oc.getTreeController(ZmOrganizer.TAG)._doCreate(params);
};

/**
 * @private
 */
ZmController.prototype._createTabGroup =
function(name) {
	name = name ? name : this.toString();
	this._tabGroup = new DwtTabGroup(name);
	return this._tabGroup;
};

/**
 * @private
 */
ZmController.prototype._setTabGroup =
function(tabGroup) {
	this._tabGroup = tabGroup;
};

/**
 * Gets the tab group.
 * 
 * @return	{Object}	the tab group
 */
ZmController.prototype.getTabGroup =
function() {
	return this._tabGroup;
};

/**
 * Gets the new folder callback.
 * 
 * @return	{AjxCallback}	the callback
 */
ZmController.prototype.getNewFolderCallback =
function() {
	if (!this._newFolderCb) {
		this._newFolderCb = new AjxCallback(this, this._newFolderCallback);
	}
	return this._newFolderCb;
};

/**
 * Remember the currently focused item before this view is hidden. Typically called by a preHideCallback.
 * 
 * @private
 */
ZmController.prototype._saveFocus = 
function() {
	var currentFocusMember = appCtxt.getRootTabGroup().getFocusMember();
	var myTg = this.getTabGroup();
	this._savedFocusMember = (currentFocusMember && myTg && myTg.contains(currentFocusMember)) ? currentFocusMember : null;
	return this._savedFocusMember;
};

/**
 * Make our tab group the current app view tab group, and restore focus to
 * whatever had it last time we were visible. Typically called by a postShowCallback.
 * 
 * @private
 */
ZmController.prototype._restoreFocus = 
function(focusItem, noFocus) {

	var rootTg = appCtxt.getRootTabGroup();

	var curApp = appCtxt.getCurrentApp();
	var ovId = curApp && curApp.getOverviewId();
	var overview = ovId && appCtxt.getOverviewController().getOverview(ovId);
	if (rootTg && overview && (overview != ZmController._currentOverview)) {
		var currTg = ZmController._currentOverview &&
			ZmController._currentOverview.getTabGroupMember();
		rootTg.replaceMember(currTg, overview.getTabGroupMember(),
		                     false, false, null, true);
		ZmController._currentOverview = overview;
	}

	var myTg = this.getTabGroup();
	focusItem = focusItem || this._savedFocusMember || this._getDefaultFocusItem() || rootTg.getFocusMember();
	noFocus = noFocus || ZmController.noFocus;
	ZmController.noFocus = false;
	if (rootTg && myTg && (myTg != ZmController._currentAppViewTabGroup)) {
		rootTg.replaceMember(ZmController._currentAppViewTabGroup, myTg, false, false, focusItem, noFocus);
		ZmController._currentAppViewTabGroup = myTg;
	} else if (focusItem && !noFocus) {
		appCtxt.getKeyboardMgr().grabFocus(focusItem);
	}
};

/**
 * @private
 */
ZmController.prototype._getDefaultFocusItem = 
function() {
	var myTg = this.getTabGroup();
	return myTg ? myTg.getFirstMember(true) : null;
};

// Callbacks to run on changes in view state
ZmController.prototype._preUnloadCallback	= function() { return true; };
ZmController.prototype._postHideCallback	= function() { return true; };
ZmController.prototype._postRemoveCallback	= function() { return true; };
ZmController.prototype._preShowCallback		= function() { return true; };

// preserve focus state
ZmController.prototype._preHideCallback = 
function() {
	DBG.println(AjxDebug.DBG2, "ZmController.prototype._preHideCallback");
	this._saveFocus();
	return true;
};

// restore focus state
ZmController.prototype._postShowCallback = 
function() {
	DBG.println(AjxDebug.DBG2, "ZmController.prototype._postShowCallback");
	this._restoreFocus();
	return true;
};

/**
 * Common exception handling entry point for sync and async commands.
 * 
 * @private
 */
ZmController.prototype._handleError =
function(ex, continuation) {
	this._handleException(ex, continuation);
};

/**
 * Handles exceptions. There is special handling for auth-related exceptions.
 * Other exceptions generally result in the display of an error dialog. An
 * auth-expired exception results in the display of a login dialog. After the
 * user logs in, we use the continuation to re-run the request that failed.
 * 
 * @param {AjxException}	ex				the exception
 * @param {Hash}	continuation		the original request params
 * 
 * @private
 */
ZmController.prototype._handleException = function(ex, continuation) {

	if (ex.code == AjxSoapException.INVALID_PDU) {
		ex.code = ZmCsfeException.SVC_FAILURE;
		ex.detail = ["contact your administrator (", ex.msg, ")"].join("");
		ex.msg = "Service failure";
	}
	
	if (ex.code == ZmCsfeException.SVC_AUTH_EXPIRED || ex.code == ZmCsfeException.SVC_AUTH_REQUIRED || ex.code == ZmCsfeException.NO_AUTH_TOKEN) {
		ZmCsfeCommand.noAuth = true;
        DBG.println(AjxDebug.DBG1, "ZmController.prototype._handleException ex.code : " + ex.code + ". Invoking logout.");
		ZmZimbraMail.logOff(null, true);
		return;
	}

	// If we get this error, user is probably looking at a stale list. Let's
	// refetch user's search results. This is more likely to happen in zdesktop.
	// See bug 33760.
	if (ex.code == ZmCsfeException.MAIL_NO_SUCH_MSG) {
		var vid = appCtxt.getCurrentViewId();
		// only process if we're in one of these views otherwise, do the default
		if (vid == ZmId.VIEW_CONVLIST || vid == ZmId.VIEW_TRAD) {
			var mailApp = appCtxt.getApp(ZmApp.MAIL);
			var callback = appCtxt.isOffline ? new AjxCallback(this, this._handleMailSearch, mailApp) : null;
			mailApp.mailSearch(null, callback);
			return;
		}
	}

	// silently ignore polling exceptions
	if (ex.method !== "NoOpRequest") {
		var args;
		if (ex.code === ZmCsfeException.MAIL_NO_SUCH_ITEM) {
			args = ex.data.itemId;
		}
        else if (ex.code === ZmCsfeException.MAIL_SEND_FAILURE) {
			args = ex.code; // bug fix #5603 - error msg for mail.SEND_FAILURE takes an argument
		}
        else if (ex.code === ZmCsfeException.MAIL_INVALID_NAME) {
			args = ex.data.name;
		}
        else if (ex.code === ZmCsfeException.SVC_UNKNOWN_DOCUMENT) {
            args = ex.msg.split(': ')[1];
        }

		if (ex.lineNumber && !ex.detail) {
			// JS error that was caught before our JS-specific handler got it
			ZmController.handleScriptError(ex);
		}
        else {
            var msg;

            if (continuation && continuation.restUri && continuation.restUri.indexOf('zimbraim') !== -1) {
                msg = ZmMsg.chatXMPPError;
            }
            else {
                msg = ex.getErrorMsg ? ex.getErrorMsg(args) : ex.msg || ex.message;
            }

			this.popupErrorDialog(msg, ex, true, this._hideSendReportBtn(ex));
		}
	}
};

ZmController.prototype._handleMailSearch =
function(app) {
	if (appCtxt.get(ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES)) {
		app.getOverviewContainer().highlightAllMboxes();
	}
};

/**
 * @private
 */
ZmController.prototype._hideSendReportBtn =
function(ex) {
	return (ex.code == ZmCsfeException.MAIL_TOO_MANY_TERMS ||
		  	ex.code == ZmCsfeException.MAIL_MAINTENANCE_MODE ||
			ex.code == ZmCsfeException.MAIL_MESSAGE_TOO_BIG ||
			ex.code == ZmCsfeException.NETWORK_ERROR ||
		   	ex.code == ZmCsfeException.EMPTY_RESPONSE ||
		   	ex.code == ZmCsfeException.BAD_JSON_RESPONSE ||
		   	ex.code == ZmCsfeException.TOO_MANY_TAGS ||
			ex.code == ZmCsfeException.OFFLINE_ONLINE_ONLY_OP);
};

//
// Msg dialog Callbacks
//

/**
 * @private
 */
ZmController.prototype._errorDialogCallback =
function() {
	appCtxt.getErrorDialog().popdown();
};

/**
 * Shows a dialog. Since the dialog is a shared resource, a dialog reset is performed.
 * 
 * @param	{DwtDialog}		dialog		the dialog
 * @param	{AjxCallback}	callback	the callback
 * @param	{Hash}		params		a hash of parameters
 * @param	{ZmAccount}	account		the account
 * 
 * @see DwtDialog#reset
 * @see DwtDialog#popup
 */
ZmController.showDialog = 
function(dialog, callback, params, account) {
	dialog.reset(account);
	dialog.registerCallback(DwtDialog.OK_BUTTON, callback);
	dialog.popup(params, account);
};

/**
 * Pop down the dialog and clear any pending actions (initiated from an action menu).
 * 
 * @private
 */
ZmController.prototype._clearDialog =
function(dialog) {
	dialog.popdown();
	this._pendingActionData = null;
};

/**
 * @private
 */
ZmController.prototype._menuPopdownActionListener = function() {};

/**
 * Checks if the view is transient.
 * 
 * @param	{Object}	oldView		the old view
 * @param	{Object}	newView		the new view
 * @return	{Boolean}		<code>true</code> if the controller is transient.
 */
ZmController.prototype.isTransient =
function(oldView, newView) {
	return false;
};

}
if (AjxPackage.define("zimbraMail.share.controller.ZmBaseController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines a base controller class.
 *
 */

/**
 * This class is a base class for any controller that manages items such as messages, contacts,
 * appointments, tasks, etc. It handles operations that can be performed on those items such as
 * move, delete, tag, print, etc.
 *
 * @author Conrad Damon
 *
 * @param {DwtControl}					container					the containing shell
 * @param {ZmApp}						app							the containing application
 * @param {constant}					type						type of controller (typically a view type)				
 * @param {string}						sessionId					the session id
 * @param {ZmSearchResultsController}	searchResultsController		containing controller
 * 
 * @extends		ZmController
 */
ZmBaseController = function(container, app, type, sessionId, searchResultsController) {

	if (arguments.length == 0) { return; }
	ZmController.apply(this, arguments);

	this.setSessionId(sessionId, type || this.getDefaultViewType(), searchResultsController);
	
    //this._refreshQuickCommandsClosure = this._refreshQuickCommands.bind(this);
    //this._quickCommandMenuHandlerClosure = this._quickCommandMenuHandler.bind(this);

	// hashes keyed by view type
	this._view		= {};
	this._toolbar	= {};	// ZmButtonToolbar
	this._tabGroups = {};	// DwtTabGroup

	this._tagList = appCtxt.getTagTree();
	if (this._tagList) {
		this._boundTagChangeListener = this._tagChangeListener.bind(this);
		this._tagList.addChangeListener(this._boundTagChangeListener);
	}

	// create a listener for each operation
	this._listeners = {};
	this._listeners[ZmOperation.NEW_MENU]		= this._newListener.bind(this);
	this._listeners[ZmOperation.TAG_MENU]		= this._tagButtonListener.bind(this);
	this._listeners[ZmOperation.MOVE_MENU]		= this._moveButtonListener.bind(this);
	this._listeners[ZmOperation.ACTIONS_MENU]	= this._actionsButtonListener.bind(this);
	this._listeners[ZmOperation.TAG]			= this._tagListener.bind(this);
	this._listeners[ZmOperation.PRINT]			= this._printListener.bind(this);
	this._listeners[ZmOperation.DELETE]			= this._deleteListener.bind(this);
	this._listeners[ZmOperation.DELETE_WITHOUT_SHORTCUT]			= this._deleteListener.bind(this);
	this._listeners[ZmOperation.CLOSE]			= this._backListener.bind(this);
	this._listeners[ZmOperation.MOVE]			= this._moveListener.bind(this);
	this._listeners[ZmOperation.SEARCH]			= this._searchListener.bind(this);
	this._listeners[ZmOperation.NEW_MESSAGE]	= this._composeListener.bind(this);
	this._listeners[ZmOperation.CONTACT]		= this._contactListener.bind(this);
	this._listeners[ZmOperation.VIEW]			= this._viewMenuItemListener.bind(this);
	this._listeners[ZmOperation.GO_TO_URL]		= this._goToUrlListener.bind(this);

	// TODO: do this better - avoid referencing specific apps
	if (window.ZmImApp) {
		this._listeners[ZmOperation.IM] = ZmImApp.getImMenuItemListener();
	}

	/**
	 * List of toolbar operations to enable on Zero/no selection
	 * - Default is only enable ZmOperation.NEW_MENU
	 */
	this.operationsToEnableOnZeroSelection = [ZmOperation.NEW_MENU];

	/**
	 * List of toolbar operations to enable when multiple items are selected
	 * - Default is to enable: ZmOperation.NEW_MENU, ZmOperation.TAG_MENU, ZmOperation.DELETE, ZmOperation.MOVE,
	 * 						ZmOperation.MOVE_MENU, ZmOperation.FORWARD & ZmOperation.ACTIONS_MENU
	 */
	this.operationsToEnableOnMultiSelection = [ZmOperation.NEW_MENU, ZmOperation.TAG_MENU, ZmOperation.DELETE,
												ZmOperation.MOVE, ZmOperation.MOVE_MENU, ZmOperation.FORWARD,
												ZmOperation.ACTIONS_MENU];
	/**
	 * List of toolbar operations to *disable*
	 * Default is to enable-all
	 */
	this.operationsToDisableOnSingleSelection = [];
};

ZmBaseController.prototype = new ZmController;
ZmBaseController.prototype.constructor = ZmBaseController;

ZmBaseController.prototype.isZmBaseController = true;
ZmBaseController.prototype.toString = function() { return "ZmBaseController"; };



// public methods

/**
 * Sets the session id, view id, and tab id. Notes whether this controller is being
 * used to display search results.
 *
 * @param {string}						sessionId					the session id
 * @param {string}						type						the type
 * @param {ZmSearchResultsController}	searchResultsController		owning controller
 */
ZmBaseController.prototype.setSessionId =
function(sessionId, type, searchResultsController) {

	ZmController.prototype.setSessionId.apply(this, arguments);
	this.searchResultsController = searchResultsController;
	this.isSearchResults = Boolean(searchResultsController);
};

/**
 * Gets the current view object.
 * 
 * @return	{DwtComposite}	the view object
 */
ZmBaseController.prototype.getCurrentView =
function() {
	return this._view[this._currentViewId];
};

/**
 * Returns the view used to display a single item, if any.
 */
ZmBaseController.prototype.getItemView = function() {
	return null;
};

/**
 * Gets the current tool bar.
 * 
 * @return	{ZmButtonToolbar}		the toolbar
 */
ZmBaseController.prototype.getCurrentToolbar =
function() {
	return this._toolbar[this._currentViewId];
};

/**
 * Returns the list of items to be acted upon.
 */
ZmBaseController.prototype.getItems = function() {};

/**
 * Returns the number of items to be acted upon.
 */
ZmBaseController.prototype.getItemCount = function() {};

/**
 * Handles a shortcut.
 * 
 * @param	{constant}	actionCode		the action code
 * @return	{Boolean}	<code>true</code> if the action is handled
 */
ZmBaseController.prototype.handleKeyAction =
function(actionCode, ev) {

	DBG.println(AjxDebug.DBG3, "ZmBaseController.handleKeyAction");
    var isExternalAccount = appCtxt.isExternalAccount();

	switch (actionCode) {

		case ZmKeyMap.MOVE:
            if (isExternalAccount) { break; }
			var items = this.getItems();
			if (items && items.length) {
				this._moveListener();
			}
			break;

		case ZmKeyMap.PRINT:
			if (appCtxt.get(ZmSetting.PRINT_ENABLED) && !appCtxt.isWebClientOffline()) {
				this._printListener();
			}
			break;

		case ZmKeyMap.TAG:
            if (isExternalAccount) { break; }
			var items = this.getItems();
			if (items && items.length && (appCtxt.getTagTree().size() > 0)) {
				var dlg = appCtxt.getPickTagDialog();
				ZmController.showDialog(dlg, new AjxCallback(this, this._tagSelectionCallback, [items, dlg]));
			}
			break;

		case ZmKeyMap.UNTAG:
            if (isExternalAccount) { break; }
			if (appCtxt.get(ZmSetting.TAGGING_ENABLED)) {
				var items = this.getItems();
				if (items && items.length) {
					this._doRemoveAllTags(items);
				}
			}
			break;

		default:
			return ZmController.prototype.handleKeyAction.apply(this, arguments);
	}
	return true;
};

/**
 * Returns true if this controller's view is currently being displayed (possibly within a search results tab)
 */
ZmBaseController.prototype.isCurrent =
function() {
	return (this._currentViewId == appCtxt.getCurrentViewId());
};

ZmBaseController.prototype.supportsDnD =
function() {
	return !appCtxt.isExternalAccount();
};

// abstract protected methods

// Creates the view element
ZmBaseController.prototype._createNewView	 		= function() {};

// Populates the view with data
ZmBaseController.prototype._setViewContents			= function(view) {};

// Returns text for the tag operation
ZmBaseController.prototype._getTagMenuMsg 			= function(num) {};

// Returns text for the move dialog
ZmBaseController.prototype._getMoveDialogTitle		= function(num) {};

// Returns a list of desired toolbar operations
ZmBaseController.prototype._getToolBarOps 			= function() {};

// Returns a list of secondary (non primary) toolbar operations
ZmBaseController.prototype._getSecondaryToolBarOps 	= function() {};

// Returns a list of buttons that align to the right, like view and detach
ZmBaseController.prototype._getRightSideToolBarOps 	= function() {};


// private and protected methods

/**
 * Creates basic elements and sets the toolbar and action menu.
 * 
 * @private
 */
ZmBaseController.prototype._setup =
function(view) {
	this._initialize(view);
	this._resetOperations(this._toolbar[view], 0);
};

/**
 * Creates the basic elements: toolbar, list view, and action menu.
 *
 * @private
 */
ZmBaseController.prototype._initialize =
function(view) {
	this._initializeToolBar(view);
	this._initializeView(view);
	this._initializeTabGroup(view);
};

// Below are functions that return various groups of operations, for cafeteria-style
// operation selection.

/**
 * @private
 */
ZmBaseController.prototype._standardToolBarOps =
function() {
	return [ZmOperation.DELETE, ZmOperation.MOVE_MENU, ZmOperation.PRINT];
};

/**
 * Initializes the toolbar buttons and listeners.
 * 
 * @private
 */
ZmBaseController.prototype._initializeToolBar =
function(view, className) {

	if (this._toolbar[view]) { return; }

	var buttons = this._getToolBarOps();
	var secondaryButtons = this._getSecondaryToolBarOps() || [];
	var rightSideButtons = this._getRightSideToolBarOps() || [];
	if (!(buttons || secondaryButtons)) { return; }

	var tbParams = {
		parent:				this._container,
		buttons:			buttons,
		secondaryButtons:	secondaryButtons,
		rightSideButtons: 	rightSideButtons,
		overrides:          this._getButtonOverrides(buttons.concat(secondaryButtons).concat(rightSideButtons)),
		context:			view,
		controller:			this,
		refElementId:		ZmId.SKIN_APP_TOP_TOOLBAR,
		addTextElement:		true,
		className:			className
	};
	var tb = this._toolbar[view] = new ZmButtonToolBar(tbParams);

	var text = tb.getButton(ZmOperation.TEXT);
	if (text) {
		text.addClassName("itemCountText");
	}

	var button;
	for (var i = 0; i < tb.opList.length; i++) {
		button = tb.opList[i];
		if (this._listeners[button]) {
			tb.addSelectionListener(button, this._listeners[button]);
		}
	}

	button = tb.getButton(ZmOperation.TAG_MENU);
	if (button) {
		button.noMenuBar = true;
		this._setupTagMenu(tb);
	}

	button = tb.getButton(ZmOperation.MOVE_MENU);
	if (button) {
		button.noMenuBar = true;
		this._setupMoveMenu(tb);
	}


	// add the selection listener for when user clicks on the little drop-down arrow (unfortunately we have to do that here separately) It is done for the main button area in a generic way to all toolbar buttons elsewhere
	var actionsButton = tb.getActionsButton();
	if (actionsButton) {
		actionsButton.addDropDownSelectionListener(this._listeners[ZmOperation.ACTIONS_MENU]);
	}

	var actionsMenu = tb.getActionsMenu();
	if (actionsMenu) {
		this._setSearchMenu(actionsMenu, true);
	}	

	appCtxt.notifyZimlets("initializeToolbar", [this._app, tb, this, view], {waitUntilLoaded:true});
};

ZmBaseController.prototype._getButtonOverrides = function(buttons) {};

/**
 * Initializes the view and its listeners.
 * 
 * @private
 */
ZmBaseController.prototype._initializeView =
function(view) {

	if (this._view[view]) { return; }

	this._view[view] = this._createNewView(view);
	this._view[view].addSelectionListener(this._listSelectionListener.bind(this));
	this._view[view].addActionListener(this._listActionListener.bind(this));
};

// back-compatibility (bug 60073)
ZmBaseController.prototype._initializeListView = ZmBaseController.prototype._initializeView;

/**
 * Sets up tab groups (focus ring).
 * 
 * @private
 */
ZmBaseController.prototype._initializeTabGroup = function(view) {

	if (this._tabGroups[view]) {
        return;
    }

	this._tabGroups[view] = this._createTabGroup();
	this._tabGroups[view].newParent(appCtxt.getRootTabGroup());
	this._tabGroups[view].addMember(this._toolbar[view].getTabGroupMember());
    this._tabGroups[view].addMember(this._view[view].getTabGroupMember());
};

/**
 * Creates the desired application view.
 *
 * @param params		[hash]			hash of params:
 *        view			[constant]		view ID
 *        elements		[array]			array of view components
 *        controller	[ZmController]	controller responsible for this view
 *        isAppView		[boolean]*		this view is a top-level app view
 *        clear			[boolean]*		if true, clear the hidden stack of views
 *        pushOnly		[boolean]*		if true, don't reset the view's data, just swap the view in
 *        noPush		[boolean]*		if true, don't push the view, just set its contents
 *        isTransient	[boolean]*		this view doesn't go on the hidden stack
 *        stageView		[boolean]*		stage the view rather than push it
 *        tabParams		[hash]*			button params; view is opened in app tab instead of being stacked
 *        
 * @private
 */
ZmBaseController.prototype._setView =
function(params) {

	var view = params.view;
	
	// create the view (if we haven't yet)
	if (!this._appViews[view]) {
		// view management callbacks
		var callbacks = {};
		callbacks[ZmAppViewMgr.CB_PRE_HIDE]		= this._preHideCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_PRE_UNLOAD]	= this._preUnloadCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_POST_HIDE]	= this._postHideCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_POST_REMOVE]	= this._postRemoveCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_PRE_SHOW]		= this._preShowCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_POST_SHOW]	= this._postShowCallback.bind(this);

		params.callbacks = callbacks;
		params.viewId = view;
		params.controller = this;
		this._app.createView(params);
		this._appViews[view] = true;
	}

	// populate the view
	if (!params.pushOnly) {
		this._setViewContents(view);
	}

	// push the view
	if (params.stageView) {
		this._app.stageView(view);
	} else if (!params.noPush) {
		return (params.clear ? this._app.setView(view) : this._app.pushView(view));
	}
};



// Operation listeners

/**
 * Tag button has been pressed. We don't tag anything (since no tag has been selected),
 * we just show the dynamic tag menu.
 * 
 * @private
 */
ZmBaseController.prototype._tagButtonListener =
function(ev) {
	var toolbar = this._toolbar[this._currentViewId];
	if (ev.item.parent == toolbar) {
		this._setTagMenu(toolbar);
	}
};

/**
 * Move button has been pressed. We don't move anything (since no folder has been selected),
 * we just show the dynamic move menu.
 *
 * @private
 */
ZmBaseController.prototype._moveButtonListener =
function(ev, list) {
	this._pendingActionData = list || this.getItems();

	var toolbar = this._toolbar[this._currentViewId];

	var moveButton = toolbar.getOp(ZmOperation.MOVE_MENU);
	if (!moveButton) {
		return;
	}
	if (!this._moveButtonInitialized) {
		this._moveButtonInitialized = true;
		appCtxt.getShell().setBusy(true);
		this._setMoveButton(moveButton);
		appCtxt.getShell().setBusy(false);
	}
	else {
		//need to update this._data so the chooser knows from which folder we are trying to move.
		this._folderChooser.updateData(this._getMoveParams(this._folderChooser).data);
	}
	var newButton = this._folderChooser._getNewButton();
	if (newButton) {
		newButton.setVisible(!appCtxt.isWebClientOffline());
	}
	moveButton.popup();
	moveButton.getMenu().getHtmlElement().style.width = "auto"; //reset the width so it's dynamic. without this it is set to 0, and in any case even if it was set to some other > 0 value, it needs to be dynamic due to collapse/expand (width changes)
	this._folderChooser.focus();
};

/**
 * Actions button has been pressed.
 * @private
 */
ZmBaseController.prototype._actionsButtonListener =
function(ev) {
	var menu = this.getCurrentToolbar().getActionsMenu();
	menu.parent.popup();	
};


/**
 * Tag/untag items.
 * 
 * @private
 */
ZmBaseController.prototype._tagListener =
function(ev, items) {

	if (this.isCurrent()) {
		var menuItem = ev.item;
		var tagEvent = menuItem.getData(ZmTagMenu.KEY_TAG_EVENT);
		var tagAdded = menuItem.getData(ZmTagMenu.KEY_TAG_ADDED);
		items = items || this.getItems();

		if (tagEvent == ZmEvent.E_TAGS && tagAdded) {
			this._doTag(items, menuItem.getData(Dwt.KEY_OBJECT), true);
		} else if (tagEvent == ZmEvent.E_CREATE) {
			this._pendingActionData = items;
			var newTagDialog = appCtxt.getNewTagDialog();
			if (!this._newTagCb) {
				this._newTagCb = new AjxCallback(this, this._newTagCallback);
			}
			ZmController.showDialog(newTagDialog, this._newTagCb);
			newTagDialog.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, newTagDialog);
		} else if (tagEvent == ZmEvent.E_TAGS && !tagAdded) {
			//remove tag
			this._doTag(items, menuItem.getData(Dwt.KEY_OBJECT), false);
		} else if (tagEvent == ZmEvent.E_REMOVE_ALL) {
			// bug fix #607
			this._doRemoveAllTags(items);
		}
	}
};

/**
 * Called after tag selection via dialog.
 * 
 * @private
 */
ZmBaseController.prototype._tagSelectionCallback =
function(items, dialog, tag) {
	if (tag) {
		this._doTag(items, tag, true);
	}
	dialog.popdown();
};

/**
 * overload if you want to print in a different way.
 * 
 * @private
 */
ZmBaseController.prototype._printListener =
function(ev) {
	var items = this.getItems();
    if (items && items[0]) {
	    window.open(items[0].getRestUrl(), "_blank");
	}
};

ZmBaseController.prototype._backListener =
function(ev) {
	this._app.popView();
};

/**
 * Delete one or more items.
 * 
 * @private
 */
ZmBaseController.prototype._deleteListener =
function(ev) {
	this._doDelete(this.getItems(), ev.shiftKey);
};

/**
 * Move button has been pressed, show the dialog.
 * 
 * @private
 */
ZmBaseController.prototype._moveListener =
function(ev, list) {

	this._pendingActionData = list || this.getItems();
	var moveToDialog = appCtxt.getChooseFolderDialog();
	if (!this._moveCb) {
		this._moveCb = new AjxCallback(this, this._moveCallback);
	}
	ZmController.showDialog(moveToDialog, this._moveCb, this._getMoveParams(moveToDialog));
	moveToDialog.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, moveToDialog);
};

/**
 * @protected
 */
ZmBaseController.prototype._getMoveParams =
function(dlg) {

	var org = ZmApp.ORGANIZER[this._app._name] || ZmOrganizer.FOLDER;
	return {
		overviewId:		dlg.getOverviewId(this._app._name),
		data:			this._pendingActionData,
		treeIds:		[org],
		title:			this._getMoveDialogTitle(this._pendingActionData.length, this._pendingActionData),
		description:	ZmMsg.targetFolder,
		treeStyle:		DwtTree.SINGLE_STYLE,
		noRootSelect: 	true, //I don't think you can ever use the "move" dialog to move anything to a root folder... am I wrong?
		appName:		this._app._name
	};
};

/**
 * Switch to selected view.
 * 
 * @private
 */
ZmBaseController.prototype._viewMenuItemListener =
function(ev) {
	if (ev.detail == DwtMenuItem.CHECKED || ev.detail == DwtMenuItem.UNCHECKED) {
		this.switchView(ev.item.getData(ZmOperation.MENUITEM_ID));
	}
};


// new organizer callbacks

/**
 * Created a new tag, now apply it.
 * 
 * @private
 */
ZmBaseController.prototype._tagChangeListener =
function(ev) {

	// only process if current view is this view!
	if (this.isCurrent()) {
		if (ev.type == ZmEvent.S_TAG && ev.event == ZmEvent.E_CREATE && this._pendingActionData) {
			var tag = ev.getDetail("organizers")[0];
			this._doTag(this._pendingActionData, tag, true);
			this._pendingActionData = null;
			this._menuPopdownActionListener();
		}
	}
};

/**
 * Move stuff to a new folder.
 * 
 * @private
 */
ZmBaseController.prototype._moveCallback =
function(folder) {
	this._doMove(this._pendingActionData, folder);
	this._clearDialog(appCtxt.getChooseFolderDialog());
	this._pendingActionData = null;
};

/**
 * Move stuff to a new folder. 
 *
 * @private
 */
ZmBaseController.prototype._moveMenuCallback =
function(moveButton, folder) {
	this._doMove(this._pendingActionData, folder);
	moveButton.getMenu().popdown();
	this._pendingActionData = null;
};

// Data handling

// Actions on items are performed through their containing list
ZmBaseController.prototype._getList =
function(items) {

	items = AjxUtil.toArray(items);
	var item = items[0];
	return item && item.list;
};

// callback (closure) to run when an action has completely finished
ZmBaseController.prototype._getAllDoneCallback = function() {};

/**
 * Shows the given summary as status toast.
 *
 * @param {String}		summary						the text that summarizes the recent action
 * @param {ZmAction}	actionLogItem				the logged action for possible undoing
 * @param {boolean}		showToastOnParentWindow		the toast message should be on the parent window (since the child window is being closed)
 */
ZmBaseController.showSummary =
function(summary, actionLogItem, showToastOnParentWindow) {
	
	if (!summary) {
		return;
	}
	var ctxt = showToastOnParentWindow ? parentAppCtxt : appCtxt;
	var actionController = ctxt.getActionController();
	var undoLink = actionLogItem && actionController && actionController.getUndoLink(actionLogItem);
	if (undoLink && actionController) {
		actionController.onPopup();
		ctxt.setStatusMsg({msg: summary + undoLink, transitions: actionController.getStatusTransitions()});
	} else {
		ctxt.setStatusMsg(summary);
	}
};

/**
 * Flag/unflag an item
 * 
 * @private
 */
ZmBaseController.prototype._doFlag =
function(items, on) {

	items = AjxUtil.toArray(items);
	if (!items.length) { return; }

	if (items[0].isZmItem) {
		if (on !== true && on !== false) {
			on = !items[0].isFlagged;
		}
		var items1 = [];
		for (var i = 0; i < items.length; i++) {
			if (items[i].isFlagged != on) {
				items1.push(items[i]);
			}
		}
	} else {
		items1 = items;
	}

	var params = {items:items1, op:"flag", value:on};
    params.actionTextKey = on ? 'actionFlag' : 'actionUnflag';
	var list = params.list = this._getList(params.items);
	this._setupContinuation(this._doFlag, [on], params);
	list.flagItems(params);
};

// TODO: shouldn't this be in ZmMailItemController?
ZmBaseController.prototype._doMsgPriority = 
function(items, on) {
	items = AjxUtil.toArray(items);
	if (!items.length) { return; }

	if (items[0].isZmItem) {
		if (on !== true && on !== false) {
			on = !items[0].isPriority;
		}
		var items1 = [];
		for (var i = 0; i < items.length; i++) {
			if (items[i].isPriority != on) {
				items1.push(items[i]);
			}
		}
	} else {
		items1 = items;
	}

	var params = {items:items1, op:"priority", value:on};
    params.actionTextKey = on ? 'actionMsgPriority' : 'actionUnMsgPriority';
	var list = params.list = this._getList(params.items);
	this._setupContinuation(this._doMsgPriority, [on], params);
	list.flagItems(params);	
};

/**
 * Tag/untag items
 * 
 * @private
 */
ZmBaseController.prototype._doTag =
function(items, tag, doTag) {

	items = AjxUtil.toArray(items);
	if (!items.length) { return; }

	//see bug 79756 as well as this bug, bug 98316.
	for (var i = 0; i < items.length; i++) {
		if (items[i].cloneOf) {
			items[i] = items[i].cloneOf;
		}
	}

	var params = {items:items, tag:tag, doTag:doTag};
	var list = params.list = this._getList(params.items);
	this._setupContinuation(this._doTag, [tag, doTag], params);
	list.tagItems(params);
};

/**
 * Remove all tags for given items
 * 
 * @private
 */
ZmBaseController.prototype._doRemoveAllTags =
function(items) {

	items = AjxUtil.toArray(items);
	if (!items.length) { return; }

	//see bug 79756 as well as this bug.
	for (var i = 0; i < items.length; i++) {
		if (items[i].cloneOf) {
			items[i] = items[i].cloneOf;
		}
	}
	var params = {items:items};
	var list = params.list = this._getList(params.items);
	this._setupContinuation(this._doRemoveAllTags, null, params);
	list.removeAllTags(params);
};

/**
* Deletes one or more items from the list.
*
* @param items			[Array]			list of items to delete
* @param hardDelete		[boolean]*		if true, physically delete items
* @param attrs			[Object]*		additional attrs for SOAP command
* @param confirmDelete  [Boolean]       user already confirmed hard delete (see ZmBriefcaseController.prototype._doDelete and ZmBriefcaseController.prototype._doDelete2) 
* 
* @private
*/
ZmBaseController.prototype._doDelete =
function(items, hardDelete, attrs, confirmDelete) {

	items = AjxUtil.toArray(items);
	if (!items.length) { return; }

	// If the initial set of deletion items is incomplete (we will be using continuation) then if its deletion
	// from the trash folder mark it as a hardDelete.  Otherwise, upon continuation the items will be moved
	// (Trash to Trash) instead of deleted.
	var folder = this._getSearchFolder();
	var inTrashFolder = (folder && folder.nId == ZmFolder.ID_TRASH);
	if (inTrashFolder) {
		hardDelete = true;
	}

	var params = {
		items:			items,
		hardDelete:		hardDelete,
		attrs:			attrs,
		childWin:		appCtxt.isChildWindow && window,
		closeChildWin:	appCtxt.isChildWindow,
		confirmDelete:	confirmDelete
	};
	var allDoneCallback = this._getAllDoneCallback();
	var list = params.list = this._getList(params.items);
	this._setupContinuation(this._doDelete, [hardDelete, attrs, true], params, allDoneCallback);
	
	if (!hardDelete) {
		var anyScheduled = false;
		for (var i=0, cnt=items.length; i<cnt; i++) {
			if (items[i] && items[i].isScheduled) {
				anyScheduled = true;
				break;
			}
		}
		if (anyScheduled) {
			params.noUndo = true;
			this._popupScheduledWarningDialog(list.deleteItems.bind(list, params));
		} else {
			list.deleteItems(params);
		}
	} else {
		list.deleteItems(params);
	}
};

/**
 * Moves a list of items to the given folder. Any item already in that folder is excluded.
 *
 * @param {Array}	items		a list of items to move
 * @param {ZmFolder}	folder		the destination folder
 * @param {Object}	attrs		the additional attrs for SOAP command
 * @param {Boolean}		isShiftKey	<code>true</code> if forcing a copy action
 * @param {Boolean}		noUndo	<code>true</code> undo not allowed
 * @private
 */
ZmBaseController.prototype._doMove =
function(items, folder, attrs, isShiftKey, noUndo) {

	items = AjxUtil.toArray(items);
	if (!items.length) { return; }

	var move = [];
	var copy = [];
	if (items[0].isZmItem) {
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			if (!item.folderId || (item.folderId != folder.id || (attrs && attrs.op == "recover"))) {
				if (!this._isItemMovable(item, isShiftKey, folder)) {
					copy.push(item);
				} else {
					move.push(item);
				}
			}
		}
	} else {
		move = items;
	}

	var params = {folder:folder, attrs:attrs, noUndo: noUndo};
    params.errorCallback = this._actionErrorCallback.bind(this);

	var allDoneCallback = this._getAllDoneCallback();
	if (move.length) {
		params.items = move;
		var list = params.list = this._getList(params.items);
		this._setupContinuation(this._doMove, [folder, attrs, isShiftKey], params, allDoneCallback);

		if (folder.isInTrash()) {
			var anyScheduled = false;
			var mItems = AjxUtil.toArray(move);
			for (var i=0, cnt=mItems.length; i<cnt; i++) {
				if (mItems[i] && mItems[i].isScheduled) {
					anyScheduled = true;
					break;
				}
			}
			if (anyScheduled) {
				params.noUndo = true;
				this._popupScheduledWarningDialog(list.moveItems.bind(list, params));
			} else {
				list.moveItems(params);
			}
		}
		else if (folder.id == appCtxt.get(ZmSetting.MAIL_ACTIVITYSTREAM_FOLDER) && items.length == 1) { 
			list.moveItems(params);
			var activityStreamDialog = appCtxt.getActivityStreamFilterDialog();
			activityStreamDialog.setFields(items[0]);
			activityStreamDialog.popup();
		}
		else if (items.length == 1 && folder.id == ZmFolder.ID_INBOX) {
			list.moveItems(params);
			var fromFolder = appCtxt.getById(items[0].folderId);
			if (fromFolder && fromFolder.id == appCtxt.get(ZmSetting.MAIL_ACTIVITYSTREAM_FOLDER)) { 
				var activityStreamDialog = appCtxt.getActivityToInboxFilterDialog();
				activityStreamDialog.setFields(items[0]);
				activityStreamDialog.popup();
			}
		}
		else {
			list.moveItems(params);
		}
	}

	if (copy.length) {
		params.items = copy;
		var list = params.list = this._getList(params.items);
		this._setupContinuation(this._doMove, [folder, attrs, isShiftKey], params, allDoneCallback, true);
		list.copyItems(params);
	}
};

ZmBaseController.prototype._actionErrorCallback =
function(ex){
    return false;
};

ZmBaseController.prototype._popupScheduledWarningDialog =
function(callback) {
	var dialog = appCtxt.getOkCancelMsgDialog();
	dialog.reset();
	dialog.setMessage(ZmMsg.moveScheduledMessageWarning, DwtMessageDialog.WARNING_STYLE);
	dialog.registerCallback(DwtDialog.OK_BUTTON, this._scheduledWarningDialogListener.bind(this, callback, dialog));
	dialog.associateEnterWithButton(DwtDialog.OK_BUTTON);
	dialog.popup(null, DwtDialog.OK_BUTTON);
};

ZmBaseController.prototype._scheduledWarningDialogListener =
function(callback, dialog) {
	dialog.popdown()
	callback();
};

/**
 * Decides whether an item is movable
 *
 * @param {Object}	item			the item to be checked
 * @param {Boolean}		isShiftKey	<code>true</code> if forcing a copy (not a move)
 * @param {ZmFolder}	folder		the folder this item belongs under
 * 
 * @private
 */
ZmBaseController.prototype._isItemMovable =
function(item, isShiftKey, folder) {
	return (!isShiftKey && !item.isReadOnly() && !folder.isReadOnly());
};

/**
 * Modify an item.
 * 
 * @private
 */
ZmBaseController.prototype._doModify =
function(item, mods) {
	var list = this._getList(item);
	list.modifyItem(item, mods);
};

/**
 * Create an item. We need to be passed a list since we may not have one.
 * 
 * @private
 */
ZmBaseController.prototype._doCreate =
function(list, args) {
	list.create(args);
};

// Miscellaneous


/**
 * Add listener to tag menu
 * 
 * @private
 */
ZmBaseController.prototype._setupTagMenu =
function(parent, listener) {
	if (!parent) return;
	var tagMenu = parent.getTagMenu();
	listener = listener || this._listeners[ZmOperation.TAG];
	if (tagMenu) {
		tagMenu.addSelectionListener(listener);
	}
	if (parent.isZmButtonToolBar) {
		var tagButton = parent.getOp(ZmOperation.TAG_MENU);
		if (tagButton) {
			tagButton.addDropDownSelectionListener(this._listeners[ZmOperation.TAG_MENU]);
		}
	}
};

/**
 * setup the move menu
 *
 * @private
 */
ZmBaseController.prototype._setupMoveMenu =
function(parent) {
	if (!parent) {
		return;
	}
	if (!parent.isZmButtonToolBar) {
		return;
	}
	var moveButton = parent.getOp(ZmOperation.MOVE_MENU);
	if (moveButton) {
		moveButton.addDropDownSelectionListener(this._listeners[ZmOperation.MOVE_MENU]);
	}
};

/**
 * Dynamically build the tag menu based on selected items and their tags.
 * 
 * @private
 */
ZmBaseController.prototype._setTagMenu =
function(parent, items) {

	if (!parent) { return; }

	var tagOp = parent.getOp(ZmOperation.TAG_MENU);
	if (tagOp) {
		var tagMenu = parent.getTagMenu();
		if (!tagMenu) { return; }

		// dynamically build tag menu add/remove lists
		items = items || AjxUtil.toArray(this.getItems());

		for (var i=0; i<items.length; i++) {
			if (items[i].cloneOf) {
				items[i] = items[i].cloneOf;
			}
		}

		var account = (appCtxt.multiAccounts && items.length == 1) ? items[0].getAccount() : null;

		// fetch tag tree from appctxt (not cache) for multi-account case
		tagMenu.set(items, appCtxt.getTagTree(account));
		if (parent.isZmActionMenu) {
			tagOp.setText(this._getTagMenuMsg(items.length, items));
		}
		else {
			tagMenu.parent.popup();

			// bug #17584 - we currently don't support creating new tags in new window
			if (appCtxt.isChildWindow || appCtxt.isWebClientOffline()) {
				var mi = tagMenu.getMenuItem(ZmTagMenu.MENU_ITEM_ADD_ID);
				if (mi) {
					mi.setVisible(false);
				}
			}
		}
	}
};

/**
 * copied some from ZmCalendarApp.createMiniCalButton
 * initializes the move button with {@link ZmFolderChooser} as the menu.
 *
 * @param	{DwtButton}	the button
 */
ZmBaseController.prototype._setMoveButton =
function(moveButton) {

	// create menu for button
	var moveMenu = new DwtMenu({parent: moveButton, style:DwtMenu.CALENDAR_PICKER_STYLE, id: "ZmMoveButton_" + this.getCurrentViewId()});
	moveMenu.getHtmlElement().style.width = "auto"; //make it dynamic  (so expanding long named sub-folders would expand width. (plus right now it sets it to 0 due to some styles)
	moveButton.setMenu(moveMenu, true);

	var chooser = this._folderChooser = new ZmFolderChooser({parent:moveMenu});
	var moveParams = this._getMoveParams(chooser);
	moveParams.overviewId += this._currentViewId; //so it works when switching views (cuz the tree has a listener and the tree is shared unless it's different ID). maybe there's a different way to solve this.
	chooser.setupFolderChooser(moveParams, this._moveMenuCallback.bind(this, moveButton));

	return moveButton;
};

/**
 * Resets the available operations on a toolbar or action menu.
 * 
 * @param {DwtControl}	parent		toolbar or action menu
 * @param {number}		num			number of items selected currently
 * @private
 */
ZmBaseController.prototype._resetOperations =
function(parent, num) {

	if (!parent) { return; }

	if (num == 0) {
		parent.enableAll(false);
		parent.enable(this.operationsToEnableOnZeroSelection, true);
	} else if (num == 1) {
		parent.enableAll(true);
		parent.enable(this.operationsToDisableOnSingleSelection, false);
	} else if (num > 1) {
		parent.enableAll(false);
		parent.enable(this.operationsToEnableOnMultiSelection, true);
    }

	// bug: 41758 - don't allow shared items to be tagged
	var folder = (num > 0) && this._getSearchFolder();
	if (folder && folder.isReadOnly()) {
		parent.enable(ZmOperation.TAG_MENU, false);
	}
    //this._resetQuickCommandOperations(parent);
};

/**
 * Resets a single operation on a toolbar or action menu.
 * 
 * @param {DwtControl}	parent		toolbar or action menu
 * @param {number}		num			number of items selected currently
 * @param {constant}	op			operation
 * @private
 */
ZmBaseController.prototype._resetOperation = function(parent, num, op) {};

/**
 * Resets the available options on the toolbar.
 * 
 * @private
 */
ZmBaseController.prototype._resetToolbarOperations =
function() {
	this._resetOperations(this._toolbar[this._currentViewId], this.getItemCount());
};


/**
 * @private
 */
ZmBaseController.prototype._getDefaultFocusItem =
function() {
	return this.getCurrentView();
};

/**
 * Sets a callback that shows a summary of what was done. The first three arguments are
 * provided for overriding classes that want to apply an action to an extended list of
 * items (retrieved via successive search, for example).
 *
 * @param {function}	actionMethod		the controller action method
 * @param {Array}		args				an arg list for above (except for items arg)
 * @param {Hash}		params				the params that will be passed to list action method
 * @param {closure}		allDoneCallback		the callback to run after all items processed
 * 
 * @private
 */
ZmBaseController.prototype._setupContinuation =
function(actionMethod, args, params, allDoneCallback) {
	params.finalCallback = this._continueAction.bind(this, {allDoneCallback:allDoneCallback});
};

/**
 * Runs the "all done" callback and shows a summary of what was done.
 *
 * @param {Hash}		params				a hash of parameters
 * @param {closure}	 	allDoneCallback		the callback to run when we're all done
 * 
 * @private
 */
ZmBaseController.prototype._continueAction =
function(params) {

	if (params.allDoneCallback) {
		params.allDoneCallback();
	}
	ZmBaseController.showSummary(params.actionSummary, params.actionLogItem, params.closeChildWin);
};



ZmBaseController.prototype._bubbleSelectionListener = function(ev) {

	this._actionEv = ev;
	var bubble = ev.item;
	if (ev.detail === DwtEvent.ONDBLCLICK) {
		this._actionEv.bubble = bubble;
		this._actionEv.address = bubble.addrObj || bubble.address;
		this._composeListener(ev);
	}
	else {
		var view = this.getItemView(),
			bubbleList = view && view._bubbleList;

		if (bubbleList && bubbleList.selectAddressText) {
			bubbleList.selectAddressText();
		}
	}
};

ZmBaseController.prototype._bubbleActionListener = function(ev, addr) {

	this._actionEv = ev;
	var bubble = this._actionEv.bubble = ev.item,
		address = this._actionEv.address = addr || bubble.addrObj || bubble.address,
		menu = this._getBubbleActionMenu();

	if (menu) {
		menu.enable(
			[
				ZmOperation.CONTACT,
				ZmOperation.ADD_TO_FILTER_RULE
			],
			!appCtxt.isWebClientOffline()
		);
		this._loadContactForMenu(menu, address, ev);
	}
};

ZmBaseController.prototype._getBubbleActionMenu = function() {

	if (this._bubbleActionMenu) {
		return this._bubbleActionMenu;
	}

	var menuItems = this._getBubbleActionMenuOps();
	var menu = this._bubbleActionMenu = new ZmActionMenu({
		parent:     this._shell,
		menuItems:  menuItems,
		controller: this,
		id:         ZmId.create({
			componentType:  ZmId.WIDGET_MENU,
			componentName:  this._currentViewId,
			app:            this._app
		})
	});

	if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
		this._setSearchMenu(menu, false);
	}

	if (appCtxt.get(ZmSetting.FILTERS_ENABLED) && this._setAddToFilterMenu) {
		this._setAddToFilterMenu(menu);
	}

	menu.addPopdownListener(this._bubbleMenuPopdownListener.bind(this));

	for (var i = 0; i < menuItems.length; i++) {
		var menuItem = menuItems[i];
		if (this._listeners[menuItem]) {
			menu.addSelectionListener(menuItem, this._listeners[menuItem]);
		}
	}

	menu.setVisible(true);
	var clipboard = appCtxt.getClipboard();
	if (clipboard) {
		clipboard.init(menu.getOp(ZmOperation.COPY), {
			onMouseDown:    this._clipCopy.bind(this),
			onComplete:     this._clipCopyComplete.bind(this)
		});
	}

	return menu;
};

ZmBaseController.prototype._getBubbleActionMenuOps = function() {

	var ops = [];
	if (AjxClipboard.isSupported()) {
		// we use Zero Clipboard (a Flash hack) to copy address
		ops.push(ZmOperation.COPY);
	}
	ops.push(ZmOperation.SEARCH_MENU);
	ops.push(ZmOperation.NEW_MESSAGE);
	ops.push(ZmOperation.CONTACT);
	ops.push(ZmOperation.GO_TO_URL);

	if (appCtxt.get(ZmSetting.FILTERS_ENABLED) && this._filterListener) {
		ops.push(ZmOperation.ADD_TO_FILTER_RULE);
	}

	return ops;
};

// Copies address text from the active bubble to the clipboard.
ZmBaseController.prototype._clipCopy = function(clip) {
	clip.setText(this._actionEv.address + AjxEmailAddress.SEPARATOR);
};

ZmBaseController.prototype._clipCopyComplete = function(clip) {
	this._bubbleActionMenu.popdown();
};

// This will get called before the menu item listener. If that causes issues,
// we can run this function on a timer.
ZmBaseController.prototype._bubbleMenuPopdownListener = function() {

	var itemView = this.getItemView(),
		bubbleList = itemView && itemView._bubbleList,
		bubble = this._actionEv && this._actionEv.bubble;

	if (bubbleList) {
		bubbleList.clearRightSelection();
		if (bubble) {
			bubble.setClassName(bubbleList._normalClass);
		}
	}
	this._actionEv.bubble = null;
};

// handle click on an address (or "Select All") in popup DL expansion list
ZmBaseController.prototype._dlAddrSelected = function(match, ev) {
	this._actionEv.address = match;
	this._composeListener(ev);
};

ZmBaseController.prototype._loadContactForMenu = function(menu, address, ev, imItem) {

	var ac = window.parentAppCtxt || appCtxt;
	var contactsApp = ac.getApp(ZmApp.CONTACTS),
		address = address.isAjxEmailAddress ? address : new AjxEmailAddress(address),
		email = address.getAddress();

	if (!email) {
		return;
	}

	// first check if contact is cached, and no server call is needed
	var contact = contactsApp.getContactByEmail(email);
	if (contact) {
		this._handleResponseGetContact(menu, address, ev, imItem, contact);
		return;
	}

	var op = menu.getOp(ZmOperation.CONTACT);
	if (op) {
		op.setText(ZmMsg.loading);
	}
	if (imItem) {
		if (ZmImApp.updateImMenuItemByAddress(imItem, address, false)) {
			imItem.setText(ZmMsg.loading);
		}
		else {
			imItem = null;	// done updating item, didn't need server call
		}
	}
	menu.popup(0, ev.docX || ev.item.getXW(), ev.docY || ev.item.getYH());
	var respCallback = this._handleResponseGetContact.bind(this, menu, address, ev, imItem);
	contactsApp.getContactByEmail(email, respCallback);
};

ZmBaseController.prototype._handleResponseGetContact = function(menu, address, ev, imItem, contact) {

	this._actionEv.contact = contact;
	this._setContactText(contact, menu);

	if (imItem) {
		if (contact) {
			ZmImApp.updateImMenuItemByContact(imItem, contact, address);
		}
		else {
			ZmImApp.handleResponseGetContact(imItem, address, true);
		}
	}
	menu.popup(0, ev.docX || ev.item.getXW(), ev.docY || ev.item.getYH());
};

/**
 * Sets text to "add" or "edit" based on whether a participant is a contact or not.
 * contact - the contact (or null)
 * extraMenu - see ZmMailListController.prototype._setContactText
 *
 * @private
 */
ZmBaseController.prototype._setContactText = function(contact, menu) {
	ZmBaseController.setContactTextOnMenu(contact, menu || this._actionMenu);
};

/**
 * Sets text to "add" or "edit" based on whether a participant is a contact or not.
 * contact - the contact (or null)
 * menus - array of one or more menus
 *
 * @private
 */
ZmBaseController.setContactTextOnMenu = function(contact, menu) {

	if (!menu) {
		return;
	}

	var newOp = ZmOperation.EDIT_CONTACT;
	var newText = null; //no change ("edit contact")

	if (contact && contact.isDistributionList()) {
		newText = ZmMsg.AB_EDIT_DL;
	}
	else if (contact && contact.isGroup()) {
		newText = ZmMsg.AB_EDIT_GROUP;
	}
	else if (!contact || contact.isGal) {
		// if there's no contact, or it's a GAL contact - there's no "edit" - just "add".
		newText = ZmMsg.AB_ADD_CONTACT;
		newOp = ZmOperation.NEW_CONTACT;
	}

	ZmOperation.setOperation(menu, ZmOperation.CONTACT, newOp, newText);

	if (appCtxt.isWebClientOffline()) {
		menu.enable(ZmOperation.CONTACT, false);
	}
};

/**
 * Add listener to search menu
 *
 * @param parent
 */
ZmBaseController.prototype._setSearchMenu = function(parent, isToolbar) {

	var searchMenu = parent && parent.getSearchMenu && parent.getSearchMenu();
	if (!searchMenu) {
		return;
	}
	searchMenu.addSelectionListener(ZmOperation.SEARCH, this._searchListener.bind(this, AjxEmailAddress.FROM, isToolbar));
	searchMenu.addSelectionListener(ZmOperation.SEARCH_TO, this._searchListener.bind(this, AjxEmailAddress.TO, isToolbar));

	if (this.getSearchFromText()) {
		searchMenu.getMenuItem(ZmOperation.SEARCH).setText(this.getSearchFromText());
	}
	if (this.getSearchToText()) {
		searchMenu.getMenuItem(ZmOperation.SEARCH_TO).setText(this.getSearchToText());
	}
};

/**
 * From Search based on email address.
 *
 * @private
 */
ZmBaseController.prototype._searchListener = function(addrType, isToolbar, ev) {

	var folder = this._getSearchFolder(),
		item = this._actionEv.item,
		address = this._actionEv.address,
		name;

	if (item && item.isZmMailMsg && folder && folder.isOutbound()) {
		/* sent/drafts search from all recipients */
		var toAddrs = item.getAddresses(AjxEmailAddress.TO).getArray(),
			ccAddrs = item.getAddresses(AjxEmailAddress.CC).getArray();

		name = toAddrs.concat(ccAddrs);
	}
	else if (address) {
		name = address.isAjxEmailAddress ? address.getAddress() : address;
	}

	if (name) {
        var ac = window.parentAppCtxt || window.appCtxt;
		var srchCtlr = ac.getSearchController();
		if (addrType === AjxEmailAddress.FROM) {
			srchCtlr.fromSearch(name);
		}
		else if (addrType === AjxEmailAddress.TO) {
			srchCtlr.toSearch(name);
		}
	}
};

/**
 * Compose message to participant.
 *
 * @private
 */
ZmBaseController.prototype._composeListener = function(ev, addr) {

	var addr = addr || (this._actionEv && this._actionEv.address),
		email = addr && addr.toString();

	if (email) {
		AjxDispatcher.run("Compose", {
			action:         ZmOperation.NEW_MESSAGE,
			inNewWindow:    this._app._inNewWindow(ev),
			toOverride:     email + AjxEmailAddress.SEPARATOR
		});
	}
};

/**
 * If there's a contact for the participant, edit it, otherwise add it.
 *
 * @private
 */
ZmBaseController.prototype._contactListener = function(ev) {
	var loadCallback = this._handleLoadContactListener.bind(this);
	AjxDispatcher.require(["ContactsCore", "Contacts"], false, loadCallback, null, true);
};

/**
 * @private
 */
ZmBaseController.prototype._handleLoadContactListener = function() {

	var cc = appCtxt.isChildWindow ? window.parentAppCtxt.getApp(ZmApp.CONTACTS).getContactController() :
									AjxDispatcher.run("GetContactController");
	var contact = this._actionEv.contact;
	if (contact) {
		if (contact.isDistributionList()) {
			this._editListener(this._actionEv, contact);
			return;
		}
		if (contact.isLoaded) {
			var isDirty = contact.isGal;
			cc.show(contact, isDirty);
		} else {
			var callback = this._loadContactCallback.bind(this);
			contact.load(callback);
		}
	} else {
		var contact = cc._createNewContact(this._actionEv);
		cc.show(contact, true);
	}
	if (appCtxt.isChildWindow) {
		window.close();
	}
};

ZmBaseController.prototype.getSearchFromText = function() {
	return null;
};

ZmBaseController.prototype.getSearchToText = function() {
	return null;
};

ZmBaseController.prototype._createNewContact = function(ev) {
	var contact = new ZmContact(null);
	contact.initFromEmail(ev.address);
	return contact;
};

ZmBaseController.prototype._loadContactCallback = function(resp, contact) {
	AjxDispatcher.run("GetContactController").show(contact);
};

ZmBaseController.prototype._getSearchFolder = function() {
	var id = this._getSearchFolderId();
	return id && appCtxt.getById(id);
};

/**
 * This method gets overridden if folder id is retrieved another way
 *
 * @param {boolean}		allowComplex	if true, search can have other terms aside from the folder term
 * @private
 */
ZmBaseController.prototype._getSearchFolderId = function(allowComplex) {
	var s = this._activeSearch && this._activeSearch.search;
	return s && (allowComplex || s.isSimple()) && s.folderId;
};

ZmBaseController.prototype._goToUrlListener = function(ev) {
	var addr = this._getAddress(this._actionEv.address);
	var parts = addr.split("@");
	if (!parts.length) {
		return;
	}
	var domain = parts[1];
	var pieces = domain.split(".");
	var url = "http://" + (pieces.length <= 2 ? "www." + domain : domain);
	window.open(url, "_blank");

};

ZmBaseController.prototype._getAddress = function(obj) {
	return obj.isAjxEmailAddress ? obj.address : obj;
};
}
if (AjxPackage.define("zimbraMail.share.controller.ZmListController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines a list controller class.
 *
 */

/**
 * This class is a base class for any controller that manages a list of items such as mail messages
 * or contacts. It can handle alternative views of the same list.
 *
 * @author Conrad Damon
 *
 * @param {DwtControl}					container					the containing shell
 * @param {ZmApp}						app							the containing application
 * @param {constant}					type						type of controller
 * @param {string}						sessionId					the session id
 * @param {ZmSearchResultsController}	searchResultsController		containing controller
 * 
 * @extends		ZmBaseController
 */
ZmListController = function(container, app, type, sessionId, searchResultsController) {

	if (arguments.length == 0) { return; }
	ZmBaseController.apply(this, arguments);

	// hashes keyed by view type
	this._navToolBar = {};			// ZmNavToolBar
	this._listView = this._view;	// ZmListView (back-compatibility for bug 60073)

	this._list = null;				// ZmList
	this._activeSearch = null;
	this._newButton = null;
	this._actionMenu = null;		// ZmActionMenu
	this._actionEv = null;
	
	if (this.supportsDnD()) {
		this._dropTgt = new DwtDropTarget("ZmTag");
		this._dropTgt.markAsMultiple();
		this._dropTgt.addDropListener(this._dropListener.bind(this));
	}

	this._menuPopdownListener = this._menuPopdownActionListener.bind(this);
	
	this._itemCountText = {};
	this._continuation = {count:0, totalItems:0};
};

ZmListController.prototype = new ZmBaseController;
ZmListController.prototype.constructor = ZmListController;

ZmListController.prototype.isZmListController = true;
ZmListController.prototype.toString = function() { return "ZmListController"; };

// When performing a search action (bug 10317) on all items (including those not loaded),
// number of items to load on each search to work through all results. Should be a multiple
// of ZmList.CHUNK_SIZE. Make sure to test if you change these.
ZmListController.CONTINUATION_SEARCH_ITEMS = 500;

// states of the progress dialog
ZmListController.PROGRESS_DIALOG_INIT	= "INIT";
ZmListController.PROGRESS_DIALOG_UPDATE	= "UPDATE";
ZmListController.PROGRESS_DIALOG_CLOSE	= "CLOSE";


/**
 * Performs some setup for displaying the given search results in a list view. Subclasses will need
 * to do the actual display work, typically by calling the list view's {@link #set} method.
 *
 * @param {ZmSearchResult}	searchResults		the search results
 */
ZmListController.prototype.show	=
function(searchResults) {
	
	this._activeSearch = searchResults;
	// save current search for use by replenishment
	if (searchResults) {
		this._currentSearch = searchResults.search;
		this._activeSearch.viewId = this._currentSearch.viewId = this._currentViewId;
	}
	this.currentPage = 1;
	this.maxPage = 1;
};

/**
 * Returns the current list view.
 * 
 * @return {ZmListView}	the list view
 */
ZmListController.prototype.getListView =
function() {
	return this._view[this._currentViewId];
};

/**
 * Gets the current search results.
 * 
 * @return	{ZmSearchResults}	current search results
 */
ZmListController.prototype.getCurrentSearchResults =
function() {
	return this._activeSearch;
};

/**
 * Gets the search string.
 * 
 * @return	{String}	the search string
 */
ZmListController.prototype.getSearchString =
function() {
	return this._currentSearch ? this._currentSearch.query : "";
};


ZmListController.prototype.setSearchString =
function(query) {
	this._currentSearch.query = query;
};

/**
 * Gets the search string hint.
 * 
 * @return	{String}	the search string hint
 */
ZmListController.prototype.getSearchStringHint =
function() {
	return this._currentSearch ? this._currentSearch.queryHint : "";
};

ZmListController.prototype.getSelection =
function(view) {
    view = view || this.getListView();
    return view ? view.getSelection() : [];
};

ZmListController.prototype.getSelectionCount =
function(view) {
    view = view || this.getListView();
    return view ? view.getSelectionCount() : 0;
};

/**
 * Gets the list.
 * 
 * @return	{ZmList}		the list
 */
ZmListController.prototype.getList =
function() {
	return this._list;
};

/**
 * Sets the list.
 * 
 * @param	{ZmList}	newList		the new list
 */
ZmListController.prototype.setList =
function(newList) {
	if (newList != this._list && newList.isZmList) {
		if (this._list) {
			this._list.clear();	// also removes change listeners
		}
		this._list = newList;
		this._list.controller = this;
	}
};

/**
 * Sets the "has more" state.
 * 
 * @param	{Boolean}	hasMore		<code>true</code> if has more
 */
ZmListController.prototype.setHasMore =
function(hasMore) {
	// Note: This is a bit of a HACK that is an attempt to overcome an
	// offline issue. The problem is during initial sync when more
	// messages come in: the forward navigation arrow doesn't get enabled.
	
	if (hasMore && this._list) {
		// bug: 30546
		this._list.setHasMore(hasMore);
		this._resetNavToolBarButtons();
	}
};

/**
 * Returns a list of the selected items.
 */
ZmListController.prototype.getItems =
function() {
	return this.getSelection();
};

/**
 * Returns the number of selected items.
 */
ZmListController.prototype.getItemCount =
function() {
	return this.getSelectionCount();
};

/**
 * Handles the key action.
 * 
 * @param	{constant}	actionCode		the action code
 * @return	{Boolean}	<code>true</code> if the action is handled
 */
ZmListController.prototype.handleKeyAction =
function(actionCode, ev) {

	DBG.println(AjxDebug.DBG3, "ZmListController.handleKeyAction");
	var listView = this._view[this._currentViewId];
	var result = false;
    var activeEl = document.activeElement;

	switch (actionCode) {

		case DwtKeyMap.DBLCLICK:
            if (activeEl && activeEl.nodeName && activeEl.nodeName.toLowerCase() === 'a') {
                return false;
            }
			return listView.handleKeyAction(actionCode);

		case ZmKeyMap.SHIFT_DEL:
		case ZmKeyMap.DEL:
			var tb = this.getCurrentToolbar();
			var button = tb && (tb.getButton(ZmOperation.DELETE) || tb.getButton(ZmOperation.DELETE_MENU));
			if (button && button.getEnabled()) {
				this._doDelete(this.getSelection(), (actionCode == ZmKeyMap.SHIFT_DEL));
				result = true;
			}
			break;

		case ZmKeyMap.NEXT_PAGE:
			var ntb = this._navToolBar[this._currentViewId];
			var button = ntb ? ntb.getButton(ZmOperation.PAGE_FORWARD) : null;
			if (button && button.getEnabled()) {
				this._paginate(this._currentViewId, true);
				result = true;
			}
			break;

		case ZmKeyMap.PREV_PAGE:
			var ntb = this._navToolBar[this._currentViewId];
			var button = ntb ? ntb.getButton(ZmOperation.PAGE_BACK) : null;
			if (button && button.getEnabled()) {
				this._paginate(this._currentViewId, false);
				result = true;
			}
			break;

		// Esc pops search results tab
		case ZmKeyMap.CANCEL:
			var ctlr = this.isSearchResults && this.searchResultsController;
			if (ctlr) {
				ctlr._closeListener();
			}
			break;

		default:
			return ZmBaseController.prototype.handleKeyAction.apply(this, arguments);
	}
	return result;
};

// Returns a list of desired action menu operations
ZmListController.prototype._getActionMenuOps = function() {};

/**
 * @private
 */
ZmListController.prototype._standardActionMenuOps =
function() {
	return [ZmOperation.TAG_MENU, ZmOperation.MOVE, ZmOperation.PRINT];
};

/**
 * @private
 */
ZmListController.prototype._participantOps =
function() {
	var ops = [ZmOperation.SEARCH_MENU];

	if (appCtxt.get(ZmSetting.MAIL_ENABLED)) {
		ops.push(ZmOperation.NEW_MESSAGE);
	}

	if (appCtxt.get(ZmSetting.CONTACTS_ENABLED)) {
		ops.push(ZmOperation.CONTACT);
	}

	return ops;
};

/**
 * Initializes action menu: menu items and listeners
 * 
 * @private
 */
ZmListController.prototype._initializeActionMenu =
function() {

	if (this._actionMenu) { return; }

	var menuItems = this._getActionMenuOps();
	if (!menuItems) { return; }

	var menuParams = {parent:this._shell,
		menuItems:	menuItems,
		context:	this._getMenuContext(),
		controller:	this
	};
	this._actionMenu = new ZmActionMenu(menuParams);
	this._addMenuListeners(this._actionMenu);
	if (appCtxt.get(ZmSetting.TAGGING_ENABLED)) {
		this._setupTagMenu(this._actionMenu);
	}
};

/**
 * Sets up tab groups (focus ring).
 *
 * @private
 */
ZmListController.prototype._initializeTabGroup =
function(view) {
	if (this._tabGroups[view]) { return; }

	ZmBaseController.prototype._initializeTabGroup.apply(this, arguments);

	var navToolBar = this._navToolBar[view];
	if (navToolBar) {
		this._tabGroups[view].addMember(navToolBar.getTabGroupMember());
	}
};

/**
 * Gets the tab group.
 * 
 * @return	{Object}	the tab group
 */
ZmListController.prototype.getTabGroup =
function() {
	return this._tabGroups[this._currentViewId];
};

/**
 * @private
 */
ZmListController.prototype._addMenuListeners =
function(menu) {

	var menuItems = menu.opList;
	for (var i = 0; i < menuItems.length; i++) {
		var menuItem = menuItems[i];
		if (this._listeners[menuItem]) {
			menu.addSelectionListener(menuItem, this._listeners[menuItem], 0);
		}
	}
	menu.addPopdownListener(this._menuPopdownListener);
};

ZmListController.prototype._menuPopdownActionListener =
function(ev) {

	var view = this.getListView();
	if (!this._pendingActionData) {
		if (view && view.handleActionPopdown) {
			view.handleActionPopdown(ev);
		}
	}
	// Reset back to item count unless there is multiple selection
	var selCount = view ? view.getSelectionCount() : -1;
	if (selCount <= 1) {
		this._setItemCountText();
	}
};



// List listeners

/**
 * List selection event - handle flagging if a flag icon was clicked, otherwise
 * reset the toolbar based on how many items are selected.
 * 
 * @private
 */
ZmListController.prototype._listSelectionListener =
function(ev) {

	if (ev.field == ZmItem.F_FLAG) {
		this._doFlag([ev.item]);
		return true;
	} 
	else {
		var lv = this._listView[this._currentViewId];
		if (lv) {
			if (appCtxt.get(ZmSetting.SHOW_SELECTION_CHECKBOX) && !ev.ctrlKey) {
				if (lv.setSelectionHdrCbox) {
					lv.setSelectionHdrCbox(false);
				}
			}
			this._resetOperations(this.getCurrentToolbar(), lv.getSelectionCount());
			if (ev.shiftKey) {
				this._setItemSelectionCountText();
			}
			else {
				this._setItemCountText();
			}
		}
	}
	return false;
};

/**
 * List action event - set the dynamic tag menu, and enable operations in the
 * action menu based on the number of selected items. Note that the menu is not
 * actually popped up here; that's left up to the subclass, which should
 * override this function.
 * 
 * @private
 */
ZmListController.prototype._listActionListener =
function(ev) {

	this._actionEv = ev;
	var actionMenu = this.getActionMenu();
	if (appCtxt.get(ZmSetting.TAGGING_ENABLED)) {
		this._setTagMenu(actionMenu);
	}

    if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
        this._setSearchMenu(actionMenu);
    }
	this._resetOperations(actionMenu, this.getSelectionCount());
	this._setItemSelectionCountText();
};


// Navbar listeners

/**
 * @private
 */
ZmListController.prototype._navBarListener =
function(ev) {

	// skip listener for non-current views
	if (!this.isCurrent()) { return; }

	var op = ev.item.getData(ZmOperation.KEY_ID);

	if (op == ZmOperation.PAGE_BACK || op == ZmOperation.PAGE_FORWARD) {
		this._paginate(this._currentViewId, (op == ZmOperation.PAGE_FORWARD));
	}
};

// Drag and drop listeners

/**
 * @private
 */
ZmListController.prototype._dragListener =
function(ev) {

	if (this.isSearchResults && ev.action == DwtDragEvent.DRAG_START) {
		this.searchResultsController.showOverview(true);
	}
	else if (ev.action == DwtDragEvent.SET_DATA) {
		ev.srcData = {data: ev.srcControl.getDnDSelection(), controller: this};
	}
	else if (this.isSearchResults && (ev.action == DwtDragEvent.DRAG_END || ev.action == DwtDragEvent.DRAG_CANCEL)) {
		this.searchResultsController.showOverview(false);
	}
};

/**
 * The list view as a whole is the drop target, since it's the lowest-level widget. Still, we
 * need to find out which item got dropped onto, so we get that from the original UI event
 * (a mouseup). The header is within the list view, but not an item, so it's not a valid drop
 * target. One drawback of having the list view be the drop target is that we can't exercise
 * fine-grained control on what's a valid drop target. If you enter via an item and then drag to
 * the header, it will appear to be valid.
 * 
 * @protected
 */
ZmListController.prototype._dropListener =
function(ev) {

	var view = this._view[this._currentViewId];
	var div = view.getTargetItemDiv(ev.uiEvent);
	var item = view.getItemFromElement(div);

	// only tags can be dropped on us
	var data = ev.srcData.data;
	if (ev.action == DwtDropEvent.DRAG_ENTER) {
		ev.doIt = (item && (item instanceof ZmItem) && !item.isReadOnly() && this._dropTgt.isValidTarget(data));
        // Bug: 44488 - Don't allow dropping tag of one account to other account's item
        if (appCtxt.multiAccounts) {
           var listAcctId = item ? item.getAccount().id : null;
           var tagAcctId = (data.account && data.account.id) || data[0].account.id;
           if (listAcctId != tagAcctId) {
               ev.doIt = false;
           }
        }
		DBG.println(AjxDebug.DBG3, "DRAG_ENTER: doIt = " + ev.doIt);
		if (ev.doIt) {
			view.dragSelect(div);
		}
	} else if (ev.action == DwtDropEvent.DRAG_DROP) {
		view.dragDeselect(div);
		var items = [item];
		var sel = this.getSelection();
		if (sel.length) {
			var vec = AjxVector.fromArray(sel);
			if (vec.contains(item)) {
				items = sel;
			}
		}
		this._doTag(items, data, true);
	} else if (ev.action == DwtDropEvent.DRAG_LEAVE) {
		view.dragDeselect(div);
	} else if (ev.action == DwtDropEvent.DRAG_OP_CHANGED) {
		// nothing
	}
};

/**
 * @private
 */

/**
 * returns true if the search folder is drafts
 */
ZmListController.prototype.isDraftsFolder =
function() {
	var folder = this._getSearchFolder();
	if (!folder) {
		return false;
	}
	return folder.nId ==  ZmFolder.ID_DRAFTS;
};

/**
 * returns true if the search folder is drafts
 */
ZmListController.prototype.isOutboxFolder =
function() {
    var folder = this._getSearchFolder();
    if (!folder) {
        return false;
    }
    return folder.nId == ZmFolder.ID_OUTBOX;
};

/**
 * returns true if the search folder is sync failures
 */
ZmListController.prototype.isSyncFailuresFolder =
function() {
	var folder = this._getSearchFolder();
	if (!folder) {
		return false;
	}
	return folder.nId ==  ZmFolder.ID_SYNC_FAILURES;
};


// Actions on items are performed through their containing list
ZmListController.prototype._getList =
function(items) {

	var list = ZmBaseController.prototype._getList.apply(this, arguments);
	if (!list) {
		list = this._list;
	}

	return list;
};

// if items were removed, see if we need to fetch more
ZmListController.prototype._getAllDoneCallback =
function() {
	return this._checkItemCount.bind(this);
};

/**
 * Manages the progress dialog that appears when an action is performed on a large number of items.
 * The arguments include a state and any arguments relative to that state. The state is one of:
 * 
 * 			ZmListController.PROGRESS_DIALOG_INIT
 *			ZmListController.PROGRESS_DIALOG_UPDATE
 *			ZmListController.PROGRESS_DIALOG_CLOSE
 *  
 * @param {hash}		params		a hash of params:
 * @param {constant}	state		state of the dialog
 * @param {AjxCallback}	callback	cancel callback (INIT)
 * @param {string}		summary		summary text (UPDATE)
 */
ZmListController.handleProgress =
function(params) {

	var dialog = appCtxt.getCancelMsgDialog();
	if (params.state == ZmListController.PROGRESS_DIALOG_INIT) {
		dialog.reset();
		dialog.registerCallback(DwtDialog.CANCEL_BUTTON, params.callback);
		ZmListController.progressDialogReady = true;
	}
	else if (params.state == ZmListController.PROGRESS_DIALOG_UPDATE && ZmListController.progressDialogReady) {
		dialog.setMessage(params.summary, DwtMessageDialog.INFO_STYLE, AjxMessageFormat.format(ZmMsg.inProgress));
		if (!dialog.isPoppedUp()) {
			dialog.popup();
		}
	}
	else if (params.state == ZmListController.PROGRESS_DIALOG_CLOSE) {
		dialog.unregisterCallback(DwtDialog.CANCEL_BUTTON);
		dialog.popdown();
		ZmListController.progressDialogReady = false;
	}
};


// Pagination

/**
 * @private
 */
ZmListController.prototype._cacheList =
function(search, offset) {

	if (this._list) {
		var newList = search.getResults().getVector();
		offset = offset ? offset : parseInt(search.getAttribute("offset"));
		this._list.cache(offset, newList);
	} else {
		this._list = search.getResults(type);
	}
};

/**
 * @private
 */
ZmListController.prototype._search =
function(view, offset, limit, callback, isCurrent, lastId, lastSortVal) {
	var originalSearch = this._activeSearch && this._activeSearch.search;
	var params = {
		query:			this.getSearchString(),
		queryHint:		this.getSearchStringHint(),
		types:			originalSearch && originalSearch.types || [], // use types from original search
		userInitiated:	originalSearch && originalSearch.userInitiated,
		sortBy:			appCtxt.get(ZmSetting.SORTING_PREF, view),
		offset:			offset,
		limit:			limit,
		lastId:			lastId,
		lastSortVal:	lastSortVal
	};
	// add any additional params...
	this._getMoreSearchParams(params);

	var search = new ZmSearch(params);
	if (isCurrent) {
		this._currentSearch = search;
	}

	appCtxt.getSearchController().redoSearch(search, true, null, callback);
};

/**
 * Gets next or previous page of items. The set of items may come from the
 * cached list, or from the server (using the current search as a base).
 * <p>
 * The loadIndex is the index'd item w/in the list that needs to be loaded -
 * initiated only when user is in CV and pages a conversation that has not
 * been loaded yet.</p>
 * <p>
 * Note that this method returns a value even though it may make an
 * asynchronous SOAP request. That's possible as long as no caller
 * depends on the results of that request. Currently, the only caller that
 * looks at the return value acts on it only if no request was made.</p>
 *
 * @param {constant}	view		the current view
 * @param {Boolean}	forward		if <code>true</code>, get next page rather than previous
 * @param {int}		loadIndex	the index of item to show
 * @param {int}	limit		the number of items to fetch
 * 
 * @private
 */
ZmListController.prototype._paginate =
function(view, forward, loadIndex, limit) {

	var needMore = false;
	var lv = this._view[view];
	if (!lv) { return; }
	var offset, max;

    limit = limit || lv.getLimit(offset);

	if (lv._isPageless) {
		offset = this._list.size();
		needMore = true;
	} else {
		offset = lv.getNewOffset(forward);
		needMore = (offset + limit > this._list.size());
		this.currentPage = this.currentPage + (forward ? 1 : -1);
		this.maxPage = Math.max(this.maxPage, this.currentPage);
	}

	// see if we're out of items and the server has more
	if (needMore && this._list.hasMore()) {
		lv.offset = offset; // cache new offset
		if (lv._isPageless) {
			max = limit;
		} else {
			// figure out how many items we need to fetch
			var delta = (offset + limit) - this._list.size();
			max = delta < limit && delta > 0 ? delta : limit;
			if (max < limit) {
				offset = ((offset + limit) - max) + 1;
			}
		}

		// handle race condition - user has paged quickly and we don't want
		// to do second fetch while one is pending
		if (this._searchPending) { return false;	}

		// figure out if this requires cursor-based paging
		var list = lv.getList();
		var lastItem = list && list.getLast();
		var lastSortVal = (lastItem && lastItem.id) ? lastItem.sf : null;
		var lastId = lastSortVal ? lastItem.id : null;

		this._setItemCountText(ZmMsg.loading);

		// get next page of items from server; note that callback may be overridden
		this._searchPending = true;
		var respCallback = this._handleResponsePaginate.bind(this, view, false, loadIndex, offset);
		this._search(view, offset, max, respCallback, true, lastId, lastSortVal);
		return false;
	} else if (!lv._isPageless) {
		lv.offset = offset; // cache new offset
		this._resetOperations(this._toolbar[view], 0);
		this._resetNavToolBarButtons(view);
		this._setViewContents(view);
		this._resetSelection();
		return true;
	}
};

/**
 * Updates the list and the view after a new page of items has been retrieved.
 *
 * @param {constant}	view				the current view
 * @param {Boolean}	saveSelection			if <code>true</code>, maintain current selection
 * @param {int}	loadIndex				the index of item to show
 * @param {ZmCsfeResult}	result			the result of SOAP request
 * @param {Boolean}	ignoreResetSelection	if <code>true</code>, do not reset selection
 * 
 * @private
 */
ZmListController.prototype._handleResponsePaginate =
function(view, saveSelection, loadIndex, offset, result, ignoreResetSelection) {

	var searchResult = result.getResponse();

	// update "more" flag
	this._list.setHasMore(searchResult.getAttribute("more"));

	this._cacheList(searchResult, offset);

	var lv = this._view[this._currentViewId];
	var num = lv._isPageless ? this.getSelectionCount() : 0;
	this._resetOperations(this._toolbar[view], num);

	// remember selected index if told to
	var selItem = saveSelection ? this.getSelection()[0] : null;
	var selectedIdx = selItem ? lv.getItemIndex(selItem) : -1;

	var items = searchResult && searchResult.getResults().getArray();
	if (lv._isPageless && items && items.length) {
		lv._itemsToAdd = items;
	} else {
		lv._itemsToAdd = null;
	}
	var wasEmpty = (lv._isPageless && (lv.size() == 0));

	this._setViewContents(view);

	// add new items to selection if all results selected, in a way that doesn't call deselectAll()
	if (lv.allSelected) {
		for (var i = 0, len = items.length; i < len; i++) {
			lv.selectItem(items[i], true);
			lv.setSelectionCbox(items[i], false);
		}
		lv.setSelectionHdrCbox(true);
		DBG.println("scr", "pagination - selected more items: " + items.length);
		DBG.println("scr", "items selected: " + this.getSelectionCount());
	}
	this._resetNavToolBarButtons(view);

	// bug fix #5134 - some views may not want to reset the current selection
	if (!ignoreResetSelection && !lv._isPageless) {
		this._resetSelection(selectedIdx);
	} else if (wasEmpty) {
		lv._setNextSelection();
	}

	this._searchPending = false;
};

/**
 * @private
 */
ZmListController.prototype._getMoreSearchParams =
function(params) {
	// overload me if more params are needed for SearchRequest
};

/**
 * @private
 */
ZmListController.prototype._checkReplenish =
function(callback) {

	var view = this.getListView();
	var list = view.getList();
	// don't bother if the view doesn't really have a list
	var replenishmentDone = false;
	if (list) {
		var replCount = view.getLimit() - view.size();
		if (replCount > view.getReplenishThreshold()) {
			this._replenishList(this._currentViewId, replCount, callback);
			replenishmentDone = true;
		}
	}
	if (callback && !replenishmentDone) {
		callback.run();
	}
};

/**
 * All items in the list view are gone - show "No Results".
 * 
 * @private
 */
ZmListController.prototype._handleEmptyList =
function(listView) {
	if (this.currentPage > 1) {
		this._paginate(this._currentViewId, false, 0);
	} else {
		listView.removeAll(true);
		listView._setNoResultsHtml();
		this._resetNavToolBarButtons();
		listView._checkItemCount();
	}
};

/**
 * @private
 */
ZmListController.prototype._replenishList =
function(view, replCount, callback) {

	// determine if there are any more items to replenish with
	var idxStart = this._view[view].offset + this._view[view].size();
	var totalCount = this._list.size();

	if (idxStart < totalCount) {
		// replenish from cache
		var idxEnd = (idxEnd > totalCount) ? totalCount : (idxStart + replCount);
		var list = this._list.getVector().getArray();
		var sublist = list.slice(idxStart, idxEnd);
		var subVector = AjxVector.fromArray(sublist);
		this._view[view].replenish(subVector);
		if (callback) {
			callback.run();
		}
	} else {
		// replenish from server request
		this._getMoreToReplenish(view, replCount, callback);
	}
};

/**
 * @private
 */
ZmListController.prototype._resetSelection =
function(idx) {
	var list = this.getListView().getList();
	if (list) {
		var selIdx = idx >= 0 ? idx : 0;
		var first = list.get(selIdx);
		this._view[this._currentViewId].setSelection(first, false);
	}
};

/**
 * Requests replCount items from the server to replenish current listview.
 *
 * @param {constant}	view		the current view to replenish
 * @param {int}	replCount 	the number of items to replenish
 * @param {AjxCallback}	callback	the async callback
 * 
 * @private
 */
ZmListController.prototype._getMoreToReplenish =
function(view, replCount, callback) {

	if (this._list.hasMore()) {
		// use a cursor if we can
		var list = this._view[view].getList();
		var lastItem = list.getLast();
		var lastSortVal = (lastItem && lastItem.id) ? lastItem.sf : null;
		var lastId = lastSortVal ? lastItem.id : null;
		var respCallback = this._handleResponseGetMoreToReplenish.bind(this, view, callback);
		this._search(view, this._list.size(), replCount, respCallback, false, lastId, lastSortVal);
	} else {
		if (callback) {
			callback.run();
		}
	}
};

/**
 * @private
 */
ZmListController.prototype._handleResponseGetMoreToReplenish =
function(view, callback, result) {

	var searchResult = result.getResponse();

	// set updated has more flag
	var more = searchResult.getAttribute("more");
	this._list.setHasMore(more);

	// cache search results into internal list
	this._cacheList(searchResult);

	// update view w/ replenished items
	var list = searchResult.getResults().getVector();
	this._view[view].replenish(list);

	// reset forward pagination button only
	this._toolbar[view].enable(ZmOperation.PAGE_FORWARD, more);

	if (callback) {
		callback.run(result);
	}
};

ZmListController.prototype._initializeNavToolBar =
function(view) {
	var tb = new ZmNavToolBar({parent:this._toolbar[view], context:view});
	this._setNavToolBar(tb, view);
};

ZmListController.prototype._setNavToolBar =
function(toolbar, view) {
	this._navToolBar[view] = toolbar;
	if (this._navToolBar[view]) {
		var navBarListener = this._navBarListener.bind(this);
		this._navToolBar[view].addSelectionListener(ZmOperation.PAGE_BACK, navBarListener);
		this._navToolBar[view].addSelectionListener(ZmOperation.PAGE_FORWARD, navBarListener);
	}
};

/**
 * @private
 */
ZmListController.prototype._resetNavToolBarButtons =
function(view) {

	var lv;
    if (view) {
        lv = this._view[view];
    } else {
        lv = this.getListView();
        view = this._currentViewId;
    }
	if (!lv) { return; }

	if (lv._isPageless) {
		this._setItemCountText();
	}

	if (!this._navToolBar[view]) { return; }

	this._navToolBar[view].enable(ZmOperation.PAGE_BACK, lv.offset > 0);

	// determine if we have more cached items to show (in case hasMore is wrong)
	var hasMore = false;
	if (this._list) {
		hasMore = this._list.hasMore();
		if (!hasMore && ((lv.offset + lv.getLimit()) < this._list.size())) {
			hasMore = true;
		}
	}

	this._navToolBar[view].enable(ZmOperation.PAGE_FORWARD, hasMore);

	this._navToolBar[view].setText(this._getNavText(view));
};

/**
 * @private
 */
ZmListController.prototype.enablePagination =
function(enabled, view) {

	if (!this._navToolBar[view]) { return; }

	if (enabled) {
		this._resetNavToolBarButtons(view);
	} else {
		this._navToolBar[view].enable([ZmOperation.PAGE_BACK, ZmOperation.PAGE_FORWARD], false);
	}
};

/**
 * @private
 */
ZmListController.prototype._getNavText =
function(view) {

	var se = this._getNavStartEnd(view);
	if (!se) { return ""; }

    var size  = se.size;
    var msg   = "";
    if (size === 0) {
        msg = AjxMessageFormat.format(ZmMsg.navTextNoItems, ZmMsg[ZmApp.NAME[ZmApp.TASKS]]);
    } else if (size === 1) {
        msg = AjxMessageFormat.format(ZmMsg.navTextOneItem, ZmMsg[ZmItem.MSG_KEY[ZmItem.TASK]]);
    } else {
        // Multiple items
        var lv    = this._view[view];
        var limit = se.limit;
        if (size < limit) {
            // We have the exact size of the filtered items
            msg = AjxMessageFormat.format(ZmMsg.navTextWithTotal, [se.start, se.end, size]);
        } else {
            // If it's more than the limit, we don't have an exact count
            // available from the server
            var sizeText = this._getUpperLimitSizeText(size);
            var msgText = sizeText ? ZmMsg.navTextWithTotal : ZmMsg.navTextRange;
            msg = AjxMessageFormat.format(msgText, [se.start, se.end, sizeText]);
        }
    }
    return msg;
};

/**
 * @private
 */
ZmListController.prototype._getNavStartEnd =
function(view) {

	var lv = this._view[view];
	var limit = lv.getLimit();
	var size = this._list ? this._list.size() : 0;

	var start, end;
	if (size > 0) {
		start = lv.offset + 1;
		end = Math.min(lv.offset + limit, size);
	}

	return (start && end) ? {start:start, end:end, size:size, limit:limit} : null;
};

/**
 * @private
 */
ZmListController.prototype._getNumTotal =
function() {

	var folderId = this._getSearchFolderId();
	if (folderId && (folderId != ZmFolder.ID_TRASH)) {
		var folder = appCtxt.getById(folderId);
		if (folder) {
			return folder.numTotal;
		}
	}
	return null;
};

/**
 * @private
 */
ZmListController.prototype.getActionMenu =
function() {
	if (!this._actionMenu) {
		this._initializeActionMenu();
		//DBG.timePt("_initializeActionMenu");
		this._resetOperations(this._actionMenu, 0);
		//DBG.timePt("this._resetOperation(actionMenu)");
	}
	return this._actionMenu;
};

/**
 * Returns the context for the action menu created by this controller (used to create
 * an ID for the menu).
 * 
 * @private
 */
ZmListController.prototype._getMenuContext =
function() {
	return this._app && this._app._name;
};

/**
 * @private
 */
ZmListController.prototype._getItemCountText =
function() {

	var size = this._getItemCount();
	// Size can be null or a number
	if (!size) { return ""; }

	var lv = this._view[this._currentViewId],
		list = lv && lv._list,
		type = lv._getItemCountType(),
		total = this._getNumTotal(),
		num = total || size,
		countKey = 'type' + AjxStringUtil.capitalizeFirstLetter(ZmItem.MSG_KEY[type]),
        typeText = type ? AjxMessageFormat.format(ZmMsg[countKey], num) : "";

	if (total && (size != total)) {
		return AjxMessageFormat.format(ZmMsg.itemCount1, [size, total, typeText]);
	} else {
		var sizeText = this._getUpperLimitSizeText(size);
		return AjxMessageFormat.format(ZmMsg.itemCount, [sizeText, typeText]);
	}
};

ZmListController.prototype._getUpperLimitSizeText =
function(size) {
    var sizeText = size;
    if (this._list.hasMore()) {
        //show 4+, 5+, 10+, 20+, 100+, 200+
        var granularity = size < 10 ? 1	: size < 100 ? 10 : 100;
        sizeText = (Math.floor(size / granularity)) * granularity + "+"; //round down to the chosen granularity
    }
    return sizeText;

}



ZmListController.prototype._getItemCount =
function() {
	var lv = this.getListView();
	var list = lv && lv._list;
	if (!list) {
        return 0;
    }
	return list.size();
};

/**
 * Sets the text that shows the number of items, if we are pageless.
 * 
 * @private
 */
ZmListController.prototype._setItemCountText =
function(text) {

	text = text || this._getItemCountText();
	var field = this._itemCountText[this._currentViewId];
	if (field) {
		field.setText(text);
	}
};

// Returns text that describes how many items are selected for action
ZmListController.prototype._getItemSelectionCountText = function() {

	var lv = this._view[this._currentViewId],
		list = lv && lv._list,
		type = lv._getItemCountType(),
		num = lv.getSelectionCount(),
		countKey = 'type' + AjxStringUtil.capitalizeFirstLetter(ZmItem.MSG_KEY[type]),
		typeText = type ? AjxMessageFormat.format(ZmMsg[countKey], num) : "";

	return num > 0 ? AjxMessageFormat.format(ZmMsg.itemSelectionCount, [num, typeText]) : '';
};

ZmListController.prototype._setItemSelectionCountText = function() {
	this._setItemCountText(this._getItemSelectionCountText());
};

/**
 * Records total items and last item before we do any more searches. Adds a couple
 * params to the args for the list action method.
 *
 * @param {function}	actionMethod		the controller action method
 * @param {Array}		args				an arg list for above (except for items arg)
 * @param {Hash}		params				the params that will be passed to list action method
 * @param {closure}		allDoneCallback		the callback to run after all items processed
 * 
 * @private
 */
ZmListController.prototype._setupContinuation =
function(actionMethod, args, params, allDoneCallback, notIdsOnly) {

	// need to use AjxCallback here so we can prepend items arg when calling it
	var actionCallback = new AjxCallback(this, actionMethod, args);
	params.finalCallback = this._continueAction.bind(this, {actionCallback:actionCallback, allDoneCallback:allDoneCallback, notIdsOnly: notIdsOnly});
	
	params.count = this._continuation.count;
	params.idsOnly = !notIdsOnly;

	if (!this._continuation.lastItem) {
		this._continuation.lastItem = params.list.getVector().getLast();
		this._continuation.totalItems = params.list.size();
	}
};

/**
 * See if we are performing an action on all items, including ones that match the current search
 * but have not yet been retrieved. If so, keep doing searches and performing the action on the
 * results, until there are no more results.
 *
 * The arguments in the action callback should be those after the initial 'items' argument. The
 * array of items retrieved by the search is prepended to the callback's argument list before it
 * is run.
 *
 * @param {Hash}		params				a hash of parameters
 * @param {AjxCallback}	actionCallback		the callback with action to be performed on search results
 * @param {closure} 	allDoneCallback		the callback to run when we're all done
 * @param {Hash}		actionParams		the params from <code>ZmList._itemAction</code>, added when this is called
 * 
 * @private
 */
ZmListController.prototype._continueAction =
function(params, actionParams) {

	var lv = this._view[this._currentViewId];
	var cancelled = actionParams && actionParams.cancelled;
	var contResult = this._continuation.result;
	var hasMore = contResult ? contResult.getAttribute("more") : (this._list ? this._list.hasMore() : false);
	DBG.println("sa", "lv.allSelected: " + lv.allSelected + ", hasMore: " + hasMore);
	if (lv.allSelected && hasMore && !cancelled) {
		var cs = this._currentSearch;
		var limit = ZmListController.CONTINUATION_SEARCH_ITEMS;
		var searchParams = {
			query:		this.getSearchString(),
			queryHint:	this.getSearchStringHint(),
			types:		cs.types,
			sortBy:		cs.sortBy,
			limit:		limit,
			idsOnly:	!params.notIdsOnly
		};

		var list = contResult ? contResult.getResults() : this._list.getArray();
		var lastItem = this._continuation.lastItem;
		if (!lastItem) {
			lastItem = list && list[list.length - 1];
		}
		if (lastItem) {
			searchParams.lastId = lastItem.id;
			searchParams.lastSortVal = lastItem.sf;
			DBG.println("sa", "***** continuation search: " + searchParams.query + " --- " + [lastItem.id, lastItem.sf].join("/"));
		} else {
			searchParams.offset = limit + (this._continuation.search ? this._continuation.search.offset : 0);
		}

		this._continuation.count = actionParams.numItems;
		if (!this._continuation.totalItems) {
			this._continuation.totalItems = list.length;
		}

		this._continuation.search = new ZmSearch(searchParams);
		var respCallback = this._handleResponseContinueAction.bind(this, params.actionCallback);
		appCtxt.getSearchController().redoSearch(this._continuation.search, true, null, respCallback);
	} else {
		DBG.println("sa", "end of continuation");
		if (contResult) {
			if (lv.allSelected) {
				// items beyond page were acted on, give user a total count
				if (actionParams.actionTextKey) {
					var type = contResult.type;
					if (type === ZmId.SEARCH_MAIL) {
						type = this._list.type; //get the specific CONV/MSG type instead of the "searchFor" "MAIL".
					}
					actionParams.actionSummary = ZmList.getActionSummary({
						actionTextKey:  actionParams.actionTextKey,
						numItems:       this._continuation.totalItems,
						type:           type,
						actionArg:      actionParams.actionArg
					});
				}
				lv.deselectAll();
			}
			this._continuation = {count:0, totalItems:0};
		}
		if (params.allDoneCallback) {
			params.allDoneCallback();
		}

		ZmListController.handleProgress({state:ZmListController.PROGRESS_DIALOG_CLOSE});
		ZmBaseController.showSummary(actionParams.actionSummary, actionParams.actionLogItem, actionParams.closeChildWin);
	}
};

/**
 * @private
 */
ZmListController.prototype._handleResponseContinueAction =
function(actionCallback, result) {

	this._continuation.result = result.getResponse();
	var items = this._continuation.result.getResults();
	DBG.println("sa", "continuation search results: " + items.length);
	if (items.isZmMailList) { //no idsOnly case
		items = items.getArray();
	}
	if (items.length) {
		this._continuation.lastItem = items[items.length - 1];
		this._continuation.totalItems += items.length;
		DBG.println("sa", "continuation last item: " + this._continuation.lastItem.id);
		actionCallback.args = actionCallback.args || [];
		actionCallback.args.unshift(items);
		DBG.println("sa", "calling continuation action on search results");
		actionCallback.run();
	} else {
		DBG.println(AjxDebug.DBG1, "Continuation with empty search results!");
	}
};

/**
 * @private
 */
ZmListController.prototype._checkItemCount =
function() {
	var lv = this._view[this._currentViewId];
	lv._checkItemCount();
	lv._handleResponseCheckReplenish(true);
};

// Returns true if this controller supports sorting its items
ZmListController.prototype.supportsSorting = function() {
    return true;
};

// Returns true if this controller supports alternatively grouped list views
ZmListController.prototype.supportsGrouping = function() {
    return false;
};
}
if (AjxPackage.define("zimbraMail.share.controller.ZmTreeController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines a tree controller.
 *
 */

/**
 * Creates a tree controller.
 * @class
 * This class is a base class for controllers for organizers. Those are
 * represented by trees, both as data and visually. This class uses the support provided by
 * {@link ZmOperation}. Each type of organizer has a singleton tree controller which manages all 
 * the tree views of that type.
 *
 * @author Conrad Damon
 * 
 * @param {constant}	type		the type of organizer we are displaying/controlling
 * 
 * @extends	ZmController
 */
ZmTreeController = function(type) {

	if (arguments.length == 0) { return; }

	ZmController.call(this, null);

	this.type = type;
	this._opc = appCtxt.getOverviewController();
	
	// common listeners
	this._listeners = {};
	this._listeners[ZmOperation.DELETE]			            = this._deleteListener.bind(this);
	this._listeners[ZmOperation.DELETE_WITHOUT_SHORTCUT]    = this._deleteListener.bind(this);
	this._listeners[ZmOperation.MOVE]			            = this._moveListener.bind(this);
	this._listeners[ZmOperation.EXPAND_ALL]		            = this._expandAllListener.bind(this);
	this._listeners[ZmOperation.MARK_ALL_READ]	            = this._markAllReadListener.bind(this);
	this._listeners[ZmOperation.SYNC]			            = this._syncListener.bind(this);
	this._listeners[ZmOperation.SYNC_ALL]		            = this._syncAllListener.bind(this);
	this._listeners[ZmOperation.EDIT_PROPS]		            = this._editPropsListener.bind(this);
	this._listeners[ZmOperation.EMPTY_FOLDER]               = this._emptyListener.bind(this);
	this._listeners[ZmOperation.FIND_SHARES]	            = this._findSharesListener.bind(this);
	this._listeners[ZmOperation.OPEN_IN_TAB]                = this._openInTabListener.bind(this);

	// drag-and-drop
	this._dragSrc = new DwtDragSource(Dwt.DND_DROP_MOVE);
	this._dragSrc.addDragListener(this._dragListener.bind(this));
	this._dropTgt = new DwtDropTarget(ZmTreeController.DROP_SOURCES[type]);
	this._dropTgt.addDropListener(this._dropListener.bind(this));

	this._treeView = {};	// hash of tree views of this type, by overview ID
	this._hideEmpty = {};	// which tree views to hide if they have no data
	this._dataTree = {};	// data tree per account

	this._treeSelectionShortcutDelay = ZmTreeController.TREE_SELECTION_SHORTCUT_DELAY;
};

ZmTreeController.prototype = new ZmController;
ZmTreeController.prototype.constructor = ZmTreeController;

ZmTreeController.COLOR_CLASS = {};
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_ORANGE]	= "OrangeBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_BLUE]	= "BlueBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_CYAN]	= "CyanBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_GREEN]	= "GreenBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_PURPLE]	= "PurpleBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_RED]		= "RedBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_YELLOW]	= "YellowBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_PINK]	= "PinkBg";
ZmTreeController.COLOR_CLASS[ZmOrganizer.C_GRAY]	= "Gray";	// not GrayBg so it doesn't blend in

// time that selection via up/down arrow must remain on an item to trigger a search
ZmTreeController.TREE_SELECTION_SHORTCUT_DELAY = 750;

// valid sources for drop target for different tree controllers
ZmTreeController.DROP_SOURCES = {};

// interval of retrying empty folder (seconds)
ZmTreeController.EMPTY_FOLDER_RETRY_INTERVAL = 5;

// the maximum number of trials of empty folder
ZmTreeController.EMPTY_FOLDER_MAX_TRIALS = 6;

// Abstract protected methods

// Enables/disables operations based on the given organizer ID
ZmTreeController.prototype.resetOperations = function() {};

// Returns a list of desired header action menu operations
ZmTreeController.prototype._getHeaderActionMenuOps = function() {};

// Returns a list of desired action menu operations
ZmTreeController.prototype._getActionMenuOps = function() {};

// Returns the dialog for organizer creation
ZmTreeController.prototype._getNewDialog = function() {};

// Returns the dialog for renaming an organizer
ZmTreeController.prototype._getRenameDialog = function() {};

// Method that is run when a tree item is left-clicked
ZmTreeController.prototype._itemClicked = function() {};

// Method that is run when a tree item is dbl-clicked
ZmTreeController.prototype._itemDblClicked = function() {};

// Handles a drop event
ZmTreeController.prototype._dropListener = function() {};

// Returns an appropriate title for the "Move To" dialog
ZmTreeController.prototype._getMoveDialogTitle = function() {};

/**
 * @private
 */
ZmTreeController.prototype._resetOperation =
function(parent, id, text, image, enabled, visible) {
	var op = parent && parent.getOp(id);
	if (!op) return;

	if (text) op.setText(text);
	if (image) op.setImage(image);
	if (enabled != null) op.setEnabled(enabled);
	if (visible != null) op.setVisible(visible);
};

/**
 * @private
 */
ZmTreeController.prototype._resetButtonPerSetting =
function(parent, op, isSupported) {
	var button = parent.getOp(op);
	if (button) {
		if (isSupported) {
			button.setVisible(true);
			if (appCtxt.isOffline && !appCtxt.getActiveAccount().isZimbraAccount) {
				button.setEnabled(false);
			}
		} else {
			button.setVisible(false);
		}
	}
};

ZmTreeController.prototype._enableRecoverDeleted =
function (parent, isTrash) {
	op = parent.getOp(ZmOperation.RECOVER_DELETED_ITEMS);
	if (!op) {
		return;
	}
	var featureEnabled = appCtxt.get(ZmSetting.DUMPSTER_ENABLED);
	op.setVisible(featureEnabled && isTrash);
	op.setEnabled(isTrash);
};

ZmTreeController.prototype._findSharesListener =
function(ev) {
	var folder = this._getActionedOrganizer(ev);
	var account = folder.getAccount();

	if (appCtxt.multiAccounts && account && account.isZimbraAccount) {
		appCtxt.accountList.setActiveAccount(account);
	}
	var dialog = appCtxt.getShareSearchDialog();
	var addCallback = this._handleAddShare.bind(this);
	dialog.popup(folder.type, addCallback);
};

ZmTreeController.prototype._handleAddShare = function () {
	var dialog = appCtxt.getShareSearchDialog();
	var shares = dialog.getShares();
	dialog.popdown();
	if (shares.length === 0) {
		return;
	}

	AjxDispatcher.require("Share");
	var requests = [];
	for (var i = 0; i < shares.length; i++) {
		var share = shares[i];
		requests.push({
			_jsns: "urn:zimbraMail",
			link: {
				l: ZmOrganizer.ID_ROOT,
				name: share.defaultMountpointName,
				view: share.view,
				zid: share.ownerId,
				rid: share.folderId
			}
		});
	}

	var params = {
		jsonObj: {
			BatchRequest: {
				_jsns: "urn:zimbra",
				CreateMountpointRequest: requests
			}
		},
		asyncMode: true
	};
	appCtxt.getAppController().sendRequest(params);
};

// Opens a view of the given organizer in a search tab
ZmTreeController.prototype._openInTabListener = function(ev) {
	this._itemClicked(this._getActionedOrganizer(ev), true);
};





// Public methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmTreeController.prototype.toString =
function() {
	return "ZmTreeController";
};

/**
 * Displays the tree of this type.
 *
 * @param {Hash}	params		a hash of parameters
 * @param	{constant}	params.overviewId		the overview ID
 * @param	{Boolean}	params.showUnread		if <code>true</code>, unread counts will be shown
 * @param	{Object}	params.omit				a hash of organizer IDs to ignore
 * @param	{Object}	params.include			a hash of organizer IDs to include
 * @param	{Boolean}	params.forceCreate		if <code>true</code>, tree view will be created
 * @param	{String}	params.app				the app that owns the overview
 * @param	{Boolean}	params.hideEmpty		if <code>true</code>, don't show header if there is no data
 * @param	{Boolean}	params.noTooltips	if <code>true</code>, don't show tooltips for tree items
 */
ZmTreeController.prototype.show =
function(params) {
	var id = params.overviewId;
	this._hideEmpty[id] = params.hideEmpty;

	if (!this._treeView[id] || params.forceCreate) {
		this._treeViewCreated = false;
		this._treeView[id] = null;
		this._treeView[id] = this.getTreeView(id, true);
	}

	// bug fix #24241 - for offline, zimlet tree is re-used across accounts
	var isMultiAccountZimlet = (appCtxt.multiAccounts && this.type == ZmOrganizer.ZIMLET);
	var account = isMultiAccountZimlet
		? appCtxt.accountList.mainAccount
		: (this.type == ZmOrganizer.VOICE ? id : params.account); // HACK for voice app
	var dataTree = this.getDataTree(account);

	if (dataTree) {
		params.dataTree = dataTree;
		var setting = ZmOrganizer.OPEN_SETTING[this.type];
		params.collapsed = (!isMultiAccountZimlet && (!(!setting || (appCtxt.get(setting, null, account) !== false)))); // yikes!

		var overview = this._opc.getOverview(id);

		if (overview && overview.showNewButtons && this.type != ZmOrganizer.ZIMLET && this.type != ZmId.ORG_PREF_PAGE ) { 
			this._setupOptButton(params);
		}

		this._treeView[id].set(params);
		this._checkTreeView(id);
	}

	if (!this._treeViewCreated) {
		this._treeViewCreated = true;
		this._postSetup(id, params.account);
	}
	return this._treeView[id];
};

/**
 * Gets the tree view for the given overview.
 *
 * @param {constant}	overviewId	the overview ID
 * @param {Boolean}	force			if <code>true</code>, force tree view creation
 * @return	{ZmTreeView}		the tree view
 */
ZmTreeController.prototype.getTreeView =
function(overviewId, force) {
	// TODO: What side-effects will this have in terms of the _postSetup???
	if (force && !this._treeView[overviewId]) {
		this._treeView[overviewId] = this._setup(overviewId);
	}
	return this._treeView[overviewId];
};

/**
 * Clears the tree view for the given overview.
 *
 * @param {constant}		overviewId		the overview ID
 *
 */
ZmTreeController.prototype.clearTreeView =
function(overviewId) {
	// TODO: remove change listener if last tree view cleared
	if (this._treeView[overviewId]) {
		this._treeView[overviewId].dispose();
		delete this._treeView[overviewId];
	}
};

/**
 * Gets the controller drop target.
 * 
 * @return	{DwtDropTarget}	the drop target
 */
ZmTreeController.prototype.getDropTarget =
function() {
	return this._dropTgt;
};

/**
 * Gets the data tree.
 * 
 * @param	{ZmZimbraAccount}	account		the account
 * @return	{Object}	the data tree
 */
ZmTreeController.prototype.getDataTree =
function(account) {
	account = account || appCtxt.getActiveAccount();
	var dataTree = this._dataTree[account.id];
	if (!dataTree) {
		dataTree = this._dataTree[account.id] = appCtxt.getTree(this.type, account);
		if (dataTree) {
			dataTree.addChangeListener(this._getTreeChangeListener());
		}
	}
	return dataTree;
};

/**
 * Dispose of this controller. Removes the tree change listener.
 * called when ZmComposeController is disposed (new window).
 * If the change listener stayed we would get exceptions since this window will no longer exist.
 *
 */
ZmTreeController.prototype.dispose =
function() {
	var account = appCtxt.getActiveAccount();
	var dataTree = this._dataTree[account.id];
	if (!dataTree) {
		return;
	}
	dataTree.removeChangeListener(this._getTreeChangeListener());
};



ZmTreeController.prototype.setVisibleIfExists =
function(parent, opId, visible) {
	var op = parent.getOp(opId);
	if (!op) {
		return;
	}
	op.setVisible(visible);
};

// Private and protected methods

/**
 * Sets up the params for the new button in the header item
 *
 * @param {Hash}	params		a hash of parameters
 * 
 * @private
 */
ZmTreeController.prototype._setupOptButton =
function(params) {
	var tooltipKey = ZmOperation.getProp(ZmOperation.OPTIONS, "tooltipKey");
	params.optButton = {
		image: ZmOperation.getProp(ZmOperation.OPTIONS, "image"),
		tooltip: tooltipKey ? ZmMsg[tooltipKey] : null,
		callback: new AjxCallback(this, this._dispOpts)
	};
};

/**
 * Shows options for header item
 *
 * @param {Hash}	params		a hash of parameters
 * 
 * @private
 */

ZmTreeController.prototype._dispOpts =
function(ev){

	var treeItem = ev.dwtObj;

       var type = treeItem && treeItem.getData(ZmTreeView.KEY_TYPE);
       if (!type) { return; }

       var actionMenu = this._getHeaderActionMenu(ev);
       if (actionMenu) {
		actionMenu.popup(0, ev.docX, ev.docY);
	}
};

ZmTreeController.prototype._getTreeChangeListener =
function() {
	if (!this._dataChangeListener) {
		this._dataChangeListener = appCtxt.isChildWindow ? AjxCallback.simpleClosure(this._treeChangeListener, this) : new AjxListener(this, this._treeChangeListener);
	}
	return this._dataChangeListener;
};

/**
 * Performs initialization.
 *
 * @param overviewId		[constant]	overview ID
 */
ZmTreeController.prototype._setup =
function(overviewId) {
	var treeView = this._initializeTreeView(overviewId);
	if (this._opc.getOverview(overviewId).actionSupported) {
		this._initializeActionMenus();
	}
	return treeView;
};

/**
 * Performs any little fixups after the tree view is first created
 * and shown.
 *
 * @param {constant}	overviewId		the overview ID
 * @param {ZmZimbraAccount}	account			the current account
 * 
 * @private
 */
ZmTreeController.prototype._postSetup =
function(overviewId, account) {

	var treeView = this.getTreeView(overviewId);
	if (!treeView.isCheckedStyle && !ZmOrganizer.HAS_COLOR[this.type]) { return; }

	var rootId = ZmOrganizer.getSystemId(ZmOrganizer.ID_ROOT, account);
	var rootTreeItem = treeView.getTreeItemById(rootId);
	if (!rootTreeItem) { return; }
	if (treeView.isCheckedStyle) {
		rootTreeItem.showCheckBox(false);
	}
	var treeItems = rootTreeItem.getItems();
	for (var i = 0; i < treeItems.length; i++) {
		this._fixupTreeNode(treeItems[i], null, treeView, true);
	}
};

/**
 * Takes care of the tree item's color and/or checkbox.
 *
 * @param {DwtTreeItem}	treeItem	the tree item
 * @param {ZmOrganizer}	organizer	the organizer it represents
 * @param {ZmTreeView}	treeView	the tree view this organizer belongs to
 * 
 * @private
 */
ZmTreeController.prototype._fixupTreeNode =
function(treeItem, organizer, treeView, skipNotify) {
	if (treeItem._isSeparator) { return; }
	organizer = organizer || treeItem.getData(Dwt.KEY_OBJECT);
	if (organizer) {
		if (ZmOrganizer.HAS_COLOR[this.type]) {
			this._setTreeItemColor(treeItem, organizer);
		}
		if (treeView.isCheckedStyle) {
			if ((organizer.type == this.type && treeView.isCheckedStyle) ||
                organizer.nId == ZmOrganizer.ID_TRASH || organizer.nId == ZmOrganizer.ID_DRAFTS) {
				treeItem.setChecked(organizer.isChecked, true);
			} else {
				treeItem.showCheckBox(false);
				treeItem.enableSelection(true);
			}
		}

		// set expand state per user's prefs
		this._expandTreeItem(treeItem, skipNotify);
	}
    var treeItems = treeItem.getItems();
    for (var i = 0; i < treeItems.length; i++) {
        this._fixupTreeNode(treeItems[i], null, treeView, skipNotify);
    }
};

ZmTreeController.prototype._expandTreeItem =
function(treeItem, skipNotify) {
    var expanded = appCtxt.get(ZmSetting.FOLDERS_EXPANDED);
	var folderId = treeItem.getData(Dwt.KEY_ID);
	var parentTi = treeItem.parent;

	// only expand if the parent is also expanded
	if (expanded[folderId] &&
		parentTi && (parentTi instanceof DwtTreeItem) && parentTi.getExpanded())
	{
		treeItem.setExpanded(true, null, skipNotify);
	}
};

ZmTreeController.prototype._expandTreeItems =
function(treeItem) {
	if (treeItem._isSeparator) { return; }

	this._expandTreeItem(treeItem);

	// recurse!
	var treeItems = treeItem.getItems();
	for (var i = 0; i < treeItems.length; i++) {
		this._expandTreeItems(treeItems[i]);
	}
};

/**
 * Sets the background color of the tree item.
 *
 * @param treeItem	[DwtTreeItem]		tree item
 * @param organizer	[ZmOrganizer]		organizer it represents
 */
ZmTreeController.prototype._setTreeItemColor =
function(treeItem, organizer) {
	treeItem.setImage(organizer.getIconWithColor());
};

ZmTreeController.prototype._getTreeItemColorClassName =
function(treeItem, organizer) {
	if (!treeItem || !organizer) { return null; }
	if (organizer.isInTrash()) { return null; }

	// a color value of 0 means DEFAULT
	var color = organizer.color
		? organizer.color
		: ZmOrganizer.DEFAULT_COLOR[organizer.type];

	return (color && (color != ZmOrganizer.C_NONE))
		? ZmTreeController.COLOR_CLASS[color] : "";
};

/**
 * Lazily creates a tree view of this type, using options from the overview.
 *
 * @param {constant}	overviewId		the overview ID
 * 
 * @private
 */
ZmTreeController.prototype._initializeTreeView =
function(overviewId) {
	var overview = this._opc.getOverview(overviewId);
	var params = {
		parent: overview,
		parentElement: overview.getTreeParent(this.type),
		overviewId: overviewId,
		type: this.type,
		headerClass: overview.headerClass,
		dragSrc: (overview.dndSupported ? this._dragSrc : null),
		dropTgt: (overview.dndSupported ? this._dropTgt : null),
		treeStyle: overview.treeStyle,
		isCheckedByDefault: overview.isCheckedByDefault,
		allowedTypes: this._getAllowedTypes(),
		allowedSubTypes: this._getAllowedSubTypes()
	};
	params.id = ZmId.getTreeId(overviewId, params.type);
	if (params.type && params.type.match(/TASK|ADDRBOOK|FOLDER|BRIEFCASE|CALENDAR|PREF_PAGE/) && 
			(!params.headerClass || params.headerClass == "overviewHeader")){
		params.headerClass = "FirstOverviewHeader overviewHeader";
	}
	var treeView = this._createTreeView(params);
	treeView.addSelectionListener(new AjxListener(this, this._treeViewListener));
	treeView.addTreeListener(new AjxListener(this, this._treeListener));

	return treeView;
};

/**
 * @private
 */
ZmTreeController.prototype._createTreeView =
function(params) {
	return new ZmTreeView(params);
};

/**
 * Creates up to two action menus, one for the tree view's header item, and
 * one for the rest of the items. Note that each of these two menus is a
 * singleton, shared among the tree views of this type.
 * 
 * @private
 */
ZmTreeController.prototype._initializeActionMenus =
function() {
	var obj = this;
	var func = this._createActionMenu;

	var ops = this._getHeaderActionMenuOps();
	if (!this._headerActionMenu && ops) {
		var args = [this._shell, ops];
		this._headerActionMenu = new AjxCallback(obj, func, args);
	}
	var ops = this._getActionMenuOps();
	if (!this._actionMenu && ops) {
		var args = [this._shell, ops];
		this._actionMenu = new AjxCallback(obj, func, args);
	}
};

/**
 * Instantiates the header action menu if necessary.
 * 
 * @private
 */
ZmTreeController.prototype._getHeaderActionMenu =
function(ev) {
	if (this._headerActionMenu instanceof AjxCallback) {
		var callback = this._headerActionMenu;
		this._headerActionMenu = callback.run();
	}
	return this._headerActionMenu;
};

/**
 * Instantiates the action menu if necessary.
 * 
 * @private
 */
ZmTreeController.prototype._getActionMenu =
function(ev, item) {
    var controller = this;

    // special case - search folder. might have moved under a regular folder  
    if (item && item.type == ZmOrganizer.SEARCH) {
        controller = this._opc.getTreeController(ZmOrganizer.SEARCH);
    }

	if (controller._actionMenu instanceof AjxCallback) {
		var callback = controller._actionMenu;
		controller._actionMenu = callback.run();
	}
	return controller._actionMenu;
};

/**
 * Creates and returns an action menu, and sets its listeners.
 *
 * @param {DwtControl}	parent		the menu parent widget
 * @param {Array}	menuItems		the list of menu items
 * 
 * @private
 */
ZmTreeController.prototype._createActionMenu =
function(parent, menuItems) {
	if (!menuItems) return;

	var map = appCtxt.getCurrentController() && appCtxt.getCurrentController().getKeyMapName();
	var id = map ? ("ZmActionMenu_" + map):Dwt.getNextId("ZmActionMenu_")
	id = (map && this.type) ? id + "_" + this.type : id;
	var actionMenu = new ZmActionMenu({parent:parent, menuItems:menuItems, id: id});

	menuItems = actionMenu.opList;
	for (var i = 0; i < menuItems.length; i++) {
		var menuItem = menuItems[i];
		if (this._listeners[menuItem]) {
			actionMenu.addSelectionListener(menuItem, this._listeners[menuItem]);
		}
	}
	actionMenu.addPopdownListener(new AjxListener(this, this._menuPopdownActionListener));

	return actionMenu;
};

/**
 * Determines which types of organizer may be displayed at the top level. By default,
 * the tree shows its own type.
 * 
 * @private
 */
ZmTreeController.prototype._getAllowedTypes =
function() {
	var types = {};
	types[this.type] = true;
	return types;
};

/**
 * Determines which types of organizer may be displayed below the top level. By default,
 * the tree shows its own type.
 * 
 * @private
 */
ZmTreeController.prototype._getAllowedSubTypes =
function() {
	var types = {};
	types[this.type] = true;
	return types;
};

// Actions

/**
 * Creates a new organizer and adds it to the tree of that type.
 *
 * @param {Hash}	params	a hash of parameters
 * @param {constant}	params.type		the type of organizer
 * @param {ZmOrganizer}	params.parent	parent of the new organizer
 * @param {String}	params.name		the name of the new organizer
 *        
 * @private
 */
ZmTreeController.prototype._doCreate =
function(params) {
	params.type = this.type;
	var funcName = ZmOrganizer.CREATE_FUNC[this.type];
	if (funcName) {
		var func = eval(funcName);
		return func(params);
	}
};

/**
 * Deletes an organizer and removes it from the tree.
 *
 * @param {ZmOrganizer}	organizer		the organizer to delete
 */
ZmTreeController.prototype._doDelete =
function(organizer) {
	organizer._delete();
};

/**
 * 
 * @param {ZmOrganizer}	organizer		the organizer
 * @param {int}	trialCounter		the number of trials of empty folder
 * @param {AjxException}	ex		the exception
 *
 * @private
 */
ZmTreeController.prototype._doEmpty =
function(organizer, trialCounter, ex) {
	var recursive = false;
	var timeout = ZmTreeController.EMPTY_FOLDER_RETRY_INTERVAL;
	var noBusyOverlay = true;
	if (!trialCounter) {
		trialCounter = 1;
	}
	var errorCallback = this._doEmptyErrorHandler.bind(this, organizer, trialCounter);
	organizer.empty(recursive, null, this._doEmptyHandler.bind(this, organizer), timeout, errorCallback, noBusyOverlay);
};

/**
 *
 * @param {ZmOrganizer}	organizer		the organizer
 * @param {int}	trialCounter		the number of trials of empty folder
 * @param {AjxException}	ex		the exception
 *
 * @private
 */
ZmTreeController.prototype._doEmptyErrorHandler =
function(organizer, trialCounter, ex) {
	if (ex) {
		if (ex.code == ZmCsfeException.SVC_ALREADY_IN_PROGRESS) {
			appCtxt.setStatusMsg(ZmMsg.emptyFolderAlreadyInProgress);
			return true;
		} else if(ex.code != AjxException.CANCELED) {
			return false;
		}
	}

	if (trialCounter > ZmTreeController.EMPTY_FOLDER_MAX_TRIALS -1){
		appCtxt.setStatusMsg(ZmMsg.emptyFolderNoResponse, ZmStatusView.LEVEL_CRITICAL);
		return true;
	}
	trialCounter++;
	this._doEmpty(organizer, trialCounter);
};

ZmTreeController.prototype._doEmptyHandler =
function(organizer) {
	appCtxt.setStatusMsg({msg: AjxMessageFormat.format(ZmMsg.folderEmptied, organizer.getName())});
	var ctlr = appCtxt.getCurrentController();
	if (!ctlr || !ctlr._getSearchFolderId || !ctlr.getListView) {
		return;
	}
	var folderId = ctlr._getSearchFolderId();
	if (folderId !== organizer.id) {
		return;
	}
	var view = ctlr.getListView();
	view._resetList();
	view._setNoResultsHtml();
};

/**
 * Renames an organizer.
 *
 * @param {ZmOrganizer}	organizer	the organizer to rename
 * @param {String}	name		the new name of the organizer
 * 
 * @private
 */
ZmTreeController.prototype._doRename =
function(organizer, name) {
	organizer.rename(name);
};

/**
 * Moves an organizer to a new folder.
 *
 * @param {ZmOrganizer}	organizer	the organizer to move
 * @param {ZmFolder}	folder		the target folder
 * 
 * @private
 */
ZmTreeController.prototype._doMove =
function(organizer, folder) {
	organizer.move(folder);
};

/**
 * Marks an organizer's items as read.
 *
 * @param {ZmOrganizer}	organizer	the organizer
 * 
 * @private
 */
ZmTreeController.prototype._doMarkAllRead =
function(organizer) {
	organizer.markAllRead();
};

/**
 * Syncs an organizer to its feed (URL).
 *
 *  @param {ZmOrganizer}	organizer	the organizer
 *  
 *  @private
 */
ZmTreeController.prototype._doSync =
function(organizer) {
	organizer.sync();
};

// Listeners

/**
 * Handles left and right mouse clicks. A left click generates a selection event.
 * If selection is supported for the overview, some action (typically a search)
 * will be performed. A right click generates an action event, which pops up an
 * action menu if supported.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._treeViewListener = function(ev) {

	if (ev.detail !== DwtTree.ITEM_ACTIONED && ev.detail !== DwtTree.ITEM_SELECTED && ev.detail !== DwtTree.ITEM_DBL_CLICKED) {
		return;
	}

	var treeItem = ev.item;

	var type = treeItem.getData(ZmTreeView.KEY_TYPE);
	if (!type) {
        return;
    }

	var item = treeItem.getData(Dwt.KEY_OBJECT);
	if (item) {
		this._actionedOrganizer = item;
		if (item.noSuchFolder) {
			var folderTree = appCtxt.getFolderTree();
			if (folderTree) {
				folderTree.handleDeleteNoSuchFolder(item);
			}
			return;
		}
        if (item && item.type === ZmOrganizer.SEARCH) {
            var controller = this._opc.getTreeController(ZmOrganizer.SEARCH);
            if (controller) {
                controller._actionedOrganizer = item;
                controller._actionedOverviewId = treeItem.getData(ZmTreeView.KEY_ID);
            }
        }
	}

	var id = treeItem.getData(Dwt.KEY_ID);
	var overviewId = this._actionedOverviewId = treeItem.getData(ZmTreeView.KEY_ID);
	var overview = this._opc.getOverview(overviewId);
	if (!overview) {
        return;
    }

	if (ev.detail === DwtTree.ITEM_ACTIONED) {
		// right click
		if (overview.actionSupported) {
			var actionMenu = this.getItemActionMenu(ev, item);
			if (actionMenu) {
				this.resetOperations(actionMenu, type, id);
				actionMenu.popup(0, ev.docX, ev.docY);
			}
		}
	}
    else if ((ev.detail === DwtTree.ITEM_SELECTED) && item) {
		if (appCtxt.multiAccounts && (item instanceof ZmOrganizer)) {
			this._handleMultiAccountItemSelection(ev, overview, treeItem, item);
		}
        else {
			this._handleItemSelection(ev, overview, treeItem, item);
		}
	}
    else if ((ev.detail === DwtTree.ITEM_DBL_CLICKED) && item) {
		this._itemDblClicked(item);
	}
};

ZmTreeController.prototype.getItemActionMenu = function(ev, item) {
	var actionMenu = (item.nId == ZmOrganizer.ID_ROOT || item.isDataSource(ZmAccount.TYPE_IMAP))
		? this._getHeaderActionMenu(ev)
		: this._getActionMenu(ev, item);
	return actionMenu;
}

/**
 * @private
 */
ZmTreeController.prototype._handleItemSelection =
function(ev, overview, treeItem, item) {
	// left click or selection via shortcut
	overview.itemSelected(treeItem);

	if (ev.kbNavEvent) {
		Dwt.scrollIntoView(treeItem._itemDiv, overview.getHtmlElement());
		ZmController.noFocus = true;
	}

	if (overview._treeSelectionShortcutDelayActionId) {
		AjxTimedAction.cancelAction(overview._treeSelectionShortcutDelayActionId);
	}

	if ((overview.selectionSupported || item._showFoldersCallback) && !treeItem._isHeader) {
		if (ev.kbNavEvent) {
			// for shortcuts, process selection via Enter immediately; selection via up/down keys
			// is delayed (or can be disabled by setting the delay to 0)
			if (ev.enter || this._treeSelectionShortcutDelay) {
				var action = new AjxTimedAction(this, ZmTreeController.prototype._treeSelectionTimedAction, [item, overview]);
				overview._treeSelectionShortcutDelayActionId = AjxTimedAction.scheduleAction(action, this._treeSelectionShortcutDelay);
			}
		} else {
			if ((appCtxt.multiAccounts && (item instanceof ZmOrganizer)) ||
				(item.type == ZmOrganizer.VOICE))
			{
				appCtxt.getCurrentApp().getOverviewContainer().deselectAll(overview);

				// set the active account based on the item clicked
				var account = item.account || appCtxt.accountList.mainAccount;
				appCtxt.accountList.setActiveAccount(account);
			}

			this._itemSelected(item);
		}
	}
};

/**
 * @private
 */
ZmTreeController.prototype._itemSelected =
function(item) {
	if (item && item._showFoldersCallback) {
		item._showFoldersCallback.run();
	} else {
		this._itemClicked(item);
	}

};

/**
 * Allows subclass to overload in case something needs to be done before
 * processing tree item selection in a multi-account environment. Otherwise,
 * do the normal tree item selection.
 * 
 * @private
 */
ZmTreeController.prototype._handleMultiAccountItemSelection =
function(ev, overview, treeItem, item) {
	this._handleItemSelection(ev, overview, treeItem, item);
};

/**
 * @private
 */
ZmTreeController.prototype._treeSelectionTimedAction =
function(item, overview) {
	if (overview._treeSelectionShortcutDelayActionId) {
		AjxTimedAction.cancelAction(overview._treeSelectionShortcutDelayActionId);
	}
	this._itemSelected(item);
};

/**
 * Propagates a change in tree state to other trees of the same type in app overviews.
 * 
 * @param {ZmTreeEvent}	ev		a tree event
 * 
 * @private
 */
ZmTreeController.prototype._treeListener =
function(ev) {
	var treeItem = ev && ev.item;
	var overviewId = treeItem && treeItem._tree && treeItem._tree.overviewId;
    var overview = appCtxt.getOverviewController().getOverview(overviewId);
    var acct = overview.account;
    if (appCtxt.multiAccounts && acct) {
        appCtxt.accountList.setActiveAccount(acct);
    }

	// persist expand/collapse state for folders
	var isExpand = ev.detail == DwtTree.ITEM_EXPANDED;
	var folderId = (ev.detail == DwtTree.ITEM_COLLAPSED || isExpand)
		? treeItem.getData(Dwt.KEY_ID) : null;

	if (folderId && !treeItem._isHeader) {
		var setExpanded = appCtxt.get(ZmSetting.FOLDERS_EXPANDED, folderId) || false; //I think it's set as undefined if "false" in ZmSetting.prototype.setValue)
		if (typeof(setExpanded) == "string") {//I can't figure out why it becomes a string sometimes. That's nasty.
			setExpanded = (setExpanded === "true");
		}
		//setting in case of skipImplicit is still causing problems (the fix to bug 72590 was not good enough), since even if this "set" is not persisting,
		//future ones (collapse/expand in the mail tab) would cause it to save implicitly, which is not what we want.
		//so I simply do not call "set" in case of skipImplicit. Might want to change the name of this variable slightly, but not sure to what.
		if (!overview.skipImplicit && setExpanded !== isExpand) { //set only if changed (ZmSetting.prototype.setValue is supposed to not send a request if no change, but it might have bugs)
			appCtxt.set(ZmSetting.FOLDERS_EXPANDED, isExpand, folderId);
		}

		// check if any of this treeItem's children need to be expanded as well
		if (isExpand) {
			this._expandTreeItems(treeItem);
		}
	}

	// only handle events that come from headers in app overviews
	if (!(ev && ev.detail && overview && overview.isAppOverview && treeItem._isHeader)) { return; }

	var settings = appCtxt.getSettings(acct);
	var setting = settings.getSetting(ZmOrganizer.OPEN_SETTING[this.type]);
	if (setting) {
		setting.setValue(ev.detail == DwtTree.ITEM_EXPANDED);
	}
};

/**
 * Handles changes to the underlying model. The change is propagated to
 * all the tree views known to this controller.
 *
 * @param {ZmEvent}	ev		a change event
 * 
 * @private
 */
ZmTreeController.prototype._treeChangeListener =
function(ev) {
	this._evHandled = {};
	for (var overviewId in this._treeView) {
		this._changeListener(ev, this._treeView[overviewId], overviewId);
	}
};

/**
 * Handles a change event for one tree view.
 *
 * @param {ZmEvent}	ev				a change event
 * @param {ZmTreeView}	treeView		a tree view
 * @param {constant}	overviewId		overview ID
 * 
 * @private
 */
ZmTreeController.prototype._changeListener =
function(ev, treeView, overviewId) {
	if (this._evHandled[overviewId]) { return; }
	if (!treeView.allowedTypes[ev.type] && !treeView.allowedSubTypes[ev.type]) { return; }

	var organizers = ev.getDetail("organizers");
	if (!organizers && ev.source) {
		organizers = [ev.source];
	}

	// handle one organizer at a time
	for (var i = 0; i < organizers.length; i++) {
		var organizer = organizers[i];

		var node = treeView.getTreeItemById(organizer.id);
		// Note: source tree handles moves - it will have node
		if (!node && (ev.event != ZmEvent.E_CREATE)) { continue; }

		var fields = ev.getDetail("fields");
		if (ev.event == ZmEvent.E_DELETE) {
			if (organizer.nId == ZmFolder.ID_TRASH || organizer.nId == ZmFolder.ID_SPAM) {
				node.setText(organizer.getName(false));	// empty Trash or Junk
			} else {
				node.dispose();
			}
            this._checkTreeView(overviewId);
			this._evHandled[overviewId] = true;
		} else if (ev.event == ZmEvent.E_CREATE || ev.event == ZmEvent.E_MOVE) {
			// for multi-account, make sure this organizer applies to the given overview
			if (appCtxt.multiAccounts) {
				var overview = this._opc.getOverview(overviewId);
				if (overview && overview.account != organizer.getAccount()) {
					continue;
				}
			}
			var parentNode = this._getParentNode(organizer, ev, overviewId);
			var idx = parentNode ? ZmTreeView.getSortIndex(parentNode, organizer, eval(ZmTreeView.COMPARE_FUNC[organizer.type])) : null;
			if (parentNode && (ev.event == ZmEvent.E_CREATE)) {
				// parent's tree controller should handle creates - root is shared by all folder types
				var type = ((organizer.parent.nId == ZmOrganizer.ID_ROOT) || organizer.parent.isRemoteRoot()) ? ev.type : organizer.parent.type;
				if (type !== this.type || !treeView._isAllowed(organizer.parent, organizer)) {
					continue;
				}
				if (organizer.isOfflineGlobalSearch) {
					appCtxt.getApp(ZmApp.MAIL).getOverviewContainer().addSearchFolder(organizer);
					return;
				} else {
					node = this._addNew(treeView, parentNode, organizer, idx); // add to new parent
				}
                this.createDataSource(organizer);
			} else if (ev.event == ZmEvent.E_MOVE) {
				var selectedItem = treeView.getSelected();
				if (AjxUtil.isArray1(selectedItem)) { //make sure this tree is not a checked style one (no idea where we have that, but see the getSelected code
					selectedItem = null;
				}
				node.dispose();
				if (parentNode) {
					node = this._addNew(treeView, parentNode, organizer, idx); // add to new parent
				}
				//highlight the current chosen one again, in case it was moved, thus losing selection
				if (!treeView.getSelected() && selectedItem) { //if item was selected but now it is not
					treeView.setSelected(selectedItem.id, true, true);
				}
			}
			if (parentNode) {
				parentNode.setExpanded(true); // so that new node is visible

				this._fixupTreeNode(node, organizer, treeView);
			}
			this._checkTreeView(overviewId);
			this._evHandled[overviewId] = true;
		} else if (ev.event == ZmEvent.E_MODIFY) {
			if (!fields) { return; }
			if (fields[ZmOrganizer.F_TOTAL] || fields[ZmOrganizer.F_SIZE] || fields[ZmOrganizer.F_UNREAD] || fields[ZmOrganizer.F_NAME]) {
				node.setToolTipContent(organizer.getToolTip(true));
				if (appCtxt.multiAccounts && organizer.type == ZmOrganizer.FOLDER) {
					appCtxt.getApp(ZmApp.MAIL).getOverviewContainer().updateTooltip(organizer.nId);
				}
			}

			if (fields[ZmOrganizer.F_NAME] ||
				fields[ZmOrganizer.F_UNREAD] ||
				fields[ZmOrganizer.F_FLAGS] ||
				fields[ZmOrganizer.F_COLOR] ||
				((organizer.nId == ZmFolder.ID_DRAFTS || organizer.rid == ZmFolder.ID_DRAFTS ||
				  organizer.nId == ZmOrganizer.ID_OUTBOX) && fields[ZmOrganizer.F_TOTAL]))
			{
				this._updateOverview({
					organizer:  organizer,
					node:       node,
					fields:     fields,
					treeView:   treeView,
					overviewId: overviewId,
					ev:         ev
				});

				this._evHandled[overviewId] = true;
			}
		}
	}
};

/**
 * Handle an organizer change by updating the tree view. For example, a name change requires sorting.
 *
 * @param   params      hash            hash of params:
 *
 *          organizer   ZmOrganizer     organizer that changed
 *          node        DwtTreeItem     organizer node in tree view
 *          fields      hash            changed fields
 *          treeView    ZmTreeView      tree view for this organizer type
 *          overviewId  string          ID of containing overview
 *          ev          ZmEvent         change event
 *
 * @private
 */
ZmTreeController.prototype._updateOverview = function(params) {

	var org = params.organizer,
		node = params.node,
		parentNode = this._getParentNode(org, params.ev, params.overviewId);

	node.setText(org.getName(params.treeView._showUnread));

	// If the name changed, re-sort the containing list
	if (params.fields && params.fields[ZmOrganizer.F_NAME]) {
		if (parentNode && (parentNode.getNumChildren() > 1)) {
			var nodeSelected = node._selected;
			// remove and re-insert the node (if parent has more than one child)
			node.dispose();
			var idx = ZmTreeView.getSortIndex(parentNode, org, eval(ZmTreeView.COMPARE_FUNC[org.type]));
			node = params.treeView._addNew(parentNode, org, idx);
			if (nodeSelected) {
				//if it was selected, re-select it so it is highlighted. No need for notifications.
				params.treeView.setSelected(org, true);
			}
		} else {
			node.setDndText(org.getName());
		}
		appCtxt.getAppViewMgr().updateTitle();
	}

	// A folder aggregates unread status of its descendents, so propagate up parent chain
	if (params.fields[ZmOrganizer.F_UNREAD]) {
		var parent = org.parent;
		while (parent && parentNode && parent.nId != ZmOrganizer.ID_ROOT) {
			parentNode.setText(parent.getName(params.treeView._showUnread));
			parentNode = this._getParentNode(parent, params.ev, params.overviewId);
			parent = parent.parent;
		}
	}

	// Miscellaneous cleanup (color, selection)
	this._fixupTreeNode(node, org, params.treeView);
};

ZmTreeController.prototype._getParentNode = function(organizer, ev, overviewId) {

	if (organizer.parent) {
		// if node being moved to root, we assume new parent must be the container of its type
		var type = (organizer.parent.nId == ZmOrganizer.ID_ROOT) ? ev.type : null;
		return this._opc.getOverview(overviewId).getTreeItemById(organizer.parent.id, type);
	}
};

/**
 * Makes a request to add a new item to the tree, returning true if the item was
 * actually added, or false if it was omitted.
 *
 * @param {ZmTreeView}	treeView		the tree view
 * @param {DwtTreeItem}	parentNode	the node under which to add the new one
 * @param {ZmOrganizer}	organizer		the organizer for the new node
 * @param {int}	idx			the position at which to add the new node
 * 
 * @private
 */
ZmTreeController.prototype._addNew =
function(treeView, parentNode, organizer, idx) {
	return treeView._addNew(parentNode, organizer, idx);
};

/**
 * Pops up the appropriate "New ..." dialog.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * @param {ZmZimbraAccount}	account	used by multi-account mailbox (optional)
 * 
 * @private
 */
ZmTreeController.prototype._newListener =
function(ev, account) {
	this._pendingActionData = this._getActionedOrganizer(ev);
	var newDialog = this._getNewDialog();
	if (!this._newCb) {
		this._newCb = new AjxCallback(this, this._newCallback);
	}
	if (this._pendingActionData && !appCtxt.getById(this._pendingActionData.id)) {
		this._pendingActionData = appCtxt.getFolderTree(account).root;
	}

	if (!account && appCtxt.multiAccounts) {
		var ov = this._opc.getOverview(this._actionedOverviewId);
		account = ov && ov.account;
	}

	ZmController.showDialog(newDialog, this._newCb, this._pendingActionData, account);
	newDialog.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, newDialog);
};

ZmTreeController.prototype.createDataSource =
function(organizer) {
    //override
};

/**
 * Pops up the appropriate "Rename ..." dialog.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._renameListener =
function(ev) {
	this._pendingActionData = this._getActionedOrganizer(ev);
	var renameDialog = this._getRenameDialog();
	if (!this._renameCb) {
		this._renameCb = new AjxCallback(this, this._renameCallback);
	}
	ZmController.showDialog(renameDialog, this._renameCb, this._pendingActionData);
	renameDialog.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, renameDialog);
};

/**
 * Deletes an organizer.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._deleteListener =
function(ev) {
	this._doDelete(this._getActionedOrganizer(ev));
};

/**
 * @private
 */
ZmTreeController.prototype._emptyListener =
function(ev) {
	this._doEmpty(this._getActionedOrganizer(ev));
};

/**
 * Moves an organizer into another folder.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._moveListener =
function(ev) {
	this._pendingActionData = this._getActionedOrganizer(ev);
	var moveToDialog = appCtxt.getChooseFolderDialog();
	if (!this._moveCb) {
		this._moveCb = new AjxCallback(this, this._moveCallback);
	}
	ZmController.showDialog(moveToDialog, this._moveCb, this._getMoveParams(moveToDialog));
	moveToDialog.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, moveToDialog);
};

/**
 * @private
 */
ZmTreeController.prototype._getMoveParams =
function(dlg) {
	var omit = {};
	omit[ZmFolder.ID_SPAM] = true;
	return {
		data:			this._pendingActionData,
		treeIds:		[this.type],
		overviewId:		dlg.getOverviewId(appCtxt.getCurrentAppName() + '_' + this.type),
		omit:			omit,
		title:			AjxStringUtil.htmlEncode(this._getMoveDialogTitle()),
		description:	ZmMsg.targetFolder,
		appName:		ZmOrganizer.APP[this.type]
	};
};

/**
 * Expands the tree below the action'd node.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._expandAllListener =
function(ev) {
	var organizer = this._getActionedOrganizer(ev);
	var treeView = this.getTreeView(this._actionedOverviewId);
	var ti = treeView.getTreeItemById(organizer.id);
	window.duringExpandAll = true;
	ti.setExpanded(true, true);
	window.duringExpandAll = false;
	if (window.afterExpandAllCallback) {
		window.afterExpandAllCallback(); //save the explicit setting now after all was expanded - so only one request instead of many
		window.afterExpandAllCallback  = null;
	}
};

/**
 * Mark's an organizer's contents as read.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._markAllReadListener =
function(ev) {
	this._doMarkAllRead(this._getActionedOrganizer(ev));
};

/**
 * Syncs all the organizers to its feed (URL).
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._syncAllListener =
function(ev) {
	// Loop over all the TreeViews
	for (var overviewId in this._treeView) {
		var treeView = this.getTreeView(overviewId);
		var rootId = ZmOrganizer.getSystemId(ZmOrganizer.ID_ROOT, appCtxt.getActiveAccount());
		var rootTreeItem = treeView.getTreeItemById(rootId);
		var treeItems = rootTreeItem && rootTreeItem.getItems();
		if (treeItems) {
			for (var i = 0; i < treeItems.length; i++) {
				var ti = treeItems[i];
				var folder = ti && ti.getData && ti.getData(Dwt.KEY_OBJECT);
				if (folder && (folder.isFeed() || folder.hasFeeds())) {
					this._syncFeeds(folder);
				}
			}
		}
	}
};

/**
 * Syncs an organizer to its feed (URL).
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._syncListener =
function(ev) {
	this._syncFeeds(this._getActionedOrganizer(ev));
};

/**
 * @private
 */
ZmTreeController.prototype._syncFeeds =
function(f) {
	if (f.isFeed()) {
		this._doSync(f);
	} else if (f.hasFeeds()) {
		var a = f.children.getArray();
		var sz = f.children.size();
		for (var i = 0; i < sz; i++) {
			if (a[i].isFeed() || (a[i].hasFeeds && a[i].hasFeeds())) {
				this._syncFeeds(a[i]);
			}
		}
	}
};

/**
 * Brings up a dialog for editing organizer properties.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._editPropsListener = 
function(ev) {
	var folderPropsDialog = appCtxt.getFolderPropsDialog();
	folderPropsDialog.popup(this._getActionedOrganizer(ev));
};

/**
 * Handles a drag event by setting the source data.
 *
 * @param {DwtDragEvent}	ev		a drag event
 * 
 * @private
 */
ZmTreeController.prototype._dragListener =
function(ev) {
	switch (ev.action) {
		case DwtDragEvent.SET_DATA:
			ev.srcData = {data:ev.srcControl.getData(Dwt.KEY_OBJECT), controller:this};
			break;
	}
};

/**
 * Called when a dialog we opened is closed. Sets the style of the actioned
 * tree item from "actioned" back to its normal state.
 * 
 * @private
 */
ZmTreeController.prototype._menuPopdownActionListener = 
function() {
	if (this._pendingActionData) { return; }

	var treeView = this.getTreeView(this._actionedOverviewId);
	if (this._actionedOrganizer && (treeView.getSelected() != this._actionedOrganizer)) {
		var ti = treeView.getTreeItemById(this._actionedOrganizer.id);
		if (ti) {
			ti._setActioned(false);
		}
	}
};

// Callbacks

/**
 * Called when a "New ..." dialog is submitted to create the organizer.
 *
 * @param {Hash}	params	a hash of parameters
 * @param {ZmOrganizer}	params.organizer	the parent organizer
 * @param {String}  params.name	the name of the new organizer
 * 
 * @private
 */
ZmTreeController.prototype._newCallback =
function(params) {
	this._doCreate(params);
	this._clearDialog(this._getNewDialog());
};

/**
 * Called when a "Rename ..." dialog is submitted to rename the organizer.
 *
 * @param {ZmOrganizer}	organizer		the organizer
 * @param {String}	name		the new name of the organizer
 * 
 * @private
 */
ZmTreeController.prototype._renameCallback =
function(organizer, name) {
	this._doRename(organizer, name);
	this._clearDialog(this._getRenameDialog());
};

/**
 * Called when a "Move To ..." dialog is submitted to move the organizer.
 *
 * @param {ZmFolder}	folder		the target folder
 * 
 * @private
 */
ZmTreeController.prototype._moveCallback =
function(folder) {
	this._doMove(this._pendingActionData, folder);
	this._clearDialog(appCtxt.getChooseFolderDialog());
};

/**
 * Called if a user has agreed to go ahead and delete an organizer.
 *
 * @param {ZmOrganizer}	organizer	the organizer to delete
 * 
 * @private
 */
ZmTreeController.prototype._deleteShieldYesCallback =
function(organizer) {
	this._doDelete(organizer);
	this._clearDialog(this._deleteShield);
};

/**
 * @private
 */
ZmTreeController.prototype._emptyShieldYesCallback = 
function(organizer) {
	this._doEmpty(organizer);
	this._clearDialog(this._emptyShield);
};

/**
 * Prompts user before folder is emptied.
 *
 * @param {DwtUiEvent}		ev		the UI event
 *
 * @private
 */

ZmTreeController.prototype._getEmptyShieldWarning =
function(ev) {
    var organizer = this._pendingActionData = this._getActionedOrganizer(ev);
	var ds = this._emptyShield = appCtxt.getOkCancelMsgDialog();
	ds.reset();
	ds.registerCallback(DwtDialog.OK_BUTTON, this._emptyShieldYesCallback, this, organizer);
	ds.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, this._emptyShield);
	var msg = (organizer.nId != ZmFolder.ID_TRASH)
		? (AjxMessageFormat.format(ZmMsg.confirmEmptyFolder, organizer.getName()))
		: ZmMsg.confirmEmptyTrashFolder;
	ds.setMessage(msg, DwtMessageDialog.WARNING_STYLE);

	var focusButtonId = (organizer.nId == ZmFolder.ID_TRASH || organizer.nId == ZmFolder.ID_SPAM) ?  DwtDialog.OK_BUTTON : DwtDialog.CANCEL_BUTTON;
	ds.associateEnterWithButton(focusButtonId);
	ds.popup(null, focusButtonId);

	if (!(organizer.nId == ZmFolder.ID_SPAM || organizer.isInTrash())) {
		var cancelButton = ds.getButton(DwtDialog.CANCEL_BUTTON);
		cancelButton.focus();
	}
};

// Miscellaneous private methods

/**
 * Returns the organizer that's currently selected for action (via right-click).
 * Note: going up the object tree to find the actioned organizer will only work 
 * for tree item events; it won't work for action menu item events, since action
 * menus are children of the shell.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmTreeController.prototype._getActionedOrganizer =
function(ev) {
	if (this._actionedOrganizer) {
		return this._actionedOrganizer;
	}
		
	var obj = ev.item;
	while (obj) {
		var data = obj.getData(Dwt.KEY_OBJECT);
		if (data instanceof ZmOrganizer) {
			this._actionedOrganizer = data;
			return this._actionedOrganizer;
		}
		obj = obj.parent;
	}
	return null;
};

/**
 * Shows or hides the tree view. It is hidden only if there is no data, and we
 * have been told to hide empty tree views of this type.
 * 
 * @param {constant}	overviewId		the overview ID
 * 
 * @private
 */
ZmTreeController.prototype._checkTreeView =
function(overviewId) {
	if (!overviewId || !this._treeView[overviewId]) { return; }

	var account = this._opc.getOverview(overviewId).account;
	var dataTree = this.getDataTree(account);
	var hide = (ZmOrganizer.HIDE_EMPTY[this.type] && dataTree && (dataTree.size() == 0));
	this._treeView[overviewId].setVisible(!hide);
};
}
if (AjxPackage.define("zimbraMail.share.controller.ZmFolderTreeController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * 
 * This file defines a folder tree controller.
 *
 */

/**
 * Creates a folder tree controller.
 * @class
 * This class controls a tree display of folders.
 *
 * @param {Constant}	type			the type of organizer we are displaying/controlling ({@link ZmOrganizer.FOLDER} or {@link ZmOrganizer.SEARCH})
 * @param {DwtDropTarget}		dropTgt		the drop target for this type
 * 
 * @extends		ZmTreeController
 */
ZmFolderTreeController = function(type, dropTgt) {

	if (!arguments.length) { return; }

	ZmTreeController.call(this, (type || ZmOrganizer.FOLDER));

	this._listeners[ZmOperation.NEW_FOLDER]				= this._newListener.bind(this);
	this._listeners[ZmOperation.PRIORITY_FILTER]		= this._priorityFilterListener.bind(this);
	this._listeners[ZmOperation.RENAME_FOLDER]			= this._renameListener.bind(this);
	this._listeners[ZmOperation.SHARE_FOLDER]			= this._shareFolderListener.bind(this);
	this._listeners[ZmOperation.EMPTY_FOLDER]			= this._emptyListener.bind(this);
	this._listeners[ZmOperation.RECOVER_DELETED_ITEMS]	= this._recoverListener.bind(this);
	this._listeners[ZmOperation.SYNC_OFFLINE_FOLDER]	= this._syncOfflineFolderListener.bind(this);
};

ZmFolderTreeController.prototype = new ZmTreeController;
ZmFolderTreeController.prototype.constructor = ZmFolderTreeController;

ZmFolderTreeController.prototype.isZmFolderTreeController = true;
ZmFolderTreeController.prototype.toString = function() { return "ZmFolderTreeController"; };

// Public methods

/**
 * Shows the folder tree with certain folders hidden.
 * 
 * @param	{Hash}	params		a hash of parameters
 * @param	{Array}	params.omit		an array of folder ids to omit
 * @param	{ZmAccount}	params.account		the account
 */
ZmFolderTreeController.prototype.show =
function(params) {

	return ZmTreeController.prototype.show.call(this, params);
};

/**
* Resets and enables/disables operations based on context.
*
* @param {DwtControl}	parent		the widget that contains the operations
* @param {int}			id			the id of the currently selected/activated organizer
*/
ZmFolderTreeController.prototype.resetOperations =
function(parent, type, id) {

	var emptyText = ZmMsg.emptyFolder; //ZmMsg.empty + (ZmFolder.MSG_KEY[id]?" "+ZmFolder.MSG_KEY[id] : "");
	var folder = appCtxt.getById(id);
	var hasContent = ((folder.numTotal > 0) || (folder.children && (folder.children.size() > 0)));

    // disable empty folder option for inbox, sent and drafts: bug 66656
    var isEmptyFolderAllowed = true;
    var y = folder.rid;
    if (y == ZmFolder.ID_ROOT || y == ZmFolder.ID_INBOX || y == ZmFolder.ID_SENT || y == ZmFolder.ID_DRAFTS) {
        isEmptyFolderAllowed = false;
    }

	// user folder or Folders header
	var nId = ZmOrganizer.normalizeId(id, this.type);
	if (nId == ZmOrganizer.ID_ROOT || (!folder.isSystem() && !folder.isSystemEquivalent()) /*&& !folder.isSyncIssuesFolder()*/) {
		var isShareVisible = (!folder.link || folder.isAdmin());
        if (appCtxt.isOffline) {
            isShareVisible = !folder.getAccount().isMain && folder.getAccount().isZimbraAccount;
        }
		parent.enableAll(true);
		var isSubFolderOfReadOnly = folder.parent && folder.parent.isReadOnly();
		parent.enable([ZmOperation.DELETE_WITHOUT_SHORTCUT, ZmOperation.MOVE, ZmOperation.EDIT_PROPS], !isSubFolderOfReadOnly);
		parent.enable(ZmOperation.SYNC, folder.isFeed()/* || folder.hasFeeds()*/);
		parent.enable(ZmOperation.SYNC_ALL, folder.isFeed() || folder.hasFeeds());
		parent.enable(ZmOperation.SHARE_FOLDER, isShareVisible);
		parent.enable(ZmOperation.EMPTY_FOLDER, ((hasContent || folder.link) && isEmptyFolderAllowed && !appCtxt.isExternalAccount()));	// numTotal is not set for shared folders
		parent.enable(ZmOperation.RENAME_FOLDER, !(isSubFolderOfReadOnly || folder.isDataSource() || appCtxt.isExternalAccount()));		// dont allow datasource'd folder to be renamed via overview
		parent.enable(ZmOperation.NEW_FOLDER, !(folder.disallowSubFolder || appCtxt.isExternalAccount()));

		if (folder.isRemote() && folder.isReadOnly()) {
			parent.enable([ZmOperation.NEW_FOLDER, ZmOperation.MARK_ALL_READ, ZmOperation.EMPTY_FOLDER], false);
		}
        if (appCtxt.isExternalAccount()) {
			parent.enable([ZmOperation.DELETE_WITHOUT_SHORTCUT, ZmOperation.MOVE], false);
		}
	}
	// system folder
	else {
		if (folder.isSystemEquivalent()) {
			nId = folder.getSystemEquivalentFolderId();
		}
		parent.enableAll(false);
		// can't create folders under Drafts or Junk
		if (!folder.disallowSubFolder &&
			(nId == ZmFolder.ID_INBOX ||
			 nId == ZmFolder.ID_SENT  ||
			 nId == ZmFolder.ID_TRASH))
		{
			parent.enable(ZmOperation.NEW_FOLDER, true);
		}
		// "Empty" for Chats, Junk and Trash
		if (nId == ZmFolder.ID_SPAM  ||
			nId == ZmFolder.ID_TRASH ||
			nId == ZmFolder.ID_CHATS)
		{
			if (nId == ZmFolder.ID_SPAM) {
				emptyText = ZmMsg.emptyJunk;
			} else if (nId == ZmFolder.ID_TRASH) {
				 emptyText = ZmMsg.emptyTrash;
			}
			parent.enable(ZmOperation.EMPTY_FOLDER, hasContent);
		}
		// only allow Inbox and Sent system folders to be share-able for now
		if (!folder.link && (nId == ZmFolder.ID_INBOX || nId == ZmFolder.ID_SENT || nId == ZmFolder.ID_DRAFTS)) {
			parent.enable([ZmOperation.SHARE_FOLDER, ZmOperation.EDIT_PROPS], true);
		}
        if (appCtxt.multiAccounts) {
            var isShareVisible = !folder.getAccount().isMain && folder.getAccount().isZimbraAccount;
            if(nId == ZmFolder.ID_SPAM || nId == ZmFolder.ID_TRASH) {
                isShareVisible = false;
            }
            parent.enable([ZmOperation.SHARE_FOLDER, ZmOperation.EDIT_PROPS], isShareVisible);
        }
		// bug fix #30435 - enable empty folder for sync failures folder
		if (appCtxt.isOffline && nId == ZmOrganizer.ID_SYNC_FAILURES && hasContent) {
			parent.enable(ZmOperation.EMPTY_FOLDER, true);
		}
	}

	parent.enable(ZmOperation.OPEN_IN_TAB, true);
	parent.enable(ZmOperation.EXPAND_ALL, (folder.size() > 0));
	if (nId != ZmOrganizer.ID_ROOT && !folder.isReadOnly()) {
		// always enable for shared folders since we dont get this info from server
		parent.enable(ZmOperation.MARK_ALL_READ, !folder.isRemoteRoot() && (folder.numUnread > 0 || folder.link));
	}

	var op = parent.getOp(ZmOperation.EMPTY_FOLDER);
	if (op) {
		op.setText(emptyText);
	}

    var isTrash = (nId == ZmOrganizer.ID_TRASH);
	// are there any external accounts associated to this folder?
	var button = parent.getOp(ZmOperation.SYNC);
	if (button) {
		var syncAllButton = parent.getOp(ZmOperation.SYNC_ALL);
		var hasFeeds = folder.hasFeeds();
		if (folder.isFeed()) {
			button.setEnabled(true);
			button.setVisible(true);
			button.setText(ZmMsg.checkFeed);
			if (syncAllButton) {
				syncAllButton.setEnabled(true);
				syncAllButton.setVisible(true);
				syncAllButton.setText(ZmMsg.checkAllFeed);
			}
		}
		else if (hasFeeds && !isTrash) {
			if (syncAllButton){
				syncAllButton.setEnabled(true);
				syncAllButton.setVisible(true);
				syncAllButton.setText(ZmMsg.checkAllFeed);
			}
		}
		else {
			var isEnabled = appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED) || appCtxt.get(ZmSetting.IMAP_ACCOUNTS_ENABLED);
			if (!appCtxt.isOffline && isEnabled) {
				var dsCollection = AjxDispatcher.run("GetDataSourceCollection");
				var dataSources = dsCollection.getItemsFor(ZmOrganizer.normalizeId(folder.id));
				if (dataSources.length > 0) {
					button.setText(ZmMsg.checkExternalMail);
					button.setEnabled(true);
					button.setVisible(true);
				} else {
					button.setVisible(false);
				}
			}
			else {
				button.setVisible(false);
			}

			if ((!hasFeeds || isTrash) && syncAllButton) {
				syncAllButton.setVisible(false);
			}
		}
	}

	button = parent.getOp(ZmOperation.SYNC_OFFLINE_FOLDER);
	if (button) {
		if (!folder.isOfflineSyncable) {
			button.setVisible(false);
		} else {
			button.setVisible(true);
			button.setEnabled(true);
			var text = (folder.isOfflineSyncing)
				? ZmMsg.syncOfflineFolderOff : ZmMsg.syncOfflineFolderOn;
			button.setText(text);
		}
	}
	var priorityInboxEnabled = appCtxt.get(ZmSetting.PRIORITY_INBOX_ENABLED);
	var priorityInboxOp = parent.getOp(ZmOperation.PRIORITY_FILTER);
	if (priorityInboxOp) {
		priorityInboxOp.setVisible(priorityInboxEnabled);
		priorityInboxOp.setEnabled(priorityInboxEnabled);
	}
	this._enableRecoverDeleted(parent, isTrash);

	// we always enable sharing in case we're in multi-mbox mode
	this._resetButtonPerSetting(parent, ZmOperation.SHARE_FOLDER, appCtxt.get(ZmSetting.SHARING_ENABLED));
};


// Private methods

/**
 * Returns ops available for "Folders" container.
 * 
 * @private
 */
ZmFolderTreeController.prototype._getHeaderActionMenuOps =
function() {
    if (appCtxt.isExternalAccount()) {
        return [ZmOperation.EXPAND_ALL];
    }
	return [
		ZmOperation.NEW_FOLDER,
		ZmOperation.SEP,
		ZmOperation.PRIORITY_FILTER,
		ZmOperation.EXPAND_ALL,
		ZmOperation.SYNC,
		ZmOperation.FIND_SHARES
	];
};

/**
 * Returns ops available for folder items.
 * 
 * @private
 */
ZmFolderTreeController.prototype._getActionMenuOps = function() {

	return [
		ZmOperation.NEW_FOLDER,
		ZmOperation.SYNC,
		ZmOperation.SYNC_ALL,
		ZmOperation.MARK_ALL_READ,
		ZmOperation.EMPTY_FOLDER,
		ZmOperation.RECOVER_DELETED_ITEMS,
		ZmOperation.SHARE_FOLDER,
		ZmOperation.MOVE,
		ZmOperation.DELETE_WITHOUT_SHORTCUT,
		ZmOperation.RENAME_FOLDER,
		ZmOperation.EDIT_PROPS,
		ZmOperation.SYNC_OFFLINE_FOLDER,
		ZmOperation.OPEN_IN_TAB,
		ZmOperation.EXPAND_ALL
	];
};

/**
 * @private
 */
ZmFolderTreeController.prototype._getAllowedSubTypes =
function() {
	var types = {};
	types[ZmOrganizer.FOLDER] = true;
	types[ZmOrganizer.SEARCH] = true;
	return types;
};

/**
 * Returns a "New Folder" dialog.
 * 
 * @private
 */
ZmFolderTreeController.prototype._getNewDialog =
function() {
	return appCtxt.getNewFolderDialog();
};

/**
 * Returns a "Rename Folder" dialog.
 * 
 * @private
 */
ZmFolderTreeController.prototype._getRenameDialog =
function() {
	return appCtxt.getRenameFolderDialog();
};

/**
 * Called when a left click occurs (by the tree view listener). The folder that
 * was clicked may be a search, since those can appear in Trash within the folder tree. The
 * appropriate search will be performed.
 *
 * @param {ZmOrganizer}		folder		the folder or search that was clicked
 * 
 * @private
 */
ZmFolderTreeController.prototype._itemClicked = function(folder, openInTab) {

	// bug 41196 - turn off new mail notifier if inactive account folder clicked
	if (appCtxt.isOffline) {
		var acct = folder.getAccount();
		if (acct && acct.inNewMailMode) {
			acct.inNewMailMode = false;
			var allContainers = appCtxt.getOverviewController()._overviewContainer;
			for (var i in allContainers) {
				allContainers[i].updateAccountInfo(acct, true, true);
			}
		}
	}

	if (folder.type == ZmOrganizer.SEARCH) {
		// if the clicked item is a search (within the folder tree), hand
		// it off to the search tree controller
		var stc = this._opc.getTreeController(ZmOrganizer.SEARCH);
		stc._itemClicked(folder, openInTab);
	} else if (folder.id == ZmFolder.ID_ATTACHMENTS) {
		var attController = AjxDispatcher.run("GetAttachmentsController");
		attController.show();
	}
    else {
		var searchFor = ZmId.SEARCH_MAIL;
		if (folder.isInTrash()) {
			var app = appCtxt.getCurrentAppName();
			// if other apps add Trash to their folder tree, set appropriate type here:
			if (app == ZmApp.CONTACTS) {
				searchFor = ZmItem.CONTACT;
			}
		}
		var sc = appCtxt.getSearchController();
		var acct = folder.getAccount();

		var sortBy = appCtxt.get(ZmSetting.SORTING_PREF, folder.nId);
		if (!sortBy) {
			sortBy = (sc.currentSearch && folder.nId == sc.currentSearch.folderId) ? null : ZmSearch.DATE_DESC;
		}
		else {
			//user may have saved folder with From search then switched views; don't allow From sort in conversation mode
			var groupMode = appCtxt.getApp(ZmApp.MAIL).getGroupMailBy();
			if (groupMode == ZmItem.CONV && (sortBy == ZmSearch.NAME_ASC || sortBy == ZmSearch.NAME_DESC)) {
				sortBy = appCtxt.get(ZmSetting.SORTING_PREF, appCtxt.getCurrentViewId());  //default to view preference
				if (!sortBy) {
					sortBy = ZmSearch.DATE_DESC; //default
				}
				appCtxt.set(ZmSetting.SORTING_PREF, sortBy, folder.nId);
			}
		}
		var params = {
			query:          folder.createQuery(),
			searchFor:      searchFor,
			getHtml:        folder.nId == ZmFolder.ID_DRAFTS || appCtxt.get(ZmSetting.VIEW_AS_HTML),
			types:          folder.nId == ZmOrganizer.ID_SYNC_FAILURES ? [ZmItem.MSG] : null, // for Sync Failures folder, always show in traditional view
			sortBy:         sortBy,
			accountName:    acct && acct.name,
			userInitiated:  openInTab,
			origin:         ZmId.SEARCH
		};

		sc.resetSearchAllAccounts();

		if (appCtxt.multiAccounts) {
			// make sure we have permissions for this folder (in case an "external"
			// server was down during account load)
			if (folder.link && folder.perm == null) {
				var folderTree = appCtxt.getFolderTree(acct);
				if (folderTree) {
					var callback = new AjxCallback(this, this._getPermissionsResponse, [params]);
					folderTree.getPermissions({callback:callback, folderIds:[folder.id]});
				}
				return;
			}

			if (appCtxt.isOffline && acct.hasNotSynced() && !acct.__syncAsked) {
				acct.__syncAsked = true;

				var dialog = appCtxt.getYesNoMsgDialog();
				dialog.registerCallback(DwtDialog.YES_BUTTON, this._syncAccount, this, [dialog, acct]);
				dialog.setMessage(ZmMsg.neverSyncedAsk, DwtMessageDialog.INFO_STYLE);
				dialog.popup();
			}
		}

		sc.search(params);
	}
};

/**
 * @private
 */
ZmFolderTreeController.prototype._syncAccount =
function(dialog, account) {
	dialog.popdown();
	account.sync();
};

/**
 * @private
 */
ZmFolderTreeController.prototype._getPermissionsResponse =
function(params) {
	appCtxt.getSearchController().search(params);
};


// Actions

/**
 * @private
 */
ZmFolderTreeController.prototype._doSync =
function(folder) {
	var dsc = AjxDispatcher.run("GetDataSourceCollection");
	var nFid = ZmOrganizer.normalizeId(folder.id);
	var dataSources = dsc.getItemsFor(nFid);

	if (dataSources.length > 0) {
		dsc.importMailFor(nFid);
	}
	else {
		ZmTreeController.prototype._doSync.call(this, folder);
	}
};

/**
 * @private
 */
ZmFolderTreeController.prototype._syncFeeds =
function(folder) {
	if (!appCtxt.isOffline && folder && !folder.isFeed()) {
		var dataSources = (appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED) || appCtxt.get(ZmSetting.IMAP_ACCOUNTS_ENABLED))
			? folder.getDataSources(null, true) : null;

		if (dataSources) {
			var dsc = AjxDispatcher.run("GetDataSourceCollection");
			dsc.importMail(dataSources);
			return;
		}
	}

	ZmTreeController.prototype._syncFeeds.call(this, folder);
};

/**
 * Adds the new item to the tree.
 *
 * @param {ZmTreeView}		treeView		a tree view
 * @param {DwtTreeItem}		parentNode		the node under which to add the new one
 * @param {ZmOrganizer}		organizer		the organizer for the new node
 * @param {int}				idx				theposition at which to add the new node
 * @return	{DwtTreeItem}	the resulting item
 * 
 * @private
 */
ZmFolderTreeController.prototype._addNew =
function(treeView, parentNode, organizer, idx) {
	if (ZmFolder.HIDE_ID[organizer.id]) {
		return false;
	}
	return treeView._addNew(parentNode, organizer, idx);
};

// Listeners

/**
 * Deletes a folder. If the folder is in Trash, it is hard-deleted. Otherwise, it
 * is moved to Trash (soft-delete). If the folder is Trash or Junk, it is emptied.
 * A warning dialog will be shown before the Junk folder is emptied.
 *
 * @param {DwtUiEvent}	ev		the UI event
 * 
 * @private
 */
ZmFolderTreeController.prototype._deleteListener =
function(ev) {
	var organizer = this._getActionedOrganizer(ev);

	// bug fix #35405 - accounts with disallowSubFolder flag set (eg Yahoo) do not support moving folder to Trash
	var trashFolder = appCtxt.isOffline ? this.getDataTree().getById(ZmFolder.ID_TRASH) : null;
	if (trashFolder && trashFolder.disallowSubFolder && organizer.numTotal > 0) {
		var d = appCtxt.getMsgDialog();
		d.setMessage(ZmMsg.errorCannotDeleteFolder);
		d.popup();
		return;
	}

	// TODO: not sure what SPAM is doing in here - can you delete it?
	if (organizer.nId == ZmFolder.ID_SPAM || organizer.isInTrash() || (trashFolder && trashFolder.disallowSubFolder)) {
		this._pendingActionData = organizer;
		var ds = this._deleteShield = appCtxt.getOkCancelMsgDialog();
		ds.reset();
		ds.registerCallback(DwtDialog.OK_BUTTON, this._deleteShieldYesCallback, this, organizer);
		ds.registerCallback(DwtDialog.CANCEL_BUTTON, this._clearDialog, this, this._deleteShield);
		var confirm;
		if (organizer.type === ZmOrganizer.SEARCH) {
			confirm = ZmMsg.confirmDeleteSavedSearch;
		}
		else if (organizer.nId == ZmFolder.ID_TRASH) {
			confirm = ZmMsg.confirmEmptyTrashFolder;
		}
		else if (organizer.nId == ZmFolder.ID_SPAM) {
			confirm = ZmMsg.confirmEmptyFolder;
		}
		else {
			// TODO: should probably split out msgs by folder type
			confirm = ZmMsg.confirmDeleteFolder;
		}
		var msg = AjxMessageFormat.format(confirm, organizer.getName());
		ds.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
		ds.popup();
	}
	else {
		this._doMove(organizer, appCtxt.getById(ZmFolder.ID_TRASH));
	}
};

/**
 * Empties a folder.
 * It removes all the items in the folder except sub-folders.
 * If the folder is Trash, it empties even the sub-folders.
 * A warning dialog will be shown before any folder is emptied.
 *
 * @param {DwtUiEvent}		ev		the UI event
 * 
 * @private
 */
ZmFolderTreeController.prototype._emptyListener =
function(ev) {
	this._getEmptyShieldWarning(ev);
};

ZmFolderTreeController.prototype._recoverListener =
function(ev) {
	appCtxt.getDumpsterDialog().popup(this._getSearchFor(), this._getSearchTypes());
};

ZmFolderTreeController.prototype._getSearchFor =
function(ev) {
	return ZmId.SEARCH_MAIL; // Fallback value; subclasses should return differently
};

ZmFolderTreeController.prototype._getSearchTypes =
function(ev) {
	return [ZmItem.MSG]; // Fallback value; subclasses should return differently
};

/**
 * Toggles on/off flag for syncing IMAP folder with server. Only for offline use.
 *
 * @param {DwtUiEvent}	ev	the UI event
 * 
 * @private
 */
ZmFolderTreeController.prototype._syncOfflineFolderListener =
function(ev) {
	var folder = this._getActionedOrganizer(ev);
	if (folder) {
		folder.toggleSyncOffline();
	}
};

/**
 * Don't allow dragging of system folders.
 *
 * @param {DwtDragEvent}	ev		the drag event
 * 
 * @private
 */
ZmFolderTreeController.prototype._dragListener =
function(ev) {
	if (ev.action == DwtDragEvent.DRAG_START) {
		var folder = ev.srcControl.getData(Dwt.KEY_OBJECT);
		ev.srcData = {data:folder, controller:this};
		if (!(folder instanceof ZmFolder) || folder.isSystem() /*|| folder.isSyncIssuesFolder()*/) {
			ev.operation = Dwt.DND_DROP_NONE;
		}
	}
};

/**
 * Handles the potential drop of something onto a folder. When something is dragged over
 * a folder, returns true if a drop would be allowed. When something is actually dropped,
 * performs the move. If items are being dropped, the source data is not the items
 * themselves, but an object with the items (data) and their controller, so they can be
 * moved appropriately.
 *
 * @param {DwtDropEvent}	ev		the drop event
 * 
 * @private
 */
ZmFolderTreeController.prototype._dropListener =
function(ev) {

	var dropFolder = ev.targetControl.getData(Dwt.KEY_OBJECT);
	var data = ev.srcData.data;
	var isShiftKey = (ev.shiftKey || ev.uiEvent.shiftKey);

	if (ev.action == DwtDropEvent.DRAG_ENTER) {
		if (!data) {
			ev.doIt = false;
			return;
		}
		var type = ev.targetControl.getData(ZmTreeView.KEY_TYPE);
		if (data instanceof ZmFolder) {
			ev.doIt = dropFolder.mayContain(data, type) && !dropFolder.disallowSubFolder;
		} else if (data instanceof ZmTag) {
			ev.doIt = false; // tags cannot be moved
		} else {
			if (this._dropTgt.isValidTarget(data)) {
				ev.doIt = dropFolder.mayContain(data, type);

				var action;
				var actionData = AjxUtil.toArray(data);

				// walk thru the array and find out what action is allowed
				for (var i = 0; i < actionData.length; i++) {
					if (actionData[i] instanceof ZmItem) {
						action |= actionData[i].getDefaultDndAction(isShiftKey);
					}
				}

				var plusDiv = document.getElementById(DwtId.DND_PLUS_ID);
				if (action && plusDiv) {
					// TODO - what if action is ZmItem.DND_ACTION_BOTH ??
					var isCopy = ((action & ZmItem.DND_ACTION_COPY) != 0);
					Dwt.setVisibility(plusDiv, isCopy);
				}
			} else {
				ev.doIt = false;
			}
		}
	} else if (ev.action == DwtDropEvent.DRAG_DROP) {
		if (data instanceof ZmFolder) {
			this._doMove(data, dropFolder);
		} else {
			var ctlr = ev.srcData.controller;
			var items = (data instanceof Array) ? data : [data];
			if (appCtxt.multiAccounts && !isShiftKey && !dropFolder.getAccount().isMain &&
				this._isMovingAcrossAccount(items, dropFolder))
			{
				var dialog = appCtxt.getYesNoMsgDialog();
				dialog.registerCallback(DwtDialog.YES_BUTTON, this._continueMovingAcrossAccount, this, [dialog, ctlr, items, dropFolder]);
				dialog.setMessage(ZmMsg.moveAcrossAccountWarning, DwtMessageDialog.WARNING_STYLE);
				dialog.popup();
			}
			else {
				ctlr._doMove(items, dropFolder, null, isShiftKey);
			}
		}
	}
};

ZmFolderTreeController.prototype._isMovingAcrossAccount =
function(items, dropFolder) {
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		var itemAcct = item.getAccount();
		if (itemAcct && itemAcct != dropFolder.getAccount()) {
			return true;
		}
	}
	return false;
};

ZmFolderTreeController.prototype._continueMovingAcrossAccount =
function(dialog, ctlr, items, dropFolder) {
	dialog.popdown();
	ctlr._doMove(items, dropFolder);
};


ZmTreeController.prototype._priorityFilterListener =
function(ev) {
	var priorityFilterDialog = appCtxt.getPriorityMessageFilterDialog();
	ZmController.showDialog(priorityFilterDialog);
};

/**
 * @private
 */
ZmFolderTreeController.prototype._shareFolderListener =
function(ev) {
	this._pendingActionData = this._getActionedOrganizer(ev);
	appCtxt.getSharePropsDialog().popup(ZmSharePropsDialog.NEW, this._pendingActionData);
};

// Miscellaneous

/**
 * Returns a title for moving a folder.
 * 
 * @return	{String}	the title
 * @private
 */
ZmFolderTreeController.prototype._getMoveDialogTitle =
function() {
	return AjxMessageFormat.format(ZmMsg.moveFolder, this._pendingActionData.name);
};
}
if (AjxPackage.define("zimbraMail.share.controller.ZmSearchController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the search controller.
 *
 */

/**
 * Creates a search controller.
 * @class
 * This class represents the search controller.
 * 
 * @param {DwtControl}	container	the top-level container
 * @extends	ZmController
 */
ZmSearchController = function(container) {

	ZmController.call(this, container);

	this._inited = false;
	this._contactSource = ZmItem.CONTACT;
	this._results = null;

	if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
		this._setView();
	}
};

ZmSearchController.prototype = new ZmController;
ZmSearchController.prototype.constructor = ZmSearchController;

ZmSearchController.prototype.isZmSearchController = true;
ZmSearchController.prototype.toString = function() { return "ZmSearchController"; };

// Consts
ZmSearchController.QUERY_ISREMOTE = "is:remote OR is:local";


/**
 * Gets the search tool bar.
 * 
 * @return	{ZmButtonToolBar}		the tool bar
 */
ZmSearchController.prototype.getSearchToolbar =
function() {
	return this._searchToolBar;
};

/**
 * Performs a search by date.
 * 
 * @param	{Date}	d		the date or <code>d</code> for now
 * @param	{String}	searchFor	the search for string
 */
ZmSearchController.prototype.dateSearch =
function(d, searchFor) {
	d = d || new Date();
    var formatter = AjxDateFormat.getDateInstance(AjxDateFormat.SHORT);
    var date = formatter.format(d);
	var groupBy = appCtxt.getApp(ZmApp.MAIL).getGroupMailBy();
	var query = "date:" + date;
	this.search({
		query:			query,
		types:			[groupBy],
		searchFor:		searchFor,
		origin:			ZmId.SEARCH,
		userInitiated:	true
	});
};

/**
 * Performs a search by from address.
 * 
 * @param	{String}	address		the from address
 */
ZmSearchController.prototype.fromSearch =
function(address) {

	// always search for mail when doing a "from: <address>" search
	var groupBy = appCtxt.getApp(ZmApp.MAIL).getGroupMailBy();
	var terms = AjxUtil.map(AjxUtil.toArray(address), function(addr) {
		return "from:" + ((addr && addr.isAjxEmailAddress) ? addr.getAddress() : addr);
	});
	
	this.search({
		query:			terms.join(" OR "),
		types:			[groupBy],
		origin:			ZmId.SEARCH,
		userInitiated:	true
	});
};


/**
 * Performs a search by to address.
 *
 * @param	{String}	address		the to address
 */
ZmSearchController.prototype.toSearch =
function(address) {

	// always search for mail when doing a "tocc: <address>" search
	var groupBy = appCtxt.getApp(ZmApp.MAIL).getGroupMailBy();
	var terms = AjxUtil.map(AjxUtil.toArray(address), function(addr) {
		return "tocc:" + ((addr && addr.isAjxEmailAddress) ? addr.getAddress() : addr);
	});

	var params = {
		types:			[groupBy],
		origin:			ZmId.SEARCH,
		userInitiated:	true,
		query:			terms.join(" OR ")
	}
    if (this.currentSearch && this.currentSearch.folderId == ZmFolder.ID_SENT) {
		if (terms.length > 1) {
			params.query = "(" + params.query + ")";
		}
		params.query = "in:sent AND " + params.query;
	}
    this.search(params);
};

/**
 * Sets the search field.
 * 
 * @param	{String}	searchString	the search string
 */
ZmSearchController.prototype.setSearchField =
function(searchString) {
	if (appCtxt.get(ZmSetting.SHOW_SEARCH_STRING) && this._searchToolBar) {
		this._searchToolBar.setSearchFieldValue(searchString);
	} else {
		this._currentQuery = searchString;
	}
};

/**
 * Gets the search field value.
 * 
 * @return	{String}	the search field value or an empty string
 */
ZmSearchController.prototype.getSearchFieldValue =
function() {
	return this._searchToolBar ? this._searchToolBar.getSearchFieldValue() : "";
};

ZmSearchController.prototype.setEnabled =
function(enabled) {
	if (this._searchToolBar) {
		this._searchToolBar.setEnabled(enabled);
	}
};

/**
 * Sets the default type. This method provides a programmatic way to set the search type.
 *
 * @param {Object}	type		the search type to set as the default
 */
ZmSearchController.prototype.setDefaultSearchType =
function(type) {
	if (!this._searchToolBar) {
		return;
	}
	var menu = this._searchToolBar.getButton(ZmSearchToolBar.TYPES_BUTTON).getMenu();
	menu.checkItem(ZmOperation.MENUITEM_ID, type);
	this._searchMenuListener(null, type, true);
};

/**
 * @private
 */
ZmSearchController.prototype._setView =
function() {

	// Create search panel - a composite is needed because the search builder
	// element (ZmBrowseView) is added to it (can't add it to the toolbar)
	this.searchPanel = new DwtComposite({
				parent:		this._container,
				className:	"SearchPanel",
				posStyle:	Dwt.ABSOLUTE_STYLE
			});

	this._searchToolBar = new ZmMainSearchToolBar({
				parent:	this.searchPanel,
				id:		ZmId.SEARCH_TOOLBAR
			});

	this._createTabGroup();
	this._tabGroup.addMember(this._searchToolBar.getChildren());
	
	// Register keyboard callback for search field
	this._searchToolBar.registerEnterCallback(this._toolbarSearch.bind(this));

	// Button listeners
	this._searchToolBar.addSelectionListener(ZmSearchToolBar.SEARCH_BUTTON, this._searchButtonListener.bind(this));
};

/**
 * @private
 */
ZmSearchController.prototype._addMenuListeners =
function(menu) {
	// Menu listeners
	var searchMenuListener = this._searchMenuListener.bind(this);
	var items = menu.getItems();
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		item.addSelectionListener(searchMenuListener);
		var mi = item.getData(ZmOperation.MENUITEM_ID);
		// set mail as default search
		if (mi == ZmId.SEARCH_MAIL) {
			item.setChecked(true, true);
		}
	}
};

/**
 * Performs a search and displays the results.
 *
 * @param {Hash}	params		a hash of parameters:
 * 
 * @param {String}		query						the search string
 * @param {constant}	searchFor					the semantic type to search for
 * @param {Array}		types						the item types to search for
 * @param {constant}	sortBy						the sort constraint
 * @param {int}			offset						the starting point in list of matching items
 * @param {int}			limit						the maximum number of items to return
 * @param {int}			searchId					the ID of owning search folder (if any)
 * @param {Boolean}		noRender					if <code>true</code>, results will not be passed to controller
 * @param {Boolean}		userText					if <code>true</code>, text was typed by user into search box
 * @param {AjxCallback}	callback					the async callback
 * @param {AjxCallback}	errorCallback				the async callback to run if there is an exception
 * @param {Object}		response					the canned JSON response (no request will be made)
 * @param {boolean}		skipUpdateSearchToolbar     don't update the search toolbar (e.g. from the ZmDumpsterDialog where the search is called from its own search toolbar
 * @param {string}		origin						indicates what initiated the search
 * @param {string}		sessionId					session ID of search results tab (if search came from one)
 * @param {Boolean}		noGal     if true, don't search GAL. This is to override the this._contactSource value in contacts search, specifically for clicking on TAGS. 
 *
 */
ZmSearchController.prototype.search =
function(params) {

	// if the search string starts with "$set:" then it is a command to the client
	if (params.query && (params.query.indexOf("$set:") == 0 || params.query.indexOf("$cmd:") == 0)) {
		appCtxt.getClientCmdHandler().execute((params.query.substr(5)), this);
		return;
	}

	params.searchAllAccounts = this.searchAllAccounts;
	var respCallback = this._handleResponseSearch.bind(this, params.callback);
	this._doSearch(params, params.noRender, respCallback, params.errorCallback);
};

/**
 * @private
 */
ZmSearchController.prototype._handleResponseSearch =
function(callback, result) {
	if (callback) {
		callback.run(result);
	}
};

/**
 * Performs the given search. It takes a ZmSearch, rather than constructing one out of the currently selected menu
 * choices. Aside from re-executing a search, it can be used to perform a canned search.
 *
 * @param {ZmSearch}	search		the search object
 * @param {Boolean}		noRender		if <code>true</code>, results will not be passed to controller
 * @param {Object}	changes		the hash of changes to make to search
 * @param {AjxCallback}	callback		the async callback
 * @param {AjxCallback}	errorCallback	the async callback to run if there is an exception
 */
ZmSearchController.prototype.redoSearch =
function(search, noRender, changes, callback, errorCallback) {

	var params = {};
	params.query		= search.query;
	params.queryHint	= search.queryHint;
	params.types		= search.types;
	params.forceTypes	= search.forceTypes;
	params.sortBy		= search.sortBy;
	params.offset		= search.offset;
	params.limit		= search.limit;
	params.fetch		= search.fetch;
	params.searchId		= search.searchId;
	params.lastSortVal	= search.lastSortVal;
	params.endSortVal	= search.endSortVal;
	params.lastId		= search.lastId;
	params.soapInfo		= search.soapInfo;
	params.accountName	= search.accountName;
	params.searchFor	= this._searchFor;
	params.idsOnly		= search.idsOnly;
	params.inDumpster   = search.inDumpster;
	params.userInitiated = search.userInitiated;
	params.sessionId	= search.sessionId;
    params.isEmpty      = search.isEmpty;
	params.markRead     = search.markRead;

	if (changes) {
		for (var key in changes) {
			params[key] = changes[key];
		}
	}

	this._doSearch(params, noRender, callback, errorCallback);
};

/**
 * Resets search for all accounts.
 * 
 */
ZmSearchController.prototype.resetSearchAllAccounts =
function() {
	var button = this.searchAllAccounts && this._searchToolBar.getButton(ZmSearchToolBar.TYPES_BUTTON);
	var menu = button && button.getMenu();
	var allAccountsMI = menu && menu.getItemById(ZmOperation.MENUITEM_ID, ZmId.SEARCH_ALL_ACCOUNTS);

	if (allAccountsMI) {
		allAccountsMI.setChecked(false, true);

		var selItem = menu.getSelectedItem();
		var icon = this._inclSharedItems
			? this._getSharedImage(selItem) : selItem.getImage();
		button.setImage(icon);

		this.searchAllAccounts = false;
	}
};

/**
 * Resets the search toolbar. This is used by the offline client to "reset" the toolbar whenever user
 * switches between accounts.
 * 
 */
ZmSearchController.prototype.resetSearchToolbar =
function() {
	var smb = this._searchToolBar.getButton(ZmSearchToolBar.TYPES_BUTTON);
	var mi = smb ? smb.getMenu().getItemById(ZmOperation.MENUITEM_ID, ZmId.SEARCH_GAL) : null;
	if (mi) {
		mi.setVisible(appCtxt.getActiveAccount().isZimbraAccount);
	}
};

/**
 * Gets the item type, based on searchFor. The type is the same as the searchFor, except for mail in which the type is either msg or conv based on view.
 *
 * @param   {String}	searchFor		   general description of what to search for
 * @param   {Boolean}   userInitiated      true if using a search tab
 * @return	{String}	type
 * 
 * @see		#search
 */
ZmSearchController.prototype.getTypeFromSearchFor =
function(searchFor, userInitiated) {

	var type = searchFor;

	if (searchFor === ZmId.SEARCH_MAIL) {
        var ac = window.parentAppCtxt || window.appCtxt,
            app = ac.getApp(userInitiated ? ZmApp.SEARCH : ZmApp.MAIL);
		type = app ? app.getGroupMailBy() : ZmItem.MSG;
	}

	return type;
};

/**
 * Get the searchFor var which is the same as type except for mail, in which case the type is either msg or conv but searchFor is mail.
 *
 * @param {String} type	type of items to search for
 * @return	{String}	searchFor
 *
 * @see		#search
 */
ZmSearchController.prototype.getSearchForFromType =
function(type) {
	return (type === ZmItem.MSG || type === ZmItem.CONV) ? ZmId.SEARCH_MAIL : type;
};

/**
 * Selects the appropriate item in the overview based on the search. Selection only happens
 * if the search was a simple search for a folder, tag, or saved search. A check is done to
 * make sure that item is not already selected, so selection should only occur for a query
 * manually run by the user.
 *
 * @param {ZmSearch}	searchObj		the current search
 */
ZmSearchController.prototype.updateOverview = function(searchObj) {

	var search = searchObj || appCtxt.getCurrentSearch();
    if (!search) {
        return;
    }

	var id, type;
	if (search.isSimple() || search.searchId) {
		if (search.searchId) {
			id = this._getNormalizedId(search.searchId);
			type = ZmOrganizer.SEARCH;
		}
        else if (search.folderId) {
			id = this._getNormalizedId(search.folderId);
			var folderTree = appCtxt.getFolderTree(),
			    folder = folderTree && folderTree.getById(id);

            type = ZmOrganizer.ITEM_ORGANIZER[search.searchFor] || (folder && folder.type) || ZmOrganizer.FOLDER;
		}
        else if (search.tagId) {
			id = this._getNormalizedId(search.tagId);
			type = ZmOrganizer.TAG;
		}

		if (type) {
			var app = appCtxt.getCurrentApp();
			var overview = app && app.getOverview();
			if (overview) {
				overview.setSelected(id, type);
			}
		}
	}
};

/**
 * @private
 */
ZmSearchController.prototype._getSuitableSortBy =
function(type) {
	var sortBy;

	var viewType;
	switch (type) {
		case ZmItem.CONV:		viewType = ZmId.VIEW_CONVLIST; break;
		case ZmItem.MSG:		viewType = ZmId.VIEW_TRAD; break;
		case ZmItem.CONTACT:	viewType = ZmId.VIEW_CONTACT_SIMPLE; break;
		case ZmItem.APPT:		viewType = ZmId.VIEW_CAL; break;
		case ZmItem.TASK:		viewType = ZmId.VIEW_TASKLIST; break;
		case ZmId.SEARCH_GAL:	viewType = ZmId.VIEW_CONTACT_SIMPLE; break;
		case ZmItem.BRIEFCASE_ITEM:	viewType = ZmId.VIEW_BRIEFCASE_DETAIL; break;
		// more types go here as they are suported...
	}

	if (viewType) {
		sortBy = appCtxt.get(ZmSetting.SORTING_PREF, viewType);
	}
	//bug:1108 & 43789#c19 (changelist 290073) since sort-by-[RCPT|ATTACHMENT|FLAG|PRIORITY] gives exception with querystring.
	// Avoided [RCPT|ATTACHMENT|FLAG|PRIORITY] sorting with querysting instead used date sorting
	var queryString = this._searchToolBar.getSearchFieldValue();
	if (queryString && queryString.length > 0) {
		if (sortBy === ZmSearch.RCPT_ASC || sortBy === ZmSearch.RCPT_DESC) {
			sortBy = sortBy === ZmSearch.RCPT_ASC ? ZmSearch.DATE_ASC : ZmSearch.DATE_DESC;
		}
		else if (sortBy === ZmSearch.FLAG_ASC || sortBy === ZmSearch.FLAG_DESC) {
			sortBy = sortBy === ZmSearch.FLAG_ASC ? ZmSearch.DATE_ASC : ZmSearch.DATE_DESC;
		}
		else if (sortBy === ZmSearch.ATTACH_ASC || sortBy === ZmSearch.ATTACH_DESC) {
			sortBy = sortBy === ZmSearch.ATTACH_ASC ? ZmSearch.DATE_ASC : ZmSearch.DATE_DESC;
		}
		else if (sortBy === ZmSearch.PRIORITY_ASC || sortBy === ZmSearch.PRIORITY_DESC) {
			sortBy = sortBy === ZmSearch.PRIORITY_ASC ? ZmSearch.DATE_ASC : ZmSearch.DATE_DESC;
		}
	}

	return sortBy;
};

/**
 * Performs the search.
 *
 * @param {Hash}	params		a hash of params for the search
 * @param {String}	params.searchFor	the search for
 * @param {String}	params.query	the search query
 * @param {String}	params.userText	the user text
 * @param {Array}	params.type		an array of types
 * @param {Boolean}	params.forceTypes	use the types we pass, do not override (in case of mail) to the current user's view pref (MSG vs. CONV).
 * @param {boolean}	params.inclSharedItems		overrides this._inclSharedItems - see ZmTagsHelper._tagClick
 * @param {boolean} params.forceSearch     Ignores special processing and just executes the search.
 * @param {Boolean}	noRender		if <code>true</code>, the search results will not be rendered
 * @param {AjxCallback}	callback		the callback
 * @param {AjxCallback}	errorCallback	the error callback
 * @param {boolean} params.skipUpdateSearchToolbar     don't update the search toolbar (e.g. from the ZmDumpsterDialog where the search is called from its own search toolbar
 * @param {Boolean}		noGal     if true, don't search GAL. This is to override the this._contactSource value in contacts search, specifically for clicking on TAGS.
 *
 * @see	#search
 * 
 * @private
 */
ZmSearchController.prototype._doSearch =
function(params, noRender, callback, errorCallback) {

	var searchFor = this._searchFor = params.searchFor || this._searchFor || ZmSearchToolBar.MENU_ITEMS[0];
	appCtxt.notifyZimlets("onSearch", [params.query]);

	if (!params.skipUpdateSearchToolbar && this._searchToolBar) {
		var value = (appCtxt.get(ZmSetting.SHOW_SEARCH_STRING) || params.userText)
			? params.query : null;
		this._searchToolBar.setSearchFieldValue(value || "");

		// bug: 42512 - deselect global inbox if searching via search toolbar
		if (appCtxt.multiAccounts && params.userText && this.searchAllAccounts) {
			appCtxt.getCurrentApp().getOverviewContainer().deselectAll();
		}
	}

	// get types from search type if not passed in explicitly
	// Note - types is now always one value (used to allow all types case, but not anymore).
	var types = params.types;
	// Support calling it with null, scalar, array or vector, to make sure different clients of this method work.
	var type = !types ? searchFor : AjxUtil.toArray(types)[0];

	//now make sure the searchFor matches the type (searchFor can be taken from the toolbar, but it's not always what we want, for example
	//in the case of saved search)
	searchFor = this.getSearchForFromType(type);

	//this makes sure for mail we get the type from the user's setting (CONV/MSG).
	if (!params.forceTypes) {
		type = this.getTypeFromSearchFor(searchFor, params.userInitiated);
	}

	var types = AjxVector.fromArray([type]); //need this Vector (one item) only for couple more usages below that I'm afraid to change now.

	if (searchFor == ZmId.SEARCH_MAIL) {
		params = appCtxt.getApp(ZmApp.MAIL).getSearchParams(params);
	}

	if (searchFor == ZmItem.TASK) {
		var tlc = AjxDispatcher.run("GetTaskListController");
		params.allowableTaskStatus = tlc && tlc.getAllowableTaskStatus();
	}

	if (params.searchAllAccounts && !params.queryHint) {
		params.queryHint = appCtxt.accountList.generateQuery(null, types);
		params.accountName = appCtxt.accountList.mainAccount.name;
	}
	else if (params.inclSharedItems || this._inclSharedItems) {
		// a query hint is part of the query that the user does not see
		params.queryHint = ZmSearchController.generateQueryForShares(type);
	}

	// only set contact source if we are searching for contacts
	params.contactSource = !params.noGal && (type === ZmItem.CONTACT || type === ZmId.SEARCH_GAL)
		? this._contactSource : null;
	if (params.contactSource == ZmId.SEARCH_GAL) {
		params.expandDL = true;
	}

	// find suitable sort by value if not given one (and if applicable)
	params.sortBy = params.sortBy || this._getSuitableSortBy(type);
	params.types = types;
	var search = new ZmSearch(params);

	// force drafts folder into msg view
	//Also force dumpster search into msg view
	if (searchFor === ZmId.SEARCH_MAIL && (params.inDumpster || (!params.isViewSwitch && search.folderId && search.folderId == ZmFolder.ID_DRAFTS))) {
		search.types = AjxVector.fromArray([ZmItem.MSG]);
		search.isDefaultToMessageView = true;
	}

	var respCallback = this._handleResponseDoSearch.bind(this, search, noRender, callback, params.noUpdateOverview);
    var offlineCallback = this._handleOfflineDoSearch.bind(this, search, respCallback);
    if (search.folderId == ZmFolder.ID_OUTBOX) {
        var offlineRequest = true;
    }
	if (!errorCallback) {
		errorCallback = this._handleErrorDoSearch.bind(this, search);
		if (!params.errorCallback) {
			params.errorCallback = errorCallback;
		}
	}

	// calendar searching is special so hand it off if necessary
	search.calController = null;
	if (searchFor == ZmItem.APPT && !params.forceSearch && !params.inDumpster) {
		var searchResultsController, sessionId;
		if (search.userInitiated && ZmApp.SEARCH_RESULTS_TAB[ZmApp.CALENDAR]) {
			searchResultsController = appCtxt.getApp(ZmApp.SEARCH).getSearchResultsController(search.sessionId, ZmApp.CALENDAR);
			sessionId = searchResultsController.getCurrentViewId();
		}
		var controller = AjxDispatcher.run("GetCalController", sessionId, searchResultsController);
		if (controller && type === ZmItem.APPT) {
			search.calController = controller;
			controller.handleUserSearch(params, respCallback);
		} else {
            search.execute({offlineCache:params && params.offlineCache, callback:respCallback, errorCallback:errorCallback, offlineCallback:offlineCallback, offlineRequest:offlineRequest});
        }
	} else {
		search.execute({offlineCache:params && params.offlineCache, callback:respCallback, errorCallback:errorCallback, offlineCallback:offlineCallback, offlineRequest:offlineRequest});
	}
};

/**
 * Takes the search result and hands it to the appropriate controller for display.
 *
 * @param {ZmSearch}	search			contains search info used to run search against server
 * @param {Boolean}		noRender		<code>true</code> to skip rendering results
 * @param {AjxCallback}	callback		the callback to run after processing search response
 * @param {Boolean}	noUpdateOverview	<code>true</code> to skip updating the overview
 * @param {ZmCsfeResult}	result			the search results
 */
ZmSearchController.prototype._handleResponseDoSearch =
function(search, noRender, callback, noUpdateOverview, result) {

	DBG.println("s", "SEARCH was user initiated: " + Boolean(search.userInitiated));
	var results = result && result.getResponse();
	if (!results) { return; }

	if (!results.type) {
		results.type = search.types.get(0);
	}

	this.currentSearch = search;
	DBG.timePt("execute search", true);

	if (!noRender) {
		this._showResults(results, search, noUpdateOverview);
	}

	if (callback) {
		callback.run(result);
	}
};

/**
 * Takes the search result and hands it to the appropriate controller for display.
 *
 * @param {ZmSearch}	search			contains search info used to run search against server
 * @param {AjxCallback}	callback		the callback to run after generating offline result
 */
ZmSearchController.prototype._handleOfflineDoSearch =
function(search, callback) {
	//force webclient offline mode into msg view for mail search
	if (search.types && search.types.replaceObject(ZmItem.CONV, ZmItem.MSG)) {
		search.isDefaultToMessageView = true;
	}
    var respCallback = this._handleOfflineResponseDoSearch.bind(this, search, callback);
    ZmOfflineDB.search(search, respCallback);
};

/**
 * @private
 */
ZmSearchController.prototype._showResults =
function(results, search, noUpdateOverview) {

	this._results = results = (results && results.isZmSearchResult) ? results : new ZmSearchResult(search);

	DBG.timePt("handle search results");

    var ac = window.parentAppCtxt || window.appCtxt;
	if (ac.get(ZmSetting.SAVED_SEARCHES_ENABLED)) {
		var saveBtn = this._searchToolBar && this._searchToolBar.getButton(ZmSearchToolBar.SAVE_BUTTON);
		if (saveBtn) {
			saveBtn.setEnabled(this._contactSource != ZmId.SEARCH_GAL);
		}
	}

	var app = search.calController ? ac.getApp(ZmApp.CALENDAR) : ac.getApp(ZmItem.APP[results.type]) || ac.getCurrentApp();
	var appName = app.getName();
	if (search.userInitiated && ZmApp.SEARCH_RESULTS_TAB[appName]) {
		var ctlr = (search.calController && search.calController.searchResultsController) ||
					ac.getApp(ZmApp.SEARCH).getSearchResultsController(search.sessionId, appName);
		DBG.println("sr", "New search results controller: " + ctlr.viewId);
		ctlr.show(results, search.calController);
		this._searchToolBar.setSearchFieldValue("");
	}
	else if (app.showSearchResults) {
		// show results based on type - may invoke package load
		var loadCallback = this._handleLoadShowResults.bind(this, results, search, noUpdateOverview);
		app.currentSearch = search;
		app.currentQuery = search.query;
		app.showSearchResults(results, loadCallback);
	}
};

// Opens a new, empty search tab
ZmSearchController.prototype.openNewSearchTab = function() {
	this._toolbarSearch({
		isEmpty:    true,
		origin:     ZmId.SEARCH
	});
};

/**
 * @private
 */
ZmSearchController.prototype._handleLoadShowResults =
function(results, search, noUpdateOverview) {
	appCtxt.setCurrentList(results.getResults(results.type));
	if (!noUpdateOverview) {
		this.updateOverview(search);
	}
	DBG.timePt("render search results");
};

/**
 * Handle a few minor errors where we show an empty result set and issue a
 * status message to indicate why the query failed. Those errors are: no such
 * folder, no such tag, and bad query. If it's a "no such folder" error caused
 * by the deletion of a folder backing a mountpoint, we pass it along for
 * special handling by ZmZimbraMail.
 *
 * @private
 */
ZmSearchController.prototype._handleErrorDoSearch =
function(search, ex) {
	DBG.println(AjxDebug.DBG1, "Search exception: " + ex.code);
    if (ex.code == ZmCsfeException.MAIL_NO_SUCH_TAG ||
		ex.code == ZmCsfeException.MAIL_QUERY_PARSE_ERROR ||
		ex.code == ZmCsfeException.MAIL_TOO_MANY_TERMS ||
		(ex.code == ZmCsfeException.MAIL_NO_SUCH_FOLDER && !(ex.data.itemId && ex.data.itemId.length)))
	{
		var msg = ex.getErrorMsg();
		appCtxt.setStatusMsg(msg, ZmStatusView.LEVEL_WARNING);
		return true;
	}
	return false;
};

/**
 * Provides a string to add to the query when the search includes shared items.
 * 
 * @param {String} type		item type
 * 
 * @private
 */
ZmSearchController.generateQueryForShares =
function(type, account) {
	var ac = window.parentAppCtxt || window.appCtxt;
	var list = [];
	var app = ac.getApp(ZmItem.APP[type]);
	if (!app) {
		return null;
	}
	var ids = app.getRemoteFolderIds(account);
	for (var i = 0; i < ids.length; i++) {
		var id = ids[i];
		var idText = AjxUtil.isNumeric(id) ? id : ['"', id, '"'].join("");
		list.push("inid:" + idText);
	}

	if (list.length > 0) {
		list.push("is:local");
		return list.join(" OR ");
	}

	return null;
};

// called when the search button has been pressed
ZmSearchController.prototype._searchButtonListener =
function(ev) {
	this._toolbarSearch({
				ev:				ev,
				zimletEvent:	"onSearchButtonClick",
				origin:			ZmId.SEARCH
			});
};

/**
 * Runs a search based on the state of the toolbar.
 * 
 * @param {Hash}	params		a hash of parameters:
 * 
 * @param {Event}		ev							browser event	
 * @param {string}		zimletEvent					type of notification to send zimlets
 * @param {string}		query						search string (optional, overrides input field)
 * @param {Boolean}     isEmpty                     force a search for ""
 * @param {string}		origin						indicates what initiated the search
 * @param {string}		sessionId					session ID of search results tab (if search came from one)
 * @param {boolean}		skipUpdateSearchToolbar     don't update the search toolbar (e.g. from the ZmDumpsterDialog where the search is called from its own search toolbar
 * @param {String}		sortBy
 * 
 * @private
 */
ZmSearchController.prototype._toolbarSearch =
function(params) {

	// find out if the custom search menu item is selected and pass it the event
	var result = params.searchFor || this._searchToolBar.getSearchType();
	if (result && result.listener) {
		result.listener.run(params.ev);
	} else {
		var queryString = !params.isEmpty ? params.query || this._searchToolBar.getSearchFieldValue() : "";
		var userText = (queryString.length > 0);
		if (queryString) {
			this._currentQuery = null;
		} else {
			queryString = this._currentQuery || "";
		}

		appCtxt.notifyZimlets(params.zimletEvent, [queryString]);
		var searchParams = {
			query:						queryString,
			userText:					userText,
			userInitiated:				true,
			getHtml:					appCtxt.get(ZmSetting.VIEW_AS_HTML),
			searchFor:					result,
			skipUpdateSearchToolbar:	params.skipUpdateSearchToolbar,
			origin:						params.origin,
			sessionId:					params.sessionId,
			errorCallback:				params.errorCallback,
			sortBy:						params.sortBy,
			isEmpty:					params.isEmpty || !queryString
		};
		this.search(searchParams);
	}
};

/**
 * @private
 */
ZmSearchController.prototype._searchMenuListener =
function(ev, id, noFocus) {
	var btn = this._searchToolBar.getButton(ZmSearchToolBar.TYPES_BUTTON);
	if (!btn) { return; }

	var menu = btn.getMenu();
	var item = ev ? ev.item : (menu.getItemById(ZmOperation.MENUITEM_ID, id));

	if (!item || (!!(item._style & DwtMenuItem.SEPARATOR_STYLE))) { return; }
	id = item.getData(ZmOperation.MENUITEM_ID);

	var selItem = menu.getSelectedItem();
	var sharedMI = menu.getItemById(ZmOperation.MENUITEM_ID, ZmId.SEARCH_SHARED);

	// enable shared menu item if not a gal search
	if (id == ZmId.SEARCH_GAL) {
		this._contactSource = ZmId.SEARCH_GAL;
		if (sharedMI) {
			sharedMI.setChecked(false, true);
			sharedMI.setEnabled(false);
		}
	} else {
		if (sharedMI) {
			// we allow user to check "Shared Items" for appointments since it
			// is based on whats checked in their tree view
			if (id == ZmItem.APPT || id == ZmId.SEARCH_CUSTOM) {
				if (this._sharedMenuItemChecked == null) {
					this._sharedMenuItemChecked = sharedMI.getChecked();
				}
				sharedMI.setChecked(false, true);
				sharedMI.setEnabled(false);
			} else {
				sharedMI.setEnabled(true);
				if (this._sharedMenuItemChecked) {
					sharedMI.setChecked(true, true);
				}
				this._sharedMenuItemChecked = null;
			}
		}
		this._contactSource = ZmItem.CONTACT;
	}
	this._inclSharedItems = sharedMI && sharedMI.getChecked();

	// search all accounts? Only applies to multi-account mbox
	var allAccountsMI = menu.getItemById(ZmOperation.MENUITEM_ID, ZmId.SEARCH_ALL_ACCOUNTS);
	if (allAccountsMI) {
		if (id == ZmItem.APPT) {
			this.resetSearchAllAccounts();
			allAccountsMI.setEnabled(false);
		} else {
			allAccountsMI.setEnabled(true);
			this.searchAllAccounts = allAccountsMI && allAccountsMI.getChecked();
		}
	}

	if (id == ZmId.SEARCH_SHARED) {
		var icon = this.searchAllAccounts
			? allAccountsMI.getImage() : selItem.getImage();

		if (this._inclSharedItems) {
			icon = this._getSharedImage(selItem);
		}

		btn.setImage(icon);
	}
	else if (id == ZmId.SEARCH_ALL_ACCOUNTS) {
		var icon = (this.searchAllAccounts && !this._inclSharedItems)
			? item.getImage()
			: (this._inclSharedItems) ? this._getSharedImage(selItem) : selItem.getImage();
		btn.setImage(icon);
	}
	else {
		// only set search for if a "real" search-type menu item was clicked
		this._searchFor = id;
		var icon = item.getImage();

		if (this._inclSharedItems) {
			icon = this._getSharedImage(selItem);
		}
		else if (this.searchAllAccounts) {
			icon = allAccountsMI.getImage();
		}

		btn.setImage(icon);
	}

	// set button tooltip
	var tooltip = ZmMsg[ZmSearchToolBar.TT_MSG_KEY[id]];
	if (id != ZmId.SEARCH_SHARED && id != ZmId.SEARCH_ALL_ACCOUNTS) {
		btn.setToolTipContent(tooltip);
		btn.setAttribute('aria-label', tooltip);
	}
	
	if (!noFocus) {
		// restore focus to INPUT if user changed type
		setTimeout(this._searchToolBar.focus.bind(this._searchToolBar), 10);
	}
};

/**
 * @private
 */
ZmSearchController.prototype._getSharedImage =
function(selItem) {
	var selItemId = selItem && selItem.getData(ZmOperation.MENUITEM_ID);
	return (selItemId && ZmSearchToolBar.SHARE_ICON[selItemId])
		? ZmSearchToolBar.SHARE_ICON[selItemId]
		: ZmSearchToolBar.ICON[selItemId]; //use regular icon if no share icon
};

/**
 * @private
 */
ZmSearchController.prototype._getNormalizedId =
function(id) {
	var nid = id;

	var acct = appCtxt.getActiveAccount();
	if (!acct.isMain && id.indexOf(":") == -1) {
		nid = acct.id + ":" + id;
	}

	return nid;
};

/**
 * Takes the search result and hands it to the appropriate controller for display.
 *
 * @param {ZmSearch}	search			contains search info used to run search against server
 * @param {AjxCallback}	callback		online response callback to run after generating search response
 * @param {Object}	    result			the object stored in indexedDB
 *
 * @private
 */
ZmSearchController.prototype._handleOfflineResponseDoSearch =
function(search, callback, result) {

    if (search.sortBy === ZmSearch.DATE_DESC) {
		//Sort by received date descending
		result.sort(function(a, b) {
			return b.d - a.d;
	    });
    }
	else if (search.sortBy === ZmSearch.DATE_ASC) {
	    //Sort by received date ascending
	    result.sort(function(a, b) {
		    return a.d - b.d;
	    });
    }

    var searchResult = new ZmSearchResult(search);
    if (search.searchFor === ZmId.SEARCH_MAIL || search.parsedSearchFor === ZmId.SEARCH_MAIL) {
        search.types =  new AjxVector([ZmItem.MSG]);
        searchResult.set({m : result});
    }
    else if (search.searchFor === ZmItem.CONTACT || search.contactSource === ZmItem.CONTACT) {
        searchResult.set({cn : result});
    }
    var zmCsfeResult = new ZmCsfeResult(searchResult);
    callback(zmCsfeResult);

    if (search.folderId == ZmFolder.ID_OUTBOX || search.folderId == ZmFolder.ID_DRAFTS) {
		ZmOffline.updateFolderCountCallback(search.folderId, result.length);
    }
};

ZmSearchController.prototype._addOfflineDrafts =
function(search, result) {
    var callback = this._addOfflineDraftsCallback.bind(this, search, result);
    var key = {methodName : "SaveDraftRequest"};
    ZmOfflineDB.getItemInRequestQueue(key, callback, callback);
};

ZmSearchController.prototype._addOfflineDraftsCallback =
function(search, result, newResult) {
    var respEl = ZmOffline.generateMsgResponse(newResult);
    this._handleResponseDoIndexedDBSearch(search, [].concat(result).concat(respEl));
};
}
if (AjxPackage.define("zimbraMail.share.controller.ZmOverviewController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the overview controller.
 *
 */

/**
 * Creates an overview as a set of tree views. When the overview is created, various
 * characteristics of its tree views can be provided. Each type of tree view
 * has a corresponding tree controller (also a singleton), which is lazily
 * created.
 * @class
 * This singleton class manages overviews, each of which has a unique ID.
 *
 * @author Conrad Damon
 * 
 * @param {DwtControl}	container	the top-level container
 * 
 * @extends		ZmController
 */
ZmOverviewController = function(container) {
	ZmController.call(this, container);

	this._overviewContainer = {};
	this._overview			= {};
	this._controller		= {};
	this._appOverviewId		= {};
};

// Controller for given org type
ZmOverviewController.CONTROLLER = {};

ZmOverviewController.DEFAULT_FOLDER_ID = ZmFolder.ID_INBOX;

ZmOverviewController.prototype = new ZmController;
ZmOverviewController.prototype.constructor = ZmOverviewController;

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmOverviewController.prototype.toString = 
function() {
	return "ZmOverviewController";
};

/**
 * Creates a new overview container with the given options. Used when mailbox
 * has multiple accounts.
 *
 * @param {Hash}	containerParams	a hash of params (see {@link ZmOverviewContainer})
 * @param {Hash}	overviewParams	a hash of params (see {@link ZmOverview})
 */
ZmOverviewController.prototype.createOverviewContainer =
function(containerParams, overviewParams) {
	containerParams.parent = containerParams.parent || this._shell;
	containerParams.controller = this;
	containerParams.id = ZmId.getOverviewContainerId(containerParams.containerId);

	// the overview container will create overviews for each account
	var container = this._overviewContainer[containerParams.containerId] =
		new ZmAccountOverviewContainer(containerParams);

	// we call initialize *after* creating new object since it references
	// this._overviewContainer hash
	overviewParams.containerId = containerParams.id;
	container.initialize(overviewParams);

	return container;
};

/**
 * Creates a new overview with the given options.
 *
 * @param {Hash}	params			a hash of params (see {@link ZmOverview})
 */
ZmOverviewController.prototype.createOverview =
function(params) {
	params.parent = params.parent || this._shell;

	var ov = this._overview[params.overviewId] = new ZmOverview(params, this);
	return ov;
};

/**
 * Gets the overview container for the given app.
 *
 * @param {String}	containerId		the container ID (defaults to current app name)
 * @return	{ZmOverviewContainer}	the container
 */
ZmOverviewController.prototype.getOverviewContainer =
function(containerId) {
	var containerId = containerId || appCtxt.getCurrentAppName();
	return this._overviewContainer[containerId];
};

/**
 * Gets the overview with the given id.
 *
 * @param {String}	overviewId		the overview id
 * @return	{ZmOverview}	the overview
 */
ZmOverviewController.prototype.getOverview =
function(overviewId) {
	return this._overview[overviewId];
};

/**
 * Gets the tree controller.
 *
 * @param {String}	treeId		the tree id
 * @param {Boolean}	noCreate		if <code>true</code>, only return an already created controller
 * 
 * @return	{ZmTreeController}	the tree controller
 */
ZmOverviewController.prototype.getTreeController =
function(treeId, noCreate) {
	if (!treeId) { return null; }
	if (!this._controller[treeId] && !noCreate) {
		var className = ZmOverviewController.CONTROLLER[treeId];
		if (className && window[className]) { // make sure the class has been loaded
			var treeControllerCtor = eval(ZmOverviewController.CONTROLLER[treeId]);
			if (treeControllerCtor) {
				this._controller[treeId] = new treeControllerCtor(treeId);
			}
		}
	}
	return this._controller[treeId];
};

/**
 * Gets the tree data for the given organizer type.
 *
 * @param {String}	treeId		the tree id
 * @return {ZmTree}		the tree
 */
ZmOverviewController.prototype.getTreeData =
function(treeId) {
	return treeId ? appCtxt.getTree(treeId) : null;
};

/**
 * Gets the tree view in the given overview.
 *
 * @param {String}	overviewId		the overview id
 * @param {String}	treeId			the organizer type
 * @return	{ZmTreeView}	the tree view or <code>null</code> if not found
 */
ZmOverviewController.prototype.getTreeView =
function(overviewId, treeId) {
	if (!overviewId || !treeId) { return null; }
	if (!this.getOverview(overviewId)) { return null; }
	return this.getOverview(overviewId).getTreeView(treeId);
};
}

if (AjxPackage.define("zimbraMail.core.ZmAppViewMgr")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the application view manager class.
 * 
 */
/**
 * Creates a layout manager from the given components.
 * @class
 * This class performs view and layout management. It expects there to be an HTML "skin" with
 * containers for various components. A container is an empty DIV with a known ID, so that we
 * can use it to place the corresponding component's content. A component is a widget; it is
 * the widget's HTML element that is positioned and sized based on the container's location and
 * size. The containers are part of the flow (they are positioned relatively), so their location
 * and size should be adjusted when necessary by the browser. The components are not children of
 * their containers within the DOM tree; they are children of the shell, and are positioned
 * absolutely. There appears to be a performance gain in keeping our HTML elements closer to the
 * top of the DOM tree, possibly because events do not propagate as far.
 * 
 * A handful of components are positioned statically. Those are generally the ones that appear
 * in the top row: banner, user info, etc. The positioning style is set through skin hints.
 * <br/>
 * <br/>
 * The following containers/components are supported:
 *
 * <ul>
 *  <li>banner: displays logo</li>
 *  <li>user info: user name</li>
 *  <li>quota: quota bar</li>
 *  <li>search bar: a text input and a few buttons</li>
 *  <li>search results toolbar: search tab only</li>
 *  <li>app chooser: a toolbar with buttons for changing apps</li>
 *  <li>new button: button for creating something new (email, contact, etc)</li>
 *  <li>tree: area on left that usually shows overview (folders, calendars, etc)</li>
 *  <li>tree footer: optionally displays mini-calendar</li>
 *  <li>top toolbar: a view-specific toolbar</li>
 *  <li>app content: used to present data to the user</li>
 *  <li>sash: a thin moveable vertical bar for resizing tree width</li>
 * </ul>
 *
 * <br/>
 * <br/>
 * In general, the app view manager responds to changes in the skin by having each of the
 * affected components adapt to its container's new location and/or size. That means that
 * we are dependent on the browser to relocate and resize the containers within the skin
 * properly.
 * <br/>
 * <br/>
 * The top and bottom toolbars and the app content are treated somewhat differently: they
 * come under the purview of "app view management". In general, an application represents a
 * view with a toolbar and a content area (which is often a list view). App view management
 * allows these views to be pushed and popped as if they were in a stack. That way, the views
 * only need be constructed once each.
 * <br/>
 * <br/>
 * The app view components are hidden and shown using two methods: z-index and relocation. 
 * Since every component hangs off the shell, it must have a z-index of at least Z_VIEW
 * (300) to be visible. It can be hidden by setting its z-index to Z_HIDDEN (100). Since
 * both IE and Firefox have display bugs related to the use of z-index, we use relocation as
 * well: a hidden component is positioned way off the screen. (In IE, SELECT fields don't
 * obey z-index, and in Firefox, the cursor bleeds through.) Note: the above was true in 2005,
 * and we haven't rewritten the app view manager substantially since then. Some day we may just
 * append the elements to their parent containers within the DOM, but until then we'll do
 * absolute positioning.
 * <br/>
 * <br/>
 * A view can open in a tab (in the row of app buttons) rather than replacing the current view. Those
 * are handled in essentially the same way (view push and pop), but they also manage the app button.
 * We currently manage only a single view in a tab.
 *
 * @author Conrad Damon
 * 
 * @param {DwtShell}		shell			the outermost containing element
 * @param {ZmController}	controller		the app controller
 * @param {Boolean}			isNewWindow		if <code>true</code>, we are a child window of the main app
 * @param {Boolean}			hasSkin			if <code>true</code>, the app has provided containing HTML
 */
ZmAppViewMgr = function(shell, controller, isNewWindow, hasSkin) {

	ZmAppViewMgr._setContainerIds();

	this._shell = shell;
	this._controller = controller;
	this._isNewWindow = isNewWindow;
	this._hasSkin = hasSkin;

	this._shellSz = this._shell.getSize();
	this._shell.addControlListener(this._shellControlListener.bind(this));
	this._sashSupported = (window.skin && typeof window.skin.setTreeWidth == "function");

	// history support
	if (appCtxt.get(ZmSetting.HISTORY_SUPPORT_ENABLED) && !isNewWindow && !AjxEnv.isPrism) {
		this._historyMgr = appCtxt.getHistoryMgr();
		this._historyMgr.addListener(this._historyChangeListener.bind(this));
	}
	this._hashViewId			= {};		// matches numeric hash to its view
	this._nextHashIndex			= 0;		// index for adding to browser history stack
	this._curHashIndex			= 0;		// index of current location in browser history stack
	this._noHistory				= false;	// flag to prevent history ops as result of programmatic push/pop view
	this._ignoreHistoryChange	= false;	// don't push/pop view as result of history.back() or history.forward()

	this._lastViewId	= null;	// ID of previously visible view
	this._currentViewId	= null;	// ID of currently visible view
	this._hidden		= [];	// stack of views that aren't visible
	this._toRemove		= [];	// views to remove from hidden on next view push

	this._view		= {};	// information about each view (components, controller, callbacks, app, etc)
	this._component	= {};	// component data (container, bounds, current control)
	this._app		= {};	// app info (current view)
	
	// reduce need for null checks
	this._emptyView = {component:{}, callback:{}, hide:{}};
	
	// Hashes keyed by tab ID
	this._viewByTabId = {};	// view for the given tab
	
	// view pre-emption
	this._pushCallback = this.pushView.bind(this);
	this._popCallback = this.popView.bind(this);
	
	// placeholder view
	this._createLoadingView();
};

ZmAppViewMgr.prototype.isZmAppViewMgr = true;
ZmAppViewMgr.prototype.toString = function() { return "ZmAppViewMgr"; };

// Components. A component must be a DwtControl. These component names must match the ones
// used in ZmSkin.

// components that are visible by default
ZmAppViewMgr.C_BANNER					= "banner";
ZmAppViewMgr.C_USER_INFO				= "userInfo";
ZmAppViewMgr.C_QUOTA_INFO				= "quota";
ZmAppViewMgr.C_SEARCH					= "search";
ZmAppViewMgr.C_APP_CHOOSER				= "appChooser";
ZmAppViewMgr.C_TREE						= "tree";
ZmAppViewMgr.C_TOOLBAR_TOP				= "topToolbar";
ZmAppViewMgr.C_NEW_BUTTON				= "newButton";
ZmAppViewMgr.C_APP_CONTENT				= "main";
ZmAppViewMgr.C_SASH						= "sash";

// components that are hidden by default
ZmAppViewMgr.C_TREE_FOOTER				= "treeFooter";
ZmAppViewMgr.C_SEARCH_RESULTS_TOOLBAR	= "searchResultsToolbar";

// Components that make up the left nav, which we may want to hide
ZmAppViewMgr.LEFT_NAV = [ ZmAppViewMgr.C_NEW_BUTTON, ZmAppViewMgr.C_TREE, ZmAppViewMgr.C_TREE_FOOTER, ZmAppViewMgr.C_SASH ];

// deprecated, unused, and obsolete components

//ZmAppViewMgr.C_TOOLBAR_BOTTOM			= "bottomToolbar";
//ZmAppViewMgr.C_APP_CONTENT_FULL		= "fullScreen";
//ZmAppViewMgr.C_AD						= "adsrvc";
//ZmAppViewMgr.C_FOOTER					= "footer";
//ZmAppViewMgr.C_UNITTEST				= "unittest";
//ZmAppViewMgr.C_SEARCH_BUILDER			= "searchBuilder";
//ZmAppViewMgr.C_SEARCH_BUILDER_TOOLBAR	= "searchBuilderToolbar";
//ZmAppViewMgr.C_STATUS					= "status";

// Constants used to control component mappings and visibility
ZmAppViewMgr.GLOBAL	= "Global";
ZmAppViewMgr.APP	= "App";

// keys for getting container IDs
ZmAppViewMgr.CONT_ID_KEY = {};

// callbacks
ZmAppViewMgr.CB_PRE_HIDE	= "PRE_HIDE";
ZmAppViewMgr.CB_POST_HIDE	= "POST_HIDE";
ZmAppViewMgr.CB_PRE_SHOW	= "PRE_SHOW";
ZmAppViewMgr.CB_POST_SHOW	= "POST_SHOW";
ZmAppViewMgr.CB_PRE_UNLOAD	= "PRE_UNLOAD";
ZmAppViewMgr.CB_POST_REMOVE	= "POST_REMOVE";

// used to continue when returning from callbacks
ZmAppViewMgr.PENDING_VIEW = "ZmAppViewMgr.PENDING_VIEW";

// history support
ZmAppViewMgr.BROWSER_BACK		= "BACK";
ZmAppViewMgr.BROWSER_FORWARD	= "FORWARD";

ZmAppViewMgr.TAB_BUTTON_MAX_TEXT = 15;

ZmAppViewMgr._setContainerIds =
function() {
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_BANNER]					= ZmId.SKIN_LOGO;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_USER_INFO]				= ZmId.SKIN_USER_INFO;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_QUOTA_INFO]				= ZmId.SKIN_QUOTA_INFO;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_SEARCH]					= ZmId.SKIN_SEARCH;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_SEARCH_RESULTS_TOOLBAR]	= ZmId.SKIN_SEARCH_RESULTS_TOOLBAR;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_APP_CHOOSER]			= ZmId.SKIN_APP_CHOOSER;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_TREE]					= ZmId.SKIN_TREE;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_TREE_FOOTER]			= ZmId.SKIN_TREE_FOOTER;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_TOOLBAR_TOP]			= ZmId.SKIN_APP_TOP_TOOLBAR;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_NEW_BUTTON]				= ZmId.SKIN_APP_NEW_BUTTON;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_APP_CONTENT]			= ZmId.SKIN_APP_MAIN;
	ZmAppViewMgr.CONT_ID_KEY[ZmAppViewMgr.C_SASH]					= ZmId.SKIN_SASH;

	ZmAppViewMgr.ALL_COMPONENTS = AjxUtil.keys(ZmAppViewMgr.CONT_ID_KEY);
};


// Public methods

/**
 * Returns the requested component (widget) for the given view. The search is done
 * in the following order:
 * 		1. A component particular to that view
 * 		2. A component associated with the view's app
 * 		3. A global component	
 * 
 * @param {constant}	cid			component ID
 * @param {constant}	viewId		view ID
 */
ZmAppViewMgr.prototype.getViewComponent =
function(cid, viewId) {
	var view = this._view[viewId || this._currentViewId] || this._emptyView;
	var app = view.app || appCtxt.getCurrentAppName();
	var appView = this._view[app];
	var globalView = this._view[ZmAppViewMgr.GLOBAL];
	return ((view && view.component[cid]) ||
			(appView && appView.component[cid]) ||
			(globalView && globalView.component[cid]));
};
ZmAppViewMgr.prototype.getCurrentViewComponent = ZmAppViewMgr.prototype.getViewComponent;

// Returns the view based on the ID, handling global and app views
ZmAppViewMgr.prototype._getView =
function(viewId, app) {
	var view;
	if (viewId == ZmAppViewMgr.GLOBAL) {
		view = this._view[viewId] || this.createView({ viewId:viewId }); 
	}
	else if (viewId == ZmAppViewMgr.APP) {
		viewId = app || appCtxt.getCurrentAppName();
		view = this._view[viewId] || this.createView({ viewId:viewId }); 
	}
	else {
		view = this._view[viewId || this._currentViewId] || this.createView({ viewId:viewId }); 
	}
	return view;
};

/**
 * Registers the given components with the app view manager, and optionally displays them.
 *
 * @param	{constant}	viewId		the view id
 * @param	{hash}		components	a hash of component IDs and matching objects
 * @param	{boolean}	show		if <code>true</code>, show the components
 * @param	{constant}	app			name of app (for view ZmAppViewMgr.APP)
 */
ZmAppViewMgr.prototype.setViewComponents =
function(viewId, components, show, app) {

	DBG.println("avm", "-------------- SET components: " + AjxUtil.keys(components));
		
	// set up to add component to the appropriate map: global, app, or local
	var view = this._getView(viewId, app);
	if (!view) { return; }

	var i = 0;
	var numComponents = AjxUtil.arraySize(components);
	for (var cid in components) {
		var comp = components[cid];
		if (!comp) { continue; }
		if (this.isHidden(cid, viewId)) { continue; }
		
		var doShow = show && !this.isHidden(cid, this._currentViewId);
		if (doShow) {
			// if we're replacing a visible component, hide the old one
			var oldComp = this._component[cid] && this._component[cid].control;
			if (oldComp && (oldComp != comp)) {
				this.showComponent(cid, false, oldComp);
			}
		}
		
		view.component[cid] = comp;
		
		if (this._hasSkin) {
			this.getContainer(cid, comp);
		}

		this.displayComponent(cid, doShow, false, null, true);

		// TODO: move this code
		if (cid == ZmAppViewMgr.C_SASH) {
			if (this._sashSupported){
				comp.registerCallback(this._appTreeSashCallback, this);
				if (appCtxt.get(ZmSetting.FOLDER_TREE_SASH_WIDTH)) {
					var newWidth =  appCtxt.get(ZmSetting.FOLDER_TREE_SASH_WIDTH);
					var oldWidth = skin.getTreeWidth();
					this._appTreeSashCallback(newWidth - oldWidth);
				}
			}
			comp.setCursor("default");
		}
		i++;
	}
	if (show) {
		this.fitAll();
	}
};
ZmAppViewMgr.prototype.addComponents = ZmAppViewMgr.prototype.setViewComponents;

/**
 * Returns true if the given component should be hidden. Checks local, app, and then
 * global levels. At any level, the presence of a component trumps whether it is supposed
 * to be hidden.
 * 
 * @param {constant}	cid			component ID
 * @param {constant}	viewId		view ID
 */
ZmAppViewMgr.prototype.isHidden =
function(cid, viewId) {

	var view = this._view[viewId || this._currentViewId] || this._emptyView;
	var app = view.app || appCtxt.getCurrentAppName();
	var appView = this._view[app];
	var globalView = this._view[ZmAppViewMgr.GLOBAL];
	
	if		(view && view.component[cid])				{ return false; }	// view has comp
	else if (view && view.hide[cid])					{ return true; }	// view says hide
	else if (appView && appView.component[cid])			{ return false; }	// app has comp
	else if (appView && appView.hide[cid])				{ return true; }	// app says hide
	else if (globalView && globalView.component[cid])	{ return false; }	// global comp
	else												{ return globalView && globalView.hide[cid]; }	// global hide
};

/**
 * Sets whether the given components should be hidden. That setting can appear at any
 * of three levels: global, app, or local.
 * 
 * @param	{constant}	viewId		the view id
 * @param	{array}		cidList		list of component IDs
 * @param	{boolean}	hide		if <code>true</code>, hide the components
 * @param	{constant}	app			name of app (for view ZmAppViewMgr.APP)
 */
ZmAppViewMgr.prototype.setHiddenComponents =
function(viewId, cidList, hide, app) {

	cidList = AjxUtil.toArray(cidList);

	// set up to add component to the appropriate map: global, app, or local
	var view = this._getView(viewId, app);
	if (!view) { return; }

	for (var i = 0; i < cidList.length; i++) {
		view.hide[cidList[i]] = hide;
	}
};

/**
 * Shows or hides the skin element (not always the same as the container) for a given
 * component.
 * 
 * @param {constant}	cid			the component ID
 * @param {boolean}		show		if true, show the skin element; otherwise hide it
 * @param {boolean}		noReflow	if true, tell skin to not refit all components
 */
ZmAppViewMgr.prototype.showSkinElement =
function(cid, show, noReflow) {
	if (this._hasSkin) {
		DBG.println("avm", (show ? "SHOW " : "HIDE ") + "SKIN element for: " + cid);
		skin.show(cid, show, noReflow);
	}
};

/**
 * Shows or hides the given component. It may still need to be positioned.
 * 
 * @param {constant}	cid		the component ID
 * @param {boolean}		show	if true, show the component; otherwise hide it
 * @param {DwtControl}	comp	component (optional)
 */
ZmAppViewMgr.prototype.showComponent =
function(cid, show, comp) {
	
	comp = comp || this.getViewComponent(cid);
	
	if (comp) {
		DBG.println("avm", (show ? "SHOW " : "HIDE ") + cid + " / " + comp.toString() + " / " + comp._htmlElId);
		if (show) {
			comp.zShow(true);
			comp.noTab = false;
		}
		else {
			if (comp.getPosition() == Dwt.ABSOLUTE_STYLE) {
				comp.setLocation(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
			}
			comp.zShow(false);
			comp.noTab = true;
		}
	}
};

/**
 * Handles several tasks needed to make sure a component is actually visible.
 * 
 * @param {constant}	cid		the component ID
 * @param {boolean}		show	if true, show the component; otherwise hide it
 * @param {boolean}		doFit	if true, fit component to container
 * @param {object}		comp	if provided, pass this to showComponent, so it does not just look for the cid in the current view (useful for previous view. see ZmAppViewMgr.prototype._setViewVisible)
 * @param {boolean}		noReflow	if true, tell skin to not refit all components
 */
ZmAppViewMgr.prototype.displayComponent =
function(cid, show, doFit, comp, noReflow) {
	this.showSkinElement(cid, show, noReflow);
	this.showComponent(cid, show, comp);
	if (doFit) {
		this._fitToContainer(cid);
	}
};

/**
 * Returns the requested container.
 * 
 * @param cid
 * @param comp
 */
ZmAppViewMgr.prototype.getContainer =
function(cid, comp) {

	var component = this._component[cid] = this._component[cid] || {};
	
	if (!component.container) {
		var contId = ZmAppViewMgr.CONT_ID_KEY[cid];
		var contEl = document.getElementById(contId);
		if (!contEl) {
			// skin may want to omit certain containers
			DBG.println(AjxDebug.DBG2, "Skin container '" + contId + "' not found.");
			return null;
		}
		component.container = contEl;
		if (comp) {
			contEl.innerHTML = "";

			// if the container has bounds, fit the component to it now to prevent resize flash
			var bounds = this._getContainerBounds(cid);
			var toolbarExists = Boolean(this.getViewComponent(ZmAppViewMgr.C_TOOLBAR_TOP));
			if (bounds) {
				DBG.println("avm", "SET BOUNDS " + cid + ": " + [bounds.x, bounds.y, bounds.width, bounds.height].join("/"));
				comp.setBounds(bounds.x, bounds.y, bounds.width, bounds.height, toolbarExists);
			}
		}
	}
	
	return component.container;
};

/**
 * Gets the ID of the view currently being displayed.
 * 
 * @return	{string}	the view id
 */
ZmAppViewMgr.prototype.getCurrentViewId =
function() {
	return this._currentViewId;
};

/**
 * Gets the type of the view currently being displayed.
 * 
 * @return	{string}	the view type
 */
ZmAppViewMgr.prototype.getCurrentViewType =
function() {
	var view = this._view[this._currentViewId];
	return view ? view.type : "";
};

/**
 * Gets the ID of the app view last displayed.
 * 
 * @return	{Object}	the last view
 */
ZmAppViewMgr.prototype.getLastViewId =
function() {
	return this._lastViewId;
};

/**
 * Gets the main content object of the given view.
 * 
 * @return	{Object}	the current main content view object
 */
ZmAppViewMgr.prototype.getCurrentView =
function(view) {
	return this.getViewComponent(ZmAppViewMgr.C_APP_CONTENT, view || this._currentViewId);
};

/**
 * Gets the current top-level view for the given app.
 *
 * @param {String}	app		the name of an app
 * 
 * @return	{string}	ID of the app's current view
 */
ZmAppViewMgr.prototype.getAppView =
function(app) {
	return this._app[app] && this._app[app].viewId;
};

/**
 * Sets the current top-level view for the given app. Should be called by an app (or controller) that
 * changes the top-level view of the app.
 *
 * @param {String}	app			the name of an app
 * @param {string}	viewId		the view ID
 */
ZmAppViewMgr.prototype.setAppView =
function(app, viewId) {
	if (!app || !viewId) { return; }
	var app = this._app[app];
	if (!app) {
		app = this._app[app] = {};
	}
	app.viewId = viewId;
};

/**
 * Returns a list of views of the given type. The views are the anonymous view objects used by the app view mgr.
 * 
 * @param {string}	type	a view type
 * @param {boolean}	visible if true, only return visible views
 */
ZmAppViewMgr.prototype.getViewsByType =
function(type, visible) {
	var list = [];
	for (var viewId in this._view) {
		var view = this._view[viewId];
		if (view.type == type && (!visible || view.visible)) {
			list.push(view);
		}
	}
	return list;
};

/**
 * Returns true if the given view is visible to the user.
 *
 * @param {string}  viewId  a view ID
 *
 * @returns {boolean}   true if the given view is visible to the user
 */
ZmAppViewMgr.prototype.isVisible = function(viewId) {

    var view = this._view[viewId];

    return view && view.visible;
};

/**
 * Registers a set of elements comprising an app view.
 *
 * @param	{Hash}			params				a hash of parameters
 * @param	{string}		params.viewId		the view ID
 * @param	{string}		params.viewType		the view type
 * @param	{String}		params.appName		the name of the owning app
 * @param	{Hash}			params.elements		a hash of elements
 * @param	{ZmController}	params.controller	controller responsible for this view
 * @param	{Hash}			params.callbacks 	a hash of functions to call before/after this view is shown/hidden
 * @param	{Boolean}		params.isAppView 	if <code>true</code>, this view is an app-level view
 * @param	{Boolean}		params.isTransient	if <code>true</code>, this view does not go on the hidden stack
 * @param	{Hash}			params.tabParams	the tab button params; view is opened in app tab instead of being stacked
 * @param	{Hash}			params.hide			components that aren't displayed in this view
 */
ZmAppViewMgr.prototype.createView =
function(params) {

	params = params || {};
	var viewId = params.viewId;
	if (!viewId) { return null; }
	DBG.println(AjxDebug.DBG1, "createView: " + viewId);

	var view = this._view[viewId] = {
		id:				viewId,
		type:			params.viewType || viewId,
		component:		params.elements || {},
		controller:		params.controller,
		callback:		params.callbacks || {},
		app:			params.appName,
		isAppView:		params.isAppView,
		isTransient:	params.isTransient,
		isFullScreen:	params.isFullScreen,
		hide:			AjxUtil.arrayAsHash(params.hide || [])
	};

	if (params.appName && !this._app[params.appName]) {
		this._app[params.appName] = {};
	}

	if (!this._isNewWindow && params.tabParams) {
		view.tabParams	= params.tabParams;
		view.isTabView = true;
		this._viewByTabId[params.tabParams.id] = viewId;
	}

	// Accessibility - let AT know this is the main content area
	var mainView = params.isAppView && params.elements && params.elements[ZmAppViewMgr.C_APP_CONTENT],
		mainEl = mainView && mainView.getHtmlElement();
	if (mainEl) {
		mainEl.setAttribute("role", "main");
	}

	return view;
};

/**
 * Makes the given view visible, pushing the previously visible one to the top of the
 * hidden stack.
 *
 * @param {int}		viewId		the ID of the app view to push
 * @param {Boolean}	force		if <code>true</code>, do not run callbacks
 *
 * @returns	{Boolean}	<code>true</code> if the view was pushed (is now visible)
 */
ZmAppViewMgr.prototype.pushView =
function(viewId, force) {

	if (!viewId) { return false; }
	DBG.println("avm", "------- PUSH view: " + viewId);
	
	viewId = this._viewByTabId[viewId] || viewId;
	var view = this._view[viewId] || this._emptyView;
	
	var isPendingView = (viewId == ZmAppViewMgr.PENDING_VIEW);
	if (!isPendingView && !view) {
		// view has not been created, bail
		return false;
	}

	if (isPendingView) {
		viewId = this._pendingView;
	}
	DBG.println(AjxDebug.DBG1, "pushView: " + viewId);

	var viewController = view.controller;

	// if same view, no need to hide previous view or check for callbacks
	//also no need to make the view visible, it already is.
	if (viewId == this._currentViewId) {
		// make sure the new content has focus
		if (viewController) {
			viewController._restoreFocus();
		}
		return true;
	}

	DBG.println(AjxDebug.DBG2, "hidden (before): " + this._hidden);

	if (view.isTabView) {
		var tp = view.tabParams;
		var handled = tp && tp.tabCallback && tp.tabCallback.run(this._currentViewId, viewId);
		if (tp && !handled) {
			var ac = appCtxt.getAppChooser();
			var button = ac.getButton(tp.id);
			if (!button) {
				button = ac.addButton(tp.id, tp);
				button.setHoverImage("Close", "right");
			}
		}
	}

	if (isPendingView) {
		DBG.println(AjxDebug.DBG1, "push of pending view: " + this._pendingView);
		force = true;
	}

	var curView = this._view[this._currentViewId] || this._emptyView;
	if (!this._hideView(this._currentViewId, force || curView.isTabView, false, viewId)) {
		this._pendingAction = this._pushCallback;
		this._pendingView = viewId;
		return false;
	}
	this.setViewComponents(viewId, view.component);

	var curViewController = curView.controller;
	var isTransient = curView.isTransient || (curViewController && curViewController.isTransient(this._currentViewId, viewId));
	if (this._currentViewId && (this._currentViewId != viewId) && !isTransient) {
		this._hidden.push(this._currentViewId);
	}

	this._removeFromHidden(viewId);
	var temp = this._lastViewId;
	this._lastViewId = this._currentViewId;
	this._currentViewId = viewId;
	DBG.println(AjxDebug.DBG2, "app view mgr: current view is now " + this._currentViewId);

	if (!this._showView(viewId, force, (viewId != this._currentViewId))) {
		this._currentViewId = this._lastViewId;
		this._lastViewId = temp;
		this._pendingAction = this._pushCallback;
		this._pendingView = viewId;
		return false;
	}
	DBG.println(AjxDebug.DBG2, "hidden (after): " + this._hidden);

	// a view is being pushed - add it to browser history stack unless we're
	// calling this function as a result of browser Back or Forward
	if (this._noHistory) {
		DBG.println(AjxDebug.DBG2, "noHistory: push " + viewId);
		this._noHistory = false;
	} else {
		if (viewId != ZmId.VIEW_LOADING) {
			this._nextHashIndex++;
			this._curHashIndex = this._nextHashIndex;
			this._hashViewId[this._curHashIndex] = viewId;
			DBG.println(AjxDebug.DBG2, "adding to browser history: " + this._curHashIndex + "(" + viewId + ")");
			if (this._historyMgr) {
				this._historyMgr.add(this._curHashIndex);
			}
		}
	}

	this._layout(this._currentViewId);

	if (viewController && viewController.setCurrentViewId) {
		viewController.setCurrentViewId(viewId);
	}
	if (view.isAppView) {
		this.setAppView(view.app, viewId);
	}
	
	if (this._toRemove.length) {
		for (var i = 0; i < this._toRemove.length; i++) {
			this._removeFromHidden(this._toRemove[i]);
		}
		this._toRemove = [];
	}

	return true;
};

/**
 * Hides the currently visible view, and makes the view on top of the hidden stack visible.
 *
 * @param	{Boolean}	force	if <code>true</code>, do not run callbacks (which check if popping is OK)
 * @param	{int}	viewId	the view ID. Only pop if this is current view
 * @returns	{Boolean}		<code>true</code> if the view was popped
 */
ZmAppViewMgr.prototype.popView =
function(force, viewId, skipHistory) {

	DBG.println("avm", "------- POP view: " + viewId);
	
	viewId = this._viewByTabId[viewId] || viewId;
	var view = this._view[viewId] || this._emptyView;

	if (!this._currentViewId) {
		DBG.println(AjxDebug.DBG1, "ERROR: no view to pop");
		return false;
	}

	var isPendingView = (force == ZmAppViewMgr.PENDING_VIEW);
	if (isPendingView) {
		viewId = force;
		force = true;
	}

	// a tab view is the only type of non-current view we can pop; if it is not the
	// current view, push it first so that callbacks etc work as expected
	if (viewId && !isPendingView && (this._currentViewId != viewId)) {
		if (view.isTabView && (this._currentViewId != viewId)) {
			this.pushView(viewId);
		}
		else {
			return false;
		}
	}

	// handle cases where there are no views in the hidden stack (entry via deep link)
	var noHide = false, noShow = false;
	var goToApp = null;
	var curView = this._view[this._currentViewId] || this._emptyView;
	if (!this._hidden.length && !this._isNewWindow) {
		noHide = !curView.isTabView;
		noShow = true;
		goToApp = appCtxt.getCurrentAppName() || appCtxt.startApp;
	}

	DBG.println(AjxDebug.DBG1, "popView: " + this._currentViewId);
	DBG.println(AjxDebug.DBG2, "hidden (before): " + this._hidden);
	if (!this._hideView(this._currentViewId, force, noHide)) {
		this._pendingAction = this._popCallback;
		this._pendingView = null;
		return false;
	}

	this._deactivateView(this._currentViewId);

	if (curView.isTabView) {
		appCtxt.getAppChooser().removeButton(curView.tabParams.id);
		var callback = curView.callback[ZmAppViewMgr.CB_POST_REMOVE];
		if (callback) {
			callback.run();
		}
	}
	
	if (noShow) {
		if (goToApp) {
			this._controller.activateApp(ZmApp.MAIL);
		}
		return !noHide;
	}

	this._lastViewId = this._currentViewId;
	this._currentViewId = this._hidden.pop();

	// close this window if no more views exist and it's a child window
	if (!this._currentViewId && this._isNewWindow) {
		window.close();
		return false;
	}

	DBG.println(AjxDebug.DBG2, "app view mgr: current view is now " + this._currentViewId);
	if (!this._showView(this._currentViewId, this._popCallback, null, force, true)) {
		DBG.println(AjxDebug.DBG1, "ERROR: pop with no view to show");
		return false;
	}
	this._removeFromHidden(this._currentViewId);
	DBG.println(AjxDebug.DBG2, "hidden (after): " + this._hidden);
	DBG.println(AjxDebug.DBG2, "hidden (" + this._hidden.length + " after pop): " + this._hidden);

	// Move one back in the browser history stack so that we stay in sync, unless
	// we're calling this function as a result of browser Back
	if (this._historyMgr && !skipHistory) {
		if (this._noHistory) {
			DBG.println(AjxDebug.DBG2, "noHistory (pop)");
			this._noHistory = false;
		} else {
			this._ignoreHistoryChange = true;
			history.back();
		}
	}

	this._layout(this._currentViewId);

	return true;
};

/**
 * Makes the given view visible, and clears the hidden stack.
 *
 * @param 	{int}	viewId		the ID of the view
 * @param 	{Boolean}	force		if <code>true</code>, ignore pre-emption callbacks
 * @returns	{Boolean}	<code>true</code> if the view was set
 */
ZmAppViewMgr.prototype.setView =
function(viewId, force) {
	DBG.println(AjxDebug.DBG1, "setView: " + viewId);
	var result = this.pushView(viewId, force);
	if (result) {
		for (var i = 0; i < this._hidden.length; i++) {
			this._deactivateView(this._hidden[i]);
		}
		this._hidden = [];
	}
	return result;
};

/**
 * Moves the given view to the top of the hidden stack, so that it will
 * appear when the current view is popped.
 * 
 * @param {int}	viewId		the ID of the view
 */
ZmAppViewMgr.prototype.stageView =
function(viewId) {
	DBG.println(AjxDebug.DBG1, "stageView: " + viewId);
	this._removeFromHidden(viewId);
	this._hidden.push(viewId);
};

/**
 * Checks if the view is the app view.
 * 
 * @param	{int}	viewId	the view id
 * @return	{Boolean}	<code>true</code> if the view is the app view
 */
ZmAppViewMgr.prototype.isAppView =
function(viewId) {
	var view = this._view[viewId || this._currentViewId] || this._emptyView;
	return view.isAppView;
};

/**
 * Returns true if the view is full screen.
 * 
 * @param	{constant}	viewId		the view id
 * @return	{boolean}	<code>true</code> if full screen
 */
ZmAppViewMgr.prototype.isFullScreen =
function(viewId) {
	var view = this._view[viewId || this._currentViewId] || this._emptyView;
	return view.isFullScreen;
};

/**
* Shows the view that was waiting for return from a popped view's callback. Typically, the
* popped view's callback will have put up some sort of dialog, and this function would be
* called by a listener on a dialog button.
*
* @param {Boolean}	show		if <code>true</code>, show the pending view
*/
ZmAppViewMgr.prototype.showPendingView =
function(show) {
	if (show && this._pendingAction) {
		this._pendingAction.run(ZmAppViewMgr.PENDING_VIEW);
	}

	// If a pop shield has been dismissed and we're not going to show the
	// pending view, and we got here via press of browser Back/Forward button,
	// then undo that button press so that the browser history is correct.
	if (!show) {
		if (this._browserAction == ZmAppViewMgr.BROWSER_BACK) {
			this._ignoreHistoryChange = true;
			history.forward();
		} else if (this._browserAction == ZmAppViewMgr.BROWSER_FORWARD) {
			this._ignoreHistoryChange = true;
			history.back();
		}
		this._browserAction = null;
	}
	this._pendingAction = this._pendingView = null;
};

/**
 * Fits all components to the container.
 */
ZmAppViewMgr.prototype.fitAll =
function() {
	this._shell.relayout();
	this._fitToContainer(ZmAppViewMgr.ALL_COMPONENTS);
};

/**
 * Gets the currently pending view waiting to get pushed.
 * 
 * @return	{Object}	the pending view id
 */
ZmAppViewMgr.prototype.getPendingViewId = 
function() {
	return this._pendingView;
};

/**
 * Updates and shows the current view title in the title bar.
 */
ZmAppViewMgr.prototype.updateTitle = 
function() {
	this._setTitle(this._currentViewId);
};

/**
 * Sets the tab title.
 * 
 * @param	{int}	viewId	the view id
 * @param	{String}	text	the title
 */
ZmAppViewMgr.prototype.setTabTitle =
function(viewId, text) {
	var view = this._view[viewId || this._currentViewId] || this._emptyView;
	var tp = view.tabParams;
	var button = !appCtxt.isChildWindow && tp && appCtxt.getAppChooser().getButton(tp.id);
	if (button) {
		button.setText(AjxStringUtil.htmlEncode(text));
	}
};

/**
 * Checks if it is OK to unload the app (for example, user logs out, navigates away, closes browser).
 * 
 * @return	{Boolean}	<code>true</code> if OK to unload the app
 */
ZmAppViewMgr.prototype.isOkToUnload =
function() {
	for (var viewId in this._view) {
		var view = this._view[viewId];
		var callback = view && view.callback && view.callback[ZmAppViewMgr.CB_PRE_UNLOAD];
		if (callback) {
			DBG.println(AjxDebug.DBG2, "checking if ok to unload " + viewId);
			var okToContinue = callback.run(viewId);
			if (!okToContinue) { return false; }
		}
	}
	return true;
};

// Private methods

/**
 * @private
 */
ZmAppViewMgr.prototype._createLoadingView =
function() {
	this.loadingView = new DwtControl({parent:this._shell, className:"DwtListView",
									   posStyle:Dwt.ABSOLUTE_STYLE, id:ZmId.LOADING_VIEW});
	var el = this.loadingView.getHtmlElement();
	el.innerHTML = AjxTemplate.expand("share.App#Loading", this._htmlElId);
	var elements = {};
	elements[ZmAppViewMgr.C_APP_CONTENT] = this.loadingView;
	this.createView({viewId:ZmId.VIEW_LOADING, elements:elements});
};

/**
 * Locates and sizes the given list of components to fit within their containers.
 * 
 * @private
 */
ZmAppViewMgr.prototype._fitToContainer =
function(cidList, isIeTimerHack) {
	
	var cidList = AjxUtil.toArray(cidList);

	for (var i = 0; i < cidList.length; i++) {
		var cid = cidList[i];
		DBG.println(AjxDebug.DBG3, "fitting to container: " + cid);
		var cont = this.getContainer(cid);
		if (cont) {
			var comp = this.getViewComponent(cid);
			if (comp && !this.isHidden(cid, this._currentViewId)) {
				var position = this._getComponentPosition(cid);
				var isStatic = (position == Dwt.STATIC_STYLE);
				
				// reset position if skin overrides default of absolute
				var compEl = comp.getHtmlElement();
				if (position) {
					compEl.style.position = position;
				}

				var component = this._component[cid];
				if (isStatic) {
					if (compEl.parentNode != cont) {
						DBG.println("avm", "APPEND " + cid);
						cont.appendChild(compEl);
					}
					if (comp.adjustSize) {
						comp.adjustSize();
					}
				} else {
					var contBds = Dwt.getBounds(cont);
					// take insets (border + padding) into account
					var insets = Dwt.getInsets(cont);
					Dwt.insetBounds(contBds, insets);
					
					// save bounds
					component.bounds = contBds;
					var toolbarExists = Boolean(this._component[ZmAppViewMgr.C_TOOLBAR_TOP].control);
					DBG.println("avm", "FIT " + cid + ": " + [contBds.x, contBds.y, contBds.width, contBds.height].join("/"));
					comp.setBounds(contBds.x, contBds.y, contBds.width, contBds.height, toolbarExists);
				}
				component.control = comp;
			}
		}
	}

	if (window.DBG && DBG.getDebugLevel() >= AjxDebug.DBG2) {
		this._debugShowMetrics(cidList);
	}
};

/**
 * @private
 */
ZmAppViewMgr.prototype._getComponentPosition =
function(cid) {
	return appCtxt.getSkinHint(cid, "position");
};

/**
 * @private
 */
ZmAppViewMgr.prototype._getContainerBounds =
function(cid) {
	// ignore bounds for statically laid-out components
	var position = this._getComponentPosition(cid);
	if (position == Dwt.STATIC_STYLE) { return null; }

	var container = this.getContainer(cid);
	if (container) {
		var bounds = Dwt.getBounds(container);
		// take insets (border + padding) into account
		var insets = Dwt.getInsets(container);
		Dwt.insetBounds(bounds, insets);
		return bounds;
	}
	return null;
};

/**
 * Performs manual layout of the components, absent a containing skin. Currently assumes
 * that there will be a top toolbar and app content.
 * 
 * @private
 */
ZmAppViewMgr.prototype._layout =
function(view) {
	// if skin, elements already laid out by being placed in their containers
	if (this._hasSkin) { return; }
	
	var topToolbar = this.getViewComponent(ZmAppViewMgr.C_TOOLBAR_TOP);
	if (topToolbar) {
		var sz = topToolbar.getSize();
		var height = sz.y ? sz.y : topToolbar.getHtmlElement().clientHeight;
		topToolbar.setBounds(0, 0, this._shellSz.x, height);
	}
	var appContent = this.getCurrentView();
	if (appContent) {
		appContent.setBounds(0, height, this._shellSz.x, this._shellSz.y - height, Boolean(topToolbar));
	}
};

/**
 * Tries to hide the given view. First checks to see if the view has a callback
 * for when it is hidden. The callback must return true for the view to be hidden.
 * 
 * @private
 */
ZmAppViewMgr.prototype._hideView =
function(viewId, force, noHide, newViewId) {

	if (!viewId) { return true; }

	var view = this._view[viewId] || this._emptyView;
	var okToContinue = true;
	var callback = view.callback[ZmAppViewMgr.CB_PRE_HIDE];
	if (callback) {
		DBG.println(AjxDebug.DBG2, "hiding " + viewId);
		okToContinue = callback.run(viewId, force, newViewId);
	}
	if (okToContinue) {
		if (!noHide) {
			this._setViewVisible(viewId, false);
		}
        if (appCtxt.get(ZmSetting.USE_KEYBOARD_SHORTCUTS)) {
		    appCtxt.getKeyboardMgr().clearKeySeq();
        }
		DBG.println(AjxDebug.DBG2, viewId + " hidden");
		callback = view.callback[ZmAppViewMgr.CB_POST_HIDE];
		if (callback) {
			callback.run(viewId, newViewId);
		}
	}

	return okToContinue;
};

/**
 * Makes the given view visible.
 * 
 * @private
 */
ZmAppViewMgr.prototype._showView =
function(viewId, force, isNewView) {

	if (!viewId) { return true; }
	
	var view = this._view[viewId] || this._emptyView;
	var okToContinue = true;
	var callback = view.callback[ZmAppViewMgr.CB_PRE_SHOW];
	if (callback) {
		DBG.println(AjxDebug.DBG2, "showing " + viewId);
		okToContinue = callback.run(viewId, isNewView, force);
	}
	if (okToContinue) {
		this._setViewVisible(viewId, true);
		DBG.println(AjxDebug.DBG2, viewId + " shown");
		callback = view.callback[ZmAppViewMgr.CB_POST_SHOW];
		if (callback) {
			callback.run(viewId, isNewView);
		}
	}
	appCtxt.notifyZimlets("onShowView", [viewId, isNewView]);

	return okToContinue;
};

/**
 * Shows or hides the components of a view.
 * 
 * @private
 */
ZmAppViewMgr.prototype._setViewVisible =
function(viewId, show) {

	DBG.println("avm", "-------------- " + (show ? "SHOW " : "HIDE ") + viewId);

	var view = this._view[viewId] || this._emptyView;
	view.visible = show;
	
	if (show) {

		for (var i = 0; i < ZmAppViewMgr.ALL_COMPONENTS.length; i++) {
			var cid = ZmAppViewMgr.ALL_COMPONENTS[i];
			var oldComp = this.getViewComponent(cid, this._lastViewId);
			if (oldComp) {
				this.displayComponent(cid, false, null, oldComp, true);
			}
			var comp = this.getViewComponent(cid, viewId);
			if (comp) {
                this.displayComponent(cid, !this.isHidden(cid, viewId), null, comp, true);
			}
		}

		// fit the components now that we're done messing with the skin
		if (this._hasSkin) {
			this.fitAll();
		}
		
		this._setTitle(viewId);
		
		if (view.isTabView) {
			var tabId = view.tabParams.id;
			this._controller.setActiveTabId(tabId);
		}
		
		if (view.app) {
			this._controller.setActiveApp(view);
		}
	}
	else {
		// hiding a view is lightweight - just hide the component widgets
		for (var cid in view.component) {
			this.showComponent(cid, false);
		}
		// hide the app components too - if we're not changing apps, they will reappear
		// when the new view is shown. Done this way since this._lastViewId is not yet set.
		var appView = this._view[view.app];
		if (appView) {
			for (var cid in appView.component) {
				this.showComponent(cid, false);
			}
		}
	}
};

/**
 * Removes a view from the hidden stack.
 * 
 * @private
 */
ZmAppViewMgr.prototype._removeFromHidden =
function(view) {
	AjxUtil.arrayRemove(this._hidden, view);
};

/**
 * Tells a view's components that it has been hidden.
 * 
 * @private
 */
ZmAppViewMgr.prototype._deactivateView =
function(viewId) {
	viewId = viewId || this._currentViewId;
	var view = this._view[viewId] || this._emptyView;
	for (var cid in view.component) {
		var comp = this.getViewComponent(cid, viewId);
		if (comp && comp.deactivate) {
			comp.deactivate();
		}
	}
};

/**
 * Sets the browser title based on the view's APP_CONTENT component
 * @private
 */
ZmAppViewMgr.prototype._setTitle =
function(view) {
	var content = this.getCurrentView();
	if (content && content.getTitle) {
		var title = content.getTitle();
		Dwt.setTitle(title ? title : ZmMsg.zimbraTitle);
	}
};

// Listeners

/**
 * Handles shell resizing event.
 * 
 * @private
 */
ZmAppViewMgr.prototype._shellControlListener =
function(ev) {

	if (ev.oldWidth != ev.newWidth || ev.oldHeight != ev.newHeight) {
		this._shellSz.x = ev.newWidth;
		this._shellSz.y = ev.newHeight;
		var deltaWidth = ev.newWidth - ev.oldWidth;
		var deltaHeight = ev.newHeight - ev.oldHeight;
		DBG.println(AjxDebug.DBG1, "shell control event: dW = " + deltaWidth + ", dH = " + deltaHeight);
		if (this._isNewWindow) {
			var view = this._view[this._currentViewId] || this._emptyView
			if (view.component) {
				// reset width of top toolbar
				var topToolbar = view.component[ZmAppViewMgr.C_TOOLBAR_TOP]; //todo - something similar for new button here?
				if (topToolbar) {
					topToolbar.setSize(ev.newWidth, Dwt.DEFAULT);
				}
				// make sure to remove height of top toolbar for height of app content
				var appContent = this.getCurrentView();
				if (appContent) {
					appContent.setSize(ev.newWidth, ev.newHeight - topToolbar.getH());
				}
			}
		} else {
			this.fitAll();
		}
	}
};

/**
 * @private
 */
ZmAppViewMgr.prototype._debugShowMetrics =
function(components) {
	for (var i = 0; i < components.length; i++) {
		var cid = components[i];
		var cont = this.getContainer(cid);
		if (cont) {
			var contBds = Dwt.getBounds(cont);
			DBG.println("Container bounds for " + cid + ": " + contBds.x + ", " + contBds.y + " | " + contBds.width + " x " + contBds.height);
		}
	}
};

/**
 * Handles browser Back/Forward. We compare the new index to our current one
 * to see if the user has gone back or forward. If back, we pop the view,
 * otherwise we push the appropriate view.
 * 
 * @param {AjxEvent}	ev	the history event
 * 
 * @private
 */
ZmAppViewMgr.prototype._historyChangeListener = function(ev) {

	if (appCtxt.inStartup) {
        return;
    }
	if (!(ev && ev.data)) {
        return;
    }
	if (this._ignoreHistoryChange) {
		this._ignoreHistoryChange = false;
		return;
	}

	var dlg;
    while (dlg = DwtBaseDialog.getActiveDialog()) {
        if (dlg && dlg.isPoppedUp()) {
            dlg.popdown();
        }
    }

	var hashIndex = parseInt(ev.data);
	this._noHistory = true;
	var viewId = this._hashViewId[hashIndex];
	if (hashIndex == (this._curHashIndex - 1)) {
		// Back button has been pressed
		this._browserAction = ZmAppViewMgr.BROWSER_BACK;
		this.popView();
	} else if (hashIndex == (this._curHashIndex + 1)) {
		// Forward button has been pressed
		this._browserAction = ZmAppViewMgr.BROWSER_FORWARD;
		this.pushView(viewId);
	} else {
		// Not sure where we are - just push the correct view
		this._browserAction = null;
		this.pushView(viewId);
	}
	this._curHashIndex = hashIndex;

	DBG.println(AjxDebug.DBG2, "History change to " + hashIndex + ", new view: " + viewId);
};

/**
 * Handles app/tree movement. If you move the sash beyond the max or min width, pins to the respective width.
 * 
 * @private
 */
ZmAppViewMgr.prototype._appTreeSashCallback =
function(delta) {
	if (!window.skin) { return; }

	// ask skin for width of tree, rather than hard-coding name of tree div here
	var currentWidth = skin.getTreeWidth();
	if (currentWidth === null) { return 0; }

	DBG.println(AjxDebug.DBG3, "************ sash callback **************");
	DBG.println(AjxDebug.DBG3, "delta = " + delta);
	DBG.println(AjxDebug.DBG3, "shell width = " + this._shellSz.x);
	DBG.println(AjxDebug.DBG3, "current width = " + currentWidth);

	// MOW: get the min/max sizes from the skin.hints
	if (!this.treeMinSize) {
		this.treeMinSize =
			DwtCssStyle.asPixelCount(window.skin.hints.tree.minWidth || 150);
		this.treeMaxSize =
			DwtCssStyle.asPixelCount(window.skin.hints.tree.maxWidth || 1000);
	}

	// pin the resize to the minimum and maximum allowable
	if (currentWidth + delta > this.treeMaxSize) {
		delta = Math.max(0, this.treeMaxSize - currentWidth);
	}
	if (currentWidth + delta < this.treeMinSize) {
		delta = Math.min(0, this.treeMinSize - currentWidth);
	}

	// tell skin to resize the tree to keep the separation of tree/skin clean
	var newTreeWidth = currentWidth + delta;

	skin.setTreeWidth(newTreeWidth);

	// call fitAll() on timeout, so we dont get into a problem w/ sash movement code
	var me = this;
	setTimeout(function(){me.fitAll()},0);
	return delta;
};
}
if (AjxPackage.define("zimbraMail.core.ZmRequestMgr")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the request manager class.
 */

/**
 * Creates a request manager.
 * @class
 * This class manages the sending of requests to the server, and handles the
 * responses, including refresh blocks and notifications.
 *
 * @author Conrad Damon
 * 
 * @param {ZmController}	controller	the main controller
 */
ZmRequestMgr = function(controller) {

	this._controller = controller;
	
	appCtxt.setRequestMgr(this);

	ZmCsfeCommand.setServerUri(appCtxt.get(ZmSetting.CSFE_SERVER_URI));
	var cv = appCtxt.get(ZmSetting.CLIENT_VERSION);
	ZmCsfeCommand.clientVersion = (!cv || cv.indexOf('@') == 0) ? "dev build" : cv;
	
	this._shell = appCtxt.getShell();

    this._highestNotifySeen = 0;

	this._cancelActionId = {};
	this._pendingRequests = {};

	this._useXml = appCtxt.get(ZmSetting.USE_XML);
	this._logRequest = appCtxt.get(ZmSetting.LOG_REQUEST);
	this._stdTimeout = appCtxt.get(ZmSetting.TIMEOUT);

	this._unreadListener = new AjxListener(this, this._unreadChangeListener);
};

ZmRequestMgr.prototype.isZmRequestMgr = true;
ZmRequestMgr.prototype.toString = function() { return "ZmRequestMgr"; };

// request states
ZmRequestMgr._SENT		= 1;
ZmRequestMgr._RESPONSE	= 2;
ZmRequestMgr._CANCEL	= 3;

// retry settings
ZmRequestMgr.RETRY_MAX			= 2;	// number of times to retry before throwing exception
ZmRequestMgr.RETRY_DELAY		= 5;	// seconds to delay between retries
ZmRequestMgr.RETRY_ON_EXCEPTION = {};	// which exceptions to retry on
ZmRequestMgr.RETRY_ON_EXCEPTION[ZmCsfeException.EMPTY_RESPONSE] = true;

ZmRequestMgr._nextReqId = 1;

ZmRequestMgr.OFFLINE_HEAP_DUMP          = "heapdump_upload";
ZmRequestMgr.OFFLINE_MUST_RESYNC        = "resync";
ZmRequestMgr.OFFLINE_MUST_GAL_RESYNC    = "gal_resync";
ZmRequestMgr.OFFLINE_FOLDER_MOVE_FAILED = "foldermove_failed";

// ms to delay after a response to make sure focus is in sync
ZmRequestMgr.FOCUS_CHECK_DELAY = 500;

/**
 * Sends a request to the CSFE and processes the response. Notifications and
 * refresh blocks that come in the response header are handled. Also handles
 * exceptions by default, though the caller can pass in a special callback to
 * run for exceptions. The error callback should return true if it has
 * handled the exception, and false if standard exception handling should still
 * be performed.
 *
 * @param {Hash}		params				a hash of parameters
 * @param {AjxSoapDoc}	soapDoc				the SOAP document that represents the request
 * @param {Object}		jsonObj				the JSON object that represents the request (alternative to soapDoc)
 * @param {Boolean}		asyncMode			if <code>true</code>, request will be made asynchronously
 * @param {AjxCallback}	callback			the next callback in chain for async request
 * @param {AjxCallback}	errorCallback		the callback to run if there is an exception
 * @param {AjxCallback}	continueCallback	the callback to run after user re-auths
 * @param {AjxCallback}	offlineCallback	    the callback to run if the user is offline
 * @param {int}			timeout				the timeout value (in seconds)
 * @param {Boolean}		noBusyOverlay		if <code>true</code>, don't use the busy overlay
 * @param {String}		accountName			the name of account to execute on behalf of
 * @param {Object}		response			the pre-determined response (no request will be made)
 * @param {Boolean}		skipAuthCheck		if <code>true</code>, do not check if auth token has changed
 * @param {constant}	resend				the reason for resending request
 * @param {Boolean}		sensitive			if <code>true</code>, attempt to use secure conn to protect data
 * @param {Boolean}		noSession			if <code>true</code>, no session info is included
 * @param {String}		restUri				the REST URI to send the request to
 * @param {boolean}		emptyResponseOkay	if true, empty or no response from server is not an erro
 * @param {boolean}		offlineRequest	    if true, request will not be send to server
 * @param {boolean}		useChangeToken	    if true, request will try to use change token in header
 */
ZmRequestMgr.prototype.sendRequest =
function(params) {
	var response = params.response;
	if (response) {
		if (params.reqId) {
			params = this._pendingRequests[params.reqId] || params;
			params.response = response;
		}
		params.asyncMode = true;	// canned response set up async style
		return this._handleResponseSendRequest(params, new ZmCsfeResult(response));
	}
	if (params.offlineRequest || appCtxt.isWebClientOffline()) {
		if (params.offlineCallback) {
			params.offlineCallback.run(params);
		}
		return;
	}
	
	var reqId = params.reqId = ("Req_"+ZmRequestMgr._nextReqId++);
	DBG.println("req", "assign req ID: " + reqId);
	var timeout = params.timeout = (params.timeout != null) ? params.timeout : this._stdTimeout;
	if (timeout) {
		timeout = timeout * 1000; // convert seconds to ms
	}
	var asyncCallback = params.asyncMode ? new AjxCallback(this, this._handleResponseSendRequest, [params]) : null;

	if (params.sensitive) {
		DBG.println(AjxDebug.DBG2, "request contains sensitive data");
		// NOTE: If only http mode is available, there's nothing we can
		//       do. And if we're already using https mode, then there's
		//       nothing we need to do. We only attempt to send the
		//       request securely if mixed mode is enabled and the app
		//       was loaded using http.
		var isHttp = document.location.protocol == ZmSetting.PROTO_HTTP;
		var isMixedMode = appCtxt.get(ZmSetting.PROTOCOL_MODE) == ZmSetting.PROTO_MIXED;
		if(isHttp && isMixedMode) {
			return this._sensitiveRequest(params, reqId);
		}
	}

	var command = new ZmCsfeCommand();
	// bug fix #10652, 82704 - dont set change token if accountName is not main account or is not specified
	// (since we're executing on someone else's mbox)
	var accountName = params.accountName;
	if (!accountName) {
		var acct = appCtxt.getActiveAccount();
		accountName = (acct && acct.id != ZmAccountList.DEFAULT_ID) ? acct.name : null;
	}
	var changeToken = null;
	if (params.useChangeToken && (!accountName || (accountName === appCtxt.accountList.mainAccount.name))) {
		changeToken = this._changeToken;
	}
	var cmdParams, methodName;

	if (params.restUri) {
		cmdParams =	{	restUri:			params.restUri,
						asyncMode:			params.asyncMode,
						callback:			asyncCallback
					};
	} else {
		cmdParams = {	jsonObj:			params.jsonObj,
						soapDoc:			params.soapDoc,
						accountName:		accountName,
						useXml:				this._useXml,
						changeToken:		changeToken,
						asyncMode:			params.asyncMode,
						callback:			asyncCallback,
						logRequest:			this._logRequest,
						highestNotifySeen:	this._highestNotifySeen,
						noAuthToken:		true,	// browser will handle auth token cookie
						skipAuthCheck:		params.skipAuthCheck,
						resend:				params.resend,
						noSession:			params.noSession,
						useStringify1:		(AjxEnv.isIE || AjxEnv.isModernIE) && params.fromChildWindow,
						emptyResponseOkay:	params.emptyResponseOkay
					};
		methodName = params.methodName = ZmCsfeCommand.getMethodName(cmdParams.jsonObj || cmdParams.soapDoc);
	}

	appCtxt.currentRequestParams = params;
	DBG.println("req", "send request " + reqId + ": " + methodName);
	var cancelParams = timeout ? [reqId, params.errorCallback, params.noBusyOverlay] : null;
	if (!params.noBusyOverlay) {
		var cancelCallback = null;
		var showBusyDialog = false;
		if (timeout) {
			DBG.println("req", "ZmRequestMgr.sendRequest: timeout for " + reqId + " is " + timeout);
			cancelCallback = new AjxCallback(this, this.cancelRequest, cancelParams);
			this._shell.setBusyDialogText(ZmMsg.askCancel);
			showBusyDialog = true;
		}
		// put up busy overlay to block user input
		this._shell.setBusy(true, reqId, showBusyDialog, timeout, cancelCallback);
	} else if (timeout) {
		var action = new AjxTimedAction(this, this.cancelRequest, cancelParams);
		this._cancelActionId[reqId] = AjxTimedAction.scheduleAction(action, timeout);
		DBG.println("req", "schedule cancel action for reqId " + reqId + ": " + this._cancelActionId[reqId]);
	}

	this._pendingRequests[reqId] = command;

	try {
		DBG.println("req", "invoke req: " + params.reqId);
		var response = params.restUri ? command.invokeRest(cmdParams) : command.invoke(cmdParams);
		command.state = ZmRequestMgr._SENT;
	} catch (ex) {
		DBG.println("req", "caught exception on invoke of req: " + params.reqId);
		this._handleResponseSendRequest(params, new ZmCsfeResult(ex, true));
		return;
	}

	return (params.asyncMode) ? reqId : (this._handleResponseSendRequest(params, response));
};

/**
 * @private
 * @param {Array}	params.ignoreErrs	list of error codes that can be ignored, when params.errorCallback does not exists.
 */
ZmRequestMgr.prototype._handleResponseSendRequest =
function(params, result) {
	DBG.println("req", "ZmRequestMgr.handleResponseSendRequest for req: " + params.reqId);
	var isCannedResponse = (params.response != null);
	if (!isCannedResponse && !appCtxt.isWebClientOffline()) {
		if (!this._pendingRequests[params.reqId]) {
			DBG.println("req", "ZmRequestMgr.handleResponseSendRequest no pending request for " + params.reqId);
			return;
		}
		if (this._pendingRequests[params.reqId].state == ZmRequestMgr._CANCEL) {
			DBG.println("req", "ZmRequestMgr.handleResponseSendRequest state=CANCEL for " + params.reqId);
			return;
		}
	
		this._pendingRequests[params.reqId].state = ZmRequestMgr._RESPONSE;
	
		if (!params.noBusyOverlay) {
			this._shell.setBusy(false, params.reqId); // remove busy overlay
		}
	}

	var response, refreshBlock;
	try {
		if (params.asyncMode && !params.restUri) {
			response = result.getResponse(); // may throw exception
		} else {
			// for sync responses, manually throw exception if necessary
			if (result._isException) {
				throw result._data;
			} else {
				response = result;
			}
		}
		if (response.Header) {
			refreshBlock = this._handleHeader(response.Header);
		}
	} catch (ex) {
		DBG.println("req", "Request " + params.reqId + " got an exception");
		var ecb = params.errorCallback;
		if (ecb) {
            var handled = ecb.run(ex, params);
			if (!handled) {
				this._handleException(ex, params);
			}
		} else {
			var ignore = function(ignoreErrs, errCode){
			/*
				Checks errCode exits in ignoreErrs
			*/
				if (ignoreErrs && (ignoreErrs.length > 0)){
					for (var val in ignoreErrs)
						if (ignoreErrs[val] == errCode) 
							return true;
				}
				return false;
			}(params.ignoreErrs, ex.code)

            if (ex.code === ZmCsfeException.EMPTY_RESPONSE && params.offlineCallback) {
                params.offlineCallback(params);
				if (appCtxt.isWebClientOffline() && !params.noBusyOverlay) {
					this._shell.setBusy(false, params.reqId); // remove busy overlay
				}
                ignore = true;
            }
			if (!ignore)
				this._handleException(ex, params);
		}
		var hdr = result.getHeader();
		if (hdr) {
			this._handleHeader(hdr);
			this._handleNotifications(hdr);
		}
		this._clearPendingRequest(params.reqId);
		return;
	}

    if (params.asyncMode && !params.restUri) {
	    result.set(response.Body);
	}

    // if we didn't get an exception, then we should make sure that the
    // poll timer is running (just in case it got an exception and stopped)
	if (!appCtxt.isOffline && !isCannedResponse) {
		this._controller._kickPolling(true);
	}

	var methodName = ZmCsfeCommand.getMethodName(params.jsonObj || params.soapDoc);
	if (params.asyncMode && params.callback) {
		DBG.println(AjxDebug.DBG1, "------------------------- Running response callback for " + methodName);
		params.callback.run(result);
	}

	DBG.println(AjxDebug.DBG1, "------------------------- Processing notifications for " + methodName);
	this._handleNotifications(response.Header, methodName);

	this._clearPendingRequest(params.reqId);

	if (refreshBlock && (!appCtxt.isOffline || !appCtxt.multiAccounts) && !params.more) {
		this._refreshHandler(refreshBlock);
	}
	
	if (!params.asyncMode) {
		return response.Body;
	}
	
	var ctlr = this._controller;
	if (ctlr._evtMgr && ctlr._evtMgr.isListenerRegistered(ZmAppEvent.RESPONSE)) {
		ctlr._evt.request = methodName;
		ctlr.notify(ZmAppEvent.RESPONSE);
	}
};

/**
 * Cancels the request.
 * 
 * @param	{String}	reqId		the request id
 * @param	{AjxCallback}	errorCallback		the callback
 * @param	{Boolean}	noBusyOverlay	if <code>true</code>, do not show busy overlay
 */
ZmRequestMgr.prototype.cancelRequest =
function(reqId, errorCallback, noBusyOverlay) {
	DBG.println("req", "ZmRequestMgr.cancelRequest: " + reqId);
	if (!this._pendingRequests[reqId]) { return; }
	if (this._pendingRequests[reqId].state == ZmRequestMgr._RESPONSE) { return; }

	this._pendingRequests[reqId].state = ZmRequestMgr._CANCEL;
	if (!noBusyOverlay) {
		this._shell.setBusy(false, reqId);
	}
	DBG.println("req", "canceling the XHR");
	this._pendingRequests[reqId].cancel();
	if (errorCallback) {
		DBG.println("req", "calling the error callback");
		var ex = new AjxException("Request canceled", AjxException.CANCELED, "ZmRequestMgr.prototype.cancelRequest");
		errorCallback.isAjxCallback ? errorCallback.run(ex) : errorCallback(ex);
	}
	this._clearPendingRequest(reqId);
};

/**
 * @private
 */
ZmRequestMgr.prototype._clearPendingRequest =
function(reqId) {
	var request = this._pendingRequests[reqId];
	if (request) {
		if (request.iframeId) {
			var iframe = document.getElementById(request.iframeId);
			if (iframe) {
				iframe.parentNode.removeChild(iframe);
			}
		}
		delete this._pendingRequests[reqId];
	}
	var cancelId = this._cancelActionId[reqId];
	if (cancelId && cancelId != -1) {
		DBG.println("req", "unschedule cancel action for reqId " + reqId + ": " + cancelId);
		AjxTimedAction.cancelAction(cancelId);
		this._cancelActionId[reqId] = -1;
	}
};

/**
 * Handles a response's SOAP header, except for notifications. Updates our
 * change token, and processes a <code>&lt;refresh&gt;</code> block if there is one (happens
 * when a new session is created on the server).
 *
 * @param {Object}	hdr	a SOAP header
 * 
 * @private
 */
ZmRequestMgr.prototype._handleHeader =
function(hdr) {

	var ctxt = hdr && hdr.context;
	if (!ctxt) { return; }

	// update change token if we got one
	if (ctxt.change) {
		this._changeToken = ctxt.change.token;
	}

	// offline/zdesktop only
	if (ctxt.zdsync && ctxt.zdsync.account) {
		var acctList = ctxt.zdsync.account;
		for (var i = 0; i < acctList.length; i++) {
            var acct = appCtxt.accountList.getAccount(acctList[i].id);
			if (acct) {
                //server is sending info to get user's consent on something.
                var dialog = acctList[i].dialog;
                if(dialog) {
                    this._handleOfflineInfoDialog(dialog[0], acct)
                }
				acct.updateState(acctList[i]);
			}
		}
	}

	if (ctxt.refresh) {
		this._controller.runAppFunction("_clearDeferredFolders");
		this._loadTrees(ctxt.refresh);
		this._controller.runAppFunction("_createVirtualFolders");
		this._highestNotifySeen = 0;
	}

	return ctxt.refresh;
};
/**
 * Handles server's notification to get user's consent on something
 *
 * @param {Object}	dlg is json object
 * @param {Object}	account object
 *
 * @private
 */
ZmRequestMgr.prototype._handleOfflineInfoDialog =
function(dlg, acct) {

    if(!dlg.type) {
        return;
    }
    var cont;
    switch(dlg.type) {
        case ZmRequestMgr.OFFLINE_HEAP_DUMP: {
            cont = ZmMsg.offlineHeapDump;
            break;
        }
        case ZmRequestMgr.OFFLINE_MUST_RESYNC: {
            cont = AjxMessageFormat.format(ZmMsg.offlineMustReSync, acct.name);
            break;
        }
		case ZmRequestMgr.OFFLINE_MUST_GAL_RESYNC: {
			cont = AjxMessageFormat.format(ZmMsg.offlineMustGalReSync, acct.name);
			break;
		}
        case ZmRequestMgr.OFFLINE_FOLDER_MOVE_FAILED: {
            appCtxt.setStatusMsg(ZmMsg.offlineMoveFolderError);
            break;
        }
        default:
    }
    if (!cont) {
        return;
    }
    var dialog = appCtxt.getOkCancelMsgDialog();
    dialog.setMessage(cont);
    dialog.registerCallback(DwtDialog.OK_BUTTON, this._handleOfflineDialogAction, this, [dialog, dlg.type, acct.id, true]);
    dialog.registerCallback(DwtDialog.CANCEL_BUTTON, this._handleOfflineDialogAction, this, [dialog, dlg.type, acct.id, false]);
    dialog.popup();
};
/**
 * Sends DialogActionRequest with user's consent YES/NO
 * @param {object} dlg is getOkCancelMsgDialog
 * @param {string} type
 * @param {string} acctId Account ID
 * @param {boolean} action
 */
ZmRequestMgr.prototype._handleOfflineDialogAction =
function(dlg, type, acctId, action) {
    var args = {
			jsonObj: { DialogActionRequest: { _jsns: "urn:zimbraOffline", type: type, id:acctId, action: action ? "yes" : "no" } },
            callback: new AjxCallback(this, this._handleOfflineDialogActionResp, dlg),
			errorCallback: new AjxCallback(this, this._handleOfflineDialogActionResp, dlg),
			asyncMode: true
		};
    this.sendRequest(args);
};
/**
 * callback to hide dialog
 *
 * @param dlg
 * @param resp
 */
ZmRequestMgr.prototype._handleOfflineDialogActionResp =
function(dlg, resp) {
      if(dlg.isPoppedUp()){
        dlg.popdown();
    }
};

/**
 * For transient network exceptions, retry the request after a small delay.
 * We will only retry a limited number of times.
 * 
 * @param {AjxException}	ex			the exception
 * @param {Hash}	params		a hash of the original request params
 */
ZmRequestMgr.prototype._handleException =
function(ex, params) {
	var handled = false;
	if (ZmRequestMgr.RETRY_ON_EXCEPTION[ex.code]) {
		params.retryCount = params.retryCount || 0;
		if (params.retryCount < ZmRequestMgr.RETRY_MAX) {
			DBG.println(AjxDebug.DBG1, "RETRY " + ex.method + " due to " + ex.code);
			params.resend = ZmCsfeCommand.RETRY;
			params.retryCount++;
			AjxTimedAction.scheduleAction(new AjxTimedAction(this, 
				function() {
					this.sendRequest(params);
				}), ZmRequestMgr.RETRY_DELAY * 1000);
			handled = true;
		}
	}
	
	if (!handled) {
		this._controller._handleException(ex, params);
	}
};

/**
 * Handles the <code>&lt;notify&gt;</code> block of a response's SOAP header.
 *
 * @param {Object}	hdr	a SOAP header
 * 
 * @private
 */
ZmRequestMgr.prototype._handleNotifications =
function(hdr, methodName) {

	if (hdr && hdr.context && hdr.context.notify) {
        for (var i = 0; i < hdr.context.notify.length; i++) {
        	var notify = hdr.context.notify[i];
        	var seq = notify.seq;
            // BUG?  What if the array isn't in sequence-order?  Could we miss notifications?
			var sid = hdr.context && ZmCsfeCommand.extractSessionId(hdr.context.session);
            if (notify.seq > this._highestNotifySeen && !(sid && ZmCsfeCommand._staleSession[sid])) {
                DBG.println(AjxDebug.DBG1, "Handling notification[" + i + "] seq=" + seq);
                this._highestNotifySeen = seq;
                this._notifyHandler(notify, methodName);
            } else {
            	DBG.println(AjxDebug.DBG1, "SKIPPING notification[" + i + "] seq=" + seq + " highestNotifySeen=" + this._highestNotifySeen);
	      	}
    	}
	}
};

/**
 * A <code>&lt;refresh&gt;</code> block is returned in a SOAP response any time the session ID has 
 * changed. It always happens on the first SOAP command (GetInfoRequest).
 * After that, it happens after a session timeout. 
 * 
 * @param {Object}	refresh	the refresh block (JSON)
 * @private
 */
ZmRequestMgr.prototype._refreshHandler =
function(refresh) {

	DBG.println(AjxDebug.DBG1, "Handling REFRESH");
	AjxDebug.println(AjxDebug.NOTIFY, "REFRESH block received");
	if (!appCtxt.inStartup) {
		this._controller._execPoll();
	}

	if (refresh.version) {
		if (!this._canceledReload) {
			var curVersion = appCtxt.get(ZmSetting.SERVER_VERSION);
			if (curVersion != refresh.version) {
				appCtxt.set(ZmSetting.SERVER_VERSION, refresh.version);
				if (curVersion) {
					var dlg = appCtxt.getYesNoMsgDialog();
					dlg.reset();
					dlg.registerCallback(DwtDialog.YES_BUTTON, this._reloadYesCallback, this, [dlg, curVersion, refresh.version]);
					dlg.registerCallback(DwtDialog.NO_BUTTON, this._reloadNoCallback, this, [dlg, refresh]);
					var msg = AjxMessageFormat.format(ZmMsg.versionChangeRestart, [curVersion, refresh.version]);
					dlg.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
					dlg.popup();
					appCtxt.reloadAppCache(true);
					return;
				}
			}
		}
	}

	if (!this._recentlyRefreshed) {
		// Run any app-requested refresh routines
		this._controller.runAppFunction("refresh", false, refresh);
		this._recentlyRefreshed = true;
		this._lastSkippedRefresh = null;
	} else {
		this._lastSkippedRefresh = refresh;
	}

	if (!this._refreshTimer)
		this._refreshTimer = new AjxTimedAction(this, this._refreshTimeout);

	AjxTimedAction.scheduleAction(this._refreshTimer, 5000);
};

ZmRequestMgr.prototype._refreshTimeout =
function() {
	if (this._lastSkippedRefresh) {
		this._controller.runAppFunction("refresh", false, this._lastSkippedRefresh);
		this._lastSkippedRefresh = null;
	}
	this._recentlyRefreshed = false;
};

ZmRequestMgr.prototype._loadTrees =
function(refresh) {
	var unread = {};
	var main = appCtxt.multiAccounts ? appCtxt.accountList.mainAccount : null;
	this._loadTree(ZmOrganizer.TAG, unread, refresh.tags, null, main);
	this._loadTree(ZmOrganizer.FOLDER, unread, refresh.folder[0], "folder", main);
};

/**
 * User has accepted reload due to change in server version.
 * 
 * @private
 */
ZmRequestMgr.prototype._reloadYesCallback =
function(dialog) {
	dialog.popdown();
    window.onbeforeunload = null;
    var url = AjxUtil.formatUrl();
	DBG.println(AjxDebug.DBG1, "SERVER_VERSION changed!");
    ZmZimbraMail.sendRedirect(url); // redirect to self to force reload
};

/**
 * User has canceled reload due to change in server version.
 * 
 * @private
 */
ZmRequestMgr.prototype._reloadNoCallback =
function(dialog, refresh) {
	dialog.popdown();
	this._canceledReload = true;
	this._refreshHandler(refresh);
};

/**
 * @private
 */
ZmRequestMgr.prototype._loadTree =
function(type, unread, obj, objType, account) {
	var isTag = (type == ZmOrganizer.TAG);
	var tree = appCtxt.getTree(type, account);
	if (tree) {
		tree.reset();
	} else {
		tree = isTag ? new ZmTagTree(account) : new ZmFolderTree();
	}
	appCtxt.setTree(type, tree, account);
	tree.addChangeListener(this._unreadListener);
	tree.getUnreadHash(unread);
	tree.loadFromJs(obj, objType, account);
};

/**
 * To handle notifications, we keep track of all the models in use. A model could
 * be an item, a list of items, or an organizer tree. Currently we never get an
 * organizer by itself.
 * 
 * @private
 */
ZmRequestMgr.prototype._notifyHandler =
function(notify, methodName) {
	DBG.println(AjxDebug.DBG1, "Handling NOTIFY");
	AjxDebug.println(AjxDebug.NOTIFY, "Notification block:");
	AjxDebug.dumpObj(AjxDebug.NOTIFY, notify);
	this._controller.runAppFunction("preNotify", false, notify);
	if (notify.deleted && notify.deleted.id) {
		this._handleDeletes(notify.deleted);
	}
	if (notify.created) {
		this._handleCreates(notify.created);
	}
	if (notify.modified) {
		this._handleModifies(notify.modified);
	}

	if (ZmOffline.isOnlineMode() && (notify.deleted || notify.created || notify.modified)) {
		appCtxt.webClientOfflineHandler.scheduleSyncRequest(notify, methodName);
	}
	this._controller.runAppFunction("postNotify", false, notify);
};

/**
 * A delete notification hands us a list of IDs which could be anything. First, we
 * run any app delete handlers. Any IDs which have been handled by an app will
 * be nulled out. The generic handling here will be applied to the rest - the item is
 * retrieved from the item cache and told it has been deleted.
 *
 * @param {Object}	deletes	the node containing all 'deleted' notifications
 * 
 * @private
 */
ZmRequestMgr.prototype._handleDeletes =
function(deletes) {
	var ids = deletes.id.split(",");
	this._controller.runAppFunction("deleteNotify", false, ids);

	for (var i = 0; i < ids.length; i++) {
		var id = ids[i];
		if (!id) { continue; }
		var item = appCtxt.cacheGet(id);
		DBG.println(AjxDebug.DBG2, "ZmRequestMgr: handling delete notif for ID " + id);
		if (item && item.notifyDelete) {
			item.notifyDelete();
			appCtxt.cacheRemove(id);
			item = null;
		}
	}
};

/**
 * Create notifications hand us full XML nodes. First, we run any app
 * create handlers, which will mark any create nodes that they handle. Remaining
 * creates are handled here.
 * 
 * @param {Object}	creates	the node containing all 'created' notifications
 * 
 * @private
 */
ZmRequestMgr.prototype._handleCreates =
function(creates) {
	this._controller.runAppFunction("createNotify", false, creates);

	for (var name in creates) {
        if (creates.hasOwnProperty(name)) {
            var list = creates[name];
            for (var i = 0; i < list.length; i++) {
                var create = list[i];
                if (create._handled) { continue; }
                // ignore create notif for item we already have (except tags, which can reuse IDs)
                if (appCtxt.cacheGet(create.id) && name != "tag") { continue; }

                DBG.println(AjxDebug.DBG1, "ZmRequestMgr: handling CREATE for node: " + name);
                if (name == "tag") {
                    var account = appCtxt.multiAccounts && ZmOrganizer.parseId(create.id).account;
                    var tagTree = appCtxt.getTagTree(account);
                    if (tagTree) {
                        tagTree.root.notifyCreate(create);
                    }
                } else if (name == "folder" || name == "search" || name == "link") {
                    var parentId = create.l;
                    var parent = appCtxt.getById(parentId);
                    if (parent && parent.notifyCreate && parent.type != ZmOrganizer.TAG) { // bug #37148
                        parent.notifyCreate(create, name);
                    }
                }
            }
        }
	}
};

/**
 * First, we run any app modify handlers, which will mark any nodes that
 * they handle. Remaining modify notifications are handled here.
 * 
 * @param {Object}	modifies	the node containing all 'modified' notifications
 * 
 * @private
 */
ZmRequestMgr.prototype._handleModifies =
function(modifies) {

	this._controller.runAppFunction("modifyNotify", false, modifies);

	for (var name in modifies) {
		if (name == "mbx") {
			var mboxes = modifies[name];
			for (var i = 0; i < mboxes.length; i++) {
				var mbox = mboxes[i];
				var acctId = mbox.acct;
				var account = acctId && appCtxt.accountList.getAccount(acctId);
				var setting = appCtxt.getSettings(account).getSetting(ZmSetting.QUOTA_USED);
				setting.notifyModify({_name:name, s:mbox.s, account:account});
			}
			continue;
		}

		var list = modifies[name];
		for (var i = 0; i < list.length; i++) {
			var mod = list[i];
			if (mod._handled) { continue; }
			DBG.println(AjxDebug.DBG2, "ZmRequestMgr: handling modified notif for ID " + mod.id + ", node type = " + name);
			var item = appCtxt.cacheGet(mod.id);

			// bug fix #31991 - for contact modifies, check the contact list
			// Since we lazily create ZmContact items, it wont be in the global cache.
			// TODO: move to contacts app
			if (!item && name == "cn" && AjxDispatcher.loaded("ContactsCore")) {
				var capp = appCtxt.getApp(ZmApp.CONTACTS);
				if (capp.isContactListLoaded()) {
					item = capp.getContactList().getById(mod.id);
				}
			}

			if (item && item.notifyModify) {
				mod._isRemote = (name == "folder" && item.link);	// remote subfolder
				item.notifyModify(mod);
			}
		}
	}
};

/**
 * Changes browser title if it's a folder or tag whose unread count has changed.
 *
 * @param ev	the event
 * 
 * @private
 */
ZmRequestMgr.prototype._unreadChangeListener =
function(ev) {
	if (ev.event == ZmEvent.E_MODIFY) {
		var fields = ev.getDetail("fields");
		if (fields && fields[ZmOrganizer.F_UNREAD]) {
			var organizers = ev.getDetail("organizers");
			var organizer = organizers ? organizers[0] : null;
			var id = organizer ? (organizer.isSystem() ? organizer.nId : organizer.id) : null;
			var search = appCtxt.getCurrentSearch();
			if (search) {
				var searchFolder = appCtxt.multiAccounts && appCtxt.getById(search.folderId);
				var searchFolderId = (searchFolder && searchFolder.getAccount() == appCtxt.getActiveAccount())
					? searchFolder.nId : search.folderId;

				if (id && (id == searchFolderId || id == search.tagId)) {
					Dwt.setTitle(search.getTitle());
				}
			}
			var mailApp = appCtxt.getApp(ZmApp.MAIL);
			if (mailApp) {
				mailApp.setNewMailNotice(organizer);
			}
		}
	}
};

ZmRequestMgr.prototype._sensitiveRequest =
function(params, reqId) {
	DBG.println(AjxDebug.DBG2, "sending request securely");
	// adjust command parameters
	// TODO: Because of timing issues, should we not use session info?
	// TODO: But for batch commands, some updates would not be seen immediately.
	// TODO: To avoid security warning, send response in URL; so limit length
	params.noSession = true;
	params.noAuthToken = true;

	// information
	var requestStr = ZmCsfeCommand.getRequestStr(params);
	var loc = document.location;
	var port = appCtxt.get(ZmSetting.HTTPS_PORT);
	if (port && port != ZmSetting.DEFAULT_HTTPS_PORT) {
		port = ":"+port;
	}

	// create iframe
	var iframe = document.createElement("IFRAME");
	iframe.style.display = "none";
	iframe.id = Dwt.getNextId();
	document.body.appendChild(iframe);

	// set contents
	var iframeDoc = Dwt.getIframeDoc(iframe);
	iframeDoc.write(
		"<form ",
			"id=",iframe.id,"-form ",
			"target=",iframe.id,"-iframe ",
			"method=POST ",
			"action='https://",loc.hostname,port,appContextPath,"/public/secureRequest.jsp'",
		">",
			"<input type=hidden name=reqId value='",reqId,"'>",
			"<textarea name=data>",
				AjxStringUtil.htmlEncode(requestStr),
			"</textarea>",
		"</form>",
		"<iframe name=",iframe.id,"-iframe></iframe>"
	);
	iframeDoc.close();

	// save the params for the response
	params.iframeId = iframe.id;
	this._pendingRequests[reqId] = params;

	// submit form
	var form = iframeDoc.getElementById(iframe.id+"-form");
	form.submit();
};
}
if (AjxPackage.define("zimbraMail.core.ZmZimbraMail")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the Zimbra mail controller class.
 * 
 */

/**
 * Creates a controller to run ZimbraMail. Do not call directly, instead use the run()
 * factory method.
 * @constructor
 * @class
 * This class is the "ubercontroller", as it manages all the apps as well as bootstrapping
 * the ZimbraMail application.
 *
 * @param {Hash}	params	a hash of parameters
 * @param {constant}    params.app		the starting app
 * @param  {Element}	params.userShell	the top-level skin container
 *        
 * @extends	ZmController
 */
ZmZimbraMail = function(params) {

    if (arguments.length == 0) { return; }

	ZmController.call(this, null);

	appCtxt.setZimbraMail(this);
    appCtxt.setAppController(this);

	// ALWAYS set back reference into our world (also used by unload handler)
	window._zimbraMail = this;

    // app event handling
    this._evt = new ZmAppEvent();
    this._evtMgr = new AjxEventMgr();
    // copy over any statically registered listeners
    for (var type in ZmZimbraMail._listeners) {
        var list = ZmZimbraMail._listeners[type];
        if (list && list.length) {
            for (var i = 0; i < list.length; i++) {
                this._evtMgr.addListener(type, list[i]);
            }
        }
    }

    // all subsequent calls to register static app listeners go to instance
    ZmZimbraMail.addListener = AjxCallback.simpleClosure(this.addListener, this);
    ZmZimbraMail.addAppListener = AjxCallback.simpleClosure(this.addAppListener, this);

    // Create generic operations
    ZmOperation.initialize();

    // settings
    this._createSettings(params);
    this._createEnabledApps();
    this._initializeSettings(params);
	this._postInitializeSettings();

	//update body class to reflect user selected font
	document.body.className = "user_font_" + appCtxt.get(ZmSetting.FONT_NAME);
	//update root html elment class to reflect user selected font size (remove the "normal" size that was set by default).
	Dwt.delClass(document.documentElement, "user_font_size_normal", "user_font_size_" + appCtxt.get(ZmSetting.FONT_SIZE));

    // set internal state
	this._shell = appCtxt.getShell();
    this._userShell = params.userShell;

    this._requestMgr = new ZmRequestMgr(this); // NOTE: requires settings to be initialized

	this._appIframeView = {};
	this._activeApp = null;
	this._sessionTimer = new AjxTimedAction(null, ZmZimbraMail.executeSessionTimer);
	this._sessionTimerId = -1;
	this._pollActionId = null;	// AjaxTimedAction ID of timer counting down to next poll time
	this._pollRequest = null;	// HTTP request of poll we've sent to server
	this._pollInstantNotifications = false; // if TRUE, we're in "instant notification" mode
	this.statusView = null;
	ZmZimbraMail._exitTimer = new AjxTimedAction(null, ZmZimbraMail.exitSession);
	ZmZimbraMail._exitTimerId = -1;
	ZmZimbraMail.stayOnPagePrompt = false;
	ZmZimbraMail.STAYONPAGE_INTERVAL = 2;  //in minutes
    // setup history support
    if (appCtxt.get(ZmSetting.HISTORY_SUPPORT_ENABLED) && !AjxEnv.isSafari) {
        window.historyMgr = appCtxt.getHistoryMgr();
    }

    // create app view manager
    this._appViewMgr = new ZmAppViewMgr(this._shell, this, false, true);
	var hidden = [ ZmAppViewMgr.C_SEARCH_RESULTS_TOOLBAR, ZmAppViewMgr.C_TASKBAR ];
	if (!appCtxt.get(ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL)) {
		hidden.push(ZmAppViewMgr.C_TREE_FOOTER);
	}
	this._appViewMgr.setHiddenComponents(ZmAppViewMgr.GLOBAL, hidden, true);

    // register handlers
	AjxDispatcher.setPackageLoadFunction("Zimlet", new AjxCallback(this, this._postLoadZimlet));

	AjxDispatcher.setPreLoadFunction(new AjxCallback(this, function() {
		this._appViewMgr.pushView(ZmId.VIEW_LOADING);
	}));
	AjxDispatcher.setPostLoadFunction(new AjxCallback(this, function() {
		if (!AjxUtil.arrayContains(this._appViewMgr._toRemove, ZmId.VIEW_LOADING)) {
			this._appViewMgr._toRemove.push(ZmId.VIEW_LOADING);
		}
	}));

	for (var i in ZmApp.QS_ARG) {
		ZmApp.QS_ARG_R[ZmApp.QS_ARG[i]] = i;
	}

	this._shell.addGlobalSelectionListener(new AjxListener(this, this._globalSelectionListener));

    // setup webClient offline support
    appCtxt.initWebOffline();
    /// go!
	this.startup(params);
};

ZmZimbraMail.prototype = new ZmController;
ZmZimbraMail.prototype.constructor = ZmZimbraMail;

ZmZimbraMail.prototype.isZmZimbraMail = true;
ZmZimbraMail.prototype.toString = function() { return "ZmZimbraMail"; };

// REVISIT: This is done so that we when we switch from being "beta"
//          to production, we don't have to ensure that all of the
//          translations are changed at the same time. We can simply
//          remove the beta suffix from the app name.
ZmMsg.BETA_documents = [ZmMsg.documents, ZmMsg.beta].join(" ");

// dummy app (needed when defining drop targets in _registerOrganizers)
ZmApp.MAIN = "ZmZimbraMail";
ZmApp.DROP_TARGETS[ZmApp.MAIN] = {};

// Static listener registration
ZmZimbraMail._listeners = {};

// Consts
ZmZimbraMail.UI_LOAD_BEGIN		= "ui_load_begin";
ZmZimbraMail.UI_LOAD_END		= "ui_load_end";
ZmZimbraMail.UI_NETWORK_UP		= "network_up";
ZmZimbraMail.UI_NETWORK_DOWN	= "network_down";


// Public methods


/**
 * Sets up ZimbraMail, and then starts it by calling its constructor. It is assumed that the
 * CSFE is on the same host.
 *
 * @param {Hash}	params			a hash of parameters
 * @param {constant}      params.app				te starting app
 * @param {Boolean}      params.offlineMode		if <code>true</code>, this is the offline client
 * @param {Boolean}      params.devMode			if <code>true</code>, we are in development environment
 * @param {Hash}      params.settings			the server prefs/attrs
 * @param {constant}      params.protocolMode	the protocal mode (http, https or mixed)
 * @param {Boolean}      params.noSplashScreen	if <code>true</code>, do not show splash screen during startup
 */
ZmZimbraMail.run =
function(params) {

	if (params.noSplashScreen) {
		ZmZimbraMail.killSplash();
	}

	// Create the global app context
	window.appCtxt = new ZmAppCtxt();
	appCtxt.rememberMe = false;

	// Handle offline mode
	if (params.offlineMode) {
		DBG.println(AjxDebug.DBG1, "OFFLINE MODE");
		appCtxt.isOffline = true;
	}

	// Create the shell
	var userShell = params.userShell = window.document.getElementById(ZmId.SKIN_SHELL);
	if (!userShell) {
		alert("Could not get user shell - skin file did not load properly");
	}
	var shell = new DwtShell({userShell:userShell, docBodyScrollable:false, id:ZmId.SHELL});
	appCtxt.setShell(shell);

    // Go!
    new ZmZimbraMail(params);
};

/**
 * Unloads the controller. Allows parent window to walk list of open child windows and either "delete" 
 * or "disable" them.
 * 
 */
ZmZimbraMail.unload =
function() {

	if (!ZmZimbraMail._endSessionDone) {
		ZmZimbraMail._endSession();
	}

	if (ZmZimbraMail._isLogOff) {
		ZmZimbraMail._isLogOff = false;
		// stop keeping track of user input (if applicable)
		if (window._zimbraMail) {
			window._zimbraMail.setSessionTimer(false);
		}

		ZmCsfeCommand.noAuth = true;
	}

	ZmZimbraMail.closeChildWindows();
	
	ZmZimbraMail.stayOnPagePrompt = false;
	ZmZimbraMail.setExitTimer(false);
	ZmZimbraMail.sessionTimerInvoked = false;
	window._zimbraMail = window.onload = window.onunload = window.onresize = window.document.onkeypress = null;
};

ZmZimbraMail.closeChildWindows =
function() {
	
	var childWinList = window._zimbraMail && window._zimbraMail._childWinList;
	if (childWinList) {
		// close all child windows
		for (var i = 0; i < childWinList.size(); i++) {
			var childWin = childWinList.get(i);
			if (childWin.win) {
				childWin.win.onbeforeunload = null;
				childWin.win.parentController = null;
				childWin.win.close();
			}
		}
	}
};

/**
 * Returns sort order using a and b as keys into given hash.
 *
 * @param {Hash}	hash		a hash with sort values
 * @param {String}	a			a key into hash
 * @param {String}	b			a key into hash
 * @return	{int}	0 if the items are the same; 1 if "a" is before "b"; -1 if "b" is before "a"
 */
ZmZimbraMail.hashSortCompare =
function(hash, a, b) {
	var appA = a ? Number(hash[a]) : 0;
	var appB = b ? Number(hash[b]) : 0;
	if (appA > appB) { return 1; }
	if (appA < appB) { return -1; }
	return 0;
};

/**
 * Hides the splash screen.
 * 
 */
ZmZimbraMail.killSplash =
function() {
	// 	Splash screen is now a part of the skin, loaded in statically via the JSP
	//	as a well-known ID.  To hide the splash screen, just hide that div.
	Dwt.hide("skin_container_splash_screen");
};

/**
 * Returns the state of ZCS application if user is logged out in case of browser quit.
 * The public method is added to take appropriate action in the chat app if user session is ending.
 *
 *
 * @public
 */
ZmZimbraMail.hasSessionEnded =
    function() {
        return ZmZimbraMail._endSessionDone;
    };

/**
 * Startup the mail controller.
 * 
 * <p>
 * The following steps are performed:
 * <ul>
 * <li>check for skin, show it</li>
 * <li>create app view mgr</li>
 * <li>create components (sash, banner, user info, toolbar above overview, status view)</li>
 * <li>create apps</li>
 * <li>load user settings (using a <code>&lt;GetInfoRequest&gt;</code>)</li>
 * </ul>
 * 
 * @param {Hash}	params		a hash of parameters
 * @param {constant}	app			the starting app
 * @param {Hash}	settings		a hash of settings overrides
 */
ZmZimbraMail.prototype.startup =
function(params) {

	if (appCtxt.isOffline) {
		this.sendClientEventNotify(ZmZimbraMail.UI_LOAD_BEGIN);
	}

	appCtxt.inStartup = true;
	if (typeof(skin) == "undefined") {
		DBG.println(AjxDebug.DBG1, "No skin!");
	}

	skin.show("skin", true);
	appCtxt.getShell().relayout();

	if (!this._components) {
		this._components = {};
		this._components[ZmAppViewMgr.C_SASH] = new DwtSash({parent:this._shell, style:DwtSash.HORIZONTAL_STYLE,
															 className:"console_inset_app_l", threshold:20, id:ZmId.MAIN_SASH});
		this._components[ZmAppViewMgr.C_SASH].addListener(DwtEvent.ONMOUSEUP, ZmZimbraMail._folderTreeSashRelease);
		this._components[ZmAppViewMgr.C_BANNER] = this._createBanner();
		this._components[ZmAppViewMgr.C_USER_INFO] = this._userNameField =
			this._createUserInfo("BannerTextUser", ZmAppViewMgr.C_USER_INFO, ZmId.USER_NAME);
		this._components[ZmAppViewMgr.C_QUOTA_INFO] = this._usedQuotaField =
			this._createUserInfo("BannerTextQuota", ZmAppViewMgr.C_QUOTA_INFO, ZmId.USER_QUOTA);

		if (appCtxt.isOffline) {
			this._initOfflineUserInfo();
		}
	}

	if (!this.statusView) {
		this.statusView = new ZmStatusView(this._shell, "ZmStatus", Dwt.ABSOLUTE_STYLE, ZmId.STATUS_VIEW);
	}

	this._registerOrganizers();

	// set up map of search types to item types
	for (var i in ZmSearch.TYPE) {
		ZmSearch.TYPE_MAP[ZmSearch.TYPE[i]] = i;
	}
	ZmZimbraMail.registerViewsToTypeMap();

	this._getStartApp(params);
	appCtxt.startApp = params.startApp;

	this._postRenderCallbacks = [];
	this._postRenderLast = 0;
	if (params.startApp == ZmApp.MAIL) {
		this._doingPostRenderStartup = true;
		var callback = new AjxCallback(this,
			function() {
				AjxDispatcher.require("Startup2");
				var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
				if (appCtxt.get(ZmSetting.CALENDAR_ENABLED, null, account)) {
					this.handleCalendarComponents();
				}
				if (appCtxt.get(ZmSetting.TASKS_ENABLED, null, account)) {
					this.handleTaskComponents();
				}
				this._appViewMgr.loadingView.setVisible(false);
			});
		this.addPostRenderCallback(callback, 0, 0, true);

		// wait half a minute and load TinyMCE
		var callback = new AjxCallback(this, function() {
			AjxDispatcher.require("Startup2");

			var timer = new DwtIdleTimer(30 * 1000, function() {
				AjxDispatcher.require('TinyMCE', true);
				timer.kill();
			});
		});
		this.addPostRenderCallback(callback, 0, 0, true);
	}

    // NOTE: We must go through the request mgr for default handling
    var getInfoResponse = AjxUtil.get(params, "getInfoResponse");
    if (getInfoResponse) {
        this._requestMgr.sendRequest({response:getInfoResponse});
    }

	// fetch meta data for the main account
	var respCallback = new AjxCallback(this, this._handleResponseGetMetaData, params);
	appCtxt.accountList.mainAccount.loadMetaData(respCallback);

	//todo - might want to move this call and the methods to ZmMailApp as it's specific to mail app only.
    this._initDelegatedSenderAddrs();
    if(appCtxt.isOffline) {
        var updatePref = appCtxt.get(ZmSetting.OFFLINE_UPDATE_NOTIFY);
        this._offlineUpdateChannelPref(updatePref)
    }
};


ZmZimbraMail.prototype._initDelegatedSenderAddrs =
function() {
    var soapDoc = AjxSoapDoc.create("DiscoverRightsRequest", "urn:zimbraAccount");
    soapDoc.set("right","sendAs" );
    soapDoc.set("right","sendOnBehalfOf");
    soapDoc.set("right","sendAsDistList");
    soapDoc.set("right","sendOnBehalfOfDistList");
    var batchCmd = new ZmBatchCommand(null, appCtxt.accountList.mainAccount.name);
    var callback = this._initDelegatedSenderEmails.bind(this);
    batchCmd.addNewRequestParams(soapDoc, callback, callback);
	var offlineCallback = this._handleOfflineDelegatedSenderEmails.bind(this, callback);
    batchCmd.run(null, null, offlineCallback);
};

ZmZimbraMail.prototype._getDelegatedSenderEmails =
function(sendRights, sendRight) {
	var emails = [];
	if (!sendRights || !sendRights.length) {
		return emails;
	}
	for (var i = 0; i < sendRights.length; i++) {
		var targets = sendRights[i].target;
		var right = sendRights[i].right;
		var sendRightDistList = sendRight + "DistList";
		if (right !== sendRight && right !== sendRightDistList) {
			continue;
		}
		var isDL = right === sendRightDistList;
		for (var j = 0; j < targets.length; j++) {
			var target = targets[j];
			var emailList = target.email;
			for (var k = 0; k < emailList.length; k++) {
				var addr = emailList[k].addr;
				emails.push({addr: addr, isDL: isDL, displayName: target.d});
			}
		}

	}
	return emails;
};

ZmZimbraMail.prototype._initDelegatedSenderEmails =
function(result){
    var response = result.getResponse();
	if (ZmOffline.isOnlineMode()) {
		localStorage.setItem("DiscoverRightsResponse", JSON.stringify(response));
	}
	var discoverRightsResponse = response && response.DiscoverRightsResponse;
	var sendRights = discoverRightsResponse && discoverRightsResponse.targets;
    appCtxt.sendAsEmails = this._getDelegatedSenderEmails(sendRights, 'sendAs');
    appCtxt.sendOboEmails = this._getDelegatedSenderEmails(sendRights, 'sendOnBehalfOf');
};

ZmZimbraMail.prototype._handleOfflineDelegatedSenderEmails =
function(callback) {
	var result = localStorage.getItem("DiscoverRightsResponse");
	if (result) {
		var csfeResult = new ZmCsfeResult({BatchResponse : JSON.parse(result)});
		callback.run(csfeResult);
	}
};

ZmZimbraMail.registerViewsToTypeMap = function() {
	// organizer types based on view
	for (var i in ZmOrganizer.VIEWS) {
		var list = ZmOrganizer.VIEWS[i];
		for (var j = 0; j < list.length; j++) {
			ZmOrganizer.TYPE[list[j]] = i;
		}
	}
};

ZmZimbraMail.prototype._createSettings = function(params) {
    // We've received canned SOAP responses for GetInfoRequest and SearchRequest from the
    // launch JSP, wrapped in a BatchRequest. Jiggle them so that they look like real
    // responses, and pass them along.
    if (params.batchInfoResponse) {
        var batchResponse = params.batchInfoResponse.Body.BatchResponse;

        // always assume there's a get info response
		var infoResponse = batchResponse.GetInfoResponse[0];
		if(!infoResponse) {
			infoResponse ={}
		}
		//store per-domain settings in infoResponse obj so we can access it like other settings
		infoResponse.domainSettings = params.settings;
        params.getInfoResponse = {
            Header: params.batchInfoResponse.Header,
            Body: { GetInfoResponse: infoResponse}
        };
        var session = AjxUtil.get(params.getInfoResponse, "Header", "context", "session");
        if (session) {
            ZmCsfeCommand.setSessionId(session);
        }
        DBG.println(AjxDebug.DBG1, ["<b>RESPONSE (from JSP tag)</b>"].join(""), "GetInfoResponse");
        DBG.dumpObj(AjxDebug.DBG1, params.getInfoResponse, -1);

        // we may have an initial search response
        if (batchResponse.SearchResponse) {
            params.searchResponse = {
                Body: { SearchResponse: batchResponse.SearchResponse[0] }
            };
            DBG.println(AjxDebug.DBG1, ["<b>RESPONSE (from JSP tag)</b>"].join(""), "SearchResponse");
            DBG.dumpObj(AjxDebug.DBG1, params.searchResponse, -1);
        }
    }

    // create settings
    var settings = new ZmSettings()
    appCtxt.setSettings(settings);

    // We have to pre-initialize the settings in order to create
    // the enabled apps correctly.
    settings.setUserSettings({info:params.getInfoResponse.Body.GetInfoResponse, preInit:true});
};

ZmZimbraMail.prototype._initializeSettings = function(params) {
    var info = params.getInfoResponse.Body.GetInfoResponse;

    var settings = appCtxt.getSettings();
    // NOTE: Skip notify to avoid callbacks which reference objects that aren't set, yet
    settings.setUserSettings(info, null, true, true, true);
    settings.userSettingsLoaded = true;

    // settings structure and defaults
    var branch = appCtxt.get(ZmSetting.BRANCH);
    if (window.DBG && !DBG.isDisabled()) {
        DBG.setTitle("Debug (" + branch + ")");
    }

    // setting overrides
    if (params.settings) {
        for (var name in params.settings) {
            var id = settings.getSettingByName(name);
            if (id) {
                settings.getSetting(id).setValue(params.settings[name]);
            }
        }
    }

    // reset polling interval for offline
    if (appCtxt.isOffline) {
        appCtxt.set(ZmSetting.POLLING_INTERVAL, 60, null, null, true);
    }

    // Handle dev mode
    if (params.devMode == "1") {
        DBG.println(AjxDebug.DBG1, "DEV MODE");
        appCtxt.set(ZmSetting.DEV, true);
    }

    // Handle protocol mode - standardize on trailing :
    if (params.protocolMode) {
        var proto = (params.protocolMode.indexOf(":") == -1) ? params.protocolMode + ":" : params.protocolMode;
        appCtxt.set(ZmSetting.PROTOCOL_MODE, proto);
    }
    if (params.httpPort) {
        appCtxt.set(ZmSetting.HTTP_PORT, params.httpPort);
    }
    if (params.httpsPort) {
        appCtxt.set(ZmSetting.HTTPS_PORT, params.httpsPort);
    }

    // hide spam if not enabled
    if (!appCtxt.get(ZmSetting.SPAM_ENABLED)) {
        ZmFolder.HIDE_ID[ZmFolder.ID_SPAM] = true;
    }

	// Chats hidden by default, check for override
	if (appCtxt.get(ZmSetting.SHOW_CHATS_FOLDER)) {
		delete ZmFolder.HIDE_ID[ZmOrganizer.ID_CHATS];
	}
};

/**
 * Perform any additional operation after initializing settings
 * @private
 */
ZmZimbraMail.prototype._postInitializeSettings =
function() {
	this._setCustomInvalidEmailPats();
};

/**
 * Set an array of invalid Email patterns(values of zimbraMailAddressValidationRegex in ldap) to
 * AjxEmailAddress.customInvalidEmailPats
 * @private
 */
ZmZimbraMail.prototype._setCustomInvalidEmailPats =
function() {
 	var customPatSetting = appCtxt.getSettings().getSetting(ZmSetting.EMAIL_VALIDATION_REGEX);
	var cPatList = [];
	if(customPatSetting) {
		cPatList = customPatSetting.value;
	}
	for(var i = 0; i< cPatList.length; i++) {
		var pat = cPatList[i];
		if(pat && pat != "") {
			  AjxEmailAddress.customInvalidEmailPats.push(new RegExp(pat))
		}
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype._handleResponseGetMetaData =
function(params) {

	if (appCtxt.get(ZmSetting.CONTACTS_ENABLED)) {
		var method = appCtxt.multiAccounts ? "GetContactsForAllAccounts" : "GetContacts";
		AjxDispatcher.run({
			method:     method,
			callback:   this._handleResponseLoadUserSettings.bind(this, params)
		});
	}
	else {
		this._handleResponseLoadUserSettings(params);
	}
};

/**
 * Shows the mini-calendar.
 * 
 */
ZmZimbraMail.prototype.showMiniCalendar =
function() {
	var calMgr = appCtxt.getCalManager();
	calMgr.getMiniCalendar();
	appCtxt.getAppViewMgr().displayComponent(ZmAppViewMgr.C_TREE_FOOTER, true);
    calMgr.highlightMiniCal();
    calMgr.startDayRollTimer();
};

/**
 * Shows reminders.
 */
ZmZimbraMail.prototype.showReminder =
function() {
    var reminderController = appCtxt.getApp(ZmApp.CALENDAR).getReminderController();
	reminderController.refresh();
};

/**
 * Shows reminders.
 */
ZmZimbraMail.prototype.showTaskReminder =
function() {
	var taskMgr = appCtxt.getTaskManager();
	var taskReminderController = taskMgr.getReminderController();
	taskReminderController.refresh();
};

ZmZimbraMail.prototype._isProtocolHandlerAccessed =
function() {
    if (AjxEnv.isFirefox){
      if (!localStorage || localStorage['zimbra_mailto_init']) return true;
      localStorage['zimbra_mailto_init'] = true;
    }
    return false;
};

/**
 * @private
 */
ZmZimbraMail.prototype._handleResponseLoadUserSettings =
function(params, result) {
	if (appCtxt.multiAccounts) {
		var callback = new AjxCallback(this, this._handleResponseStartup, [params, result]);
		appCtxt.accountList.loadAccounts(callback);
	} else {
		this._handleResponseStartup(params, result);
	}
};

/**
 * Startup: part 2
 * 	- create app toolbar component
 * 	- determine and launch starting app
 *
 * @param {Hash}	params			a hash of parameters
 * @param       {constant}	params.app				the starting app
 * @param       {Object}	params.settingOverrides	a hash of overrides of user settings
 * @param {ZmCsfeResult}	result		the result object from load of user settings
 * 
 * @private
 */
ZmZimbraMail.prototype._handleResponseStartup =
function(params, result) {

	params = params || {};
	if (params.settingOverrides) {
		this._needOverviewLayout = true;
		for (var id in params.settingOverrides) {
			var setting = appCtxt.getSetting(id);
			if (setting) {
				setting.setValue(params.settingOverrides[id]);
			}
		}
	}
	if (params.preset) {
		var presets = params.preset.split(",");
		for (var i = 0; i < presets.length; i++) {
			var fields = presets[i].split(":");
			var setting = appCtxt.getSettings().getSetting(fields[0]);
			if (setting && setting.canPreset) {
				setting.setValue(fields[1]);
			}
		}
	}

	if (!appCtxt.isOffline) {
        if (appCtxt.get(ZmSetting.INSTANT_NOTIFY) && appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL) == appCtxt.get(ZmSetting.POLLING_INTERVAL))
            AjxTimedAction.scheduleAction(new AjxTimedAction(this, this.setInstantNotify, [true]), 4000);
        else
		    this.setPollInterval(true);
	} else {
		if (appCtxt.get(ZmSetting.OFFLINE_SUPPORTS_MAILTO) && window.platform && 
			window.platform.isRegisteredProtocolHandler("mailto")) {  
		    // bug fix #34342 - always register the protocol handler for mac and linux on start up
		    this.registerMailtoHandler(!AjxEnv.isWindows, true);
		}    
	}

	window.onbeforeunload = ZmZimbraMail._confirmExitMethod;

	if (!this._components[ZmAppViewMgr.C_APP_CHOOSER]) {
		this._components[ZmAppViewMgr.C_APP_CHOOSER] = this._appChooser = this._createAppChooser();
	}

	ZmApp.initialize();

    if(appCtxt.get(ZmSetting.DEFAULT_TIMEZONE)) {
        AjxTimezone.DEFAULT_RULE = AjxTimezone._guessMachineTimezone(appCtxt.get(ZmSetting.DEFAULT_TIMEZONE));
        AjxTimezone.DEFAULT = AjxTimezone.getClientId(AjxTimezone.DEFAULT_RULE.serverId);
    }

	this.notify(ZmAppEvent.PRE_STARTUP);

	params.result = result;
	var respCallback = new AjxCallback(this, this._handleResponseStartup1, params);

	// startup and packages have been optimized for quick mail display
	if (this._doingPostRenderStartup) {
		this.addAppListener(params.startApp, ZmAppEvent.POST_RENDER, new AjxListener(this, this._postRenderStartup));
        //For offline mode offline callback will take care
		if (!appCtxt.isWebClientOffline()) {
	        this._searchResponse = params.searchResponse;
        }
	} else {
		AjxDispatcher.require("Startup2");
	}

	// Set up post-render callbacks

	// run app-related startup functions
	var callback = new AjxCallback(this,
		function() {
			this.runAppFunction("startup", false, params.result);
		});
	this.addPostRenderCallback(callback, 2, 0, true);

	callback = new AjxCallback(this,
		function() {
			this._setupTabGroups();
			this.focusContentPane();
		});
	this.addPostRenderCallback(callback, 3, 100);

	// miscellaneous post-startup housekeeping
	callback = new AjxCallback(this,
		function() {
			AjxDispatcher.enableLoadFunctions(true);
			appCtxt.inStartup = false;
			this.notify(ZmAppEvent.POST_STARTUP);

			var sc = appCtxt.getSearchController();
			sc.getSearchToolbar().initAutocomplete();

			// bug fix #31996
			if (appCtxt.isOffline) {
				sc.resetSearchToolbar();
			}

			if (appCtxt.get(ZmSetting.OFFLINE_SUPPORTS_MAILTO) && appCtxt.isOffline) {
				this.handleOfflineMailTo(location.search);
			}
		});
	this.addPostRenderCallback(callback, 5, 100);

    if (appCtxt.get(ZmSetting.MAIL_ENABLED) && !appCtxt.isExternalAccount() && navigator.registerProtocolHandler && !this._isProtocolHandlerAccessed()){
        callback = new AjxCallback(this,
            function() {
                try {
                    navigator.registerProtocolHandler("mailto",AjxUtil.formatUrl({qsArgs:{view:'compose',to:'%s'}, qsReset:true}) ,ZmMsg.zimbraTitle);
                } catch (err){};
        });
        this.addPostRenderCallback(callback, 6, 100);
    }

	this.activateApp(params.startApp, false, respCallback, this._errorCallback, params);

	var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
	if (appCtxt.get(ZmSetting.CALENDAR_ENABLED, null, account) &&
		!this._doingPostRenderStartup &&
		(params.startApp != ZmApp.CALENDAR))
	{
		this.handleCalendarComponents();
	}
	if (appCtxt.get(ZmSetting.TASKS_ENABLED, null, account) &&
		!this._doingPostRenderStartup &&
		(params.startApp != ZmApp.TASKS))
	{
		this.handleTaskComponents();
	}

	if (appCtxt.get(ZmSetting.IMPORT_ON_LOGIN_ENABLED)) {
		var ds = new ZmDataSourceCollection();
		var dsCollection = appCtxt.getDataSourceCollection();
		var pop3Accounts = dsCollection && dsCollection.getPopAccounts();
		var imapAccounts = dsCollection && dsCollection.getImapAccounts();
		var sourceMap = {};
		if (pop3Accounts) {
			for (var i=0; i<pop3Accounts.length; i++) {
				sourceMap[pop3Accounts[i].id] = pop3Accounts[i];
			}
		}
		if (imapAccounts) {
			for (var i=0; i<imapAccounts.length; i++) {
				sourceMap[imapAccounts[i].id] = imapAccounts[i];	
			}
		}
		
		if (pop3Accounts || imapAccounts) {
			var action = new AjxTimedAction(ds, ds.checkStatus, [sourceMap, 2000]);
			AjxTimedAction.scheduleAction(action, 10000);  //kick off check in 10 seconds
		}
	}
};

/**
 * Creates & show Task Reminders on delay
 *
 * @private
 */
ZmZimbraMail.prototype.handleTaskComponents =
function() {
	var reminderAction = new AjxTimedAction(this, this.showTaskReminder);
	var delay = appCtxt.isOffline ? 0 : ZmTasksApp.REMINDER_START_DELAY;
	AjxTimedAction.scheduleAction(reminderAction, delay);
};

/**
 * Creates mini calendar and shows reminders on delay
 * 
 * @private
 */
ZmZimbraMail.prototype.handleCalendarComponents =
function() {
	if (appCtxt.get(ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL)) {
        var miniCalAction = new AjxTimedAction(this, this.showMiniCalendar);
		var delay = appCtxt.isOffline ? 0 : ZmCalendarApp.MINICAL_DELAY;
        AjxTimedAction.scheduleAction(miniCalAction, delay);
	}

	AjxDispatcher.require(["ContactsCore", "MailCore", "CalendarCore", "Calendar"]);
	var reminderAction = new AjxTimedAction(this, this.showReminder);
	var delay = appCtxt.isOffline ? 0 : ZmCalendarApp.REMINDER_START_DELAY;
	AjxTimedAction.scheduleAction(reminderAction, delay);
};

/**
 * Startup: part 3
 * 	- populate user info
 * 	- create search bar
 * 	- set up keyboard handling (shortcuts and tab groups)
 * 	- kill splash, show UI
 * 	- check license
 *
 * @param {Hash}	params			a hash of parameters
 * @param {constant}	params.app				the starting app
 * @param {Object}	params.settingOverrides	a hash of overrides of user settings
 *        
 * @private
 */
ZmZimbraMail.prototype._handleResponseStartup1 =
function(params) {

	this._setExternalLinks();
	this.setUserInfo();
	this._setRefresh();

	if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
		this._components[ZmAppViewMgr.C_SEARCH] = appCtxt.getSearchController().getSearchToolbar();
	}
	else {
		Dwt.hide(ZmId.SKIN_SEARCH);
	}
	
	var newButton = this.getNewButton();
	var tbParams = {
		parent:				this._shell,
		context:			ZmOperation.NEW_MENU,
		buttons:			ZmOperation.NONE,
		controller:			this,
		refElementId:		ZmId.SKIN_APP_NEW_BUTTON
	};
	var tb = this._newToolbar = new ZmButtonToolBar(tbParams);
	newButton.reparent(tb);
	this._components[ZmAppViewMgr.C_NEW_BUTTON] = tb;
	
	if (params.unitTest) {
		var utm = window.unitTestManager;
		appCtxt.addZimletsLoadedListener(utm.runTests.bind(utm), 0);
	}

	this.getKeyMapMgr();	// make sure keyboard handling is initialized

	this.setSessionTimer(true);
	ZmZimbraMail.killSplash();

	// Give apps a chance to add their own UI components.
	this.runAppFunction("addComponents", false, this._components);

	// make the UI appear
	this._appViewMgr.setViewComponents(ZmAppViewMgr.GLOBAL, this._components, true);

	this._checkLicense();

	if (!this._doingPostRenderStartup) {
		this._postRenderStartup();
	}
};

/**
 * set the refresh button at the masthead.
 */
ZmZimbraMail.prototype._setRefresh =
function() {
	var containerEl = document.getElementById(ZmId.SKIN_REFRESH);
	if (!containerEl) {
		return;
	}
	var button = appCtxt.refreshButton = new DwtToolBarButton({parent:DwtShell.getShell(window), id: ZmId.OP_CHECK_MAIL}); //use ToolbarButton just for the style, for now it looks ok.
	button.setImage("RefreshAll");
	button.setToolTipContent(ZmMsg.checkMailPrefUpdate, true);

	button.reparentHtmlElement(ZmId.SKIN_REFRESH);

	var refreshListener = this._refreshListener.bind(this);
	button.addSelectionListener(refreshListener);

};

/**
 * refresh button listener. call runRefresh() of all the enabled apps that have this method defined.
 */
ZmZimbraMail.prototype._refreshListener =
function() {
	if (!appCtxt.isWebClientOffline()) {
		this.runAppFunction("runRefresh");
	}
};

// popup a warning dialog if there is a problem with the license
ZmZimbraMail.prototype._checkLicense =
function(ev) {

	var status = appCtxt.get(ZmSetting.LICENSE_STATUS);
	var msg = ZmSetting.LICENSE_MSG[status];
	if (msg) {
		AjxDispatcher.require("Startup2");
		var dlg = appCtxt.getMsgDialog();
		dlg.reset();
        dlg.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
		dlg.popup();
	}
};

/**
 * The work to render the start app has been done. Now perform all the startup
 * work that remains - each piece of work is contained in a callback with an
 * associated order and delay.
 * 
 * @private
 */
ZmZimbraMail.prototype._postRenderStartup =
function(ev) {
	this._postRenderCallbacks.sort(function(a, b) {
		return a.order - b.order;
	});
	this._runNextPostRenderCallback();
};

/**
 * @private
 */
ZmZimbraMail.prototype._runNextPostRenderCallback =
function() {
	DBG.println(AjxDebug.DBG2, "POST-RENDER CALLBACKS: " + this._postRenderCallbacks.length);
	if (this._postRenderCallbacks && this._postRenderCallbacks.length) {
		var prcb = this._postRenderCallbacks.shift();
		if (!prcb) { return; }
		DBG.println(AjxDebug.DBG2, "POST-RENDER CALLBACK: #" + prcb.order + ", delay " + prcb.delay + " in " + prcb.callback.obj.toString());
		AjxTimedAction.scheduleAction(new AjxTimedAction(this,
			function() {
				prcb.callback.run();
				this._runNextPostRenderCallback();
			}), prcb.delay);
	} else {
		if (appCtxt.isOffline) {
			this.sendClientEventNotify(ZmZimbraMail.UI_LOAD_END);

			if (AjxEnv.isPrism) {
				this._firstTimeNetworkChange = true;

				var nc = new ZimbraNetworkChecker();
				nc.addEventListener("offline", function(e) { window["appCtxt"].getAppController().handleNetworkChange(false); }, false);
				nc.addEventListener("online", function(e) { window["appCtxt"].getAppController().handleNetworkChange(true); }, false);
			}
		}
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype.handleNetworkChange =
function(online) {
	this._isPrismOnline = online;

	if (this._isUserOnline || this._firstTimeNetworkChange) {
		this._updateNetworkStatus(online);
	}
};

ZmZimbraMail.prototype._updateNetworkStatus =
function(online) {
	// bug 48108 - Prism sometimes triggers network status change mutliple times
	// So don't bother if the last change is the same as current status
	if ((online && this._currentNetworkStatus == ZmZimbraMail.UI_NETWORK_UP) ||
		(!online && this._currentNetworkStatus == ZmZimbraMail.UI_NETWORK_DOWN))
	{
		return;
	}

	if (online) {
		if (!this._firstTimeNetworkChange) {
			this.setStatusMsg(ZmMsg.networkChangeOnline);
		} else {
			this._firstTimeNetworkChange = false;
			this._isUserOnline = online;
		}
		this._currentNetworkStatus = ZmZimbraMail.UI_NETWORK_UP;
        this.sendClientEventNotify(this._currentNetworkStatus, true);
	} else {
		this.setStatusMsg(ZmMsg.networkChangeOffline, ZmStatusView.LEVEL_WARNING);
		this._currentNetworkStatus = ZmZimbraMail.UI_NETWORK_DOWN;
        this.sendClientEventNotify(this._currentNetworkStatus);
	}

	this._networkStatusIcon.setToolTipContent(online ? ZmMsg.networkStatusOffline : ZmMsg.networkStatusOnline, true);
	this._networkStatusIcon.getHtmlElement().innerHTML = AjxImg.getImageHtml(online ? "Connect" : "Disconnect");
	var netStatus = online ? ZmMsg.netStatusOnline : ZmMsg.netStatusOffline;
	this._networkStatusText.getHtmlElement().innerHTML = netStatus.substr(0, 1).toUpperCase() + netStatus.substr(1);
};

/**
 * Sets up a callback to be run after the starting app has rendered, if we're doing
 * post-render callbacks. The callback is registered with an order that determines
 * when it will run relative to other callbacks. A delay can also be given, so that
 * the UI has a chance to do some work between callbacks.
 *
 * @param {AjxCallback}	callback		the callback
 * @param {int}	order			the run order for the callback
 * @param {int}	delay			how long to pause before running the callback
 * @param {Boolean}	runNow		if <code>true</code>, we are not doing post-render callbacks, run the callback now and don't add it to the list
 */
ZmZimbraMail.prototype.addPostRenderCallback =
function(callback, order, delay, runNow) {
	if (!this._doingPostRenderStartup && runNow) {
		callback.run();
	} else {
		order = order || this._postRenderLast++;
		this._postRenderCallbacks.push({callback:callback, order:order, delay:delay || 0});
	}
};

ZmZimbraMail.prototype._isInternalApp =
function(app) {
	return !ZmApp.SETTING[app] || (appCtxt.get(ZmApp.SETTING[app], null, appCtxt.multiAccounts && appCtxt.accountList.mainAccount));
};

ZmZimbraMail.prototype._isIframeApp =
function(app) {
	return !this._isInternalApp(app) && appCtxt.get(ZmApp.UPSELL_SETTING[app]);
};

/**
 * @private
 */
ZmZimbraMail.prototype._getStartApp =
function(params) {
	// determine starting app
	var startApp;
	var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
	if (params && params.app) {
		startApp = ZmApp.QS_ARG_R[params.app.toLowerCase()];
		// make sure app given in QS is actually enabled
		// an app is valid if it's enabled as internal, iframe, or external
		if (!this._isInternalApp(startApp) && !this._isIframeApp(startApp)) {
			startApp = null;
		}
	}
	if (!startApp) {
		for (var app in ZmApp.DEFAULT_SORT) {
			ZmApp.DEFAULT_APPS.push(app);
		}
		ZmApp.DEFAULT_APPS.sort(function(a, b) {
			return ZmZimbraMail.hashSortCompare(ZmApp.DEFAULT_SORT, a, b);
		});
		var defaultStartApp = null;
		for (var i = 0; i < ZmApp.DEFAULT_APPS.length; i++) {
			var app = ZmApp.DEFAULT_APPS[i];
			if (this._isInternalApp(app)) {
				defaultStartApp = app;
				break;
			}
		}
		startApp = this._getDefaultStartAppName(account);
	}

	// parse query string, in case we are coming in with a deep link	
	var qsParams = AjxStringUtil.parseQueryString();
	if (qsParams && qsParams.view && !qsParams.app) {
		startApp = ZmApp.QS_VIEWS[qsParams.view];
	}

	params.startApp = startApp;
	params.qsParams = qsParams;
};

/**
 * @private
 */
ZmZimbraMail.prototype._getDefaultStartAppName =
function(account) {
	account = account || (appCtxt.multiAccounts && appCtxt.accountList.mainAccount) || null;
	
	for (var app in ZmApp.DEFAULT_SORT) {
		ZmApp.DEFAULT_APPS.push(app);
	}
	ZmApp.DEFAULT_APPS.sort(function(a, b) {
		return ZmZimbraMail.hashSortCompare(ZmApp.DEFAULT_SORT, a, b);
	});
	var defaultStartApp = null;
	for (var i = 0; i < ZmApp.DEFAULT_APPS.length; i++) {
		var app = ZmApp.DEFAULT_APPS[i];
		var setting = ZmApp.SETTING[app];
		if (!setting || appCtxt.get(setting, null, account)) {
			return app;
		}
	}
};

/**
 * Cancels the request.
 * 
 * @param	{String}	reqId		the request id
 * @param	{AjxCallback}	errorCallback		the callback
 * @param	{Boolean}	noBusyOverlay	if <code>true</code>, do not show busy overlay
 * @see	ZmRequestMgr#cancelRequest
 */
ZmZimbraMail.prototype.cancelRequest =
function(reqId, errorCallback, noBusyOverlay) {
	this._requestMgr.cancelRequest(reqId, errorCallback, noBusyOverlay);
};

/**
 * Sends the request.
 * 
 * @param	{Hash}	params		a hash of parameters
 * @see	ZmRequestMgr#sendRequest
 */
ZmZimbraMail.prototype.sendRequest =
function(params) {
	return this._requestMgr.sendRequest(params);
};

/**
 * Runs the given function for all enabled apps, passing args.
 *
 * @param {String}	funcName		the function name
 * @param {Boolean}	force			if <code>true</code>, run func for disabled apps as well
 */
ZmZimbraMail.prototype.runAppFunction =
function(funcName, force) {
	var args = [];
	for (var i = 2; i < arguments.length; i++) {
		args.push(arguments[i]);
	}
	for (var i = 0; i < ZmApp.APPS.length; i++) {
		var appName = ZmApp.APPS[i];
		var setting = this._isIframeApp(appName) ? ZmApp.UPSELL_SETTING[appName] : ZmApp.SETTING[appName];
		var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
		if (!setting || appCtxt.get(setting, null, account) || force) {
			var app = appCtxt.getApp(appName, null, account);
			var func = app && app[funcName];
			if (func && (typeof(func) == "function")) {
				func.apply(app, args);
			}
		}
	}
	appCtxt.notifyZimlets("runAppFunction", [funcName]);
};

/**
 * Instantiates enabled apps. An optional argument may be given limiting the set
 * of apps that may be created.
 *
 * @param {Hash}	apps	the set of apps to create
 * 
 * @private
 */
ZmZimbraMail.prototype._createEnabledApps =
function(apps) {
    this._apps = {};

	for (var app in ZmApp.CLASS) {
		if (!apps || apps[app]) {
			ZmApp.APPS.push(app);
		}
	}
	ZmApp.APPS.sort(function(a, b) {
		return ZmZimbraMail.hashSortCompare(ZmApp.LOAD_SORT, a, b);
	});

	// Instantiate enabled apps, which will invoke app registration.
	// We also create iframed (external) apps, which will only show the content of a URL in an iframe.
	for (var i = 0; i < ZmApp.APPS.length; i++) {
		var app = ZmApp.APPS[i];
		var isInternal = this._isInternalApp(app);
		var isIframe = this._isIframeApp(app);
		if (isInternal || isIframe || app === ZmApp.BRIEFCASE) {
			ZmApp.ENABLED_APPS[app] = isInternal || isIframe;
			this._createApp(app);
			this._apps[app].isIframe = isIframe;
		}
	}
};

/**
 * Static function to add a listener before this class has been instantiated.
 * During construction, listeners are copied to the event manager. This function
 * could be used by a skin, for example.
 *
 * @param {constant}	type		the event type
 * @param {AjxListener}	listener	a listener
 */
ZmZimbraMail.addListener =
function(type, listener) {
	if (!ZmZimbraMail._listeners[type]) {
		ZmZimbraMail._listeners[type] = [];
	}
	ZmZimbraMail._listeners[type].push(listener);
};

/**
 * Static function to add an app listener before this class has been
 * instantiated. This is separate from {@link ZmZimbraMail#addListener}
 * so that the caller doesn't need to know the specifics of how we
 * twiddle the type name for app events.
 * 
 * @param	{String}	appName		the application name
 * @param {constant}	type		the event type
 * @param {AjxListener}	listener	a listener
 * 
 */
ZmZimbraMail.addAppListener =
function(appName, type, listener) {
	type = [appName, type].join("_");
	ZmZimbraMail.addListener(type, listener);
};

/**
 * Adds a listener for the given event type.
 *
 * @param {constant}	type		the event type
 * @param {AjxListener}	listener	a listener
 * @return	{Boolean}	<code>true</code> if the listener is added
 * 
 */
ZmZimbraMail.prototype.addListener =
function(type, listener) {
	return this._evtMgr.addListener(type, listener);
};

/**
 * Removes a listener for the given event type.
 *
 * @param {constant}	type		the event type
 * @param {AjxListener}	listener	a listener
 * @return	{Boolean}	<code>true</code> if the listener is removed
 */
ZmZimbraMail.prototype.removeListener =
function(type, listener) {
	return this._evtMgr.removeListener(type, listener);
};

/**
 * Adds a listener for the given event type and app.
 *
 * @param {constant}	app		the app name
 * @param {constant}	type		the event type
 * @param {AjxListener}	listener	a listener
 * @return	{Boolean}	<code>true</code> if the listener is added
 */
ZmZimbraMail.prototype.addAppListener =
function(app, type, listener) {
	type = [app, type].join("_");
	return this.addListener(type, listener);
};

/**
 * Removes a listener for the given event type and app.
 *
 * @param {constant}	app		the app name
 * @param {constant}	type		the event type
 * @param {AjxListener}	listener	a listener
 * @return	{Boolean}	<code>true</code> if the listener is removed
 */
ZmZimbraMail.prototype.removeAppListener =
function(app, type, listener) {
	type = [app, type].join("_");
	return this.removeListener(type, listener);
};

/**
 * Sends a <code>&lt;NoOpRequest&gt;</code> to the server. Used for '$set:noop'
 */
ZmZimbraMail.prototype.sendNoOp =
function() {
	var jsonObj = { NoOpRequest: { _jsns: "urn:zimbraMail" } };
	var accountName = appCtxt.isOffline && appCtxt.accountList.mainAccount.name;
	this.sendRequest({jsonObj:jsonObj, asyncMode:true, noBusyOverlay:true, accountName:accountName});
};

/**
 * Sends a <code>&lt;ClientEventNotifyRequest&gt;</code> to the server.
 * 
 * @param	{Object}	event		the event
 */
ZmZimbraMail.prototype.sendClientEventNotify =
function(event, isNetworkOn) {
	var params = {
		jsonObj: {
			ClientEventNotifyRequest: {
				_jsns:"urn:zimbraOffline",
				e: event
			}
		},
		asyncMode:true
	};

    if (isNetworkOn) {
        params.callback = new AjxCallback(this, this.handleClientEventNotifyResponse, event);
        params.noBusyOverlay = true;

        if (this.clientEventNotifyReqId) {
            appCtxt.getRequestMgr().cancelRequest(this.clientEventNotifyReqId);
        }
        this.clientEventNotifyTimerId = 
            AjxTimedAction.scheduleAction(new AjxTimedAction(this, this.sendClientEventNotify, [event, true]), 3000);
    } else {
        params.callback = new AjxCallback(this, this.setInstantNotify, true);
    }

    this.clientEventNotifyReqId = this.sendRequest(params);
};

ZmZimbraMail.prototype.handleClientEventNotifyResponse =
function(event, res) {
    if (!res.isException() && res.getResponse()) {
        if (this.clientEventNotifyTimerId) {
            AjxTimedAction.cancelAction(this.clientEventNotifyTimerId);
            this.clientEventNotityTimerId = null;
        }
        this.setInstantNotify(true);
    }
};

/**
 * Sets the client into "instant notifications" mode.
 * 
 * @param {Boolean}	on				if <code>true</code>, turn on instant notify
 */
ZmZimbraMail.prototype.setInstantNotify =
function(on) {
	if (on) {
		this._pollInstantNotifications = true;
		// set nonzero poll interval so cant ever get into a full-speed request loop
		this._pollInterval = appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL);
		if (this._pollActionId) {
			AjxTimedAction.cancelAction(this._pollActionId);
			this._pollActionId = null;
		}
		this._kickPolling(true);
	} else {
		this._pollInstantNotifications = false;
		this._cancelInstantNotify();
		this.setPollInterval(true);
	}
};

/**
 * Gets the "instant notification" setting.
 * 
 * @return	{Boolean}	<code>true</code> if instant notification is "ON"
 */
ZmZimbraMail.prototype.getInstantNotify =
function() {
	return this._pollInstantNotifications;
};

ZmZimbraMail.prototype.registerMailtoHandler =
function(regProto, selected) {
	if (appCtxt.get(ZmSetting.OFFLINE_SUPPORTS_MAILTO) && window.platform) {
		try { // add try/catch - see bug #33870
			if (selected) { // user selected zd as default mail app 
				// register mailto handler
				if (regProto) {
					var url = appCtxt.get(ZmSetting.OFFLINE_WEBAPP_URI, null, appCtxt.accountList.mainAccount);
					window.platform.registerProtocolHandler("mailto", url + "&mailto=%s");
				
					// handle "send to mail recipient" on windows (requires mapi@zimbra.com extension)
					if (AjxEnv.isWindows) {
						var shell = new ZimbraDesktopShell;
						shell.defaultClient = true;
					}
				}

				// register mailto callback
				var callback = AjxCallback.simpleClosure(this.handleOfflineMailTo, this);
				window.platform.registerProtocolCallback("mailto", callback);
			} else { // unselected (box unchecked) 
				window.platform.unregisterProtocolHandler("mailto");

				if (AjxEnv.isWindows) {
					var shell = new ZimbraDesktopShell;
					shell.defaultClient = false;
				}
			}
		} catch(ex) {
			// do nothing
		}
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype.handleOfflineMailTo =
function(uri, callback) {
	if (window.platform && !window.platform.isRegisteredProtocolHandler("mailto")) { return false; }

	var mailApp = this.getApp(ZmApp.MAIL);
	var idx = (uri.indexOf("mailto"));
	if (idx >= 0) {
		var query = "to=" + decodeURIComponent(uri.substring(idx+7));
		query = query.replace(/\?/g, "&");
		var controller = mailApp._showComposeView(callback, query);
        	this._checkOfflineMailToAttachments(controller, query);
		return true;
	}
	return false;
};

ZmZimbraMail.prototype._checkOfflineMailToAttachments =
function(controller, queryStr) {
    var qs = queryStr || location.search;

    var match = qs.match(/\bto=([^&]+)/);
    var to = match ? AjxStringUtil.urlComponentDecode(match[1]) : null;

    match = qs.match(/\battachments=([^&]+)/);
    var attachments = match ? (AjxStringUtil.urlComponentDecode(match[1]).replace(/\+/g, " ")) : null;

    if (to && to.indexOf('mailto') == 0) {
        to = to.replace(/mailto:/,'');
        var mailtoQuery = to.split('?');
        if (mailtoQuery.length > 1) {
            mailtoQuery = mailtoQuery[1];
            match = mailtoQuery.match(/\battachments=([^&]+)/);
            if(!attachments) attachments = match ? (AjxStringUtil.urlComponentDecode(match[1]).replace(/\+/g, " ")) : null;
        }
    }

    if(attachments) {
        attachments = attachments.replace(/;$/, "");
        attachments = attachments.split(";");
        this._mailtoAttachmentsLength = attachments.length;
        this._attachmentsProcessed = 0;        
        this.attachment_ids = [];
        for(var i=0; i<attachments.length; i++) {
            this._handleMailToAttachment(attachments[i], controller);
        }
    }
};

ZmZimbraMail.prototype._handleMailToAttachment =
function(attachment, controller) {

    var filePath = attachment;
    var filename = filePath.replace(/^.*\\/, '');

    DBG.println("Uploading File :" + filename + ",filePath:" + filePath);

    //check read file permission;
    try {
        netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    } catch (e) {
        //permission denied to read file
        DBG.println("Permission denied to read file");
        return;
    }

    try {
        var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
        file.initWithPath( filePath );

        var contentType = this._getAttachmentContentType(file);

        var inputStream = Components.classes[ "@mozilla.org/network/file-input-stream;1" ].createInstance(Components.interfaces.nsIFileInputStream);
        inputStream.init(file, -1, -1, false );

        var binary = Components.classes[ "@mozilla.org/binaryinputstream;1" ].createInstance(Components.interfaces.nsIBinaryInputStream);
        binary.setInputStream(inputStream);

        var req = new XMLHttpRequest();
        req.open("POST", appCtxt.get(ZmSetting.CSFE_UPLOAD_URI)+"&fmt=extended,raw", true);
        req.setRequestHeader("Cache-Control", "no-cache");
        req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        req.setRequestHeader("Content-Type",  (contentType || "application/octet-stream") );
        req.setRequestHeader("Content-Disposition", 'attachment; filename="'+ AjxUtil.convertToEntities(filename) + '"');

        var reqObj = req;
        req.onreadystatechange = AjxCallback.simpleClosure(this._handleUploadResponse, this, reqObj, controller);
        req.sendAsBinary(binary.readBytes(binary.available()));
        delete req;
    }catch(ex) {
        DBG.println("exception in handling attachment: " + attachment);
        DBG.println(ex);
        this._attachmentsProcessed++;
    }
};

ZmZimbraMail.prototype._getAttachmentContentType =
function(file) {
	var contentType;
	try {
		contentType = Components.classes["@mozilla.org/mime;1"].getService(Components.interfaces.nsIMIMEService).getTypeFromFile(file);
	}catch(ex) {
		 DBG.println("exception in reading content type: " + ex);
		 contentType =  "application/octet-stream";
	}
	return contentType;
};

ZmZimbraMail.prototype._handleUploadResponse = function(req, controller) {
    if(req) {
        if(req.readyState == 4 && req.status == 200) {
            var resp = eval("["+req.responseText+"]");
            this._attachmentsProcessed++;
            this.popupUploadErrorDialog(ZmItem.MSG, resp[0]);
            if(resp.length > 2) {
                var respObj = resp[2];
                for (var i = 0; i < respObj.length; i++) {
                    if(respObj[i].aid != "undefined") {
                        this.attachment_ids.push(respObj[i].aid);
                    }
                }

                if(this.attachment_ids.length > 0 && this._attachmentsProcessed == this._mailtoAttachmentsLength) {
                    var attachment_list = this.attachment_ids.join(",");
                    if(!controller) {
                        var msg = new ZmMailMsg();
                        controller = AjxDispatcher.run("GetComposeController");
                        controller._setView({action:ZmOperation.NEW_MESSAGE, msg:msg, inNewWindow:false});
                    }
                    var callback = new AjxCallback (controller,controller._handleResponseSaveDraftListener);
        		    controller.sendMsg(attachment_list, ZmComposeController.DRAFT_TYPE_MANUAL,callback);
                    this.getAppViewMgr().pushView(controller.getCurrentViewId());
                }
            }
        }
    }

};

/**
 * Resets the interval between poll requests, based on what's in the settings,
 * only if we are not in instant notify mode.
 *
 * @param {Boolean}	kickMe	if <code>true</code>, start the poll timer
 * @return	{Boolean}	<code>true</code> if poll interval started; <code>false</code> if in "instant notification" mode
 */
ZmZimbraMail.prototype.setPollInterval =
function(kickMe) {
	if (!this._pollInstantNotifications) {
		this._pollInterval = appCtxt.get(ZmSetting.POLLING_INTERVAL) * 1000;

		if (this._pollInterval) {
			DBG.println(AjxDebug.DBG1, "poll interval = " + this._pollInterval + "ms");
			if (kickMe)
				this._kickPolling(true);
		} else {
			// cancel timer if it is waiting...
			if (this._pollActionId) {
				AjxTimedAction.cancelAction(this._pollActionId);
				this._pollActionId = null;
			}
		}
		return true;
	} else {
		this._pollInterval = appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL);
		DBG.println(AjxDebug.DBG1, "Ignoring Poll Interval (in instant-notify mode)");
		return false;
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype._cancelInstantNotify =
function() {
	if (this._pollRequest) {
		this._requestMgr.cancelRequest(this._pollRequest);
		this._pollRequest = null;
	}

	if (this._pollActionId) {
		AjxTimedAction.cancelAction(this._pollActionId);
		this._pollActionId = null;
	}
};

/**
 * Make sure the polling loop is running.  Basic flow:
 *
 *       1) kickPolling():
 *             - cancel any existing timers
 *             - set a timer for _pollInterval time
 *             - call execPoll() when the timer goes off
 *
 *       2) execPoll():
 *             - make the NoOp request, if we're in "instant notifications"
 *               mode, this request will hang on the server until there is more data,
 *               otherwise it will return immediately.  Call into a handle() func below
 *
 *       3) handleDoPollXXXX():
 *             - call back to kickPolling() above
 *
 * resetBackoff = TRUE e.g. if we've just received a successful
 * response from the server, or if the user just changed our
 * polling settings and we want to start in fast mode
 * 
 * @private
 */
ZmZimbraMail.prototype._kickPolling =
function(resetBackoff) {
	DBG.println(AjxDebug.DBG2, [
		"ZmZimbraMail._kickPolling ",
		this._pollInterval, ", ",
		this._pollActionId, ", ",
		this._pollRequest ? "request_pending" : "no_request_pending"
	].join(""));

	// reset the polling timeout
	if (this._pollActionId) {
		AjxTimedAction.cancelAction(this._pollActionId);
		this._pollActionId = null;
	}

	if (resetBackoff && this._pollInstantNotifications) {
		// we *were* backed off -- reset the delay back to 1s fastness
		var interval = appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL);
		if (this._pollInterval > interval) {
			this._pollInterval = interval;
		}
	}

	if (this._pollInterval && !this._pollRequest) {
		try {
			this._pollActionId = AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._execPoll), this._pollInterval);
		} catch (ex) {
			this._pollActionId = null;
			DBG.println(AjxDebug.DBG1, "Caught exception in ZmZimbraMail._kickPolling.  Polling chain broken!");
		}
	}
};

/**
 * We've finished waiting, do the actual poll itself
 *
 * @private
 */
ZmZimbraMail.prototype._execPoll =
function() {

	this._cancelInstantNotify();

	// It'd be more efficient to make these instance variables, but for some
	// reason that breaks polling in IE.
	var jsonObj = { NoOpRequest: { _jsns: "urn:zimbraMail" } },
		method = jsonObj.NoOpRequest;

	try {
        if (this._pollInstantNotifications) {
			var sessionId = ZmCsfeCommand.getSessionId();
			if (sessionId) {
				method.wait = 1;
				method.limitToOneBlocked = 1;
			}
        }
		var params = {
			jsonObj:        jsonObj,
			asyncMode:      true,
			callback:       this._handleResponseDoPoll.bind(this),
			errorCallback:  this._handleErrorDoPoll.bind(this),
			noBusyOverlay:  true,
			timeout:        appCtxt.get(ZmSetting.INSTANT_NOTIFY_TIMEOUT),
			accountName:    appCtxt.isOffline && appCtxt.accountList.mainAccount.name
		};
		this._pollRequest = this.sendRequest(params);

		// bug #42664 - handle case where sync-status-changes fall between 2 client requests
		var accList = appCtxt.accountList;
		if (appCtxt.isOffline && !accList.isInitialSyncing() && accList.isSyncStatus(ZmZimbraAccount.STATUS_RUNNING)) {
			this.sendNoOp();
		}
	} catch (ex) {
		this._handleErrorDoPoll(ex); // oops!
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype._handleErrorDoPoll =
function(ex) {
	if (this._pollRequest) {
		// reset the polling timeout
		if (this._pollActionId) {
			AjxTimedAction.cancelAction(this._pollActionId);
			this._pollActionId = null;
		}
		this._requestMgr.cancelRequest(this._pollRequest);
		this._pollRequest = null;
	}

	if (this._pollInstantNotifications) {
		// very simple-minded exponential backoff
		this._pollInterval *= 2;
		if (this._pollInterval > (1000 * 60 * 2)) {
			this._pollInterval = 1000 * 60 * 2;
		}
	}

	var isAuthEx = (ex.code == ZmCsfeException.SVC_AUTH_EXPIRED ||
					ex.code == ZmCsfeException.SVC_AUTH_REQUIRED ||
					ex.code == ZmCsfeException.NO_AUTH_TOKEN);

	// restart poll timer if we didn't get an auth exception
	if (!isAuthEx) {
		this._kickPolling(false);
	}

	return !isAuthEx;
};

/**
 * @private
 */
ZmZimbraMail.prototype._handleResponseDoPoll =
function(result) {
	this._pollRequest = null;
	var noopResult = result.getResponse().NoOpResponse;
	if (noopResult.waitDisallowed) {
		this._waitDisallowed = true;
		// revert to polling mode - server doesn't want us to use instant notify.
		this.setInstantNotify(false);
	}  else {
		// restart poll timer if we didn't get an exception
		this._kickPolling(true);
	}
};

/**
 * Gets the key map manager.
 * 
 * @return	{DwtKeyMapMgr}	the key map manager
 */
ZmZimbraMail.prototype.getKeyMapMgr =
function() {
	var kbMgr = appCtxt.getKeyboardMgr();
	if (!kbMgr.__keyMapMgr) {
		this._initKeyboardHandling();
	}
	return kbMgr.__keyMapMgr;
};

/**
 * @private
 */
ZmZimbraMail.prototype._initKeyboardHandling =
function() {
	var kbMgr = appCtxt.getKeyboardMgr();
	if (kbMgr.__keyMapMgr) { return; }
	if (appCtxt.get(ZmSetting.USE_KEYBOARD_SHORTCUTS)) {
		// Register our keymap and global key action handler with the shell's keyboard manager
		kbMgr.enable(true);
		kbMgr.registerKeyMap(new ZmKeyMap());
		kbMgr.pushDefaultHandler(this);
	} else {
		kbMgr.enable(false);
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype._setupTabGroups =
function() {
	DBG.println(AjxDebug.DBG2, "SETTING SEARCH CONTROLLER TAB GROUP");
	var rootTg = appCtxt.getRootTabGroup();
	if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
		rootTg.addMember(appCtxt.getSearchController().getSearchToolbar().getTabGroupMember());
	}

	rootTg.addMember(this._userNameField);
	rootTg.addMember(this._usedQuotaField);

	if (this._helpButton) {
		rootTg.addMember(this._helpButton);
	}

	rootTg.addMember(appCtxt.getAppChooser().getTabGroupMember());
	rootTg.addMember(appCtxt.refreshButton);
	rootTg.addMember(this._newToolbar);

	var curApp = appCtxt.getCurrentApp();
	var overview = curApp && curApp.getOverview();
	if (overview) {
		rootTg.addMember(overview.getTabGroupMember());
		ZmController._currentOverview = overview;
	}
	
	appCtxt.getKeyboardMgr().setTabGroup(rootTg);
};

/**
 * @private
 */
ZmZimbraMail.prototype._registerOrganizers =
function() {

	ZmOrganizer.registerOrg(ZmOrganizer.FOLDER,
							{app:				ZmApp.MAIL,
							 nameKey:			"folder",
							 defaultFolder:		ZmOrganizer.ID_INBOX,
							 soapCmd:			"FolderAction",
							 firstUserId:		256,
							 orgClass:			"ZmFolder",
							 orgPackage:		"MailCore",
							 treeController:	"ZmMailFolderTreeController",
							 labelKey:			"mailFolders",
							 itemsKey:			"messages",
							 hasColor:			true,
							 defaultColor:		ZmOrganizer.C_NONE,
							 treeType:			ZmOrganizer.FOLDER,
							 dropTargets:		[ZmOrganizer.FOLDER],
							 views:				["message", "conversation"],
							 folderKey:			"mailFolder",
							 mountKey:			"mountFolder",
							 createFunc:		"ZmOrganizer.create",
							 compareFunc:		"ZmFolder.sortCompare",
							 newOp:				ZmOperation.NEW_FOLDER,
							 displayOrder:		100,
							 childWindow:		true,
							 openSetting:		ZmSetting.FOLDER_TREE_OPEN
							});

	ZmOrganizer.registerOrg(ZmOrganizer.SEARCH,
							{app:				ZmApp.MAIN,
							 nameKey:			"savedSearch",
							 precondition:		ZmSetting.SAVED_SEARCHES_ENABLED,
							 soapCmd:			"FolderAction",
							 firstUserId:		256,
							 orgClass:			"ZmSearchFolder",
							 treeController:	"ZmSearchTreeController",
							 labelKey:			"searches",
							 hasColor:			true,
							 defaultColor:		ZmOrganizer.C_NONE,
							 treeType:			ZmOrganizer.FOLDER,
							 folderKey:			"savedSearch",
							 disableShare:		true,
 							 dropTargets:		[ZmOrganizer.FOLDER, ZmOrganizer.SEARCH],
							 createFunc:		"ZmSearchFolder.create",
							 compareFunc:		"ZmFolder.sortCompare",
							 openSetting:		ZmSetting.SEARCH_TREE_OPEN,
							 displayOrder:		300
							});

    ZmOrganizer.registerOrg(ZmOrganizer.SHARE, {
        orgClass:       "ZmShareProxy",
        treeController: "ZmShareTreeController",
        labelKey:       "sharedFoldersHeader",
        compareFunc:	"ZmFolder.sortCompare",
        displayOrder:	101, // NOTE: Always show shares below primary folder tree
        hideEmpty:		false
    });

	ZmOrganizer.registerOrg(ZmOrganizer.TAG,
							{app:				ZmApp.MAIN,
							 nameKey:			"tag",
							 precondition:		ZmSetting.TAGGING_ENABLED,
							 soapCmd:			"TagAction",
							 firstUserId:		64,
							 orgClass:			"ZmTag",
							 treeController:	"ZmTagTreeController",
							 hasColor:			true,
							 defaultColor:		ZmOrganizer.C_ORANGE,
							 labelKey:			"tags",
							 treeType:			ZmOrganizer.TAG,
							 createFunc:		"ZmTag.create",
							 compareFunc:		"ZmTag.sortCompare",
							 newOp:				ZmOperation.NEW_TAG,
							 openSetting:		ZmSetting.TAG_TREE_OPEN,
							 displayOrder:		400
							});

	ZmOrganizer.registerOrg(ZmOrganizer.ZIMLET,
							{orgClass:			"ZmZimlet",
							 treeController:	"ZmZimletTreeController",
							 labelKey:			"zimlets",
							 compareFunc:		"ZmZimlet.sortCompare",
							 openSetting:		ZmSetting.ZIMLET_TREE_OPEN,
							 hideEmpty:			true
							});
	
	// Technically, we don't need to do this because the drop listeners for dragged organizers typically do their
	// own checks on the class of the dragged object. But it's better to do it anyway, in case it ever gets
	// validated within the drop target against the valid types.
	this._name = ZmApp.MAIN;
	ZmApp.prototype._setupDropTargets.call(this);
};

/**
 * Gets a handle to the given app.
 *
 * @param {String}	appName		the app name
 * @return	{ZmApp}	the app
 */
ZmZimbraMail.prototype.getApp =
function(appName) {
	if (!ZmApp.ENABLED_APPS[appName]) {
		return null;
	}
	if (!this._apps[appName]) {
		this._createApp(appName);
	}
	return this._apps[appName];
};

/**
 * Gets a handle to the app view manager.
 * 
 * @return	{ZmAppViewMgr}	the app view manager
 */
ZmZimbraMail.prototype.getAppViewMgr =
function() {
	return this._appViewMgr;
};

/**
 * Gets the active app.
 * 
 * @return	{ZmApp}	the app
 */
ZmZimbraMail.prototype.getActiveApp =
function() {
	return this._activeApp;
};

/**
 * Gets the previous application.
 * 
 * @return	{ZmApp}	the app
 */
ZmZimbraMail.prototype.getPreviousApp =
function() {
	return this._previousApp;
};

/**
 * Activates the given application.
 *
 * @param {constant}	appName		the application name
 * @param {Boolean}	force			if <code>true</code>, launch the app
 * @param {AjxCallback}	callback		the callback
 * @param {AjxCallback}	errorCallback	the error callback
 * @param {Hash}	params		a hash of parameters		(see {@link #startup} for full list)
 * @param {Boolean}	params.checkQS		if <code>true</code>, check query string for launch args
 * @param {ZmCsfeResult}	params.result		the result object from load of user settings
 */
ZmZimbraMail.prototype.activateApp =
function(appName, force, callback, errorCallback, params) {
	DBG.println(AjxDebug.DBG1, "activateApp: " + appName + ", current app = " + this._activeApp);

	var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
	var isIframe = this._isIframeApp(appName);
	var view = this._appViewMgr.getAppView(appName);
	if (view && !force) {
		// if the app has been launched, make its view the current one
		DBG.println(AjxDebug.DBG3, "activateApp, current " + appName + " view: " + view);
		if (this._appViewMgr.pushView(view)) {
			this._appViewMgr.setAppView(appName, view);
            if (isIframe) {
                var title = [ZmMsg.zimbraTitle, appName].join(": ");
                Dwt.setTitle(title);
            }            
		}
		if (callback) {
			callback.run();
		}
	} else {
		// launch the app
		if (!this._apps[appName]) {
			this._createApp(appName);
		}

		if (isIframe) {
			this._createAppIframeView(appName);
			if (callback) {
				callback.run();
			}
		}
		else {
			DBG.println(AjxDebug.DBG1, "Launching app " + appName);
			var respCallback = new AjxCallback(this, this._handleResponseActivateApp, [callback, appName]);
			var eventType = [appName, ZmAppEvent.PRE_LAUNCH].join("_");
			this._evt.item = this._apps[appName];
			this.notify(eventType);
			params = params || {};
			params.searchResponse = this._searchResponse;
			this._apps[appName].launch(params, respCallback);
			delete this._searchResponse;
		}
	}
};

/**
 * @private
 */
ZmZimbraMail.prototype._handleResponseActivateApp =
function(callback, appName) {
	if (callback) {
		callback.run();
	}

	if (ZmApp.DEFAULT_SEARCH[appName]) {
		appCtxt.getSearchController().setDefaultSearchType(ZmApp.DEFAULT_SEARCH[appName]);
	}

	var eventType = [appName, ZmAppEvent.POST_LAUNCH].join("_");
	this._evt.item = this._apps[appName];
	this.notify(eventType);
};

/**
 * Handles a change in which app is current. The change will be reflected in the
 * current app toolbar and the overview. The previous and newly current apps are
 * notified of the change. This method is called after a new view is pushed.
 *
 * @param {Object}	view
 */
ZmZimbraMail.prototype.setActiveApp =
function(view) {
	var appName = view.app;

	// update app chooser
	if (!view.isTabView) {
		this._components[ZmAppViewMgr.C_APP_CHOOSER].setSelected(appName);
	}

	// app not actually enabled if this is result of iframe view push
	var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
	var appEnabled = !ZmApp.SETTING[appName] || appCtxt.get(ZmApp.SETTING[appName], null, account);

	this._activeTabId = null;	// app is active; tab IDs are for non-apps

	if (appName === ZmApp.SEARCH) {
		//this is a special case - the search tab - set the new button based on type by using the results type app to get the button props.
		this._setSearchTabNewButtonProps(view.controller._resultsController);
	}

	if (this._activeApp != appName) {
		// deactivate previous app
	    if (this._activeApp) {
			// some views are not stored in _apps collection, so check if it exists.
			var app = this._apps[this._activeApp];
			if (app) {
				app.activate(false, view.id);
			}
			this._previousApp = this._activeApp;
		}

		// switch app
		this._activeApp = appName;
		if (appEnabled) {
			var app = this._apps[this._activeApp];
			if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
				var searchType;
				var currentSearch;
				if (appName === ZmApp.SEARCH) {
					currentSearch = view.controller._resultsController._currentSearch;
					var types = currentSearch && currentSearch.types;
					searchType = types && types.size() > 0 && types.get(0);
				}
				else {
					currentSearch = app.currentSearch;
					searchType = app.getInitialSearchType();
					if (!searchType) {
						searchType = ZmApp.DEFAULT_SEARCH[appName];
					}
				}
				if (searchType) {
					appCtxt.getSearchController().setDefaultSearchType(searchType);
				}
				// set search string value to match current app's last search, if applicable
				var stb = appCtxt.getSearchController().getSearchToolbar();
				if (appCtxt.get(ZmSetting.SHOW_SEARCH_STRING) && stb) {
					var value = currentSearch ? currentSearch.query : app.currentQuery;
					value = appName === ZmApp.SEARCH ? "" : value;
					stb.setSearchFieldValue(value || "");
				}
			}

			// activate current app - results in rendering of overview
			if (app) {
				if (appCtxt.inStartup && this._doingPostRenderStartup) {
					var callback = new AjxCallback(this,
						function() {
							app.activate(true);
						});
					this.addPostRenderCallback(callback, 1, 0, true);
				} else {
					app.activate(true);
				}
			}
		}
		this._evt.item = this._apps[appName];
		this.notify(ZmAppEvent.ACTIVATE);
	}
	else if (this._activeApp && this._apps[this._activeApp]) {
		this._apps[this._activeApp].stopAlert();
	}
};

ZmZimbraMail.prototype._setSearchTabNewButtonProps =
function(resultsController) {
	var resultsApp;
	if (resultsController.isZmCalViewController) {
		//calendar search is different, no _currentSearch unfortunately.
		resultsApp = appCtxt.getApp(ZmApp.CALENDAR);
	}
	else {
		var currentSearch = resultsController._currentSearch;
		var types = currentSearch && currentSearch.types;
		var searchType = types && types.size() > 0 && types.get(0);
		resultsApp = searchType && appCtxt.getApp(ZmItem.APP[searchType]);
	}
	if (resultsApp) {
		appCtxt.getAppController().setNewButtonProps(resultsApp.getNewButtonProps());
	}

};

/**
 * Gets the app chooser button.
 * 
 * @param	{String}	id		the id
 * @return	{ZmAppButton}	the button
 */
ZmZimbraMail.prototype.getAppChooserButton =
function(id) {
	var chooser = this._components[ZmAppViewMgr.C_APP_CHOOSER];
	return chooser && chooser.getButton(id);
};

/**
 * An app calls this once it has fully rendered, so that we may notify
 * any listeners.
 * 
 * @param	{String}	appName		the app name
 */
ZmZimbraMail.prototype.appRendered =
function(appName) {
	var eventType = [appName, ZmAppEvent.POST_RENDER].join("_");
	this.notify(eventType);

	if (window._facadeCleanup) {
		window._facadeCleanup();
		window._facadeCleanup = null;
	}
};

/**
 * Adds the application.
 * 
 * @param	{ZmApp}		app		the app
 */
ZmZimbraMail.prototype.addApp = function(app) {
	var appName = app.getName();
	this._apps[appName] = app;
	ZmApp.ENABLED_APPS[appName] = true;
};

// Private methods

/**
 * Creates an app object, which doesn't necessarily do anything just yet.
 * 
 * @private
 */
ZmZimbraMail.prototype._createApp =
function(appName) {
	if (!appName || this._apps[appName]) return;
	DBG.println(AjxDebug.DBG1, "Creating app " + appName);
	var appClass = eval(ZmApp.CLASS[appName]);
	this.addApp(new appClass(this._shell));
};

/**
 * @private
 */
ZmZimbraMail.prototype._setExternalLinks =
function() {
    // bug: 41313 - admin console link
    var adminUrl;
    if (!appCtxt.isOffline &&
        (appCtxt.get(ZmSetting.IS_ADMIN) ||
         appCtxt.get(ZmSetting.IS_DELEGATED_ADMIN))) {

        adminUrl = appCtxt.get(ZmSetting.ADMIN_URL);
        if (!adminUrl) {
            adminUrl = ["https://", location.hostname, ":7071"].join("");
        }
    }
	var el = document.getElementById("skin_container_links");
	if (el) {
		var data = {
			showOfflineLink: (!appCtxt.isOffline && appCtxt.get(ZmSetting.SHOW_OFFLINE_LINK)),
			helpIcon: (appCtxt.getSkinHint("helpButton", "hideIcon") ? null : "Help"),
			logoutIcon: (appCtxt.getSkinHint("logoutButton", "hideIcon") ? null : "Logoff"),
			logoutText: (appCtxt.isOffline ? ZmMsg.setup : ZmMsg.logOff),
			adminUrl: adminUrl
		};
		el.innerHTML = AjxTemplate.expand("share.App#UserInfo", data);
	}
	
	el = document.getElementById("skin_container_help_button");
	if (el) {
		this._helpButton = this.getHelpButton(DwtShell.getShell(window));
		this._helpButton.reparentHtmlElement("skin_container_help_button");
	}

    el = document.getElementById("skin_dropMenu");
    if (el) {
		this._helpButton = this.getDropMenuOptions(DwtShell.getShell(window), el, adminUrl);
		//this._helpButton.reparentHtmlElement("skin_dropMenu");
	}
};


ZmZimbraMail.ONLINE_HELP_URL = "https://help.zimbra.com/?";
ZmZimbraMail.NEW_FEATURES_URL = "https://www.zimbra.com/products/whats_new.html?";

ZmZimbraMail.DEFAULT_CONTACT_ICON = appContextPath + "/img/large/ImgPerson_48.png?v=" + window.cacheKillerVersion;
ZmZimbraMail.DEFAULT_CONTACT_ICON_SMALL = appContextPath + "/img/large/ImgPerson_32.png?v=" + window.cacheKillerVersion;

/**
* Adds a "help" submenu.
*
* @param {DwtComposite}		parent		the parent widget
* @return {ZmActionMenu}	the menu
*/
ZmZimbraMail.prototype.getDropMenuOptions =
function(parent, parentElement, adminUrl) {

	var button = new DwtLinkButton({parent: parent, className: DwtButton.LINK_BUTTON_CLASS, parentElement: parentElement, elementTag: "DIV"});
	button.whatToShow = { };
	button.setSize(Dwt.DEFAULT);
	button.setAlign(DwtLabel.ALIGN_LEFT);
	button.setText(ZmMsg.help);
	button.setAttribute('aria-label', ZmMsg.userActions);
	var menu = new ZmPopupMenu(button);

	var supportedHelps = appCtxt.get(ZmSetting.SUPPORTED_HELPS);
	var helpListener = new AjxListener(this, this._helpListener);
	button.addSelectionListener(helpListener);

    var mi;
	if (adminUrl) {
	    mi = menu.createMenuItem("adminLink", {text: ZmMsg.adminLinkLabel});
	    mi.addSelectionListener(new AjxListener(null, ZmZimbraMail.adminLinkCallback, adminUrl));
	}

    mi = menu.createMenuItem("standardHtmlLink", {text: ZmMsg.htmlClient});
    mi.addSelectionListener(ZmZimbraMail.standardHtmlLinkCallback);

	menu.createSeparator();

	if (supportedHelps.indexOf("productHelp") !== -1) {
		mi = menu.createMenuItem("documentation", {text: ZmMsg.productHelp});
		mi.addSelectionListener(helpListener);
	}

	if (supportedHelps.indexOf("onlineHelp") !== -1) {
		mi = menu.createMenuItem("onlinehelp", {text: ZmMsg.onlineHelp});
		mi.addSelectionListener(new AjxListener(this, this._onlineHelpListener));
	}


	if (supportedHelps.indexOf("newFeatures") !== -1) {
		mi = menu.createMenuItem("newFeatures", {text: ZmMsg.newFeatures});
		mi.addSelectionListener(new AjxListener(this, this._newFeaturesListener));
	}

	mi = menu.createMenuItem("showCurrentShortcuts", {text: ZmMsg.shortcuts});
	mi.addSelectionListener(this._showCurrentShortcuts.bind(this));

	menu.createSeparator();

	mi = menu.createMenuItem(ZmZimbraMail.HELP_MENU_ABOUT, {text: ZmMsg.about});
	mi.addSelectionListener(new AjxListener(this, this._aboutListener));

    menu.createSeparator();

	if (!appCtxt.isExternalAccount() && appCtxt.get(ZmSetting.WEBCLIENT_OFFLINE_ENABLED)) {
        mi = menu.createMenuItem("offlineSettings", {text: ZmMsg.offlineSettings});
        mi.addSelectionListener(new AjxListener(this, this._offlineSettingsListener));
    }

	if (AjxEnv.isFirefox && (AjxEnv.browserVersion >= 23.0) && !appCtxt.isExternalAccount()) {
		mi = menu.createMenuItem("socialfoxSettings", {text: ZmMsg.socialfoxEnableSidebar});
		mi.addSelectionListener(this._socialfoxSettingsListener.bind(this));
	}

	if (appCtxt.get(ZmSetting.CHANGE_PASSWORD_ENABLED)) {
        mi = menu.createMenuItem("changePassword", {text: ZmMsg.changePassword});
        mi.addSelectionListener(new AjxListener(this, this._changePasswordListener));
	}

    mi = menu.createMenuItem(ZmZimbraMail.HELP_MENU_LOGOFF, {text: ZmMsg.logOff});
	mi.addSelectionListener(new AjxListener(null, ZmZimbraMail.logOff));

	button.setMenu(menu);
	this.setupHelpMenu(button);
	return button;
};

ZmZimbraMail.HELP_MENU_ABOUT  = "about";
ZmZimbraMail.HELP_MENU_LOGOFF = "logOff";


ZmZimbraMail.prototype.setupHelpMenu = function(button) {
	button = button || this._helpButton;
	if (!button) return;

	var menu = button.getMenu();
	if (!menu) return;

	var isOnline = !appCtxt.isWebClientOffline();
	if (isOnline) {
		menu.enableAll(true);
	} else {
		menu.enableAll(false);
		var offlineEnabledIds = [ZmZimbraMail.HELP_MENU_ABOUT];
		menu.enable(offlineEnabledIds, true);
	}
};

ZmZimbraMail.prototype.getNewButton =
function() {

	var newButton = this._newButton;
	if (!newButton) {
		var buttonId = ZmId.getButtonId(null, ZmOperation.NEW_MENU);
		var buttonParams = {
			parent:		appCtxt.getShell(),
			id:			buttonId,
			posStyle:	DwtControl.ABSOLUTE_STYLE,
			className:	"ZToolbarButton ZNewButton"
		};
		newButton = this._newButton = new DwtToolBarButton(buttonParams);
		newButton.setText(ZmMsg._new);

		ZmOperation.addNewMenu(newButton);

		var selectionListener = this._newButtonListener.bind(this);
		var listener = this._newDropDownListener.bind(this, selectionListener);
		this._newDropDownListener = listener;
		newButton.addSelectionListener(selectionListener);
		newButton.addDropDownSelectionListener(listener);
	}

	return newButton;
};



/**
 * Creates the New menu's drop down menu the first time the drop down arrow is used,
 * then removes itself as a listener.
 *
 * @private
 */
ZmZimbraMail.prototype._newDropDownListener =
function(selectionListener, event) {

	var newButton = this.getNewButton();
	var menu = newButton.getMenu();
	var items = menu.getItems();
	for (var i = 0; i < menu.getItemCount(); i++) {
		items[i].addSelectionListener(selectionListener);
	}

	var listener = this._newDropDownListener;
	newButton.removeDropDownSelectionListener(listener);
	//Called explicitly as its a selection listener. Refer DwtButton._dropDownCellMouseDownHdlr()
	newButton.popup();

	delete this._newDropDownListener;
};

/**
 * Create some new thing, via a dialog. If just the button has been pressed (rather than
 * a menu item), the action taken depends on the app.
 *
 * @param {DwtUiEvent}	ev		the ui event
 * @param {constant}	op		the operation ID
 * @param {Boolean}		newWin	<code>true</code> if in a separate window
 *
 * @private
 */
ZmZimbraMail.prototype._newButtonListener =
function(ev, op, params) {

	if (!ev && !op) { return; }

	op = op || ev.item.getData(ZmOperation.KEY_ID);
	if (!op || op == ZmOperation.NEW_MENU) {
		op = ZmController._defaultNewId;
	}

	var app = ZmApp.OPS_R[op];
	if (app) {
		params = params || {};
		params.ev = ev;
		appCtxt.getApp(app).handleOp(op, params);
	} else {
		var ctlr = appCtxt.getCurrentController();
		if (ctlr) {
			ctlr._newListener(ev, op);
		}
	}
};

/**
 * Set up the New button based on the current app.
 */
ZmZimbraMail.prototype.setNewButtonProps =
function(params) {
	var newButton = this.getNewButton();
	if (newButton) {
		newButton.setText(params.text);
		newButton.setToolTipContent(params.tooltip);
		newButton.setImage(params.icon);
		newButton.setEnabled(!params.disabled);
		ZmController._defaultNewId = params.defaultId;
		params.hidden ? newButton.setVisibility(false) : newButton.setVisibility(true);
	}
};


/**
* Adds a "help" submenu.
*
* @param {DwtComposite}		parent		the parent widget
* @return {ZmActionMenu}	the menu
*/
ZmZimbraMail.prototype.getHelpButton =
function(parent) {

	var button = new DwtLinkButton({parent: parent, className: DwtButton.LINK_BUTTON_CLASS});
	button.dontStealFocus();
	button.setSize(Dwt.DEFAULT);
	button.setAlign(DwtLabel.ALIGN_LEFT);
	button.setText(ZmMsg.help);
	var menu = new ZmPopupMenu(button);

	var helpListener = new AjxListener(this, this._helpListener);
	button.addSelectionListener(helpListener);

	var mi = menu.createMenuItem("documentation", {text: ZmMsg.productHelp});
	mi.addSelectionListener(helpListener);

	var mi = menu.createMenuItem("onlinehelp", {text: ZmMsg.onlineHelp});
	mi.addSelectionListener(new AjxListener(this, this._onlineHelpListener));


	mi = menu.createMenuItem("newFeatures", {text: ZmMsg.newFeatures});
	mi.addSelectionListener(new AjxListener(this, this._newFeaturesListener));

	mi = menu.createMenuItem("showCurrentShortcuts", {text: ZmMsg.shortcuts});
	mi.addSelectionListener(this._showCurrentShortcuts.bind(this));

	menu.createSeparator();

	mi = menu.createMenuItem("about", {text: ZmMsg.about});
	mi.addSelectionListener(new AjxListener(this, this._aboutListener));

	button.setMenu(menu);
	return button;
};

ZmZimbraMail.prototype._helpListener =
function(ev) {
	ZmZimbraMail.helpLinkCallback();
};


ZmZimbraMail.prototype._getVersion =
function() {
	return appCtxt.get(ZmSetting.CLIENT_VERSION);
};


ZmZimbraMail.prototype._getQueryParams =
function() {

	var appName = appCtxt.getCurrentAppName().toLowerCase();
	var prod = appCtxt.isOffline ? "zd" : "zcs";
	return ["utm_source=", appName, "&utm_medium=", prod, "&utm_content=", this._getVersion(), "&utm_campaign=help"].join("");
};


ZmZimbraMail.prototype._onlineHelpListener =
function(ev) {
	ZmZimbraMail.unloadHackCallback();
	var url = [ZmZimbraMail.ONLINE_HELP_URL, this._getQueryParams()].join("");
	window.open(url);
};

ZmZimbraMail.prototype._newFeaturesListener =
function(ev) {
	ZmZimbraMail.unloadHackCallback();
	var url = [ZmZimbraMail.NEW_FEATURES_URL, this._getQueryParams()].join("");
	window.open(url);
};

ZmZimbraMail.prototype._changePasswordListener =
function(ev) {
    appCtxt.getChangePasswordWindow(ev);
}

ZmZimbraMail.prototype._aboutListener =
function(ev) {
	var dialog = appCtxt.getMsgDialog();
	dialog.reset();
	var version = this._getVersion();
	var release = appCtxt.get(ZmSetting.CLIENT_RELEASE);
	var aboutMsg = appCtxt.isOffline ? ZmMsg.aboutMessageZD : ZmMsg.aboutMessage;
	dialog.setMessage(AjxMessageFormat.format(aboutMsg, [version, release, AjxDateUtil.getYearStr()]), DwtMessageDialog.INFO_STYLE, ZmMsg.about);
	dialog.popup();

};

ZmZimbraMail.prototype._offlineSettingsListener =
function(ev) {
    var dialog;
    if (AjxEnv.isOfflineSupported) {
        dialog = appCtxt.getOfflineSettingsDialog();
    } else {
        dialog = appCtxt.getMsgDialog();
        dialog.setMessage(ZmMsg.offlineSupportedBrowser, "", ZmMsg.offlineSettings);
    }
    dialog.popup();
};

ZmZimbraMail.prototype._socialfoxSettingsListener =
function(ev) {
    var dialog = new ZmSocialfoxActivationDialog();
    dialog.popup();
};


ZmZimbraMail.prototype._initOfflineUserInfo =
function() {
	var htmlElId = this._userNameField.getHTMLElId();
	this._userNameField.getHtmlElement().innerHTML = AjxTemplate.expand('share.App#NetworkStatus', {id:htmlElId});
	this._userNameField.addClassName("BannerTextUserOffline");

	var params = {
		parent: this._userNameField,
		parentElement: (htmlElId+"_networkStatusIcon")
	};
	this._networkStatusIcon = new DwtComposite(params);

	var params1 = {
		parent: this._userNameField,
		parentElement: (htmlElId+"_networkStatusText")
	};
	this._networkStatusText = new DwtComposite(params1);

	var topTreeEl = document.getElementById("skin_container_tree_top");
	if (topTreeEl) {
		Dwt.setSize(topTreeEl, Dwt.DEFAULT, "20");
	}
};

ZmZimbraMail.prototype._offlineUpdateChannelPref =
function(val) {
    try {
        netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
        var prefs =
            Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefBranch);
        if (prefs) {
            prefs.setCharPref("app.update.channel", val);
        }
    } catch (ex) {
        DBG.println(AjxDebug.DBG1, "-----------Exception while setting update channel preference " + ex);
    }
};

/**
 * Sets the user info.
 *
 */
ZmZimbraMail.prototype.setUserInfo = function() {

	if (appCtxt.isOffline) {
		return;
	}

	// username
	var login = appCtxt.getLoggedInUsername();
	var username = (appCtxt.get(ZmSetting.DISPLAY_NAME)) || login;
	if (username) {
		var el = this._userNameField.getHtmlElement();
        el.innerHTML =  AjxStringUtil.htmlEncode(AjxStringUtil.clipByLength(username, 24));
		el.setAttribute('aria-label', username);
		if (AjxEnv.isLinux) {	// bug fix #3355
			el.style.lineHeight = "13px";
		}
	}

    this.setQuotaInfo(login, username);
};

ZmZimbraMail.prototype.setQuotaInfo = function(login, username) {

    var quota = appCtxt.get(ZmSetting.QUOTA);
	var usedQuota = (appCtxt.get(ZmSetting.QUOTA_USED)) || 0;
	var data = {
		id: this._usedQuotaField._htmlElId,
		login: login,
		username: username,
		quota: quota,
		usedQuota: usedQuota,
		size: (AjxUtil.formatSize(usedQuota, false, 1))
	};

	var quotaTemplateId;
	if (data.quota) {
		quotaTemplateId = 'UsedLimited';
		data.limit = AjxUtil.formatSize(data.quota, false, 1);
		data.percent = Math.min(Math.round((data.usedQuota / data.quota) * 100), 100);
		data.desc = AjxMessageFormat.format(ZmMsg.usingDescLimited, [data.size, '(' + data.percent + '%)', data.limit]);
	}
    else {
		data.desc = AjxMessageFormat.format(ZmMsg.usingDescUnlimited, [data.size]);
		quotaTemplateId = 'UsedUnlimited';
	}

	var el = this._usedQuotaField.getHtmlElement();
    el.innerHTML = AjxTemplate.expand('share.Quota#' + quotaTemplateId, data);
	el.setAttribute('aria-label', data.desc);

	// tooltip for username/quota fields
	var html = AjxTemplate.expand('share.Quota#Tooltip', data);
	this._components[ZmAppViewMgr.C_USER_INFO].setToolTipContent(html);
	this._components[ZmAppViewMgr.C_QUOTA_INFO].setToolTipContent(html);
};

/**
 * If a user has been prompted and elects to stay on page, this timer automatically logs them off after an interval of time.
 * @param startTimer {boolean} true to start timer, false to cancel
 */
ZmZimbraMail.setExitTimer = 
function(startTimer) {
	if (startTimer && ZmZimbraMail.stayOnPagePrompt) {
		DBG.println(AjxDebug.DBG1, "user has clicked stay on page. scheduled exit timer at " + new Date().toLocaleString());
		if (ZmZimbraMail._exitTimerId == -1) {
			ZmZimbraMail._exitTimerId = AjxTimedAction.scheduleAction(ZmZimbraMail._exitTimer, ZmZimbraMail.STAYONPAGE_INTERVAL * 60 * 1000); //give user 2 minutes
			if (AjxEnv.isFirefox) {
				var msg = AjxMessageFormat.format(ZmMsg.appExitPrompt, [ZmZimbraMail.STAYONPAGE_INTERVAL]);
				var msgDialog = appCtxt.getMsgDialog();
				msgDialog.setMessage(msg, DwtMessageDialog.CRITICAL_STYLE); //Firefox 4+ doesn't allow custom stay on page message. Prompt user they have X minutes
				//wait 2 seconds before popping up  so FF doesn't show dialog when leave page is clicked
				setTimeout(function() { msgDialog.popup()}, 1000 * 2);
			}
		}

	}
	else if (!startTimer && ZmZimbraMail._exitTimerId) {
		DBG.println(AjxDebug.DBG1, "canceling exit timer at " + new Date().toLocaleString());
		AjxTimedAction.cancelAction(ZmZimbraMail._exitTimerId);
		ZmZimbraMail._exitTimerId = -1;
	}
	
};

// Listeners

/**
 * Logs off the application.
 * 
 */
ZmZimbraMail.logOff =
function(ev, relogin) {
	if (appCtxt.isChildWindow) {
		window.close();
		return;
	}
	if (appCtxt.isWebClientOfflineSupported && (ev || relogin)) {
		return ZmOffline.handleLogOff(ev, relogin);
    }

	ZmZimbraMail._isLogOff = true;

	// bug fix #36791 - reset the systray icon when returning to Account Setup
	if (appCtxt.isOffline && AjxEnv.isWindows &&
		appCtxt.get(ZmSetting.OFFLINE_SUPPORTS_DOCK_UPDATE))
	{
		window.platform.icon().imageSpec = "resource://webapp/icons/default/launcher.ico";
		window.platform.icon().title = null;
	}
    var urlParams = {
                path:appContextPath,
                qsArgs: {
                        loginOp: relogin ? 'relogin' : 'logout'
                    }
                };
	if (relogin) {
		urlParams.qsArgs.username = appCtxt.getLoggedInUsername();
	}
    if(appCtxt.isExternalAccount()) {
        var vAcctDomain = appCtxt.getUserDomain();
        urlParams.qsArgs.virtualacctdomain = vAcctDomain ? vAcctDomain : "";
    }
	var url = AjxUtil.formatUrl(urlParams);
	ZmZimbraMail.sendRedirect(url);	// will trigger onbeforeunload
	if (AjxEnv.isFirefox) {
		DBG.println(AjxDebug.DBG1, "calling setExitTimer from logoff "  + new Date().toLocaleString());
		ZmZimbraMail.setExitTimer(true);	
	}
	

};

/**
 * Logs user off when session has expired and user has choosen to stay on page when prompted
 */
ZmZimbraMail.exitSession =
function() {
	DBG.println(AjxDebug.DBG1, "exit timer called  " + new Date().toLocaleString());
	ZmZimbraMail.logOff();
};

ZmZimbraMail.executeSessionTimer = 
function() {
	ZmZimbraMail.sessionTimerInvoked = true;
	DBG.println(AjxDebug.DBG1, "session timer invoked  " + new Date().toLocaleString());
	ZmZimbraMail.logOff();
};


/**
 * Return the confirmExitMethod that can be used for window.onbeforeunload
 *
 */
ZmZimbraMail.getConfirmExitMethod =
function(){
    return this._confirmExitMethod;
}


/**
 * @private
 */
ZmZimbraMail._onClickLogOff =
function() {
	if (AjxEnv.isIE) {
		// Don't the the default <a> handler process the event. It can bring up
		// an unwanted "Are you sure you want to exit?" dialog.
		var ev = DwtUiEvent.getEvent();
		ev.returnValue = false;
	}
	ZmZimbraMail.logOff();
};

/**
 * @private
 */
ZmZimbraMail.adminLinkCallback =
function(url) {
	ZmZimbraMail.unloadHackCallback();
	var ac = window.parentAppCtxt || window.appCtxt;
	window.open(url);
};

/**
 * @private
 */
ZmZimbraMail.standardHtmlLinkCallback =
function() {
	var urlParams = {
		path: appContextPath,
		qsArgs: {
			client: "standard"
		}
	};
	var url = AjxUtil.formatUrl(urlParams);
	ZmZimbraMail.sendRedirect(url);	// will trigger onbeforeunload
};

/**
 * @private
 */
ZmZimbraMail.helpLinkCallback =
function(helpurl) {
	ZmZimbraMail.unloadHackCallback();

	var ac = window.parentAppCtxt || window.appCtxt;
	var url;
	if (!ac.isOffline) {
		try { url = helpurl || skin.hints.helpButton.url; } catch (e) { /* ignore */ }
		url = url || ac.get(ZmSetting.HELP_URI);
		var sep = url.match(/\?/) ? "&" : "?";
		url = [url, sep, "locid=", AjxEnv.DEFAULT_LOCALE].join("");
	} else {
		url = ac.get(ZmSetting.HELP_URI).replace(/\/$/,"");
		// bug fix #35098 - offline help is only available in en_US for now
		url = [url, "help", "en_US", "Zimbra_Mail_Help.htm"].join("/");
//		url = [url, "help", AjxEnv.DEFAULT_LOCALE, "Zimbra_Mail_Help.htm"].join("/");
	}
	window.open(url);
};

/**
 * Sends a redirect.
 * 
 * @param	{String}	locationStr		the redirect location
 */
ZmZimbraMail.sendRedirect =
function(locationStr) {
	// not sure why IE doesn't allow this to process immediately, but since
	// it does not, we'll set up a timed action.
	if (AjxEnv.isIE) {
		var act = new AjxTimedAction(null, ZmZimbraMail.redir, [locationStr]);
		AjxTimedAction.scheduleAction(act, 1);
	} else {
		ZmZimbraMail.redir(locationStr);
	}
};

/**
 * Redirect.
 * 
 * @param	{String}	locationStr		the redirect location
 */
ZmZimbraMail.redir =
function(locationStr){
	// IE has a tendency to throw a mysterious error when the "are you sure" dialog pops up and the user presses "cancel".
	// Pressing cancel, however, equals doing nothing, so we can just catch the exception and ignore it (bug #59853)
	try {
		window.location = locationStr;
	} catch (e) {
	}
};

/**
 * Sets the session timer.
 * 
 * @param	{Boolean}	bStartTimer		if <code>true</code>, start the timer
 */
ZmZimbraMail.prototype.setSessionTimer =
function(bStartTimer) {

	// if no timeout value, user's client never times out from inactivity
	var timeout = appCtxt.get(ZmSetting.IDLE_SESSION_TIMEOUT) * 1000;
	if (timeout <= 0) {
		return;
	}

	if (bStartTimer) {
		DBG.println(AjxDebug.DBG3, "INACTIVITY TIMER SET (" + (new Date()).toLocaleString() + ")");
		this._sessionTimerId = AjxTimedAction.scheduleAction(this._sessionTimer, timeout);

		DwtEventManager.addListener(DwtEvent.ONMOUSEUP, ZmZimbraMail._userEventHdlr);
		this._shell.setHandler(DwtEvent.ONMOUSEUP, ZmZimbraMail._userEventHdlr);
		if (document.attachEvent)  {
			document.attachEvent("onkeydown", ZmZimbraMail._userEventHdlr);
		}
		window.onkeydown = ZmZimbraMail._userEventHdlr;		
	}
	else {
		DBG.println(AjxDebug.DBG3, "INACTIVITY TIMER CANCELED (" + (new Date()).toLocaleString() + ")");

		AjxTimedAction.cancelAction(this._sessionTimerId);
		this._sessionTimerId = -1;

		DwtEventManager.removeListener(DwtEvent.ONMOUSEUP, ZmZimbraMail._userEventHdlr);
		this._shell.clearHandler(DwtEvent.ONMOUSEUP);
		if (document.detachEvent) {
			document.detachEvent("onkeydown", ZmZimbraMail._userEventHdlr);
		}	
		window.onkeydown = null;
	}
};

/**
 * Adds a child window.
 * 
 * @private
 */
ZmZimbraMail.prototype.addChildWindow =
function(childWin, childId) {
	if (this._childWinList == null) {
		this._childWinList = new AjxVector();
	}

	// NOTE: we now save childWin w/in Object so other params can be added to it.
	// Otherwise, Safari breaks (see http://bugs.webkit.org/show_bug.cgi?id=7162)
	var newWinObj = {win:childWin,childId:childId};
	this._childWinList.add(newWinObj);

	return newWinObj;
};

/**
 * Gets a child window.
 * 
 * @private
 */
ZmZimbraMail.prototype.getChildWindow =
function(childWin) {
	var list = this._childWinList;
	if (list && childWin) {
		for (var i = 0; i < list.size(); i++) {
			var winObj = list.get(i);
			if (childWin === winObj.win || childWin.childId === winObj.childId) {
				return winObj;
			}
		}
	}
	return null;
};

/**
 * Removes a child window.
 * 
 * @private
 */
ZmZimbraMail.prototype.removeChildWindow =
function(childWin) {
	var list = this._childWinList;
	if (list) {
		for (var i = 0; i < list.size(); i++) {
			var winObj = list.get(i);
			if (childWin == winObj.win) {
				// Bug 84426: We don't want our old window metadata to go away; if it's merely a refresh
				// we want access to the parameters of our old window, so clear the actual window object,
				// and leave the other parameters in winObj intact
				winObj.win = null;
				break;
			}
		}
	}
};

/**
 * Checks for a certain type of exception, then hands off to standard
 * exception handler.
 *
 * @param {AjxException}	ex				the exception
 * @param {Object}	continuation		the original request params
 * 
 * @private
 */
ZmZimbraMail.prototype._handleException =
function(ex, continuation) {
	var handled = false;
	if (ex.code == ZmCsfeException.MAIL_NO_SUCH_FOLDER) {
		// check for fault when getting folder perms
		var organizerTypes = [ZmOrganizer.CALENDAR, ZmOrganizer.ADDRBOOK];
		if (ex.data.itemId && ex.data.itemId.length) {
			var itemId = ex.data.itemId[0];
			var index = itemId.lastIndexOf(':');
			var zid = itemId.substring(0, index);
			var rid = itemId.substring(index + 1, itemId.length);
			var ft = appCtxt.getFolderTree();
			for (var type = 0; type < organizerTypes.length; type++) {
				handled |= ft.handleNoSuchFolderError(organizerTypes[type], zid, rid, true);
			}
		}
	}
    else if (appCtxt.isWebClientOffline() && ex.code === ZmCsfeException.EMPTY_RESPONSE) {
        handled = true;
    }
	if (!handled) {
		ZmController.prototype._handleException.apply(this, arguments);
	}
};

/**
 * This method is called by the window.onbeforeunload handler
 * 
 * @private
 */
ZmZimbraMail._confirmExitMethod =
function() {

	if (!ZmCsfeCommand.noAuth) {
		appCtxt.accountList.saveImplicitPrefs();

		if (appCtxt.get(ZmSetting.WARN_ON_EXIT) && !ZmZimbraMail._isOkToExit()) {
			if (ZmZimbraMail.stayOnPagePrompt) {
				DBG.println(AjxDebug.DBG1, "user has already been prompted. Forcing exit " + new Date().toLocaleString());
				return;
			}
			
			ZmZimbraMail._isLogOff = false;
			DBG.println(AjxDebug.DBG1, "prompting to user to stay on page or leave " + new Date().toLocaleString());
			var msg = (appCtxt.isOffline) ? ZmMsg.appExitWarningZD : ZmMsg.appExitWarning;
			
			if (ZmZimbraMail.sessionTimerInvoked) {
				ZmZimbraMail.stayOnPagePrompt = true;
				msg = AjxMessageFormat.format(msg + ZmMsg.appExitTimeWarning, [ZmZimbraMail.STAYONPAGE_INTERVAL]); //append time warning
			}
			if (!AjxEnv.isFirefox) {
				DBG.println(AjxDebug.DBG1, "calling setExitTimer  "  + new Date().toLocaleString());
				ZmZimbraMail.setExitTimer(true);
			}
			return msg;
			
		}

		ZmZimbraMail._endSession();
	}
    if (window.ZmDesktopAlert) {
        ZmDesktopAlert.closeNotification();
    }
	ZmZimbraMail._endSessionDone = true;
};

/**
 * Returns true if there is no unsaved work. If that's the case, it also
 * cancels any pending poll. Typically called by onbeforeunload handling.
 * 
 * @private
 */
ZmZimbraMail._isOkToExit =
function() {
	var appCtlr = window._zimbraMail;
	if (!appCtlr) { return true; }
	var okToExit = appCtlr._appViewMgr.isOkToUnload() && ZmZimbraMail._childWindowsOkToUnload();
	if (okToExit && !AjxEnv.isPrism && appCtlr._pollRequest) {
		appCtlr._requestMgr.cancelRequest(appCtlr._pollRequest);
	}
	return okToExit;
};

// returns true if no child windows are dirty
ZmZimbraMail._childWindowsOkToUnload =
function() {
	var childWinList = window._zimbraMail ? window._zimbraMail._childWinList : null;
	if (childWinList) {
		for (var i = 0; i < childWinList.size(); i++) {
			var childWin = childWinList.get(i);
			if (childWin.win && childWin.win.ZmNewWindow && childWin.win.ZmNewWindow._confirmExitMethod()) {
				return false;
			}
		}
	}
	return true;
};

ZmZimbraMail.handleNetworkStatusClick =
function() {
	var ac = window["appCtxt"].getAppController();

	// if already offline, then ignore this click
	if (!ac._isPrismOnline) { return; }

	ac._isUserOnline = !ac._isUserOnline;
	ac._updateNetworkStatus(ac._isUserOnline);
};

/**
 * @private
 */
ZmZimbraMail.unloadHackCallback =
function() {
	window.onbeforeunload = null;
	var f = function() { window.onbeforeunload = ZmZimbraMail._confirmExitMethod; };
	AjxTimedAction.scheduleAction((new AjxTimedAction(null, f)), 3000);
};

/**
 * @private
 */
ZmZimbraMail._userEventHdlr =
function(ev) {
	var zm = window._zimbraMail;
	if (zm) {
		// cancel old timer and start a new one
		AjxTimedAction.cancelAction(zm._sessionTimerId);
		var timeout = appCtxt.get(ZmSetting.IDLE_SESSION_TIMEOUT) * 1000;
		if (timeout <= 0) {
			return;
		}
		zm._sessionTimerId = AjxTimedAction.scheduleAction(zm._sessionTimer, timeout);
	}
	DBG.println(AjxDebug.DBG3, "INACTIVITY TIMER RESET (" + (new Date()).toLocaleString() + ")");
};

/**
 * @private
 */
ZmZimbraMail.prototype._createBanner =
function() {
	var banner = new DwtComposite({parent:this._shell, posStyle:Dwt.ABSOLUTE_STYLE, id:ZmId.BANNER});
	var logoUrl = appCtxt.getSkinHint("banner", "url") || appCtxt.get(ZmSetting.LOGO_URI);
	var data = {url:logoUrl, isOffline:appCtxt.isOffline};
	banner.getHtmlElement().innerHTML  = AjxTemplate.expand('share.App#Banner', data);
	banner.getHtmlElement().style.height = '100%';
	return banner;
};

/**
 * @private
 */
ZmZimbraMail.prototype._createUserInfo =
function(className, cid, id) {

	var position = appCtxt.getSkinHint(cid, "position");
	var posStyle = position || Dwt.ABSOLUTE_STYLE;
	var ui = new DwtComposite({
		parent:         this._shell,
		className:      className,
		posStyle:       posStyle,
		id:             id,
		isFocusable:    true
	});
	ui._setMouseEventHdlrs();
	return ui;
};

/**
 * @private
 */
ZmZimbraMail.prototype._createAppChooser =
function() {

	var buttons = [];
	for (var id in ZmApp.CHOOSER_SORT) {
		if (id == ZmAppChooser.SPACER || id == ZmAppChooser.B_HELP || id == ZmAppChooser.B_LOGOUT) {
			continue;
		}

		if (this._isInternalApp(id) || this._isIframeApp(id)) {
			buttons.push(id);
		}
	}
	buttons.sort(function(a, b) {
		return ZmZimbraMail.hashSortCompare(ZmApp.CHOOSER_SORT, a, b);
	});

	var appChooser = new ZmAppChooser({parent:this._shell, buttons:buttons, id:ZmId.APP_CHOOSER, refElementId:ZmId.SKIN_APP_CHOOSER});

	var buttonListener = new AjxListener(this, this._appButtonListener);
	appChooser.addSelectionListener(buttonListener);

	return appChooser;
};

/**
 * @private
 */
ZmZimbraMail.prototype._appButtonListener =
function(ev) {
	try {
		var id = ev.item.getData(Dwt.KEY_ID);
		DBG.println(AjxDebug.DBG1, "ZmZimbraMail button press: " + id);
		if (id == ZmAppChooser.B_HELP) {
			window.open(appCtxt.get(ZmSetting.HELP_URI));
		} else if (id == ZmAppChooser.B_LOGOUT) {
			ZmZimbraMail.logOff();
		} else if (id && ZmApp.ENABLED_APPS[id] && (id != this._activeTabId)) {
			this.activateApp(id);
			if (appCtxt.zimletsPresent()) {
				appCtxt.getZimletMgr().notifyZimlets("onSelectApp", id);
			}
		} else {
			var isCloseButton = (DwtUiEvent.getTargetWithProp(ev, "id") == ev.item._getIconEl(DwtLabel.RIGHT));
			if (isCloseButton) {
				this._appViewMgr.popView(false, id);
			}
			else if (id != this._activeTabId) {
				this._appViewMgr.pushView(id);
			}
		}
	} catch (ex) {
		this._handleException(ex);
	}
};

/**
 * Gets the application chooser.
 * 
 * @return	{ZmAppChooser}	the chooser
 */
ZmZimbraMail.prototype.getAppChooser =
function() {
	return this._appChooser;
};

/**
 * Sets the active tab.
 * 
 * @param	{String}	id		the tab id
 */
ZmZimbraMail.prototype.setActiveTabId =
function(id) {
	this._activeTabId = id;
	this._appChooser.setSelected(id);
};

/**
 * Displays a status message.
 * 
 * @param	{Hash}	params		a hash of parameters
 * @param {String}	params.msg		the message
 * @param {constant}	[params.level] ZmStatusView.LEVEL_INFO, ZmStatusView.LEVEL_WARNING, or ZmStatusView.LEVEL_CRITICAL
 * @param {constant}	[params.detail] 	the details
 * @param {constant}	[params.transitions]		the transitions
 * @param {constant}	[params.toast]		the toast control 
 * @param {boolean}     [force]        force any displayed toasts out of the way (dismiss them and run their dismissCallback). Enqueued messages that are not yet displayed will not be displayed
 * @param {AjxCallback}    [dismissCallback]    callback to run when the toast is dismissed (by another message using [force], or explicitly calling ZmStatusView.prototype.dismiss())
 * @param {AjxCallback}    [finishCallback]     callback to run when the toast finishes its transitions by itself (not when dismissed)
 */
ZmZimbraMail.prototype.setStatusMsg =
function(params) {
	params = Dwt.getParams(arguments, ZmStatusView.MSG_PARAMS);
	this.statusView.setStatusMsg(params);
};

/**
 * Dismisses the displayed status message, if any
 */

ZmZimbraMail.prototype.dismissStatusMsg =
function(all) {
	this.statusView.dismissStatusMsg(all);
};

/**
 * Gets the key map name.
 * 
 * @return	{String}	the key map name
 */
ZmZimbraMail.prototype.getKeyMapName =
function() {
	var ctlr = appCtxt.getCurrentController();
	if (ctlr && ctlr.getKeyMapName) {
		return ctlr.getKeyMapName();
	}
	return ZmKeyMap.MAP_GLOBAL;
};

/**
 * Handles the key action.
 * 
 * @param	{constant}		actionCode		the action code
 * @param	{Object}	    ev		        the event
 */
ZmZimbraMail.prototype.handleKeyAction = function(actionCode, ev) {

    DwtMenu.closeActiveMenu();

	var app = ZmApp.GOTO_ACTION_CODE_R[actionCode];
	if (app) {
		if (app == this.getActiveApp()) {
            return false;
        }
		if (appCtxt.isWebClientOffline() && !AjxUtil.arrayContains(ZmOffline.SUPPORTED_APPS, app)) {
			return false;
		}
		this.activateApp(app);
		return true;
	}

	switch (actionCode) {

		case ZmKeyMap.QUICK_REMINDER: {
            var account = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
            // calMgr.showQuickReminder uses an entire alternate search mechanism from ZmApptCache - setting params,
            // sending a search, etc.  Suppress for offline - lots of work for little gain to adapt this to offline modek
            if (appCtxt.get(ZmSetting.CALENDAR_ENABLED, null, account) && !appCtxt.isWebClientOffline()) {
                var calMgr = appCtxt.getCalManager();
                calMgr.showQuickReminder();
            }
			break;
		}

		case ZmKeyMap.FOCUS_SEARCH_BOX: {
			var stb = appCtxt.getSearchController().getSearchToolbar();
			if (stb) {
				var searchBox = stb.getSearchField();
				appCtxt.getKeyboardMgr().grabFocus(searchBox);
				if (ZmSearchAutocomplete) {
					ZmSearchAutocomplete._ignoreNextKey = true;
				}
			}
			break;
		}

		case ZmKeyMap.FOCUS_CONTENT_PANE: {
			this.focusContentPane();
			break;
		}

		case ZmKeyMap.FOCUS_TOOLBAR: {
			this.focusToolbar();
			break;
		}

		case ZmKeyMap.SHORTCUTS: {
			this._showCurrentShortcuts();
			break;
		}

		// this action needs to be last
		case ZmKeyMap.CANCEL: {
			// see if there's a current drag operation we can cancel
			var handled = false;
			var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
			var obj = captureObj && captureObj.targetObj;
			if (obj && (obj._dragging == DwtControl._DRAGGING)) {
				captureObj.release();
				obj.__lastDestDwtObj = null;
				obj._setDragProxyState(false);					// turn dnd icon red so user knows no drop is happening
				DwtControl.__badDrop(obj, DwtShell.mouseEvent);	// shell's mouse ev should have latest info
				handled = true;
			}
			if (handled) { break; }
		}

		default: {
            // Hand shortcut to current controller
			var ctlr = appCtxt.getCurrentController();
			return ctlr && ctlr.handleKeyAction ? ctlr.handleKeyAction(actionCode, ev) : false;
		}
	}

	return true;
};

/**
 * Focuses on the content pane.
 * 
 */
ZmZimbraMail.prototype.focusContentPane =
function() {
	// Set focus to the list view that's in the content pane. If there is no
	// list view in the content pane, nothing happens. The list view will be
	// found in the root tab group hierarchy.
	var ctlr = appCtxt.getCurrentController();
	var content = ctlr && ctlr._getDefaultFocusItem();
	if (content) {
		appCtxt.getKeyboardMgr().grabFocus(content);
	}
};

/**
 * Focuses on the toolbar.
 * 
 */
ZmZimbraMail.prototype.focusToolbar =
function() {
	// Set focus to the toolbar that's in the content pane.
	var ctlr = appCtxt.getCurrentController();
	var toolbar = ctlr && ctlr.getCurrentToolbar && ctlr.getCurrentToolbar();
	if (toolbar) {
		appCtxt.getKeyboardMgr().grabFocus(toolbar);
	}
};

/**
 * Creates an "iframe view", which is a placeholder view for an app that's not
 * enabled but which has a tab. The app will have
 * a URL for its external content, which we put into an IFRAME.
 *
 * @param {constant}	appName	the name of app
 * 
 * @private
 */
ZmZimbraMail.prototype._createAppIframeView =
function(appName) {

	var viewName = [appName, "iframe"].join("_"),
		isSocial = (appName === ZmApp.SOCIAL),
		params = { appName: appName },
		appIframeView = this._appIframeView[appName];

	if (!appIframeView) {
		appIframeView = this._appIframeView[appName] = isSocial ? new ZmCommunityView(params) : new ZmAppIframeView(params);

		var elements = {}, callbacks = {};
		elements[ZmAppViewMgr.C_APP_CONTENT] = appIframeView;
		callbacks[ZmAppViewMgr.CB_POST_SHOW] = this._displayAppIframeView.bind(this);

		var hide = [ ZmAppViewMgr.C_TREE, ZmAppViewMgr.C_TREE_FOOTER, ZmAppViewMgr.C_TOOLBAR_TOP,
			ZmAppViewMgr.C_NEW_BUTTON, ZmAppViewMgr.C_SASH ];

		this._appViewMgr.createView({	viewId:			viewName,
										appName:		appName,
										controller:		this,
										elements:		elements,
										hide:			hide,
										isTransient:	true,
										isFullScreen:	true,
										callbacks:		callbacks});
	}

	this._appViewMgr.pushView(viewName);
	appIframeView.activate(true);
};

ZmZimbraMail.prototype._displayAppIframeView =
function(appName) {
	appCtxt.getApp(this._getDefaultStartAppName()).setOverviewPanelContent(false);
};

/**
 * Sets up Zimlet organizer type. This is run if we get zimlets in the
 * GetInfoResponse. Note that this will run before apps are instantiated,
 * which is necessary because they depend on knowing whether there are zimlets.
 * 
 * @private
 */
ZmZimbraMail.prototype._postLoadZimlet =
function() {
	appCtxt.setZimletsPresent(true);
};

/**
 * @private
 */
ZmZimbraMail.prototype._globalSelectionListener =
function(ev) {
	// bug 47514
	if (this._waitDisallowed) {
		this._waitDisallowed = false;
		this.setInstantNotify(true);
	}

	if (!appCtxt.areZimletsLoaded()) { return; }

	var item = ev.item;

	// normalize action
	var text = (item && item.getText) ? (item.getText() || item._toggleText) : null;
	if (item && !text) {
		text = item.getData(ZmOperation.KEY_ID) || item.getData(Dwt.KEY_ID);
	}
	if (text) {
		var type;
		if (item instanceof ZmAppButton) {
			type = "app";
		} else if (item instanceof DwtMenuItem) {
			type = "menuitem";
		} else if (item instanceof DwtButton) {
			type = "button";
		} else if (item instanceof DwtTreeItem) {
			if (!item.getSelected()) { return; }
			type = "treeitem";
		} else {
			type = item.toString();
		}

		var avm = appCtxt.getAppViewMgr();
		var currentViewId = avm.getCurrentViewId();
		var lastViewId = avm.getLastViewId();
		var action = (AjxStringUtil.split((""+text), " ")).join("");
		appCtxt.notifyZimlets("onAction", [type, action, currentViewId, lastViewId]);
	}
};

ZmZimbraMail._folderTreeSashRelease =
function(sash) {
	var currentWidth = skin.getTreeWidth();
	if (currentWidth) {
		appCtxt.set(ZmSetting.FOLDER_TREE_SASH_WIDTH, currentWidth);
	}
};

/**
 * @private
 */
ZmZimbraMail._endSession =
function() {
	if (!AjxEnv.isPrism && navigator.onLine) {
		// Let the server know that the session is ending.
		var args = {
			jsonObj: { EndSessionRequest: { _jsns: "urn:zimbraAccount" } },
			asyncMode: !appCtxt.get("FORCE_CLEAR_COOKIES"),
			emptyResponseOkay:	true
		};
        var controller = appCtxt.getAppController();
		controller && controller.sendRequest(args);
	}
};

ZmZimbraMail.prototype.notify =
function(eventType) {
	this._evtMgr.notifyListeners(eventType, this._evt);
};

ZmZimbraMail.prototype._showCurrentShortcuts = function() {

	var panel = appCtxt.getShortcutsPanel();
	var curMap = this.getKeyMapName();
	var km = appCtxt.getAppController().getKeyMapMgr();
	var maps = km.getAncestors(curMap);
	var inherits = (maps && maps.length > 0);
	maps.unshift(curMap);
	var maps2 = [];
	if (inherits) {
		if (maps.length > 1 && maps[maps.length - 1] == ZmKeyMap.MAP_GLOBAL) {
			maps.pop();
			maps2.push(ZmKeyMap.MAP_GLOBAL);
		}
	}

	var col1 = {}, col2 = {};
	col1.type = ZmShortcutList.TYPE_APP;
	col1.maps = maps;
	var colList = [col1];
	if (maps2.length) {
		col2.type = ZmShortcutList.TYPE_APP;
		col2.maps = maps2;
		colList.push(col2);
	}
	var col3 = {};
	col3.type = ZmShortcutList.TYPE_SYS;
	col3.maps = [];
	var ctlr = appCtxt.getCurrentController();
	var testMaps = ["list", "editor", "tabView"];
	for (var i = 0; i < testMaps.length; i++) {
		if (ctlr && ctlr.mapSupported(testMaps[i])) {
			col3.maps.push(testMaps[i]);
		}
	}
	col3.maps.push("button", "menu", "tree", "dialog", "toolbarHorizontal");
	colList.push(col3);
	panel.popup(colList);
}

// YUCK:
ZmOrganizer.ZIMLET = "ZIMLET";
}
if (AjxPackage.define("zimbraMail.core.ZmNewWindow")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the new window class.
 */

/**
 * Creates a controller to run <code>ZmNewWindow</code>. Do not call directly, instead use
 * the <code>run()</code> factory method.
 * @class
 * This class is the controller for a window created outside the main client
 * window. It is a very stripped down and specialized version of {@link ZmZimbraMail}.
 * The child window is single-use; it does not support switching among multiple
 * views.
 *
 * @author Parag Shah
 * 
 * @extends	ZmController
 * 
 * @see		#run
 */
ZmNewWindow = function() {

	ZmController.call(this, null);

	appCtxt.setAppController(this);

	//update body class to reflect user selected font
	document.body.className = "user_font_" + appCtxt.get(ZmSetting.FONT_NAME);
	//update root html elment class to reflect user selected font size
	Dwt.addClass(document.documentElement, "user_font_size_" + appCtxt.get(ZmSetting.FONT_SIZE));


	this._settings = appCtxt.getSettings();
	this._settings.setReportScriptErrorsSettings(AjxException, ZmController.handleScriptError); //must set this for child window since AjxException is fresh for this window. Also must pass AjxException and the handler since we want it to update the one from this child window, and not the parent window

	this._shell = appCtxt.getShell();

	// Register keymap and global key action handler w/ shell's keyboard manager
	this._kbMgr = appCtxt.getKeyboardMgr();
	if (appCtxt.get(ZmSetting.USE_KEYBOARD_SHORTCUTS)) {
		this._kbMgr.enable(true);
		this._kbMgr.registerKeyMap(new ZmKeyMap());
		this._kbMgr.pushDefaultHandler(this);
	}

	this._apps = {};
};

ZmNewWindow.prototype = new ZmController;
ZmNewWindow.prototype.constructor = ZmNewWindow;

ZmNewWindow.prototype.isZmNewWindow = true;
ZmNewWindow.prototype.toString = function() { return "ZmNewWindow"; };

// Public methods

/**
 * Sets up new window and then starts it by calling its constructor. It is assumed that the
 * CSFE is on the same host.
 * 
 */
ZmNewWindow.run =
function() {

	// We're using a custom pkg that includes the mail classes we'll need, so pretend that
	// we've already loaded mail packages so the real ones don't get loaded as well.
	AjxDispatcher.setLoaded("MailCore", true);
	AjxDispatcher.setLoaded("Mail", true);

	var winOpener = window.opener || window;

	if (!window.parentController) {
		window.parentController = winOpener._zimbraMail;
	}

	// Create the global app context
	window.appCtxt = new ZmAppCtxt();
	window.appCtxt.isChildWindow = true;

	// XXX: DO NOT MOVE THIS LINE
	// redefine ZmSetting from parent window since it loses this info.
	window.parentAppCtxt = winOpener.appCtxt;
	appCtxt.setSettings(parentAppCtxt.getSettings());
	appCtxt.isOffline = parentAppCtxt.isOffline;
	appCtxt.multiAccounts = parentAppCtxt.multiAccounts;
    appCtxt.sendAsEmails = parentAppCtxt.sendAsEmails;
    appCtxt.sendOboEmails = parentAppCtxt.sendOboEmails;
    window.ZmSetting = winOpener.ZmSetting;

	ZmOperation.initialize();
	ZmApp.initialize();

	var shell = new DwtShell({className:"MainShell"});
	window.onbeforeunload = ZmNewWindow._confirmExitMethod;
	appCtxt.setShell(shell);

	// create new window and Go!
	var newWindow = new ZmNewWindow();
    newWindow.startup();
	
	if (winOpener.onkeydown) {
		window.onkeydown = winOpener.onkeydown;
	}
};

/**
* Allows this child window to inform parent it's going away
*/
ZmNewWindow.unload = function(ev) {

	if (!window || !window.opener || !window.parentController) {
        return;
    }

	var command = window.newWindowCommand; //bug 54409 - was using wrong attribute for command in unload
	if (command == "compose" || command == "composeDetach"
			|| (command == "msgViewDetach" && appCtxt.composeCtlrSessionId)) { //msgViewDetach might turn into a compose session if user hits "reply"/etc
		// compose controller adds listeners to parent window's list so we
		// need to remove them before closing this window!
		var cc = AjxDispatcher.run("GetComposeController", appCtxt.composeCtlrSessionId);
		if (cc) {
			cc.dispose();
		}
	}

	if (command == "msgViewDetach") {
		// msg controller (as a ZmListController) adds listener to tag list
		var mc = AjxDispatcher.run("GetMsgController", appCtxt.msgCtlrSessionId);
		if (mc) {
			mc.dispose();
		}
	}

	if (window.parentController) {
		window.parentController.removeChildWindow(window);
	}
};

/**
 * Presents a view based on a command passed through the window object. Possible commands are:
 *
 * <ul>
 * <li><b>compose</b> compose window launched in child window</li>
 * <li><b>composeDetach</b> compose window detached from client</li>
 * <li><b>msgViewDetach</b> msg view detached from client</li>
 * </ul>
 * 
 */
ZmNewWindow.prototype.startup =
function() {
	// get params from parent window b/c of Safari bug #7162
	// and in case of a refresh, our old window parameters are still stored there
	if (window.parentController) {
		var childWinObj = window.parentController.getChildWindow(window);
		if (childWinObj) {
			window.newWindowCommand = childWinObj.command;
			window.newWindowParams = childWinObj.params;
		}
	}

    if (!this._appViewMgr) {
        this._appViewMgr = new ZmAppViewMgr(this._shell, this, true, false);
        this._statusView = new ZmStatusView(this._shell, "ZmStatus", Dwt.ABSOLUTE_STYLE, ZmId.STATUS_VIEW);
    }

    var cmd = window.newWindowCommand;
	var params = window.newWindowParams;
	if (cmd == "shortcuts") {
		var apps = {};
		apps[ZmApp.PREFERENCES] = true;
		this._createEnabledApps(apps);
		this._createView();
		return;
	}

	DBG.println(AjxDebug.DBG1, " ************ Hello from new window!");

	var rootTg = appCtxt.getRootTabGroup();

	var apps = {};
	apps[ZmApp.SEARCH] = true;
	apps[ZmApp.MAIL] = true;
	apps[ZmApp.CONTACTS] = true;
	// only load calendar app if we're dealing with an invite
	var msg = (cmd == "msgViewDetach") ? params.msg : null;
	if (msg &&
        (msg.isInvite() || this._checkShareType(msg.share, "appointment"))) {
		apps[ZmApp.CALENDAR] = true;
	} else if (msg && this._checkShareType(msg.share, "task")) {
		apps[ZmApp.TASKS] = true;
	}
	apps[ZmApp.PREFERENCES] = true;
    apps[ZmApp.BRIEFCASE] = true;  //Need this for both Compose & Msg View detach window.
	this._createEnabledApps(apps);

	// inherit parent's identity collection
	var parentPrefsApp = parentAppCtxt.getApp(ZmApp.MAIL);
    if (parentPrefsApp) {
        appCtxt.getApp(ZmApp.MAIL)._identityCollection = parentPrefsApp.getIdentityCollection();
    }

	// Find target first.
	var target;
	if (cmd == "compose" || cmd == "composeDetach") {
		target = "compose-window";
	} else if (cmd == "msgViewDetach") {
		target = "view-window";
	}

	ZmZimbraMail.prototype._registerOrganizers.call(this);
	ZmZimbraMail.registerViewsToTypeMap();

    
	// setup zimlets, Load it first becoz.. zimlets has to get processed first.
	if (target) {
		var allzimlets = parentAppCtxt.get(ZmSetting.ZIMLETS);
		allzimlets = allzimlets || [];
		var zimletArray = this._settings._getCheckedZimlets(allzimlets);
		if (this._hasZimletsForTarget(zimletArray, target)) {
			var zimletMgr = appCtxt.getZimletMgr();
			var userProps = this._getUserProps();
			var createViewCallback =  new AjxCallback(this, this._createView);
            appCtxt.setZimletsPresent(true);
			zimletMgr.loadZimlets(zimletArray, userProps, target, createViewCallback, true);
			return;
		}
	}

	this._createView();
};

/**
 * @private
 */
ZmNewWindow.prototype._checkShareType =
function(share, type) {
    return share && share.link && (type === share.link.view);
};
ZmNewWindow.prototype._createView =
function() {

	var cmd = window.newWindowCommand;
	var params = window.newWindowParams;

	var rootTg = appCtxt.getRootTabGroup();
	var startupFocusItem;

	//I null composeCtlrSessionId so it's not kept from irrelevant sessions from parent window.
	// (since I set it in every compose session, in ZmMailApp.prototype.compose).
	// This is important in case of cmd == "msgViewDetach"
	appCtxt.composeCtlrSessionId = null;  
	// depending on the command, do the right thing
	if (cmd == "compose" || cmd == "composeDetach") {
		var cc = AjxDispatcher.run("GetComposeController");	// get a new compose ctlr
		appCtxt.composeCtlrSessionId = cc.getSessionId();
		if (params.action == ZmOperation.REPLY_ALL) {
			params.msg = this._deepCopyMsg(params.msg);
		}
		if (cmd == "compose") {
			cc._setView(params);
		} else {
			AjxDispatcher.require(["MailCore", "ContactsCore", "CalendarCore"]);
			var op = params.action || ZmOperation.NEW_MESSAGE;
			if (params.msg && params.msg._mode) {
				switch (params.msg._mode) {
					case ZmAppt.MODE_DELETE:
					case ZmAppt.MODE_DELETE_INSTANCE:
					case ZmAppt.MODE_DELETE_SERIES: {
						op = ZmOperation.REPLY_CANCEL;
						break;
					}
				}
			}
			params.action = op;
			cc._setView(params);
			cc._composeView.setDetach(params);

			// bug fix #5887 - get the parent window's compose controller based on its session ID
			var parentCC = window.parentController.getApp(ZmApp.MAIL).getComposeController(params.sessionId);
			if (parentCC && parentCC._composeView) {
				// once everything is set in child window, pop parent window's compose view
				parentCC._composeView.reset(true);
				parentCC._app.popView(true);
			}
		}
		cc._setComposeTabGroup();
		rootTg.addMember(cc.getTabGroup());
		startupFocusItem = cc._getDefaultFocusItem();

		target = "compose-window";
	} else if (cmd == "msgViewDetach") {
		//bug 52366 - not sure why only REPLY_ALL causes the problem (and not REPLY for example), but in this case the window is opened first for view. But
		//the user might of course click "reply to all" later in the window so I deep copy here in any case.
		var msg = this._deepCopyMsg(params.msg);
		msg.isRfc822 = params.isRfc822; //simpler
		params.msg.addChangeListener(msg.detachedChangeListener.bind(msg));

		var msgController = AjxDispatcher.run("GetMsgController");
		appCtxt.msgCtlrSessionId = msgController.getSessionId();
		msgController.show(msg, params.parentController);
		rootTg.addMember(msgController.getTabGroup());
		startupFocusItem = msgController.getCurrentView();

		target = "view-window";
	} else if (cmd == 'documentEdit') {
		AjxDispatcher.require(["Docs"]);
 		ZmDocsEditApp.setFile(params.id, params.name, params.folderId);
		ZmDocsEditApp.restUrl = params.restUrl;
		new ZmDocsEditApp();
		if (params.name) {
			Dwt.setTitle(params.name);
		}
	} else if (cmd == "shortcuts") {
		var panel = appCtxt.getShortcutsPanel();
		panel.popup(params.cols);
	}

	if (this._appViewMgr.loadingView) {
		this._appViewMgr.loadingView.setVisible(false);
	}

	this._kbMgr.setTabGroup(rootTg);
	this._kbMgr.grabFocus(startupFocusItem);
};

/**
 * HACK: This should go away once we have a cleaner server solution that
 *       allows us to get just those zimlets for the specified target.
 *       
 * @private
 */
ZmNewWindow.prototype._hasZimletsForTarget =
function(zimletArray, target) {
	var targetRe = new RegExp("\\b"+target+"\\b");
	for (var i=0; i < zimletArray.length; i++) {
		var zimletObj = zimletArray[i];
		var zimlet0 = zimletObj.zimlet[0];
		if (targetRe.test(zimlet0.target || "main")) {
			return true;
		}
	}
	return false;
};

/**
 * @private
 */
ZmNewWindow.prototype._getUserProps =
function() {
	var userPropsArray = parentAppCtxt.get(ZmSetting.USER_PROPS);

	// default to original user props
	userPropsArray = userPropsArray ? [].concat(userPropsArray) : [];

	// current user props take precedence, if available
	var zimletHash = parentAppCtxt.getZimletMgr().getZimletsHash();
	var zimletArray = parentAppCtxt.get(ZmSetting.ZIMLETS);
	for (var i = 0; i < zimletArray.length; i++) {
		var zname = zimletArray[i].zimlet[0].name;
		var zimlet = zimletHash[zname];
		if (!zimlet || !zimlet.userProperties) continue;
		for (var j = 0; j < zimlet.userProperties.length; j++) {
			var userProp = zimlet.userProperties[j];
			var userPropObj = { zimlet: zname, name: userProp.name, _content: userProp.value };
			userPropsArray.push(userPropObj);
		}
	}

	// return user properties
	return userPropsArray;
};

/**
 * Cancels the request.
 * 
 * @param	{String}	reqId		the request id
 * @param	{AjxCallback}	errorCallback		the callback
 * @param	{Boolean}	noBusyOverlay	if <code>true</code>, do not show a busy overlay
 */
ZmNewWindow.prototype.cancelRequest =
function(reqId, errorCallback, noBusyOverlay) {
	return window.parentController ? window.parentController.cancelRequest(reqId, errorCallback, noBusyOverlay) : null;
};

/**
 * Sends the server requests to the main controller.
 * 
 * @param	{Hash}	params		a hash of parameters
 */
ZmNewWindow.prototype.sendRequest =
function(params) {
    // reset onbeforeunload on send
    window.onbeforeunload = null;
	// bypass error callback to get control over exceptions in the childwindow.
	params.errorCallback = new AjxCallback(this, this._handleException, [( params.errorCallback || null )]);
	params.fromChildWindow = true;
	return window.parentController ? window.parentController.sendRequest(params) : null;
};

/**
 * @private
 */
ZmNewWindow.prototype._handleException =
function(errCallback, ex) {
	var handled = false;
	if (errCallback) {
		handled = errCallback.run(ex);
	}
	if (!handled) {
		ZmController.prototype._handleException.apply(this, [ex]);
	}
	return true;
};

/**
 * Popup the error dialog.
 * 
 * @param	{String}	msg		the message
 * @param	{AjxException}	ex	the exception
 * @param	{Boolean}	noExecReset
 * @param	{Boolean}	hideReportButton
 */
ZmNewWindow.prototype.popupErrorDialog =
function(msg, ex, noExecReset, hideReportButton)  {
	// Since ex is from parent window, all the types seems like objects, so need
	// to filter the functions
	var detailStr;
	if (ex instanceof Object || typeof ex == "object") {
		var details = [];
		ex.msg = ex.msg || msg;
		for (var prop in ex) {
			if (typeof ex[prop] == "function" ||
				(typeof ex[prop] == "object" && ex[prop].apply && ex[prop].call))
			{
				continue;
			}
			details.push([prop, ": ", ex[prop], "<br/>\n"].join(""));
		}
		detailStr = details.join("");
	}
	ZmController.prototype.popupErrorDialog.call(this, msg, ( detailStr || ex ), noExecReset, hideReportButton);
};

/**
 * Set status messages via the main controller, so they show up in the client's status area.
 * 
 * @param	{Hash}	params		a hash of parameters
 */
ZmNewWindow.prototype.setStatusMsg =
function(params) {
	// bug: 26478. Changed status msg to be displayed within the child window.
	params = Dwt.getParams(arguments, ZmStatusView.MSG_PARAMS);
	this._statusView.setStatusMsg(params);
};

/**
 * Gets a handle to the given app.
 *
 * @param {String}	appName		the app name
 * @return	{ZmApp}		the application
 */
ZmNewWindow.prototype.getApp =
function(appName) {
	if (!this._apps[appName]) {
		this._createApp(appName);
	}
	return this._apps[appName];
};

/**
 * Gets a handle to the app view manager.
 * 
 * @return	{ZmAppViewMgr}	the view manager
 */
ZmNewWindow.prototype.getAppViewMgr =
function() {
	return this._appViewMgr;
};

// App view mgr calls this, we don't need it to do anything.
ZmNewWindow.prototype.setActiveApp = function() {};

/**
 * Gets the key map manager.
 * 
 * @return	{DwtKeyMapMgr}	the key map manager
 */
ZmNewWindow.prototype.getKeyMapMgr =
function() {
	return this._kbMgr.__keyMapMgr;
};

/**
 * Gets the key map name.
 * 
 * @return	{String}	the key map name
 */
ZmNewWindow.prototype.getKeyMapName =
function() {
	var ctlr = appCtxt.getCurrentController();
	if (ctlr && ctlr.getKeyMapName) {
		return ctlr.getKeyMapName();
	}
	return ZmKeyMap.MAP_GLOBAL;
};

/**
 * Handles the key action.
 * 
 * @param	{Object}	actionCode		the action code
 * @param	{Object}	ev		the event
 * @return	{Boolean}	<code>true</code> if the action is handled
 */
ZmNewWindow.prototype.handleKeyAction = function(actionCode, ev) {

    // Ignore global shortcuts since they don't make sense in a child window
    if (ZmApp.GOTO_ACTION_CODE_R[actionCode]) {
        return false;
    }
    switch (actionCode) {
        case ZmKeyMap.QUICK_REMINDER:
        case ZmKeyMap.FOCUS_SEARCH_BOX:
        case ZmKeyMap.FOCUS_CONTENT_PANE:
        case ZmKeyMap.FOCUS_TOOLBAR:
        case ZmKeyMap.SHORTCUTS:
            return false;
    }

    // Hand shortcut to current controller
	var ctlr = appCtxt.getCurrentController();
	if (ctlr && ctlr.handleKeyAction) {
		return ctlr.handleKeyAction(actionCode, ev);
	}

	return false;
};


// Private methods

/**
 * Instantiates enabled apps. An optional argument may be given limiting the set
 * of apps that may be created.
 *
 * @param {Hash}	apps	the set of apps to create
 * 
 * @private
 */
ZmNewWindow.prototype._createEnabledApps =
function(apps) {
	for (var app in ZmApp.CLASS) {
		if (!apps || apps[app]) {
			ZmApp.APPS.push(app);
		}
	}
	ZmApp.APPS.sort(function(a, b) {
		return ZmZimbraMail.hashSortCompare(ZmApp.LOAD_SORT, a, b);
	});

	// instantiate enabled apps - this will invoke app registration
	for (var i = 0; i < ZmApp.APPS.length; i++) {
		var app = ZmApp.APPS[i];
		if (app != ZmApp.IM) { // Don't create im app. Seems like the safest way to avoid ever logging in.
			var setting = ZmApp.SETTING[app];
			if (!setting || appCtxt.get(setting)) {
				this._createApp(app);
			}
		}
	}
};

/**
 * Creates an app object, which doesn't necessarily do anything just yet.
 * 
 * @private
 */
ZmNewWindow.prototype._createApp =
function(appName) {
	if (this._apps[appName]) return;
	var appClass = eval(ZmApp.CLASS[appName]);
	this._apps[appName] = appClass && new appClass(this._shell, window.parentController);
};

/**
 * @private
 * TODO: get rid of this function
 */
ZmNewWindow.prototype._deepCopyMsg =
function(msg) {
	// initialize new ZmSearch if applicable
	var newSearch = null;
	var oldSearch = msg.list.search;

	if (oldSearch) {
		newSearch = new ZmSearch();

		for (var i in oldSearch) {
			if ((typeof oldSearch[i] == "object") || (typeof oldSearch[i] == "function")) { continue; }
			newSearch[i] = oldSearch[i];
		}

		// manually add objects since they are no longer recognizable
		newSearch.types = new AjxVector();
		var types = oldSearch.types.getArray();
		for (var i = 0;  i < types.length; i++) {
			newSearch.types.add(types[i]);
		}
	}

	// initialize new ZmMailList
	var newMailList = new ZmMailList(msg.list.type, newSearch);
	for (var i in msg.list) {
		if ((typeof msg.list[i] == "object") || (typeof msg.list[i] == "function")) { continue; }
		newMailList[i] = msg.list[i];
	}

	// finally, initialize new ZmMailMsg
	var newMsg = new ZmMailMsg(msg.id, newMailList);

	for (var i in msg) {
		if ((typeof msg[i] == "object") || (typeof msg[i] == "function")) { continue; }
		newMsg[i] = msg[i];
	}

	// manually add any objects since they are no longer recognizable
	for (var i in msg._addrs) {
		var addrs = msg._addrs[i].getArray();
		for (var j = 0; j < addrs.length; j++) {
			newMsg._addrs[i].add(addrs[j]);
		}
	}

	if (msg.attachments && msg.attachments.length > 0) {
		for (var i = 0; i < msg.attachments.length; i++) {
			newMsg.attachments.push(msg.attachments[i]);
		}
	}

	for (var i = 0; i < msg._bodyParts.length; i++) {
		newMsg._bodyParts.push(msg._bodyParts[i]);
	}
	
	for (var ct in msg._contentType) {
		newMsg._contentType[ct] = true;
	}

	if (msg._topPart) {
		newMsg._topPart = new ZmMimePart();
		for (var i in msg._topPart) {
			if ((typeof msg._topPart[i] == "object") || (typeof msg._topPart[i] == "function"))
				continue;
			newMsg._topPart[i] = msg._topPart[i];
		}
		var children = msg._topPart.children.getArray();
		for (var i = 0; i < children.length; i++) {
			newMsg._topPart.children.add(children[i]);
		}
	}

	if (msg.invite) {
		newMsg.invite = msg.invite;
	}

	if (msg.share) {
		newMsg.share = msg.share;
	}

	newMsg.subscribeReq = msg.subscribeReq;

	// TODO: When/if you get rid of this function, also remove the cloneOf uses in:
	//		ZmBaseController.prototype._doTag
	//		ZmBaseController.prototype._setTagMenu
	//		ZmMailMsgView.prototype._setTags
	//		ZmMailMsgView.prototype._handleResponseSet
	//		ZmMailListController.prototype._handleResponseFilterListener
	//		ZmMailListController.prototype._handleResponseNewApptListener
	//		ZmMailListController.prototype._handleResponseNewTaskListener
	newMsg.cloneOf = msg;

	return newMsg;
};


// Static Methods

/**
 * @private
 */
ZmNewWindow._confirmExitMethod = function(ev) {

	if (!appCtxt.get(ZmSetting.WARN_ON_EXIT) || !window.parentController) {
		return;
    }

	var cmd = window.newWindowCommand;

	if (cmd === "compose" || cmd === "composeDetach")	{
		var cc = AjxDispatcher.run("GetComposeController", appCtxt.composeCtlrSessionId),
            cv = cc && cc._composeView,
            viewId = cc.getCurrentViewId(),
            avm = appCtxt.getAppViewMgr();

		// only show native confirmation dialog if compose view is dirty
		if (cv && avm.isVisible(viewId) && cv.isDirty()) {
			return ZmMsg.newWinComposeExit;
		}
	} else if (cmd == 'documentEdit') {
		var ctrl = ZmDocsEditApp._controller;
		var msg = ctrl.checkForChanges();
		return msg || ctrl.exit();
	}
};
}
if (AjxPackage.define("zimbraMail.core.ZmToolTipMgr")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a tooltip manager.
 * @constructor
 * @class
 * This singleton class manages tooltip content generation and retrieval. Tooltips are
 * broken down by type based on what they show (for example information about
 * a person). Each type has a handler, which gets passed the appropriate data
 * and generates the tooltip content.
 *
 * @author Conrad Damon
 * 
 * @param {DwtComposite}	container	the containing shell
 * @param {ZmMailApp}		mailApp		the containing app
 */

ZmToolTipMgr = function() {
	this._registry = {};
	this.registerToolTipHandler(ZmToolTipMgr.PERSON, this.getPersonToolTip);
};

ZmToolTipMgr.PERSON = "PERSON";

/**
 * Associates a type of tooltip with a function to generate its content.
 * 
 * @param {constant}	type		type of tooltip
 * @param {function}	handler		function that returns tooltip content
 */
ZmToolTipMgr.prototype.registerToolTipHandler =
function(type, handler) {
	this._registry[type] = handler;
};

/**
 * Returns tooltip content for the given type with the given data.
 * 
 * @param {constant}	type		type of tooltip
 * @param {hash}		params		arbitrary data to pass to tooltip function
 * @param {AjxCallback}	callback	callback to run with results (optional)
 */
ZmToolTipMgr.prototype.getToolTip =
function(type, params, callback) {
	var handler = this._registry[type];
	if (handler && AjxUtil.isFunction(handler)) {
		return handler.apply(this, [params, callback]);
	}
};

/**
 * Returns tooltip content for a person based on an email address or contact.
 * 
 * @param {hash}					params			hash of params:
 * @param {string|AjxEmailAddress}	address			email address
 * @param {ZmContact}				contact			contact - need either address or contact
 * @param {DwtMouseEvent}			ev				mouseover event
 * @param {boolean}					noRightClick	if true, don't show right click hint
 * @param {AjxCallback}				callback		callback to run with results (optional)
 */
ZmToolTipMgr.prototype.getPersonToolTip =
function(params, callback) {

	if (!(params && (params.address || params.contact))) { return ""; }

	var contact = params.contact;
	var address = params.address || contact.getEmail();
	if (!address.isAjxEmailAddress) {
		address = new AjxEmailAddress(address);
	}
	
	if (appCtxt.notifyZimlets("onHoverOverEmailInList", [address, params.ev, params.noRightClick])) {
		// Zimlet framework is handling the tooltip
		return "";
	}
	
	var contactsApp = appCtxt.get(ZmSetting.CONTACTS_ENABLED) && appCtxt.getApp(ZmApp.CONTACTS);
	if (!contact && !contactsApp) { return ""; }

	var addr = address.getAddress();

	if (callback) {
		if (contact) {
			this._handleResponseGetContact(address, callback, contact);
		}
		else {
			var respCallback = new AjxCallback(this, this._handleResponseGetContact, [address, callback]);
			contactsApp.getContactByEmail(addr, respCallback);
		}
	} else {
		contact = contact || contactsApp.getContactByEmail(addr);
		return this._handleResponseGetContact(address, null, contact);
	}
};
		
ZmToolTipMgr.prototype._handleResponseGetContact =
function(address, callback, contact) {

	if (!address && !contact) { return ""; }
	
	var tooltip;
	if (contact) {
		tooltip = contact.getToolTip(address.getAddress());
	} else {
		tooltip = AjxTemplate.expand("abook.Contacts#TooltipNotInAddrBook", {addrstr:address.toString()});
	}

	if (callback) {
		callback.run(tooltip);
	} else {
		return tooltip;
	}
};
}

if (AjxPackage.define("zimbraMail.prefs.model.ZmPref")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmPref = function(id, name, dataType) {

	ZmSetting.call(this, id, name, ZmSetting.T_PREF, dataType);

	this.origValue = null;
	this.isDirty = false;
};

ZmPref.prototype = new ZmSetting;
ZmPref.prototype.constructor = ZmPref;

ZmPref.prototype.isZmPref = true;
ZmPref.prototype.toString = function() { return "ZmPref"; };

ZmPref.KEY_ID				= "prefId_";

ZmPref.TYPE_STATIC			= "STATIC"; // static text
ZmPref.TYPE_INPUT			= "INPUT";
ZmPref.TYPE_CHECKBOX		= "CHECKBOX";
ZmPref.TYPE_COLOR			= "COLOR";
ZmPref.TYPE_RADIO_GROUP		= "RADIO_GROUP";
ZmPref.TYPE_SELECT			= "SELECT";
ZmPref.TYPE_COMBOBOX		= "COMBOBOX";
ZmPref.TYPE_TEXTAREA		= "TEXTAREA";
ZmPref.TYPE_PASSWORD		= "PASSWORD";
ZmPref.TYPE_IMPORT			= "IMPORT";
ZmPref.TYPE_EXPORT			= "EXPORT";
ZmPref.TYPE_SHORTCUTS		= "SHORTCUTS";
ZmPref.TYPE_CUSTOM			= "CUSTOM";
ZmPref.TYPE_LOCALES			= "LOCALES";
ZmPref.TYPE_FONT			= "FONT";
ZmPref.TYPE_FONT_SIZE		= "FONT_SIZE";

ZmPref.ORIENT_VERTICAL		= "vertical";
ZmPref.ORIENT_HORIZONTAL	= "horizontal";

ZmPref.MAX_ROWS	= 7;

// custom functions for loading and validation

ZmPref.loadSkins =
function(setup) {
	var skins = appCtxt.get(ZmSetting.AVAILABLE_SKINS);
	setup.options = []; // re-init otherwise we could possibly have dupes.
	for (var i = 0; i < skins.length; i++) {
		var skin = skins[i];
		setup.options.push(skin);
		var text = ZmMsg['theme-' + skin] || skin.substr(0, 1).toUpperCase() + skin.substr(1);
		setup.displayOptions.push(text);
	}
};

ZmPref.loadCsvFormats =
function(setup){
    var formats = appCtxt.get(ZmSetting.AVAILABLE_CSVFORMATS);
	if (!formats._options) {
		var options = formats._options = [];
		var displayOptions = formats._displayOptions = [];
		for(var i=0; i<formats.length; i++){
			options.push(formats[i]);
		}
		options.sort(ZmPref.__BY_CSVFORMAT);
		for(var i=0; i < options.length; i++){
			displayOptions.push((ZmMsg[options[i]] || options[i]));
		}
	}
	setup.options = formats._options;
	setup.displayOptions = formats._displayOptions;
};
ZmPref.__BY_CSVFORMAT = function(a, b) {
	if (a.match(/^zimbra/)) return -1;
	if (b.match(/^zimbra/)) return  1;
	if (a.match(/^yahoo/))  return -1;
	if (b.match(/^yahoo/))  return  1;
	return a.localeCompare(b);
};

ZmPref.loadPageSizes =
function(setup) {
	var max = (setup.maxSetting && appCtxt.get(setup.maxSetting)) || 100;
	var list = [];
	for (var i = 0; i < ZmPref.PAGE_SIZES.length; i++) {
		var num = parseInt(ZmPref.PAGE_SIZES[i]);
		if (num <= max) {
			list.push(ZmPref.PAGE_SIZES[i]);
		}
	}
	if (max > ZmPref.PAGE_SIZES[ZmPref.PAGE_SIZES.length - 1]) {
		list.push(String(max));
	}
	setup.displayOptions = setup.options = list;
};
ZmPref.PAGE_SIZES = ["10", "25", "50", "100", "250", "500", "1000"];

ZmPref.validateEmail =
function(emailStr) {
	if (emailStr) {
		// NOTE: Handle localhost for development purposes
		return emailStr.match(/\@localhost$/i) || AjxEmailAddress.parse(emailStr) != null;
	}
	return true;
};

ZmPref.validateEmailList =
function(emailStrArray) {
    for(var i in emailStrArray) {
        if(!ZmPref.validateEmail(emailStrArray[i])) return false;
    }
    return true;
};

ZmPref.downloadSinceDisplay =
function(dateStr) {
	if (!dateStr) { //usually it's "" in this case, but !dateStr would take care of 0 too (which is ZmMailApp.POP_DOWNLOAD_SINCE_ALL too) so changed it to !dateStr
		return ZmMailApp.POP_DOWNLOAD_SINCE_ALL;
	}
	if (dateStr === appCtxt.get(ZmSetting.POP_DOWNLOAD_SINCE)) {
		return ZmMailApp.POP_DOWNLOAD_SINCE_NO_CHANGE;
	}
	return ZmMailApp.POP_DOWNLOAD_SINCE_FROM_NOW;
};
ZmPref.downloadSinceValue =
function(value) {
	// == instead of === since the value is a string ("0") instead of a number (0) for some reason.
	if (value == ZmMailApp.POP_DOWNLOAD_SINCE_ALL) {
		return "";
	}
	if (value == ZmMailApp.POP_DOWNLOAD_SINCE_NO_CHANGE) {
		return appCtxt.get(ZmSetting.POP_DOWNLOAD_SINCE);
	}
	var date = new Date();
	date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
	return AjxDateFormat.format("yyyyMMddHHmmss'Z'", date);
};

ZmPref.validatePollingInterval =
function(interval) {
	var minimum = appCtxt.get(ZmSetting.MIN_POLLING_INTERVAL);
	if (interval && (!minimum || interval >= minimum)) {
		return true;
	} else {
		var min = minimum / 60;
		ZmPref.SETUP[ZmSetting.POLLING_INTERVAL].errorMessage = AjxMessageFormat.format(ZmMsg.invalidPollingInterval, min);
		return false;
	}
};

ZmPref.pollingIntervalDisplay =
function(seconds) {
    if (appCtxt.get(ZmSetting.INSTANT_NOTIFY) && seconds == appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL))
        return seconds;
    else
	    return seconds / 60;
};

ZmPref.pollingIntervalValue =
function(minutes) {
    if (appCtxt.get(ZmSetting.INSTANT_NOTIFY) && minutes == appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL))
        return minutes;
    else
	    return minutes * 60;
};


ZmPref.int2DurationDay =
function(intValue) {
	return intValue != null && intValue != 0 ? intValue + "d" : intValue;
};

ZmPref.string2EmailList =
function(value) {
    var emailList = [];
    var addr,addrs = AjxEmailAddress.split(value);
    if (addrs && addrs.length) {
        for (var i = 0; i < addrs.length; i++) {
            addr = addrs[i];
            var email = AjxEmailAddress.parse(addr);
            if(email) {
                addr = email.getAddress();
            }
            if(addr) emailList.push(AjxStringUtil.htmlEncode(addr));
        }
    }
	return emailList;
};

ZmPref.durationDay2Int =
function(durValue) {
	return parseInt(durValue, 10); // NOTE: parseInt ignores non-digits
};

ZmPref.approximateInterval =
function(value) {
	var values = [].concat(ZmPref.SETUP["POLLING_INTERVAL"].options);
	values.sort(ZmPref.__BY_NUMBER);
	return ZmPref.approximateValue(values, value);
};

ZmPref.approximateValue =
function(sortedValues, value) {
	// find closest value
	for (var i = 0; i < sortedValues.length + 1; i++) {
		var a = sortedValues[i];
		var b = sortedValues[i+1];
		if (value < b) {
			var da = value - a;
			var db = b - value;
			return da < db ? a : b;
		}
	}
	return sortedValues[sortedValues.length - 1];
};

ZmPref.validateLifetime =
function(value) {
	var globalValue = appCtxt.get(ZmSetting.MAIL_LIFETIME_GLOBAL);
	if (globalValue == "0") return true;
	return ZmPref.__BY_DURATION(value, globalValue) <= 0;
};

ZmPref.validateLifetimeJunk =
function(value) {
	var globalValue = appCtxt.get(ZmSetting.MAIL_LIFETIME_JUNK_GLOBAL);
	if (globalValue == "0") return true;
	return ZmPref.__BY_DURATION(value, globalValue) <= 0 && ZmPref.validateLifetime(value);
};

ZmPref.validateLifetimeTrash =
function(value) {
	var globalValue = appCtxt.get(ZmSetting.MAIL_LIFETIME_TRASH_GLOBAL);
	if (globalValue == "0") return true;
	return ZmPref.__BY_DURATION(value, globalValue) <= 0 && ZmPref.validateLifetime(value);
};

ZmPref.approximateLifetimeInboxRead =
function(value) {
	return ZmPref.approximateLifetime("MAIL_LIFETIME_INBOX_READ", value, ZmPref.validateLifetime);
};

ZmPref.approximateLifetimeInboxUnread =
function(value) {
	return ZmPref.approximateLifetime("MAIL_LIFETIME_INBOX_UNREAD", value, ZmPref.validateLifetime);
};

ZmPref.approximateLifetimeJunk =
function(value) {
	return ZmPref.approximateLifetime("MAIL_LIFETIME_JUNK", value, ZmPref.validateLifetimeJunk, ZmPref.validateLifetime);
};

ZmPref.approximateLifetimeSent =
function(value) {
	return ZmPref.approximateLifetime("MAIL_LIFETIME_SENT", value, ZmPref.validateLifetime);
};

ZmPref.approximateLifetimeTrash =
function(value) {
	return ZmPref.approximateLifetime("MAIL_LIFETIME_TRASH", value, ZmPref.validateLifetimeTrash, ZmPref.validateLifetime);
};

ZmPref.approximateLifetime =
function(prefId, duration, validateFunc1/*, ..., validateFuncN*/) {
	// convert durations to seconds
	var values = [].concat(ZmPref.SETUP[prefId].options);
	for (var i = 0; i < values.length; i++) {
		var value = values[i];
		values[i] = ZmPref.__DUR2SECS(value != "0" ? value+"d" : value);
	}
	values.sort(ZmPref.__BY_NUMBER);

	// remove invalid options
	valuesLoop: for (var i = values.length - 1; i >= 0; i--) {
		for (var j = 2; j < arguments.length; j++) {
			var validateFunc = arguments[j];
			var value = ZmPref.__SECS2DUR(values[i]);
			if (!validateFunc(value)) {
				values.pop();
				continue valuesLoop;
			}
		}
		break;
	}

	// if zero, the closest match is the greatest
	var seconds;
	if (duration == "0") {
		seconds = values[values.length - 1];
	}

	// approximate to closest number of seconds
	else {
		seconds = ZmPref.approximateValue(values, ZmPref.__DUR2SECS(duration+"d"));
	}

	// convert back to duration
	duration = ZmPref.__SECS2DUR(seconds);
	return duration != "0"  ? parseInt(duration, 10) : 0;
};

ZmPref.markMsgReadDisplay =
function(value) {
	return (value > 0) ? 1 : value;
};

ZmPref.markMsgReadValue =
function(value) {
	if (value == ZmSetting.MARK_READ_TIME) {
		var inputId = DwtId.makeId(ZmId.WIDGET_INPUT, ZmId.OP_MARK_READ);
		var input = DwtControl.fromElementId(inputId);
		if (input) {
			return input.getValue() || ZmSetting.MARK_READ_NOW;
		}
	}
	return value;
};

ZmPref.setFormValue =
function(pref, value) {
	var app = appCtxt.getApp(ZmApp.PREFERENCES);
	var section = ZmPref.getPrefSectionWithPref(pref);
	if (app && section) {
		var page = app.getPreferencesPage(section.id);
		if (page) page.setFormValue(pref, value);
	}
};

ZmPref.getFormValue =
function(pref) {
	var app = appCtxt.getApp(ZmApp.PREFERENCES);
	var section = ZmPref.getPrefSectionWithPref(pref);
	if (app && section) {
		var page = app.getPreferencesPage(section.id);
		if (page) return page.getFormValue(pref);
	}
};

ZmPref.setIncludeOrig =
function(pref, value, list) {

	pref.setValue(value);
    pref.origValue = pref.copyValue();
	var settings = [ZmSetting.REPLY_INCLUDE_WHAT, ZmSetting.REPLY_USE_PREFIX, ZmSetting.REPLY_INCLUDE_HEADERS];
	var settingsHash = AjxUtil.arrayAsHash(settings);
	var mainSetting = ZmSetting.REPLY_INCLUDE_ORIG;
	if (!settingsHash[pref.id]) {
		settings = [ZmSetting.FORWARD_INCLUDE_WHAT, ZmSetting.FORWARD_USE_PREFIX, ZmSetting.FORWARD_INCLUDE_HEADERS];
		mainSetting = ZmSetting.FORWARD_INCLUDE_ORIG;
	}

	var values = AjxUtil.map(settings, function(setting) { return appCtxt.get(setting); });
	var key = (values[0] == ZmSetting.INC_NONE || values[0] == ZmSetting.INC_ATTACH) ? values[0] : values.join("|");
	var newValue = ZmMailApp.INC_MAP_REV[key];
	var prefToChange = appCtxt.getSettings().getSetting(mainSetting);
	prefToChange.setValue(newValue);
	list.push(prefToChange);
};

ZmPref.addOOOVacationExternalPrefToList = function(list, aPrefName, aNewPrefValue){
    var lastPrefValue = appCtxt.get(aPrefName);     // prefvalue before saving ..
    if (lastPrefValue !== aNewPrefValue) {          // donot add pref to list if pref value is not changed
        prefToAdd = appCtxt.getSettings().getSetting(aPrefName);
        prefToAdd.setValue(aNewPrefValue);
        list.push(prefToAdd);
    }
};

/**
 * On saving, for OOO vacation external reply, depending upon the option that the user has chosen in
 * external select dropdown, we add the relevant pref that maps to the selected option in dropdown to the list that constructs the request.
 */
ZmPref.addOOOVacationExternalPrefOnSave = function(pref, value, list, viewPage) {

    var externalSelect,
        selectedText;

    ZmPref.addOOOVacationExternalPrefToList(list, ZmSetting.VACATION_EXTERNAL_SUPPRESS, value);
    externalSelect = viewPage.getFormObject(ZmSetting.VACATION_EXTERNAL_SUPPRESS);
    selectedText = externalSelect.getText();

    if (selectedText.indexOf(ZmMsg.vacationExternalReplySuppress) === -1) { //In external select, first three options are selected .
        if (selectedText === ZmMsg.vacationExternalAllStandard) { //first  option is selected ..
            ZmPref.addOOOVacationExternalPrefToList(list, ZmSetting.VACATION_EXTERNAL_MSG_ENABLED, false);
            return;
        }
        if (selectedText === ZmMsg.vacationExternalAllCustom) { //second option ALL is selected ..
            ZmPref.addOOOVacationExternalPrefToList(list, ZmSetting.VACATION_EXTERNAL_TYPE, 'ALL');
        }
        if (selectedText === ZmMsg.vacationExternalAllExceptABCustom) { //third option ALLNOTINAB is selected ..
            ZmPref.addOOOVacationExternalPrefToList(list, ZmSetting.VACATION_EXTERNAL_TYPE, 'ALLNOTINAB');
        }
        ZmPref.addOOOVacationExternalPrefToList(list, ZmSetting.VACATION_EXTERNAL_MSG_ENABLED, true);
    }
};

/* For OOO section, this method is called only for the first time after reloading .
   When OOO section loads, depending upon which OOO external select option the user has earlier saved in preferences,
   we show the relevant OOO vacation external select option, and make the external text area hide /show correspondingly.
   We get the value of OOO vacation external pref from appCtxt and then proceed.
 */
ZmPref.initOOOVacationExternalSuppress = function() {
    var section = ZmPref.getPrefSectionWithPref(ZmSetting.VACATION_EXTERNAL_MSG);
    var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView().getView(section.id);
    var externalTextArea  = view.getFormObject(ZmSetting.VACATION_EXTERNAL_MSG);
    var externalSelect =  view.getFormObject(ZmSetting.VACATION_EXTERNAL_SUPPRESS);
    if(appCtxt.get(ZmSetting.VACATION_EXTERNAL_SUPPRESS)){ // when last option is saved in preferences
        externalTextArea.setVisible(false);
        return;
    }
    if(!appCtxt.get(ZmSetting.VACATION_EXTERNAL_MSG_ENABLED)){ // handle when 1st option is selected
        externalSelect.setSelected(0);
        externalTextArea.setVisible(false);
        return;
    }
    var stringToOptionValue = {
        'ALL' : 1,
        'ALLNOTINAB' : 2
    };
    externalSelect.setSelected(stringToOptionValue[appCtxt.get(ZmSetting.VACATION_EXTERNAL_TYPE)]);
};

ZmPref.initIncludeWhat =
function(select, value) {
	// wait until prefix/headers checkboxes have been created
	AjxTimedAction.scheduleAction(new AjxTimedAction(this, function() {
		ZmPref._showIncludeOptions(select, (value == ZmSetting.INC_BODY || value == ZmSetting.INC_SMART));
	}), 100);
};

ZmPref.onChangeIncludeWhat =
function(ev) {
	var nv = ev._args.newValue;
	var ov = ev._args.oldValue;
	var newAllowOptions = (nv == ZmSetting.INC_BODY || nv == ZmSetting.INC_SMART);
	var oldAllowOptions = (ov == ZmSetting.INC_BODY || ov == ZmSetting.INC_SMART);
	if (newAllowOptions != oldAllowOptions) {
		ZmPref._showIncludeOptions(ev._args.selectObj, newAllowOptions);
	}
};

ZmPref._showIncludeOptions =
function(select, show) {
	var optionIds = (select._name == ZmSetting.REPLY_INCLUDE_WHAT) ?
						[ZmSetting.REPLY_USE_PREFIX, ZmSetting.REPLY_INCLUDE_HEADERS] :
						[ZmSetting.FORWARD_USE_PREFIX, ZmSetting.FORWARD_INCLUDE_HEADERS];
	for (var i = 0; i < optionIds.length; i++) {
		var cbox = select.parent._dwtObjects[optionIds[i]];
		if (cbox) {
			cbox.setVisible(show);
		}
	}
};

ZmPref.getSendToFiltersActive =
function(ev, callback) {
	if (ev.target.checked) {
		if (callback)
			callback.run(false);
		return false;
	}
	AjxDispatcher.run("GetFilterController").hasOutgoingFiltersActive(callback);
};

ZmPref.onChangeConfirm =
function(confirmMsg, showIfCallback, useCallback, revertCallback, ev) {
	var show = false;
	var callback = useCallback ? new AjxCallback(this, ZmPref._showOnChangeConfirm, [confirmMsg, revertCallback]) : null;
	if (AjxUtil.isFunction(showIfCallback))
		show = showIfCallback(ev, callback);
	else if (AjxUtil.isInstance(showIfCallback, AjxCallback))
		show = showIfCallback.run(ev, callback);
	else
		show = showIfCallback;
	ZmPref._showOnChangeConfirm(confirmMsg, revertCallback, show);
};

ZmPref._showOnChangeConfirm =
function(confirmMsg, revertCallback, show) {
	if (show) {
		if (show) {
			var dialog = appCtxt.getYesNoMsgDialog();
			dialog.reset();
			dialog.setMessage(confirmMsg);
			dialog.setButtonListener(DwtDialog.NO_BUTTON, new AjxListener(null, ZmPref._handleOnChangeConfirmNo, [revertCallback]));
			dialog.popup();
		}
	}
};

ZmPref._handleOnChangeConfirmNo =
function(revertCallback) {
	if (revertCallback)
		revertCallback.run();
	appCtxt.getYesNoMsgDialog().popdown();
};

// Comparators

ZmPref.__BY_NUMBER =
function(a, b) {
	if (a == b) return 0;
	if (a == Math.POSITIVE_INFINITY || b == Math.NEGATIVE_INFINITY) return 1;
	if (b == Math.POSITIVE_INFINITY || a == Math.NEGATIVE_INFINITY) return -1;
	return Number(a) - Number(b);
};

ZmPref.__BY_DURATION =
function(a, b) {
	if (a == b) return 0;
	if (a == "0") return 1;
	if (b == "0") return -1;
	var asecs = ZmPref.__DUR2SECS(a);
	var bsecs = ZmPref.__DUR2SECS(b);
	return asecs - bsecs;
};

// Converters

ZmPref.__DURMULT = { "s": 1, "m": 60, "h": 3600, "d": 86400/*, "w": 604800*/ };
ZmPref.__DURDIV = { /*604800: "w",*/ 86400: "d", 3600: "h", 60: "m", 1: "s" };

ZmPref.__DUR2SECS =
function(duration) {
	if (duration == "0") return Number.POSITIVE_INFINITY;

	var type = duration.substring(duration.length - 1).toLowerCase();
	return parseInt(duration, 10) * ZmPref.__DURMULT[type];
};

ZmPref.__SECS2DUR =
function(seconds, type) {
	if (seconds == Number.POSITIVE_INFINITY) return "0";

	var divisors = ZmPref.__DURDIV;
	if (type) {
		type = {};
		type[ ZmPref.__DURMULT[type] ] = type;
	}
	for (var divisor in divisors) {
		var result = Math.floor(seconds / divisor);
		if (result > 0) {
			return [ result, divisors[divisor] ].join("");
		}
	}

	return "0"+type;
};

// maximum value lengths
ZmPref.MAX_LENGTH = {};
ZmPref.MAX_LENGTH[ZmSetting.INITIAL_SEARCH]	= 512;
ZmPref.MAX_LENGTH[ZmSetting.SIGNATURE]		= 1024;
ZmPref.MAX_LENGTH[ZmSetting.AWAY_MESSAGE]	= 8192;

ZmPref.setPrefList =
function(prefsId, list) {
	ZmPref[prefsId] = list;
};

/**
 * The SETUP object for a pref gets translated into a form input.
 * Available properties are:
 *
 * displayName			descriptive text
 * displayFunc			A function that returns the descriptive text. Only implemented for checkboxes.
 * displayContainer		type of form input: checkbox, select, input, or textarea
 * options				values for a select input
 * displayOptions		text for the select input's values
 * validationFunction	function to validate the value
 * errorMessage			message to show if validation fails
 * precondition			pref will not be displayed unless precondition is true
 * inputId              array of unique ids to be applied to input
 */
ZmPref.SETUP = {};

ZmPref.registerPref =
function(id, params) {
	ZmPref.SETUP[id] = params;
};

/** Clears all of the preference sections. */
ZmPref.clearPrefSections =
function() {
	ZmPref._prefSectionMap = {};
	ZmPref._prefSectionArray = null;
};

/**
 * Registers a preferences section ("tab").
 * <p>
 * The <code>params</code> argument can have the following properties:
 *
 * @param title         [string]    The section title.
 * @param templateId    [string]    (Optional) The template associated to this
 *                                  section. If not specified, the id is used.
 *                                  Note: The default template base is:
 *                                  "prefs.Pages#".
 * @param priority      [int]       The section priority used when determining
 *                                  the order of the sections.
 * @param precondition  [any]       (Optional) Specifies the precondition
 *                                  under which this section is shown.
 * @param prefs         [Array]     List of preferences that appear in this
 *                                  section.
 * @param manageChanges [boolean]   Determines whether this section manages
 *                                  its own pref changes. If true, then
 *                                  ZmPrefView#getChangedPrefs will not query
 *                                  the section for changes.
 * @param manageDirty   [boolean]   Determines whether this section manages
 *                                  its "dirty" state (i.e. whether any prefs
 *                                  have changed values). If true, then
 *                                  ZmPrefView#getChangedPrefs will call
 *                                  isDirty() on the section view.
 */
ZmPref.registerPrefSection =
function(id, params) {
	if (!id || !params) { return; }

	// set template for section
	var templateId = params.templateId || id;
	if (!templateId.match(/#/)) {
		templateId = ["prefs.Pages",templateId].join("#");
	}
	params.templateId = templateId;
	params.id = id;

	// save section
	appCtxt.set(ZmSetting.PREF_SECTIONS, params, id);
	ZmPref._prefSectionArray = null;
};

ZmPref.unregisterPrefSection =
function(id) {
	appCtxt.set(ZmSetting.PREF_SECTIONS, null, id);
	ZmPref._prefSectionArray = null;
};

/** Returns the pref sections map. */
ZmPref.getPrefSectionMap =
function() {
	return appCtxt.get(ZmSetting.PREF_SECTIONS);
};

/** Returns a sorted array of pref sections (based on priority). */
ZmPref.getPrefSectionArray =
function() {
	if (!ZmPref._prefSectionArray) {
		ZmPref._prefSectionArray = [];
		var prefSectionMap = appCtxt.get(ZmSetting.PREF_SECTIONS);
		for (var id in prefSectionMap) {
			ZmPref._prefSectionArray.push(prefSectionMap[id]);
		}
		ZmPref._prefSectionArray.sort(ZmPref.__BY_PRIORITY);
	}
	return ZmPref._prefSectionArray;
};

/** Returns the section that contains the specified pref. */
ZmPref.getPrefSectionWithPref =
function(prefId) {
	var prefSectionMap = appCtxt.get(ZmSetting.PREF_SECTIONS);
	for (var sectionId in prefSectionMap) {
		var section = prefSectionMap[sectionId];
		if (section.prefs == null) continue;

		for (var i = 0; i < section.prefs.length; i++) {
			if (section.prefs[i] == prefId) {
				return section;
			}
		}
	}
	return null;
};

// Make sure the pref sections are init'd
ZmPref.clearPrefSections();

//
// Private functions
//

ZmPref.__BY_PRIORITY =
function(a, b) {
	return Number(a.priority) - Number(b.priority);
};

ZmPref.regenerateSignatureEditor =
function( control ) {
    var signaturePage = control.parent;
    var valueEl = document.getElementById(signaturePage._htmlElId + "_SIG_EDITOR");
    var htmlEditor = new ZmHtmlEditor({
        parent: signaturePage,
        parentElement: valueEl.parentNode,
        textAreaId: "TEXTAREA_SIGNATURE",
		autoFocus: true,
        attachmentCallback:
            signaturePage._insertImagesListener.bind(signaturePage)
    });
    valueEl.parentNode.removeChild(valueEl);
    signaturePage._sigEditor = htmlEditor;
    signaturePage._populateSignatures();
};

ZmPref._normalizeFontId = function(id, dontFallback) {
	var oldid = id;
	id = id.replace(/,\s/g,",").replace(/'/g,"").toLowerCase(); // Make sure all ids that are supposed to be found in ZmPref.FONT_FAMILY are actually found
	if (!dontFallback) {
		var map = ZmPref.FONT_FAMILY;
		if (map && !map[id]) {
			var keys = AjxUtil.keys(map);
			if (keys.length) {
				var splitId = id.split(","); // e.g. ["times new roman","helvetica"]
				for (var i=0; i<splitId.length; i++) { // Loop over input font names
					for (var j=0; j<keys.length; j++) { // Loop over candidate styles, e.g. ["arial,sans-serif","times new roman,serif"]
						if (keys[j].indexOf(splitId[i]) != -1) {
							return keys[j];
						}
					}
				}
				return keys[0];
			}
		}
	}
	return id;
};
ZmPref._normalizeFontName = function(fontId) {
	return ZmPref.FONT_FAMILY[ZmPref._normalizeFontId(fontId)].name;
};
ZmPref._normalizeFontValue = function(fontId) {
	return ZmPref.FONT_FAMILY[ZmPref._normalizeFontId(fontId)].value;
};

ZmPref.handleOOOVacationExternalOptionChange = function(ev) {
    var section = ZmPref.getPrefSectionWithPref(ZmSetting.VACATION_EXTERNAL_MSG);
    var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView().getView(section.id);
    var externalTextArea  = view.getFormObject(ZmSetting.VACATION_EXTERNAL_MSG);
    var externalSelect =  view.getFormObject(ZmSetting.VACATION_EXTERNAL_SUPPRESS);
    var selectedIndex = externalSelect.getSelectedOption().getItem()._optionIndex;

    if (selectedIndex === 0 || selectedIndex === 3 ) {
        externalTextArea.setVisible(false);
    } else {
        externalTextArea.setVisible(true);
    }
};

// Keep NOTIF_ENABLED updated based on whether NOTIF_ADDRESS has a value
ZmPref.setMailNotificationAddressValue = function(pref, value, list, viewPage) {

	pref.setValue(value);
	list.push(pref);

	var notifEnabledSetting = appCtxt.getSettings().getSetting(ZmSetting.NOTIF_ENABLED),
		hasValue = !!value;

	if (notifEnabledSetting.getValue() !== hasValue) {
		notifEnabledSetting.setValue(hasValue);
		list.push(notifEnabledSetting);
	}
};

ZmPref.FONT_FAMILY = {};
(function() {
	var KEYS = [ "fontFamilyIntl", "fontFamilyBase" ];
	var i, j, key, value, name;
	for (j = 0; j < KEYS.length; j++) {
		for (i = 1; value = AjxMsg[KEYS[j]+i+".css"]; i++) {
			if (value.match(/^#+$/)) break;
			value = ZmPref._normalizeFontId(value,true);
			name = AjxMsg[KEYS[j]+i+".display"];
			ZmPref.FONT_FAMILY[value] = {name:name, value:value};
		}
	}
})();
}
if (AjxPackage.define("zimbraMail.prefs.ZmPreferencesApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates the preferences application.
 * @class
 * This class represents the application for the preferences UI. This is where the preferences
 * hook into the overall application.
 * 
 * @param	{DwtControl}	container	the control that contains components
 * @param	{ZmController}	parentController	the parent window controller (set by the child window)
 * 
 * @extends		ZmApp
 */
ZmPreferencesApp = function(container, parentController) {
	ZmApp.call(this, ZmApp.PREFERENCES, container, parentController);

	// must be hash for case of multi-accounts
	this._filterRules = {};
	this._outgoingFilterRules = {};
};

ZmPreferencesApp.prototype = new ZmApp;
ZmPreferencesApp.prototype.constructor = ZmPreferencesApp;

ZmPreferencesApp.prototype.isZmPreferencesApp = true;
ZmPreferencesApp.prototype.toString = function() { return "ZmPreferencesApp"; };


// Organizer and item-related constants
ZmEvent.S_FILTER					= "FILTER";
ZmEvent.S_PREF_ZIMLET				= "PREF_ZIMLET";
ZmEvent.S_PREF_ACCOUNT				= "PREF_ACCOUNT";
ZmEvent.S_PREF_BACKUP				= "PREF_BACKUP";

// App-related constants
/**
 * Defines the "preferences" application.
 */
ZmApp.PREFERENCES					= ZmId.APP_PREFERENCES; 
ZmApp.CLASS[ZmApp.PREFERENCES]		= "ZmPreferencesApp";
ZmApp.SETTING[ZmApp.PREFERENCES]	= ZmSetting.OPTIONS_ENABLED;
ZmApp.LOAD_SORT[ZmApp.PREFERENCES]	= 10;
ZmApp.QS_ARG[ZmApp.PREFERENCES]		= "options";
ZmOrganizer.PREF_PAGE				= "PREF_PAGE";
ZmPreferencesApp.QS_ARG_SECTION		= "section";

// NOTE: This is registered staticly to guarantee that all of the
//       enabled app's preferences will be registered by the time
//       that another app listener gets the launch event and may
//       want to alter those prefs.
ZmPreferencesApp._registerAllPrefs =
function() {
	AjxDispatcher.require("PreferencesCore");
	appCtxt.getAppController().runAppFunction("_registerPrefs");
};
ZmZimbraMail.addAppListener(ZmApp.PREFERENCES, ZmAppEvent.PRE_LAUNCH, new AjxListener(ZmPreferencesApp._registerAllPrefs));

//
// Public methods
//

// App API

ZmPreferencesApp.prototype.launch =
function(params, callback) {
	// first time launch of prefs app should reset active app to "local" account
	if (appCtxt.multiAccounts) {
		appCtxt.accountList.setActiveAccount(appCtxt.accountList.mainAccount);
	}

	var gotoSection = (params.qsParams && params.qsParams[ZmPreferencesApp.QS_ARG_SECTION]) || "GENERAL";
	callback = new AjxCallback(this, this.gotoSection, [gotoSection, callback]);

	var loadCallback = new AjxCallback(this, this._handleLoadLaunch, [callback]);
	AjxDispatcher.require(["PreferencesCore", "Preferences"], true, loadCallback, null, true);
};

// Public methods

/**
 * Gets the preferences controller.
 * 
 * @return	{ZmPrefController}	the controller
 */
ZmPreferencesApp.prototype.getPrefController =
function() {
	if (!this._prefController) {
		AjxDispatcher.require(["PreferencesCore", "Preferences"]);
		this._prefController = new ZmPrefController(this._container, this);
	}
	return this._prefController;
};

/**
 * Gets the filter controller.
 * 
 * @return	{ZmFilterController}	the controller
 */
ZmPreferencesApp.prototype.getFilterController =
function() {
	if (!this._filterController) {
		this._filterController = this.getPrefController().getFilterController();
	}
	return this._filterController;
};

/**
 * Gets the filter rules.
 * 
 * @param	{String}	[accountName]		the account name or <code>null</code> to use the active account
 * @return	{ZmFilterRules}		the filter rules
 */
ZmPreferencesApp.prototype.getFilterRules =
function(accountName) {
	var ac = window.parentAppCtxt || window.appCtxt;
	var acct = accountName || ac.getActiveAccount().name;

	if (!this._filterRules[acct]) {
		this._filterRules[acct] = new ZmFilterRules(acct);
	}
	return this._filterRules[acct];
};

/**
 * Gets the outgoing filter rules.
 * 
 * @param	{String}	[accountName]		the account name or <code>null</code> to use the active account
 * @return	{ZmFilterRules}		the filter rules
 */
ZmPreferencesApp.prototype.getOutgoingFilterRules =
function(accountName) {
	var ac = window.parentAppCtxt || window.appCtxt;
	var acct = accountName || ac.getActiveAccount().name;

	if (!this._outgoingFilterRules[acct]) {
		this._outgoingFilterRules[acct] = new ZmFilterRules(acct, true);
	}
	return this._outgoingFilterRules[acct];
};

ZmPreferencesApp.prototype.modifyNotify =
function(modifies, force) {

	var sharingView = this._getSharingView();
	if (sharingView) {
		sharingView.notifyModify(modifies);
	}
};

ZmPreferencesApp.prototype.refresh =
function(refresh, addr) {
    var trustedPage = this.getPreferencesPage("TRUSTED_ADDR");
    if(trustedPage && addr) {
        trustedPage.addItem(addr);
    }
	if (!appCtxt.inStartup) {
		var sharingView = this._getSharingView();
		if (sharingView) {
			sharingView.refresh(refresh);
		}
	}
};

ZmPreferencesApp.prototype.gotoSection =
function(section, callback) {
	if (section) {
		var prefCtlr = this.getPrefController();
		var prefsView = prefCtlr && prefCtlr.getPrefsView();
		if (prefsView) {
			section = section.toUpperCase();
			var overview = this.getOverview();
			if (overview) {
				overview.setSelected([ZmOrganizer.PREF_PAGE, section].join("_"));
			}
			prefsView.selectSection(section);
		}
	}
	if (callback && callback.run) {
		callback.run();
	}
};



//
// Protected methods
//

// Construction

ZmPreferencesApp.prototype._defineAPI =
function() {
	AjxDispatcher.registerMethod("GetFilterRules", ["PreferencesCore", "Preferences"], new AjxCallback(this, this.getFilterRules));
	AjxDispatcher.registerMethod("GetOutgoingFilterRules", ["PreferencesCore", "Preferences"], new AjxCallback(this, this.getOutgoingFilterRules));
	AjxDispatcher.registerMethod("GetPrefController", ["PreferencesCore", "Preferences"], new AjxCallback(this, this.getPrefController));
	AjxDispatcher.registerMethod("GetFilterController", ["PreferencesCore", "Preferences"], new AjxCallback(this, this.getFilterController));
};

ZmPreferencesApp.prototype._registerOrganizers =  function() {
	ZmOrganizer.registerOrg(ZmOrganizer.PREF_PAGE,
							{app:				ZmApp.PREFERENCES,
							 orgClass:			"ZmPrefPage",
							 orgPackage:		"PreferencesCore",
							 treeController:	"ZmPrefPageTreeController",
							 labelKey:			"preferences",
							 treeType:			ZmOrganizer.PREF_PAGE,
							 displayOrder:		100
							});

};

ZmPreferencesApp.prototype._registerOperations =
function() {
	ZmOperation.registerOp(ZmId.OP_MOBILE_REMOVE, {textKey:"mobileRemoveFromList", image:"Delete"});
	ZmOperation.registerOp(ZmId.OP_MOBILE_RESUME_SYNC, {textKey:"mobileResumeSync", image:"ImAvailable"});
	ZmOperation.registerOp(ZmId.OP_MOBILE_SUSPEND_SYNC, {textKey:"mobileSuspendSync", image:"Offline"});
	ZmOperation.registerOp(ZmId.OP_MOBILE_WIPE, {textKey:"mobileWipe", image:"MobileWipe"}, ZmSetting.MOBILE_POLICY_ENABLED);
	ZmOperation.registerOp(ZmId.OP_MOBILE_CANCEL_WIPE, {textKey:"mobileWipeCancel", image:"MobileWipeCancel"}, ZmSetting.MOBILE_POLICY_ENABLED);
	ZmOperation.registerOp(ZmId.OP_REVERT_PAGE, {textKey:"restorePage"});

    /* ZmOperation.registerOp(ZmId.OP_ADD_QUICK_COMMAND, {textKey:"quickCommandAdd", image:"Plus"}, ZmSetting.FILTERS_ENABLED);
    ZmOperation.registerOp(ZmId.OP_EDIT_QUICK_COMMAND, {textKey:"quickCommandEdit", image:"Edit"}, ZmSetting.FILTERS_ENABLED);
    ZmOperation.registerOp(ZmId.OP_REMOVE_QUICK_COMMAND, {textKey:"quickCommandRemove", image:"Delete"}, ZmSetting.FILTERS_ENABLED); */
};

ZmPreferencesApp.prototype._registerSettings =
function(settings) {
	settings = settings || appCtxt.getSettings();
	settings.registerSetting("IMPORT_FOLDER",				{type:ZmSetting.T_PSEUDO, dataType:ZmSetting.D_NONE});
	settings.registerSetting("IMPORT_BUTTON",				{type:ZmSetting.T_PSEUDO, dataType:ZmSetting.D_NONE});
	settings.registerSetting("EXPORT_FOLDER",				{type:ZmSetting.T_PSEUDO, dataType:ZmSetting.D_NONE});
	settings.registerSetting("EXPORT_BUTTON",				{type:ZmSetting.T_PSEUDO, dataType:ZmSetting.D_NONE});
	settings.registerSetting("PREF_SECTIONS",				{type:ZmSetting.T_PSEUDO, dataType:ZmSetting.D_HASH, isGlobal:true});
	settings.registerSetting("SIGNATURE_MAX_LENGTH",		{name:"zimbraMailSignatureMaxLength", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:1024});
	settings.registerSetting("DISCARD_IN_FILTER_ENABLED",	{name:"zimbraFeatureDiscardInFiltersEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("FROM_DISPLAY_ENABLED",		{name: "zimbraFeatureFromDisplayEnabled", type: ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue: true});
    //settings.registerSetting("QUICK_COMMAND_LIST",			{name:"zimbraPrefQuickCommand", type: ZmSetting.T_COS, dataType: ZmSetting.D_LIST});
};

ZmPreferencesApp.prototype._registerApp =
function() {
	ZmApp.registerApp(ZmApp.PREFERENCES,
							 {mainPkg:				"Preferences",
							  nameKey:				"preferences",
							  icon:					"Preferences",
							  textPrecedence:		50,
							  chooserTooltipKey:	"goToOptions",
							  button:				appCtxt.isChildWindow ? null : ZmAppChooser.B_OPTIONS,
							  overviewTrees:		[ZmOrganizer.PREF_PAGE],
							  hideZimlets:			true,
							  gotoActionCode:		ZmKeyMap.GOTO_OPTIONS,
							  chooserSort:			180
                  });
};

ZmPreferencesApp.prototype._registerPrefs = function() {

	var sections = {

		GENERAL: {
			title: ZmMsg.general,
			templateId: "prefs.Pages#General",
			priority: 0,
			prefs: [
				ZmSetting.LOCALE_NAME,
                ZmSetting.COMPOSE_INIT_DIRECTION,
                ZmSetting.SHOW_COMPOSE_DIRECTION_BUTTONS,
				ZmSetting.FONT_NAME,
				ZmSetting.FONT_SIZE,
				ZmSetting.PASSWORD,
				ZmSetting.SEARCH_INCLUDES_SHARED,
				ZmSetting.SEARCH_INCLUDES_SPAM,
				ZmSetting.SEARCH_INCLUDES_TRASH,
				ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES,
				ZmSetting.SHOW_SEARCH_STRING,
				ZmSetting.SHOW_SELECTION_CHECKBOX,
				ZmSetting.SKIN_NAME,
				ZmSetting.CLIENT_TYPE,
				ZmSetting.DEFAULT_TIMEZONE,
                ZmSetting.DEFAULT_PRINTFONTSIZE,
				ZmSetting.OFFLINE_IS_MAILTO_HANDLER,
				ZmSetting.SHORT_ADDRESS,
                ZmSetting.OFFLINE_UPDATE_NOTIFY //offline
			]
		},

        ACCOUNTS: {
			icon:           "Accounts",
			title:          appCtxt.isOffline ? ZmMsg.personas : ZmMsg.accounts,
			templateId:     "prefs.Pages#Accounts",
			priority:       9,
			precondition:   ZmSetting.MAIL_PREFERENCES_ENABLED,
			prefs:          [ ZmSetting.ACCOUNTS, ZmSetting.SAVE_TO_SENT_DELEGATED_TARGET ],
			manageDirty:    true,
			createView:     function(parent, section, controller) {
								return new ZmAccountsPage(parent, section, controller);
							}
		},

        FILTERS: {
			icon:           "MailRule",
			title:          ZmMsg.filterRules,
			templateId:     "prefs.Pages#MailFilters",
			priority:       50,
	        precondition:   [ ZmSetting.MAIL_PREFERENCES_ENABLED, ZmSetting.FILTERS_ENABLED ],
			prefs:          [ ZmSetting.FILTERS ],
			manageChanges:  true,
			createView:     function(parent, section, controller) {
								return controller.getFilterController(section).getFilterView();
							}
		},

        SIGNATURES: {
			icon:           "AddSignature",
			title:          ZmMsg.signatures,
			templateId:     "prefs.Pages#Signatures",
			priority:       51,
	        precondition:   [ ZmSetting.MAIL_PREFERENCES_ENABLED, ZmSetting.SIGNATURES_ENABLED ],
			prefs:          [ ZmSetting.SIGNATURES, ZmSetting.SIGNATURE_STYLE, ZmSetting.SIGNATURE_ENABLED ],
			manageDirty:    true,
			createView:     function(parent, section, controller) {
								return new ZmSignaturesPage(parent, section, controller);
							}
		},

        OUTOFOFFICE: {
            icon:           "OutOfOffice",
			title:          ZmMsg.outOfOffice,
            priority:       55,
            templateId:     "prefs.Pages#OutOfOffice",
	        precondition:   [ ZmSetting.MAIL_PREFERENCES_ENABLED, ZmSetting.VACATION_MSG_FEATURE_ENABLED ],
	        prefs:          [
				                ZmSetting.START_DATE_ENABLED,
				                ZmSetting.END_DATE_ENABLED,
				                ZmSetting.VACATION_DURATION_ENABLED,
				                ZmSetting.VACATION_DURATION_ALL_DAY,
				                ZmSetting.VACATION_CALENDAR_ENABLED,
				                ZmSetting.VACATION_FROM,
				                ZmSetting.VACATION_FROM_TIME,
								ZmSetting.VACATION_MSG_ENABLED,
								ZmSetting.VACATION_MSG,
				                ZmSetting.VACATION_EXTERNAL_MSG_ENABLED,
								ZmSetting.VACATION_EXTERNAL_MSG,
				                ZmSetting.VACATION_EXTERNAL_TYPE,
                                ZmSetting.VACATION_EXTERNAL_SUPPRESS,
				                ZmSetting.VACATION_CALENDAR_TYPE,
								ZmSetting.VACATION_UNTIL,
				                ZmSetting.VACATION_UNTIL_TIME
				            ],
            manageDirty:    true,
			createView:     function(parent, section, controller) {
								AjxDispatcher.require("Alert");
								return new ZmMailPrefsPage(parent, section, controller);
							}
        },

        TRUSTED_ADDR: {
			title:          ZmMsg.trustedAddrs,
			icon:           "TrustedAddresses",
			templateId:     "prefs.Pages#Trusted",
			priority:       60,
	        precondition:   ZmSetting.MAIL_PREFERENCES_ENABLED,
			createView:     function(parent, section, controller) {
								return new ZmTrustedPage(parent, section, controller, "Prefs_Pages_TrustedAddresses");
							},
            manageDirty:    true,
            prefs:          [ ZmSetting.TRUSTED_ADDR_LIST ]
		},

		SHARING: {
			title:          ZmMsg.sharing,
			icon:           "SharedContact",
			templateId:     "prefs.Pages#SharingPrefPage",
			priority:       85,
			precondition:   ZmSetting.SHARING_ENABLED,
			manageChanges:  true,
			createView:     function(parent, section, controller) {
								AjxDispatcher.require("Share");
								return new ZmSharingPage(parent, section, controller, "Prefs_Pages_Sharing");
							}
		},

		NOTIFICATIONS: {
			title:              ZmMsg.notifications,
			icon:               "ApptReminder",
			templateId:         "prefs.Pages#Notifications",
			priority:           88,
			precondition:       [ ZmSetting.CALENDAR_ENABLED, ZmSetting.TASKS_ENABLED ],
			preconditionAny:    true,
			prefs:              [ ZmSetting.CAL_EMAIL_REMINDERS_ADDRESS, ZmSetting.CAL_DEVICE_EMAIL_REMINDERS_ADDRESS ],
            createView:         function(parent, section, controller) {
					                return new ZmNotificationsPage(parent, section, controller);
					            }
		},

		MOBILE: {
			title:          ZmMsg.connectedDevicesAndApps,
			icon:           "Mobile",
			templateId:     "prefs.Pages#MobileDevices",
			priority:       90,
			precondition:   ZmSetting.MOBILE_SYNC_ENABLED,
			manageChanges:  true,
			createView:     function(parent, section, controller) {
								return new ZmMobileDevicesPage(parent, section, controller);
							}
		},

		IMPORT_EXPORT: {
			title:              ZmMsg.importExport,
			icon:               "SendReceive",
			templateId:         "data.ImportExport#ImportExportPrefPage",
			priority:           100,
			precondition:       [ ZmSetting.IMPORT_ENABLED, ZmSetting.EXPORT_ENABLED ],
			preconditionAny:    true,
			prefs:              [
									ZmSetting.IMPORT_FOLDER,
									ZmSetting.IMPORT_BUTTON,
									ZmSetting.EXPORT_FOLDER,
									ZmSetting.EXPORT_BUTTON
								],
			manageChanges:      true,
			createView:         function(parent, section, controller) {
									AjxDispatcher.require("ImportExport");
									return new ZmImportExportPage(parent, section, controller);
								}
		},

		SHORTCUTS: {
			title:          ZmMsg.shortcuts,
			icon:           "Shortcut",
			templateId:     "prefs.Pages#Shortcuts",
			priority:       120,
			precondition:   ZmSetting.USE_KEYBOARD_SHORTCUTS,
			createView:     function(parent, section, controller) {
								return new ZmShortcutsPage(parent, section, controller);
							}
		},

        PREF_ZIMLETS: {
			title:          ZmMsg.zimlets,
	        icon:           "Zimlet",
			templateId:     "prefs.Pages#Zimlets",
			manageDirty:    true,
            priority:       140,
			precondition:   ZmSetting.CHECKED_ZIMLETS_ENABLED,
			prefs:          [
								ZmSetting.CHECKED_ZIMLETS,
				                ZmSetting.OFFLINE_ZIMLET_SYNC_ACCOUNT_ID
							],
            createView:     function(parent, section, controller) {
								return new ZmZimletsPage(parent, section, controller);
							}
		}
	};

    if (appCtxt.isOffline) {
        sections["BACKUP"] = {
			title:          ZmMsg.offlineBackups,
			icon:           "backup",
            manageDirty:    true,
			templateId:     "prefs.Pages#BackUp",
			priority:       130,
            prefs:          [
				                ZmSetting.OFFLINE_BACKUP_NOW_BUTTON,
				                ZmSetting.OFFLINE_BACKUP_INTERVAL,
				                ZmSetting.OFFLINE_BACKUP_PATH,
				                ZmSetting.OFFLINE_BACKUP_KEEP,
				                ZmSetting.OFFLINE_BACKUP_ACCOUNT_ID,
				                ZmSetting.OFFLINE_BACKUP_RESTORE
				            ],
			createView:     function(parent, section, controller) {
								return new ZmBackupPage(parent, section, controller);
							}
		}
    }

	if (appCtxt.get(ZmSetting.CHAT_FEATURE_ENABLED)) {
		ZmPref.registerPref("CHAT_ENABLED", {
			displayName:		ZmMsg.chatFeatureStatus,
			displayContainer:	ZmPref.TYPE_RADIO_GROUP,
			orientation:		ZmPref.ORIENT_VERTICAL,
			displayOptions:		[ZmMsg.chatFeatureEnabled, ZmMsg.chatFeatureDisabled],
			options:			[true, false]
		});

		ZmPref.registerPref("CHAT_PLAY_SOUND", {
			displayName:		ZmMsg.chatPlaySound,
			displayContainer:	ZmPref.TYPE_CHECKBOX
		});

		sections["CHAT"] = {
			title: ZmMsg.chat,
			icon: "Conversation",
			templateId: "prefs.Pages#Chat",
			priority: 65,
			prefs: [
				ZmSetting.CHAT_ENABLED,
				ZmSetting.CHAT_PLAY_SOUND
			]
		}
	}


	for (var id in sections) {
		ZmPref.registerPrefSection(id, sections[id]);
	}

	ZmPref.registerPref("CLIENT_TYPE", {
		displayName:		ZmMsg.clientType,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_VERTICAL,
		displayOptions: 	[ZmMsg.clientAdvanced, ZmMsg.clientStandard],
		options: 			[ZmSetting.CLIENT_ADVANCED, ZmSetting.CLIENT_STANDARD]
	});

	ZmPref.registerPref("COMPOSE_AS_FORMAT", {
		displayName:		ZmMsg.composeUsing,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_VERTICAL,
		displayOptions: 	[ZmMsg.composeAsHTML, ZmMsg.composeAsText],
		options: 			[ZmSetting.COMPOSE_HTML, ZmSetting.COMPOSE_TEXT],
		precondition:		ZmSetting.HTML_COMPOSE_ENABLED,
		inputId:            ["COMPOSE_AS_HTML", "COMPOSE_AS_TEXT"]
	});

	ZmPref.registerPref("COMPOSE_INIT_FONT_COLOR", {
		displayOptions: 	["rgb(0, 0, 0)"],
		displayContainer:	ZmPref.TYPE_COLOR,
		precondition:		ZmSetting.HTML_COMPOSE_ENABLED
	});

	var styles=[],names=[];
	for (var key in ZmPref.FONT_FAMILY) {
		var obj = ZmPref.FONT_FAMILY[key];
		styles.push(obj.value);
		names.push(obj.name);
	}

	ZmPref.registerPref("COMPOSE_INIT_FONT_FAMILY", {
		displayName:		ZmMsg.defaultFontSettings,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions: 	names,
		options: 			styles,
		precondition:		[ ZmSetting.HTML_COMPOSE_ENABLED, ZmSetting.NOTEBOOK_ENABLED ],
		preconditionAny:    true,
		approximateFunction: function(id) {
			// Choose the style that comes closest, or the first if none is found
			if (AjxUtil.indexOf(styles, id) != -1) {
				return id;
			}
			return ZmPref._normalizeFontId(id);
		}
	});

    var fontSizes = [ 8, 9, 10, 11, 12, 13, 14, 16, 18, 24, 36, 48 ],   // match what TinyMCE provides
        fontSizeOptions = AjxUtil.map(fontSizes, function(fontSize) {
            return AjxMessageFormat.format(ZmMsg.pt, fontSize); // pref page version (localized)
        }),
        fontSizeValueOptions = AjxUtil.map(fontSizes, function(fontSize) {
            return fontSize + 'pt'; // server version
        });

    var getZimbraAccountList = function(){
        var visAccts = appCtxt.accountList.visibleAccounts;
        var accts = [];
        accts.push(ZmMsg.zimletPrefDontSync);
        for (var k=0; k<visAccts.length; k++) {
            if(visAccts[k].isZimbraAccount && !visAccts[k].isMain) {
                accts.push([ZmMsg.zimletPrefSyncWith, " ", visAccts[k].name].join(""));
            }
        }
        return accts;
    };
    var getZimbraAccountIds = function(){
        var visAccts = appCtxt.accountList.visibleAccounts;
        var accts = [];
        accts.push("");
        for (var k=0; k<visAccts.length; k++) {
            if(visAccts[k].isZimbraAccount && !visAccts[k].isMain) {
                accts.push(visAccts[k].id);
            }
        }
        return accts;

    };
	ZmPref.registerPref("COMPOSE_INIT_FONT_SIZE", {
		displayName:		null,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions: 	fontSizeOptions,
        options:            fontSizeValueOptions,
		precondition:		ZmSetting.HTML_COMPOSE_ENABLED
	});

	ZmPref.registerPref("COMPOSE_SAME_FORMAT", {
		displayName:		ZmMsg.replyForwardInSameFormat,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

    ZmPref.registerPref("CHECKED_ZIMLETS", {
		displayName:		ZmMsg.zimlets,
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

    ZmPref.registerPref("OFFLINE_ZIMLET_SYNC_ACCOUNT_ID", {
		displayName:		ZmMsg.zimletSyncPref,
		displayContainer:	ZmPref.TYPE_SELECT,
        displayOptions:     getZimbraAccountList(),
        options:            getZimbraAccountIds()
	});

    ZmPref.registerPref("DEFAULT_TIMEZONE", {
        displayName:		ZmMsg.selectTimezone,
        displayContainer:	ZmPref.TYPE_SELECT,
        displayParams:		{ layout: DwtMenu.LAYOUT_SCROLL, maxRows:ZmPref.MAX_ROWS },
        displayOptions:		AjxTimezone.getZonePreferences(),
        options:			AjxTimezone.getZonePreferencesOptions()
    });

    ZmPref.registerPref("DEFAULT_PRINTFONTSIZE", {
		displayName:		ZmMsg.printFontSizePref,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions: 	fontSizeOptions,
        options:            fontSizeValueOptions
	});

    ZmPref.registerPref("EXPORT_FOLDER", {
        displayContainer:	ZmPref.TYPE_CUSTOM
    });

    ZmPref.registerPref("EXPORT_BUTTON", {
        displayName:		ZmMsg._export,
        displayContainer:	ZmPref.TYPE_CUSTOM
    });

	ZmPref.registerPref("FORWARD_INCLUDE_WHAT", {
		displayName:		ZmMsg.forwardInclude,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		[ZmMsg.includeInBody, ZmMsg.includeOriginalAsAttach],
		options:			[ZmSetting.INC_BODY, ZmSetting.INC_ATTACH],
        setFunction:		ZmPref.setIncludeOrig,
		initFunction:		ZmPref.initIncludeWhat,
		changeFunction:		ZmPref.onChangeIncludeWhat
	});

	ZmPref.registerPref("FORWARD_USE_PREFIX", {
		displayName:		ZmMsg.usePrefix,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
        setFunction:		ZmPref.setIncludeOrig
	});

	ZmPref.registerPref("FORWARD_INCLUDE_HEADERS", {
		displayName:		ZmMsg.includeHeaders,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
        setFunction:		ZmPref.setIncludeOrig
	});

	ZmPref.registerPref("IMPORT_FOLDER", {
		loadFunction:       ZmPref.loadCsvFormats,
		displayContainer:	ZmPref.TYPE_CUSTOM
	});
	ZmPref.registerPref("IMPORT_BUTTON", {
		displayName:		ZmMsg._import,
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

	ZmPref.registerPref("LOCALE_NAME", {
		displayName:		ZmMsg.selectLanguage,
		displayContainer:	ZmPref.TYPE_LOCALES,
		precondition:		ZmSetting.LOCALE_CHANGE_ENABLED
	});

    ZmPref.registerPref("COMPOSE_INIT_DIRECTION", {
        displayName:		ZmMsg.composeDirectionLabel,
        displayContainer:	ZmPref.TYPE_SELECT,
        displayOptions:		[ZmMsg.directionLTR, ZmMsg.directionRTL],
        options:			[ZmSetting.LTR, ZmSetting.RTL]
    });

    ZmPref.registerPref("SHOW_COMPOSE_DIRECTION_BUTTONS", {
        displayName:		ZmMsg.showDirectionButtons,
        displayContainer:	ZmPref.TYPE_CHECKBOX
    });

	ZmPref.registerPref("FONT_NAME", {
		displayName:		ZmMsg.selectFong,
		displayContainer:	ZmPref.TYPE_FONT
	});

	ZmPref.registerPref("FONT_SIZE", {
		displayName:		ZmMsg.selectFontSize, //this was never defined in ZmMsg in the above case (font_name) and see the typo there too. So not sure what's this for.
		displayContainer:	ZmPref.TYPE_FONT_SIZE
	});

	var markReadTime = AjxMessageFormat.format(ZmMsg.messageReadTime, DwtId.makeId(ZmId.WIDGET_INPUT, ZmId.OP_MARK_READ));
	ZmPref.registerPref("MARK_MSG_READ", {
		displayName:		ZmMsg.messageReadLabel,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayFunction:	ZmPref.markMsgReadDisplay,
        orientation:        ZmPref.ORIENT_VERTICAL,
        displayOptions:     [ZmMsg.messageReadNow, markReadTime, ZmMsg.messageReadNone],
        options:            [ZmSetting.MARK_READ_NOW, ZmSetting.MARK_READ_TIME, ZmSetting.MARK_READ_NONE],
        valueFunction:		ZmPref.markMsgReadValue
    });

	ZmPref.registerPref("NEW_WINDOW_COMPOSE", {
		displayName:		ZmMsg.composeInNewWin,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		[ ZmSetting.MAIL_ENABLED, ZmSetting.DETACH_COMPOSE_ENABLED ]
	});

    ZmPref.registerPref("MAIL_MANDATORY_SPELLCHECK", {
		displayName:		ZmMsg.mandatorySpellcheck,
		displayContainer:	ZmPref.TYPE_CHECKBOX		
	});

	ZmPref.registerPref("PAGE_SIZE", {
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		["25", "50", "100", "200"]
	});

	ZmPref.registerPref("PASSWORD", {
		displayName:		ZmMsg.changePassword,
		displayContainer:	ZmPref.TYPE_PASSWORD,
		precondition:		ZmSetting.CHANGE_PASSWORD_ENABLED
	});

	ZmPref.registerPref("SHARING", {
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

	ZmPref.registerPref("SHORT_ADDRESS", {
		displayName:		ZmMsg.shortAddress,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	
	if (appCtxt.isOffline) {
		ZmPref.registerPref("OFFLINE_IS_MAILTO_HANDLER", {
			displayName:		ZmMsg.offlineAllowMailTo,
			displayContainer:	ZmPref.TYPE_CHECKBOX
		});

        ZmPref.registerPref("OFFLINE_BACKUP_ACCOUNT_ID", {
            displayName:		ZmMsg.offlineBackUpAccounts,
            displayContainer:	ZmPref.TYPE_CUSTOM
        });

        ZmPref.registerPref("OFFLINE_BACKUP_RESTORE", {
            displayContainer:	ZmPref.TYPE_CUSTOM
        });

        ZmPref.registerPref("OFFLINE_BACKUP_NOW_BUTTON", {
            displayName:		ZmMsg.offlineBackUpButton,
            displayContainer:	ZmPref.TYPE_CUSTOM
        });

        ZmPref.registerPref("OFFLINE_BACKUP_INTERVAL", {
            displayName:		ZmMsg.offlineBackUpInterval,
            displayContainer:	ZmPref.TYPE_SELECT,
            displayOptions:		[ZmMsg.pollNever, ZmMsg.everyDay, ZmMsg.everyWeek, ZmMsg.everyMonth],
            options:			[0, 86400000, 604800000, 2628000000]
        });

        ZmPref.registerPref("OFFLINE_BACKUP_PATH", {
            displayName:		ZmMsg.offlineBackUpPath,
            displayContainer:	ZmPref.TYPE_INPUT
        });

        ZmPref.registerPref("OFFLINE_BACKUP_KEEP", {
            displayName:		ZmMsg.offlineBackUpKeep,
            displayContainer:	ZmPref.TYPE_SELECT,
            displayOptions:		["1", "2", "3", "4", "5"]
        });

        ZmPref.registerPref("OFFLINE_UPDATE_NOTIFY", {
            displayName:		ZmMsg.offlineUpdateNotify,
		    displayContainer:	ZmPref.TYPE_SELECT,
            displayOptions:		[ZmMsg.offlineUpdateRelease, ZmMsg.offlineUpdateBeta],
            options:    		["release", "beta"]
        });

	}

	// Polling Interval Options - Dynamically constructed according to MIN_POLLING_INTERVAL,POLLING_INTERVAL
    var neverValue = 525600;
    var numOptions = 10;
	var options = [neverValue];
    var displayOptions = [ZmMsg.pollManually];
    var pollInstant = appCtxt.get(ZmSetting.INSTANT_NOTIFY) ? true : false;

    if (pollInstant) {
        options.push(appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL));
        displayOptions.push(ZmMsg.pollInstant);
    }

    var startValue = ZmPref.pollingIntervalDisplay(appCtxt.get(ZmSetting.MIN_POLLING_INTERVAL));
	startValue = (startValue < 1) ? 1 : Math.round(startValue);

	var pollInterval = ZmPref.pollingIntervalDisplay(appCtxt.get(ZmSetting.POLLING_INTERVAL));
	pollInterval = Math.round(pollInterval);

	while (startValue <= numOptions) {
		options.push(startValue);
		startValue++;
	}
	startValue = startValue - 1;

	var count = options.length;
	while (count < numOptions) {
		startValue = startValue + 5;
		options.push(startValue);
		count++;
	}

	if (pollInterval > startValue && pollInterval !=neverValue && (pollInstant && pollInterval != appCtxt.get(ZmSetting.INSTANT_NOTIFY_INTERVAL))) {
        //pollInterval may have been set by admin
		var p = pollInterval % 5;
		p = (p == 0) ? pollInterval : ((pollInterval / 5 + 1) * 5);
        options.push(p);
	} else {
		startValue = startValue + 5;
		options.push(startValue);
	}

	while (displayOptions.length <= count) {
		displayOptions.push(ZmMsg.pollEveryNMinutes);
	}

	ZmPref.registerPref("POLLING_INTERVAL", {
		displayName:		ZmMsg.pollingInterval,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		displayOptions,
		//displayOptions:		[ ZmMsg.pollNever, ZmMsg.pollEveryNMinutes, ZmMsg.pollEveryNMinutes, ZmMsg.pollEveryNMinutes, ZmMsg.pollEveryNMinutes, ZmMsg.pollEveryNMinutes ],
		// NOTE: 525600 is the number of minutes in a year. I think that's a
		//       reasonable value for "never" since the server must have
		//       *some* number.
		options:			 options,
		approximateFunction: ZmPref.approximateInterval,
		displayFunction:	 ZmPref.pollingIntervalDisplay,
		valueFunction:	 	 ZmPref.pollingIntervalValue,
		validationFunction:  ZmPref.validatePollingInterval
	});

	ZmPref.registerPref("REPLY_INCLUDE_WHAT", {
		displayName:		ZmMsg.replyInclude,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		[ZmMsg.dontInclude,
							ZmMsg.includeInBody,
							ZmMsg.smartInclude,
							ZmMsg.includeOriginalAsAttach],
		options:			[ZmSetting.INC_NONE,
							ZmSetting.INC_BODY,
							ZmSetting.INC_SMART,
							ZmSetting.INC_ATTACH],
		setFunction:		ZmPref.setIncludeOrig,
		initFunction:		ZmPref.initIncludeWhat,
		changeFunction:		ZmPref.onChangeIncludeWhat
	});

	ZmPref.registerPref("REPLY_USE_PREFIX", {
		displayName:		ZmMsg.usePrefix,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		setFunction:		ZmPref.setIncludeOrig
	});

	ZmPref.registerPref("REPLY_INCLUDE_HEADERS", {
		displayName:		ZmMsg.includeHeaders,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		setFunction:		ZmPref.setIncludeOrig
	});

	ZmPref.registerPref("REPLY_PREFIX", {
		displayName:		ZmMsg.prefix,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		[">", "|"]
	});

	ZmPref.registerPref("SAVE_TO_SENT", {
		displayName:		ZmMsg.saveToSent,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		ZmSetting.MAIL_ENABLED,
		changeFunction:		AjxCallback.simpleClosure(ZmPref.onChangeConfirm, null, ZmMsg.saveToSentWarning, ZmPref.getSendToFiltersActive, true, new AjxCallback(null, ZmPref.setFormValue, ["SAVE_TO_SENT", true]))
	});

	ZmPref.registerPref("SAVE_TO_SENT_DELEGATED_TARGET", {
		displayName:		ZmMsg.saveToSentDelegatedTarget,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_VERTICAL,
		displayOptions:		[ZmMsg.saveToSentDelegatedOwner,
							ZmMsg.saveToSentDelegatedSender,
							ZmMsg.saveToSentDelegatedBoth,
							ZmMsg.saveToSentDelegatedNone],
		options:			["owner", "sender", "both", "none"],
		precondition:		ZmSetting.MAIL_ENABLED
	});

	ZmPref.registerPref("SEARCH_INCLUDES_SHARED", {
		displayName:		ZmMsg.includeSharedItems,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		ZmSetting.SHARING_ENABLED
	});
	
	ZmPref.registerPref("SEARCH_INCLUDES_SPAM", {
		displayName:		ZmMsg.includeJunkFolder,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		[ ZmSetting.MAIL_ENABLED, ZmSetting.SPAM_ENABLED ]
	});

	ZmPref.registerPref("SEARCH_INCLUDES_TRASH", {
		displayName:		ZmMsg.includeTrashFolder,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		[ ZmSetting.MAIL_ENABLED, ZmSetting.CONTACTS_ENABLED ],
		preconditionAny:    true
	});

	ZmPref.registerPref("SHOW_FRAGMENTS", {
		displayName:		ZmMsg.showFragments,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("COLOR_MESSAGES", {
		displayName:		ZmMsg.colorMessages,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	if (appCtxt.isOffline) {
		ZmPref.registerPref("OFFLINE_SHOW_ALL_MAILBOXES", {
			displayName:		ZmMsg.showAllMailboxes,
			displayContainer:	ZmPref.TYPE_CHECKBOX
		});
	}

	ZmPref.registerPref("SHOW_SEARCH_STRING", {
		displayName:		ZmMsg.showSearchString,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("SHOW_SELECTION_CHECKBOX", {
		displayName:		ZmMsg.showSelectionString,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("SKIN_NAME", {
		displayName:		ZmMsg.selectSkin,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		[],
		options:			[],
		loadFunction:		ZmPref.loadSkins,
		precondition:		ZmSetting.SKIN_CHANGE_ENABLED
	});

	ZmPref.registerPref("VIEW_AS_HTML", {
		displayName:		ZmMsg.displayMail,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_VERTICAL,
		displayOptions:		[ZmMsg.displayAsHTML, ZmMsg.displayAsText],
		options:			[true, false]
	});
};

// other

ZmPreferencesApp.prototype._handleLoadLaunch =
function(callback) {
	var respCallback = new AjxCallback(this, this._handleResponseLaunch, [callback]);
	appCtxt.getSettings().loadPreferenceData(respCallback);
};

ZmPreferencesApp.prototype._handleResponseLaunch =
function(callback) {
	AjxDispatcher.run("GetPrefController").show();
	if (callback) {
		callback.run();
	}
};

ZmPreferencesApp.prototype._getSharingView =
function() {
	var sharingSection = this.getPreferencesPage("SHARING");
	return (sharingSection && sharingSection.view);
};

ZmPreferencesApp.prototype.getPreferencesPage =
function(id) {
	if (!this._prefController) {
		return null;
	}
	var prefCtlr = this.getPrefController();
	var prefsView = prefCtlr && prefCtlr.getPrefsView();
	return prefsView && prefsView.getView(id);
};

// needed to hide zimlet tree view for multi-account
ZmPreferencesApp.prototype._getOverviewParams =
function() {
	var params = ZmApp.prototype._getOverviewParams.call(this);
	params.omit = {};
	params.omit[ZmOrganizer.ID_ZIMLET] = true;
	params.actionSupported = false;
	return params;
};

ZmPreferencesApp.getFilterRulesController =
function(outgoing) {
    var prefController = AjxDispatcher.run("GetPrefController");
    if (prefController && prefController.getPrefsView()) {
        var filterController = prefController.getFilterController();
        return outgoing ? filterController.getOutgoingFilterRulesController() : filterController.getIncomingFilterRulesController();
    }

    return null;
};

ZmPreferencesApp.prototype.getNewButtonProps =
function (){
    return {hidden:true};
}
}
if (AjxPackage.define("zimbraMail.mail.ZmMailApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the mail application class.
 */

/**
 * Creates and initializes the mail application.
 * @constructor
 * @class
 * The mail app manages and displays mail messages. Messages may be grouped
 * into conversations. New messages are created through a composer.
 *
 * @param	{DwtControl}	container		the container
 * @param	{ZmController}	parentController	the parent window controller (set by the child window)
 * 
 * @author Conrad Damon
 * 
 * @extends		ZmApp
 */
ZmMailApp = function(container, parentController) {
	ZmApp.call(this, ZmApp.MAIL, container, parentController);

	this._dataSourceCollection	= {};
	this._identityCollection	= {};
	this._signatureCollection	= {};

	this.numEntries				= 0; // offline, initial sync
	this.globalMailCount		= 0; // offline, new mail count

	this._throttleStats = [];
	this._addSettingsChangeListeners();
    AjxCore.addOnloadListener(this._checkVacationReplyEnabled.bind(this));
};

ZmMailApp.prototype = new ZmApp;
ZmMailApp.prototype.constructor = ZmMailApp;

ZmMailApp.prototype.isZmMailApp = true;
ZmMailApp.prototype.toString = function() {	return "ZmMailApp"; };

// Organizer and item-related constants
ZmEvent.S_CONV				= ZmId.ITEM_CONV;
ZmEvent.S_MSG				= ZmId.ITEM_MSG;
ZmEvent.S_ATT				= ZmId.ITEM_ATT;
ZmEvent.S_FOLDER			= ZmId.ORG_FOLDER;
ZmEvent.S_DATA_SOURCE		= ZmId.ITEM_DATA_SOURCE;
ZmEvent.S_IDENTITY			= "IDENTITY";
ZmEvent.S_SIGNATURE			= "SIGNATURE";
ZmItem.CONV					= ZmEvent.S_CONV;
ZmItem.MSG					= ZmEvent.S_MSG;
ZmItem.ATT					= ZmEvent.S_ATT;
ZmItem.DATA_SOURCE			= ZmEvent.S_DATA_SOURCE;
ZmOrganizer.FOLDER			= ZmEvent.S_FOLDER;

// App-related constants
/**
 * Defines the "mail" application.
 */
ZmApp.MAIL									= ZmId.APP_MAIL;
ZmApp.CLASS[ZmApp.MAIL]						= "ZmMailApp";
ZmApp.SETTING[ZmApp.MAIL]					= ZmSetting.MAIL_ENABLED;
ZmApp.UPSELL_SETTING[ZmApp.MAIL]			= ZmSetting.MAIL_UPSELL_ENABLED;
ZmApp.LOAD_SORT[ZmApp.MAIL]					= 20;
ZmApp.QS_ARG[ZmApp.MAIL]					= "mail";

ZmMailApp.DEFAULT_AUTO_SAVE_DRAFT_INTERVAL	= 15;
ZmMailApp.AUTO_SAVE_IDLE_TIME           	= 3;
ZmMailApp.DEFAULT_MAX_MESSAGE_SIZE			= 250000;

ZmMailApp.POP_DOWNLOAD_SINCE_ALL			= 0;
ZmMailApp.POP_DOWNLOAD_SINCE_NO_CHANGE		= 1;
ZmMailApp.POP_DOWNLOAD_SINCE_FROM_NOW		= 2;

ZmMailApp.POP_DELETE_OPTION_KEEP            = "keep";
ZmMailApp.POP_DELETE_OPTION_READ            = "read";
ZmMailApp.POP_DELETE_OPTION_TRASH           = "trash";
ZmMailApp.POP_DELETE_OPTION_HARD_DELETE     = "delete";

ZmMailApp.SEND_RECEIPT_NEVER				= "never";
ZmMailApp.SEND_RECEIPT_ALWAYS				= "always";
ZmMailApp.SEND_RECEIPT_PROMPT				= "prompt";

ZmMailApp.INC_MAP = {};
ZmMailApp.INC_MAP[ZmSetting.INC_NONE]			= [ZmSetting.INC_NONE, false, false];
ZmMailApp.INC_MAP[ZmSetting.INC_ATTACH]			= [ZmSetting.INC_ATTACH, false, false];
ZmMailApp.INC_MAP[ZmSetting.INC_BODY]			= [ZmSetting.INC_BODY, false, true];
ZmMailApp.INC_MAP[ZmSetting.INC_BODY_ONLY]		= [ZmSetting.INC_BODY, false, false];
ZmMailApp.INC_MAP[ZmSetting.INC_BODY_PRE]		= [ZmSetting.INC_BODY, true, false];
ZmMailApp.INC_MAP[ZmSetting.INC_BODY_HDR]		= [ZmSetting.INC_BODY, false, true];
ZmMailApp.INC_MAP[ZmSetting.INC_BODY_PRE_HDR]	= [ZmSetting.INC_BODY, true, true];
ZmMailApp.INC_MAP[ZmSetting.INC_SMART]			= [ZmSetting.INC_SMART, false, false];
ZmMailApp.INC_MAP[ZmSetting.INC_SMART_PRE]		= [ZmSetting.INC_SMART, true, false];
ZmMailApp.INC_MAP[ZmSetting.INC_SMART_HDR]		= [ZmSetting.INC_SMART, false, true];
ZmMailApp.INC_MAP[ZmSetting.INC_SMART_PRE_HDR]	= [ZmSetting.INC_SMART, true, true];

ZmMailApp.INC_MAP_REV = {};

AjxUtil.foreach(ZmMailApp.INC_MAP, function(v, i) {
	var key = (i == ZmSetting.INC_NONE || i == ZmSetting.INC_ATTACH) ?
		v[0] : v.join("|");
	ZmMailApp.INC_MAP_REV[key] = i;
});

ZmMailApp.GROUP_MAIL_BY_ITEM	= {};
ZmMailApp.GROUP_MAIL_BY_ITEM[ZmSetting.GROUP_BY_CONV]		= ZmItem.CONV;
ZmMailApp.GROUP_MAIL_BY_ITEM[ZmSetting.GROUP_BY_MESSAGE]	= ZmItem.MSG;

// Construction

ZmMailApp.prototype._defineAPI =
function() {
	AjxDispatcher.setPackageLoadFunction("MailCore", new AjxCallback(this, this._postLoadCore));
	AjxDispatcher.setPackageLoadFunction("Mail", new AjxCallback(this, this._postLoad, ZmOrganizer.FOLDER));
	AjxDispatcher.registerMethod("Compose", ["MailCore", "Mail"], new AjxCallback(this, this.compose));
	AjxDispatcher.registerMethod("GetComposeController", ["MailCore", "Mail"], new AjxCallback(this, this.getComposeController));
	AjxDispatcher.registerMethod("GetConvController", ["MailCore", "Mail"], new AjxCallback(this, this.getConvController));
	AjxDispatcher.registerMethod("GetConvListController", ["MailCore", "Mail"], new AjxCallback(this, this.getConvListController));
	AjxDispatcher.registerMethod("GetMsgController", ["MailCore", "Mail"], new AjxCallback(this, this.getMsgController));
	AjxDispatcher.registerMethod("GetTradController", ["MailCore", "Mail"], new AjxCallback(this, this.getTradController));
	AjxDispatcher.registerMethod("GetMailListController", "MailCore", new AjxCallback(this, this.getMailListController));
	AjxDispatcher.registerMethod("GetIdentityCollection", "MailCore", new AjxCallback(this, this.getIdentityCollection));
	AjxDispatcher.registerMethod("GetSignatureCollection", "MailCore", new AjxCallback(this, this.getSignatureCollection));
	AjxDispatcher.registerMethod("GetDataSourceCollection", "MailCore", new AjxCallback(this, this.getDataSourceCollection));
	AjxDispatcher.registerMethod("GetMailConfirmController", ["MailCore","Mail"], new AjxCallback(this, this.getConfirmController));
};

ZmMailApp.prototype._registerSettings =
function(settings) {
	var settings = settings || appCtxt.getSettings();
	settings.registerSetting("ALLOW_ANY_FROM_ADDRESS",			{name:"zimbraAllowAnyFromAddress", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("AUTO_READ_RECEIPT_ENABLED",		{name:"zimbraPrefMailRequestReadReceipts", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("AUTO_SAVE_DRAFT_INTERVAL",		{name:"zimbraPrefAutoSaveDraftInterval", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LDAP_TIME, defaultValue:ZmMailApp.DEFAULT_AUTO_SAVE_DRAFT_INTERVAL, isGlobal:true});
    settings.registerSetting("COLLAPSE_IMAP_TREES",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("COLOR_MESSAGES",					{name:"zimbraPrefColorMessagesEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal:true});
	settings.registerSetting("COMPOSE_SAME_FORMAT",				{name:"zimbraPrefForwardReplyInOriginalFormat", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("CONVERSATIONS_ENABLED",			{name:"zimbraFeatureConversationsEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("CONVERSATION_ORDER",				{name:"zimbraPrefConversationOrder", type:ZmSetting.T_PREF, defaultValue:ZmSearch.DATE_DESC, isImplicit:true});
	settings.registerSetting("CONVERSATION_PAGE_SIZE",			{type:ZmSetting.T_PREF, dataType:ZmSetting.D_INT, defaultValue:250, isGlobal:true});
    settings.registerSetting("CONV_SHOW_CALENDAR",			    {name:"zimbraPrefConvShowCalendar", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isImplicit:true});
 	settings.registerSetting("DEDUPE_MSG_TO_SELF",				{name:"zimbraPrefDedupeMessagesSentToSelf", type:ZmSetting.T_PREF, defaultValue:ZmSetting.DEDUPE_NONE});
    settings.registerSetting("DEDUPE_MSG_ENABLED",				{name:"zimbraPrefMessageIdDedupingEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    settings.registerSetting("DEFAULT_DISPLAY_NAME",			{type:ZmSetting.T_PSEUDO, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("DETACH_COMPOSE_ENABLED",			{name:"zimbraFeatureComposeInNewWindowEnabled",type:ZmSetting.T_PREF,dataType:ZmSetting.D_BOOLEAN,defaultValue:true});
	settings.registerSetting("DETACH_MAILVIEW_ENABLED",			{name:"zimbraFeatureOpenMailInNewWindowEnabled",type:ZmSetting.T_PREF,dataType:ZmSetting.D_BOOLEAN,defaultValue:true});
	settings.registerSetting("DISPLAY_EXTERNAL_IMAGES",			{name:"zimbraPrefDisplayExternalImages", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("END_DATE_ENABLED",				{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("FILTERS_ENABLED",					{name:"zimbraFeatureFiltersEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("FILTERS_MAIL_FORWARDING_ENABLED",	{name:"zimbraFeatureMailForwardingInFiltersEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("FORWARD_INCLUDE_HEADERS",			{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	settings.registerSetting("FORWARD_INCLUDE_ORIG",			{name:"zimbraPrefForwardIncludeOriginalText", type:ZmSetting.T_PREF, defaultValue:ZmSetting.INC_BODY, isGlobal:true});
	settings.registerSetting("FORWARD_INCLUDE_WHAT",			{type:ZmSetting.T_PREF, defaultValue:ZmSetting.INC_BODY, isGlobal:true});
	settings.registerSetting("FORWARD_MENU_ENABLED",			{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("FORWARD_USE_PREFIX",				{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("GROUP_MAIL_BY",					{name:"zimbraPrefGroupMailBy", type:ZmSetting.T_PREF, defaultValue:ZmSetting.GROUP_BY_MESSAGE, isImplicit:true, isGlobal:true});
	settings.registerSetting("HIGHLIGHT_OBJECTS",               {name:"zimbraMailHighlightObjectsMaxSize", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:70});
	settings.registerSetting("HTML_SIGNATURE_ENABLED",			{type:ZmSetting.T_PREF,dataType:ZmSetting.D_BOOLEAN,defaultValue:true});
	settings.registerSetting("IDENTITIES_ENABLED",				{name:"zimbraFeatureIdentitiesEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("INITIAL_SEARCH",					{name:"zimbraPrefMailInitialSearch", type:ZmSetting.T_PREF, defaultValue:"in:inbox"});
	settings.registerSetting("INITIAL_SEARCH_ENABLED",			{name:"zimbraFeatureInitialSearchPreferenceEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("MAIL_ATTACH_VIEW_ENABLED",		{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("MAIL_BLACKLIST",					{type: ZmSetting.T_PREF, dataType: ZmSetting.D_LIST});
    settings.registerSetting("TRUSTED_ADDR_LIST",			    {name:"zimbraPrefMailTrustedSenderList", type: ZmSetting.T_COS, dataType: ZmSetting.D_LIST});
	settings.registerSetting("TRUSTED_ADDR_LIST_MAX_NUM_ENTRIES",	{name:"zimbraMailTrustedSenderListMaxNumEntries", type: ZmSetting.T_COS, dataType: ZmSetting.D_INT, defaultValue:100});
	settings.registerSetting("MAIL_ACTIVITYSTREAM_FOLDER",   	{name:"zimbraMailActivityStreamFolder", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_INT, isImplicit:true, section:ZmSetting.M_IMPLICIT});
	settings.registerSetting("MAIL_BLACKLIST_MAX_NUM_ENTRIES",	{name:"zimbraMailBlacklistMaxNumEntries", type: ZmSetting.T_COS, dataType: ZmSetting.D_INT, defaultValue:100});
	settings.registerSetting("MAIL_FOLDER_COLORS_ENABLED",		{name:"zimbraPrefFolderColorEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("MAIL_FORWARDING_ADDRESS",			{name:"zimbraPrefMailForwardingAddress", type:ZmSetting.T_PREF});
	settings.registerSetting("MAIL_FORWARDING_ENABLED",			{name:"zimbraFeatureMailForwardingEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("MAIL_MANDATORY_SPELLCHECK",		{name:"zimbraPrefMandatorySpellCheckEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("MAIL_FROM_ADDRESS",				{name:"zimbraPrefFromAddress", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LIST });
    settings.registerSetting("MAIL_FROM_ADDRESS_TYPE",			{name:"zimbraPrefFromAddressType", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:"sendAs" });
	settings.registerSetting("MAIL_LIFETIME_GLOBAL",			{name:"zimbraMailMessageLifetime", type:ZmSetting.T_COS, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_INBOX_READ",		{name:"zimbraPrefInboxReadLifetime", type:ZmSetting.T_PREF, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_INBOX_UNREAD",		{name:"zimbraPrefInboxUnreadLifetime", type:ZmSetting.T_PREF, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_JUNK",				{name:"zimbraPrefJunkLifetime", type:ZmSetting.T_PREF, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_JUNK_GLOBAL",		{name:"zimbraMailSpamLifetime", type:ZmSetting.T_COS, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_SENT",				{name:"zimbraPrefSentLifetime", type:ZmSetting.T_PREF, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_TRASH",				{name:"zimbraPrefTrashLifetime", type:ZmSetting.T_PREF, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LIFETIME_TRASH_GLOBAL",		{name:"zimbraMailTrashLifetime", type:ZmSetting.T_COS, defaultValue:"0"}); // dataType: DURATION
	settings.registerSetting("MAIL_LOCAL_DELIVERY_DISABLED",	{name:"zimbraPrefMailLocalDeliveryDisabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("MAIL_NOTIFY_ALL",				    {name:"zimbraPrefShowAllNewMailNotifications", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("MAIL_NOTIFY_SOUNDS",				{name:"zimbraPrefMailSoundsEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("MAIL_NOTIFY_APP",					{name:"zimbraPrefMailFlashIcon", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("MAIL_NOTIFY_BROWSER",				{name:"zimbraPrefMailFlashTitle", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("MAIL_NOTIFY_TOASTER",				{name:"zimbraPrefMailToasterEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("MAIL_PRIORITY_ENABLED",			{name:"zimbraFeatureMailPriorityEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("MAIL_READ_RECEIPT_ENABLED",		{name:"zimbraFeatureReadReceiptsEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("MAIL_SEND_LATER_ENABLED",			{name:"zimbraFeatureMailSendLaterEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("MAIL_SEND_READ_RECEIPTS",			{name:"zimbraPrefMailSendReadReceipts", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:"never"});
	settings.registerSetting("MAIL_WHITELIST",					{type: ZmSetting.T_PREF, dataType: ZmSetting.D_LIST});
	settings.registerSetting("MAIL_WHITELIST_MAX_NUM_ENTRIES",	{name:"zimbraMailWhitelistMaxNumEntries", type: ZmSetting.T_COS, dataType: ZmSetting.D_INT, defaultValue:100});
	settings.registerSetting("MARK_MSG_READ",					{name:"zimbraPrefMarkMsgRead", type:ZmSetting.T_PREF, dataType:ZmSetting.D_INT, defaultValue:0, isGlobal:true});
	settings.registerSetting("MAX_MESSAGE_SIZE",				{type:ZmSetting.T_PREF, defaultValue:ZmMailApp.DEFAULT_MAX_MESSAGE_SIZE});
	settings.registerSetting("NEW_WINDOW_COMPOSE",				{name:"zimbraPrefComposeInNewWindow", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	settings.registerSetting("NOTIF_ADDRESS",					{name:"zimbraPrefNewMailNotificationAddress", type:ZmSetting.T_PREF});
	settings.registerSetting("NOTIF_ENABLED",					{name:"zimbraPrefNewMailNotificationEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("NOTIF_FEATURE_ENABLED",			{name:"zimbraFeatureNewMailNotificationEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("OPEN_MAIL_IN_NEW_WIN",			{name:"zimbraPrefOpenMailInNewWindow", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("POP_ENABLED",						{name:"zimbraPop3Enabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:!appCtxt.isOffline});
	settings.registerSetting("POP_DOWNLOAD_SINCE_VALUE",		{type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:""});
    settings.registerSetting("POP_DOWNLOAD_SINCE",				{name:"zimbraPrefPop3DownloadSince", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:""});
    settings.registerSetting("POP_DELETE_OPTION",				{name:"zimbraPrefPop3DeleteOption", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmMailApp.POP_DELETE_OPTION_HARD_DELETE});
    settings.registerSetting("POP_INCLUDE_SPAM",				{name:"zimbraPrefPop3IncludeSpam", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("READING_PANE_LOCATION",			{name:"zimbraPrefReadingPaneLocation", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmSetting.RP_BOTTOM, isImplicit:true, isGlobal:true});
	settings.registerSetting("READING_PANE_LOCATION_CV",		{name:"zimbraPrefConvReadingPaneLocation", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmSetting.RP_BOTTOM, isImplicit:true});
	settings.registerSetting("READING_PANE_SASH_HORIZONTAL",    {name:"zimbraPrefReadingPaneSashHorizontal", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_INT, isImplicit:true, section:ZmSetting.M_IMPLICIT});
	settings.registerSetting("READING_PANE_SASH_VERTICAL",      {name:"zimbraPrefReadingPaneSashVertical", type:ZmSetting.T_METADATA, dataType:ZmSetting.D_INT, isImplicit:true, section:ZmSetting.M_IMPLICIT});
	settings.registerSetting("REPLY_INCLUDE_HEADERS",			{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	settings.registerSetting("REPLY_INCLUDE_ORIG",				{name:"zimbraPrefReplyIncludeOriginalText", type:ZmSetting.T_PREF, defaultValue:ZmSetting.INC_BODY, isGlobal:true});
	settings.registerSetting("REPLY_INCLUDE_WHAT",				{type:ZmSetting.T_PREF, defaultValue:ZmSetting.INC_BODY, isGlobal:true});
	settings.registerSetting("REPLY_MENU_ENABLED",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("REPLY_PREFIX",					{name:"zimbraPrefForwardReplyPrefixChar", type:ZmSetting.T_PREF, defaultValue:">", isGlobal:true});
	settings.registerSetting("REPLY_TO_ADDRESS",				{name:"zimbraPrefReplyToAddress", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LIST });
	settings.registerSetting("REPLY_TO_ENABLED",				{name:"zimbraPrefReplyToEnabled", type:ZmSetting.T_PREF}); // XXX: Is this a list or single?
	settings.registerSetting("REPLY_USE_PREFIX",				{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("SAVE_DRAFT_ENABLED",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    settings.registerSetting("SAVE_TO_IMAP_SENT",				{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("SAVE_TO_SENT",					{name:"zimbraPrefSaveToSent", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	settings.registerSetting("SAVE_TO_SENT_DELEGATED_TARGET",	{name: "zimbraPrefDelegatedSendSaveTarget", type: ZmSetting.T_PREF, defaultValue: "owner", isGlobal: true});
	settings.registerSetting("SELECT_AFTER_DELETE",				{name:"zimbraPrefMailSelectAfterDelete", type:ZmSetting.T_PREF, defaultValue:ZmSetting.DELETE_SELECT_NEXT, isGlobal:true});
	settings.registerSetting("SENT_FOLDER_NAME",				{name:"zimbraPrefSentMailFolder", type:ZmSetting.T_PREF, defaultValue:"sent"});
	settings.registerSetting("SHOW_BCC",			            {type:ZmSetting.T_PREF, defaultValue:false});
    settings.registerSetting("SHOW_FRAGMENTS",					{name:"zimbraPrefShowFragments", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("SHOW_MAIL_CONFIRM",				{name:"zimbraFeatureConfirmationPageEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("SHOW_CHATS_FOLDER",				{name:"zimbraPrefShowChatsFolderInMail", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("SIGNATURE",						{name:"zimbraPrefMailSignature", type:ZmSetting.T_PREF});
	settings.registerSetting("SIGNATURE_ENABLED",				{name:"zimbraPrefMailSignatureEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("SIGNATURE_STYLE",					{name:"zimbraPrefMailSignatureStyle", type:ZmSetting.T_PREF, defaultValue:ZmSetting.SIG_OUTLOOK});
	settings.registerSetting("START_DATE_ENABLED",				{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("TAB_IN_EDITOR",			        {name:"zimbraPrefTabInEditorEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("USE_SEND_MSG_SHORTCUT",			{name:"zimbraPrefUseSendMsgShortcut", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
    settings.registerSetting("USER_FOLDERS_ENABLED",			{type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
    settings.registerSetting("VACATION_DURATION_ENABLED",		{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("VACATION_DURATION_ALL_DAY",		{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("VACATION_FROM",					{name:"zimbraPrefOutOfOfficeFromDate", type:ZmSetting.T_PREF, defaultValue:""});
    settings.registerSetting("VACATION_FROM_TIME",				{type:ZmSetting.T_PREF, defaultValue:""});
	settings.registerSetting("VACATION_MSG",					{name:"zimbraPrefOutOfOfficeReply", type:ZmSetting.T_PREF, defaultValue:""});
    settings.registerSetting("VACATION_EXTERNAL_TYPE",			{name:"zimbraPrefExternalSendersType", type:ZmSetting.T_PREF, defaultValue:"ALL"});
    settings.registerSetting("VACATION_EXTERNAL_SUPPRESS",	    {name:"zimbraPrefOutOfOfficeSuppressExternalReply", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("VACATION_CALENDAR_TYPE",			{name:"zimbraPrefOutOfOfficeFreeBusyStatus", type:ZmSetting.T_PREF, defaultValue:"OUTOFOFFICE"});
	settings.registerSetting("VACATION_CALENDAR_APPT_ID",		{name:"zimbraPrefOutOfOfficeCalApptID", type:ZmSetting.T_METADATA, defaultValue:"-1", isImplicit:true, section:ZmSetting.M_IMPLICIT});
    settings.registerSetting("VACATION_CALENDAR_ENABLED",		{type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("VACATION_EXTERNAL_MSG",			{name:"zimbraPrefOutOfOfficeExternalReply", type:ZmSetting.T_PREF, defaultValue:""});
	settings.registerSetting("VACATION_MSG_ENABLED",			{name:"zimbraPrefOutOfOfficeReplyEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("VACATION_EXTERNAL_MSG_ENABLED",	{name:"zimbraPrefOutOfOfficeExternalReplyEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
    settings.registerSetting("VACATION_MSG_REMIND_ON_LOGIN",	{name:"zimbraPrefOutOfOfficeStatusAlertOnLogin", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("VACATION_MSG_FEATURE_ENABLED",	{name:"zimbraFeatureOutOfOfficeReplyEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("VACATION_UNTIL",					{name:"zimbraPrefOutOfOfficeUntilDate", type:ZmSetting.T_PREF, defaultValue:""});
    settings.registerSetting("VACATION_UNTIL_TIME",				{type:ZmSetting.T_PREF, defaultValue:""});
};

ZmMailApp.prototype._registerPrefs =
function() {
	var sections = {
		MAIL: {
			title: ZmMsg.mail,
			icon: "MailApp",
			templateId: "prefs.Pages#Mail",
			priority: 10,
			precondition: ZmSetting.MAIL_PREFERENCES_ENABLED,
			prefs: [
				ZmSetting.AUTO_READ_RECEIPT_ENABLED,
				ZmSetting.DEDUPE_MSG_TO_SELF,
                ZmSetting.DEDUPE_MSG_ENABLED,
				ZmSetting.DISPLAY_EXTERNAL_IMAGES,
				ZmSetting.GET_MAIL_ACTION,
				ZmSetting.INITIAL_SEARCH,
				ZmSetting.MAIL_BLACKLIST,
				ZmSetting.MAIL_FORWARDING_ADDRESS,
				ZmSetting.MAIL_LIFETIME_INBOX_READ,
				ZmSetting.MAIL_LIFETIME_INBOX_UNREAD,
				ZmSetting.MAIL_LIFETIME_JUNK,
				ZmSetting.MAIL_LIFETIME_SENT,
				ZmSetting.MAIL_LIFETIME_TRASH,
				ZmSetting.MAIL_LOCAL_DELIVERY_DISABLED,
				ZmSetting.MAIL_NOTIFY_SOUNDS,
				ZmSetting.MAIL_NOTIFY_ALL,
				ZmSetting.MAIL_NOTIFY_APP,
				ZmSetting.MAIL_NOTIFY_BROWSER,
				ZmSetting.MAIL_NOTIFY_TOASTER,
				ZmSetting.MAIL_WHITELIST,
				ZmSetting.MAIL_SEND_READ_RECEIPTS,
				ZmSetting.MARK_MSG_READ,
				ZmSetting.NOTIF_ADDRESS,
				ZmSetting.OFFLINE_NOTIFY_NEWMAIL_ON_INBOX,
				ZmSetting.OPEN_MAIL_IN_NEW_WIN,
				ZmSetting.PAGE_SIZE,
				ZmSetting.POP_DOWNLOAD_SINCE_VALUE,
				ZmSetting.POP_DOWNLOAD_SINCE,
                ZmSetting.POP_DELETE_OPTION,
                ZmSetting.POP_INCLUDE_SPAM,
				ZmSetting.POLLING_INTERVAL,
				ZmSetting.SELECT_AFTER_DELETE,
				ZmSetting.SHOW_FRAGMENTS,
				ZmSetting.COLOR_MESSAGES,
				ZmSetting.START_DATE_ENABLED,
                ZmSetting.VACATION_DURATION_ENABLED,
                ZmSetting.VACATION_DURATION_ALL_DAY,
				ZmSetting.VACATION_FROM,
                ZmSetting.VACATION_FROM_TIME,
                ZmSetting.VACATION_CALENDAR_ENABLED,
				ZmSetting.VACATION_MSG_ENABLED,
				ZmSetting.VACATION_MSG,
                ZmSetting.VACATION_EXTERNAL_MSG_ENABLED,
				ZmSetting.VACATION_EXTERNAL_MSG,
                ZmSetting.VACATION_EXTERNAL_TYPE,
                ZmSetting.VACATION_EXTERNAL_SUPPRESS,
                ZmSetting.VACATION_CALENDAR_TYPE,
				ZmSetting.VACATION_UNTIL,
                ZmSetting.VACATION_UNTIL_TIME,
				ZmSetting.VIEW_AS_HTML,
                ZmSetting.COMPOSE_AS_FORMAT,
				ZmSetting.COMPOSE_INIT_FONT_COLOR,
				ZmSetting.COMPOSE_INIT_FONT_FAMILY,
				ZmSetting.COMPOSE_INIT_FONT_SIZE,
				ZmSetting.FORWARD_INCLUDE_WHAT,
				ZmSetting.FORWARD_USE_PREFIX,
				ZmSetting.FORWARD_INCLUDE_HEADERS,
				ZmSetting.NEW_WINDOW_COMPOSE,
				ZmSetting.AUTO_SAVE_DRAFT_INTERVAL,
				ZmSetting.REPLY_INCLUDE_WHAT,
				ZmSetting.REPLY_USE_PREFIX,
				ZmSetting.REPLY_INCLUDE_HEADERS,
				ZmSetting.REPLY_PREFIX,
				ZmSetting.SAVE_TO_SENT,
				ZmSetting.TAB_IN_EDITOR,
				ZmSetting.USE_SEND_MSG_SHORTCUT,
                ZmSetting.COMPOSE_SAME_FORMAT,
                ZmSetting.MAIL_MANDATORY_SPELLCHECK
			],
			manageDirty: true,
			createView: function(parent, section, controller) {
				AjxDispatcher.require("Alert");
				return new ZmMailPrefsPage(parent, section, controller);
			}
		}
	};

	for (var id in sections) {
		ZmPref.registerPrefSection(id, sections[id]);
	}

	ZmPref.registerPref("ACCOUNTS", {
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

	ZmPref.registerPref("AUTO_SAVE_DRAFT_INTERVAL", {
		displayName:		ZmMsg.autoSaveDrafts,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		options:			[0, ZmMailApp.DEFAULT_AUTO_SAVE_DRAFT_INTERVAL]
	});

    ZmPref.registerPref("AUTO_READ_RECEIPT_ENABLED", {
		displayName:		ZmMsg.autoReadReceiptRequest,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("USE_SEND_MSG_SHORTCUT", {
		displayFunc:        this.formatKeySeq.bind(this, AjxMessageFormat.format(ZmMsg.useSendMsgShortcut,[ZmKeys["compose.Send.display"]])),
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("DEDUPE_MSG_TO_SELF", {
		displayName:		ZmMsg.removeDupesToSelf,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayOptions:		[ZmMsg.dedupeNone, ZmMsg.dedupeSecondCopy, ZmMsg.dedupeAll],
		options:			[ZmSetting.DEDUPE_NONE, ZmSetting.DEDUPE_SECOND, ZmSetting.DEDUPE_ALL]
	});

    ZmPref.registerPref("DEDUPE_MSG_ENABLED", {
		displayName:		ZmMsg.autoDeleteDedupeMsg,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("DISPLAY_EXTERNAL_IMAGES", {
		displayName:		ZmMsg.showExternalImages,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("END_DATE_ENABLED", {
		displayName:		ZmMsg.endOn,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED
	});

	ZmPref.registerPref("INITIAL_SEARCH", {
		displayName:		ZmMsg.initialMailSearch,
		displayContainer:	ZmPref.TYPE_INPUT,
		maxLength:			ZmPref.MAX_LENGTH[ZmSetting.INITIAL_SEARCH],
		errorMessage:       AjxMessageFormat.format(ZmMsg.invalidInitialSearch, ZmPref.MAX_LENGTH[ZmSetting.INITIAL_SEARCH]),
		precondition:		ZmSetting.INITIAL_SEARCH_ENABLED
	});

	ZmPref.registerPref("MAIL_BLACKLIST", {
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

    ZmPref.registerPref("TRUSTED_ADDR_LIST", {
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

	ZmPref.registerPref("MAIL_FORWARDING_ADDRESS", {
		displayName:		ZmMsg.mailForwardingAddress,
		displayContainer:	ZmPref.TYPE_INPUT,
		validationFunction: ZmMailApp.validateForwardEmail,
		errorMessage:       ZmMsg.invalidEmail,
		precondition:		ZmSetting.MAIL_FORWARDING_ENABLED,
		hint:				ZmMsg.enterEmailAddress
	});

	ZmPref.registerPref("MAIL_LIFETIME_INBOX_READ", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		[ ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationDays,
							  ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationDays,
							  ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationNever ],
		options:			[ 30, 45, 60, 90, 120, 0 ],
		approximateFunction: ZmPref.approximateLifetimeInboxRead,
		displayFunction:	ZmPref.durationDay2Int,
		valueFunction:		ZmPref.int2DurationDay,
		validationFunction:	ZmPref.validateLifetime
	});

	ZmPref.registerPref("MAIL_LIFETIME_INBOX_UNREAD", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		[ ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationDays,
							  ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationDays,
							  ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationNever ],
		options:			[ 30, 45, 60, 90, 120, 0 ],
		approximateFunction: ZmPref.approximateLifetimeInboxUnread,
		displayFunction:	ZmPref.durationDay2Int,
		valueFunction:		ZmPref.int2DurationDay,
		validationFunction:	ZmPref.validateLifetime
	});

	ZmPref.registerPref("MAIL_LIFETIME_JUNK", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		ZmMsg.lifetimeDurationDays,
		options:			[ 1, 3, 7, 30 ],
		approximateFunction: ZmPref.approximateLifetimeJunk,
		displayFunction:	ZmPref.durationDay2Int,
		valueFunction:		ZmPref.int2DurationDay,
		validationFunction:	ZmPref.validateLifetimeJunk
	});

	ZmPref.registerPref("MAIL_LIFETIME_SENT", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		[ ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationDays,
							  ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationDays,
							  ZmMsg.lifetimeDurationDays, ZmMsg.lifetimeDurationNever ],
		options:			[ 30, 45, 60, 90, 120, 0 ],
		approximateFunction: ZmPref.approximateLifetimeSent,
		displayFunction:	ZmPref.durationDay2Int,
		valueFunction:		ZmPref.int2DurationDay,
		validationFunction:	ZmPref.validateLifetime
	});

	ZmPref.registerPref("MAIL_LIFETIME_TRASH", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		ZmMsg.lifetimeDurationDays,
		options:			[ 1, 3, 7, 30 ],
		approximateFunction: ZmPref.approximateLifetimeTrash,
		displayFunction:	ZmPref.durationDay2Int,
		valueFunction:		ZmPref.int2DurationDay,
		validationFunction:	ZmPref.validateLifetimeTrash
	});

	ZmPref.registerPref("MAIL_LOCAL_DELIVERY_DISABLED", {
		displayName:		ZmMsg.mailDeliveryDisabled,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		ZmSetting.MAIL_FORWARDING_ENABLED,
		validationFunction:	ZmMailApp.validateMailLocalDeliveryDisabled,
		errorMessage:		ZmMsg.errorMissingFwdAddr
	});

	ZmPref.registerPref("MAIL_NOTIFY_ALL", {
		displayName:		ZmMsg.messageNotificationFoldersLabel,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_VERTICAL,
		displayOptions:		[ ZmMsg.messageNotificationFoldersInbox, ZmMsg.messageNotificationFoldersAll ],
		options:			[ false, true ]
	});

	ZmPref.registerPref("MAIL_NOTIFY_SOUNDS", {
		displayName:		ZmMsg.playSound,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("MAIL_NOTIFY_APP", {
		displayName:		ZmMsg.flashMailAppTab,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("MAIL_NOTIFY_BROWSER", {
		displayName:		ZmMsg.flashBrowser,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("MAIL_SEND_READ_RECEIPTS", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayOptions:		[	ZmMsg.readReceiptNever,
								ZmMsg.readReceiptAlways,
								ZmMsg.readReceiptAsk
							],
		options:			[ 	ZmMailApp.SEND_RECEIPT_NEVER,
								ZmMailApp.SEND_RECEIPT_ALWAYS,
								ZmMailApp.SEND_RECEIPT_PROMPT
							],
		precondition:		ZmSetting.MAIL_READ_RECEIPT_ENABLED
	});

	ZmPref.registerPref("MAIL_WHITELIST", {
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

	ZmPref.registerPref("NOTIF_ADDRESS", {
		displayName:		ZmMsg.mailNotifAddress,
		displayContainer:	ZmPref.TYPE_INPUT,
		validationFunction: ZmPref.validateEmail,
		errorMessage:       ZmMsg.invalidEmail,
		precondition:		ZmSetting.NOTIF_FEATURE_ENABLED,
		hint:				ZmMsg.enterEmailAddress,
		setFunction:        ZmPref.setMailNotificationAddressValue
	});

	ZmPref.registerPref("OPEN_MAIL_IN_NEW_WIN", {
		displayName:		ZmMsg.openMailNewWin,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:		ZmSetting.DETACH_MAILVIEW_ENABLED
	});

	ZmPref.registerPref("POP_DOWNLOAD_SINCE_VALUE", {
		displayContainer:	ZmPref.TYPE_STATIC,
		precondition:		ZmSetting.POP_ENABLED
	});
	ZmPref.registerPref("POP_DOWNLOAD_SINCE", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayOptions:		[	ZmMsg.externalAccessPopDownloadAll,
								"*** NOT SHOWN ***",
								ZmMsg.externalAccessPopDownloadFromNow
							],
		options:			[	ZmMailApp.POP_DOWNLOAD_SINCE_ALL,
								ZmMailApp.POP_DOWNLOAD_SINCE_NO_CHANGE,
								ZmMailApp.POP_DOWNLOAD_SINCE_FROM_NOW
							],
		displayFunction:	ZmPref.downloadSinceDisplay,
		valueFunction:		ZmPref.downloadSinceValue,
		precondition:		ZmSetting.POP_ENABLED
	});
	ZmPref.registerPref("POP_DELETE_OPTION", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayOptions:     [   ZmMsg.popDeleteHardDelete,
                                ZmMsg.popDeleteTrash,
                                ZmMsg.popDeleteRead,
                                ZmMsg.popDeleteKeep
                            ],
		options:            [   ZmMailApp.POP_DELETE_OPTION_HARD_DELETE,
                                ZmMailApp.POP_DELETE_OPTION_TRASH,
                                ZmMailApp.POP_DELETE_OPTION_READ,
                                ZmMailApp.POP_DELETE_OPTION_KEEP
                            ],
		precondition:       ZmSetting.POP_ENABLED
	});
	ZmPref.registerPref("POP_INCLUDE_SPAM", {
		displayName:		ZmMsg.popIncludeSpam,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});
    ZmPref.registerPref("REPLY_TO_ADDRESS", {
		displayName:		ZmMsg.replyToAddress,
		displayContainer:	ZmPref.TYPE_INPUT,
		validationFunction: ZmPref.validateEmail,
		errorMessage:       ZmMsg.invalidEmail
	});

	ZmPref.registerPref("SELECT_AFTER_DELETE", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_VERTICAL,
		displayOptions: 	[ZmMsg.selectNext, ZmMsg.selectPrevious, ZmMsg.selectAdapt],
		options: 			[ZmSetting.DELETE_SELECT_NEXT, ZmSetting.DELETE_SELECT_PREV, ZmSetting.DELETE_SELECT_ADAPT]
	});

	ZmPref.registerPref("SIGNATURE", {
		displayName:		ZmMsg.signature,
		displayContainer:	ZmPref.TYPE_TEXTAREA,
		maxLength:			ZmPref.MAX_LENGTH[ZmSetting.SIGNATURE],
		errorMessage:       AjxMessageFormat.format(ZmMsg.invalidSignature, ZmPref.MAX_LENGTH[ZmSetting.SIGNATURE])
	});

	ZmPref.registerPref("SIGNATURE_ENABLED", {
		displayName:		ZmMsg.signatureEnabled,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("SIGNATURE_STYLE", {
		displayName:		ZmMsg.signatureStyle,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		orientation:		ZmPref.ORIENT_HORIZONTAL,
		displayOptions:		[ZmMsg.aboveQuotedText, ZmMsg.atBottomOfMessage],
		options:			[ZmSetting.SIG_OUTLOOK, ZmSetting.SIG_INTERNET]
	});

	ZmPref.registerPref("SIGNATURES", {
		displayContainer:	ZmPref.TYPE_CUSTOM,
        initFunction: ZmPref.regenerateSignatureEditor
	});

	ZmPref.registerPref("START_DATE_ENABLED", {
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		displayName:		ZmMsg.startOn,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED
	});

    ZmPref.registerPref("TAB_IN_EDITOR", {
        displayName:        ZmMsg.tabInEditor,
        displayContainer:	ZmPref.TYPE_CHECKBOX
    });

    ZmPref.registerPref("VACATION_DURATION_ENABLED", {
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		displayName:		ZmMsg.oooDurationLabel,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED
	});

    ZmPref.registerPref("VACATION_DURATION_ALL_DAY", {
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		displayName:		ZmMsg.oooAllDayDurationLabel,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED
	});

    ZmPref.registerPref("VACATION_CALENDAR_ENABLED", {
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		displayName:		ZmMsg.vacationCalLabel,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED
	});

	ZmPref.registerPref("VACATION_FROM", {
		displayName:		ZmMsg.startDate,
		displayContainer:	ZmPref.TYPE_INPUT,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED,
		displayFunction:	AjxDateUtil.dateGMT2Local,
		valueFunction:		AjxDateUtil.dateLocal2GMT
	});

    ZmPref.registerPref("VACATION_UNTIL", {
		displayName:		ZmMsg.endDate,
		displayContainer:	ZmPref.TYPE_INPUT,
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED,
		displayFunction:	AjxDateUtil.dateGMT2Local,
		valueFunction:		AjxDateUtil.dateLocal2GMT
	});

    ZmPref.registerPref("VACATION_MSG", {
		displayName:		ZmMsg.awayMessage,
		displayContainer:	ZmPref.TYPE_TEXTAREA,
		maxLength:			ZmPref.MAX_LENGTH[ZmSetting.AWAY_MESSAGE],
		errorMessage:       AjxMessageFormat.format(ZmMsg.invalidAwayMessage, ZmPref.MAX_LENGTH[ZmSetting.AWAY_MESSAGE]),
		precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED,
		validationFunction:	ZmMailApp.validateVacationMsg
	});

	ZmPref.registerPref("VACATION_MSG_ENABLED", {
		displayName:		ZmMsg.outOfOffice,
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
        orientation:		ZmPref.ORIENT_VERTICAL,
		errorMessage:		ZmMsg.missingAwayMessage,
		displayOptions:		[ZmMsg.noAutoReplyMessage, ZmMsg.autoReplyMessage],
		options:			[false, true],
        inputId:            ["VACATION_MSG_DISABLED", "VACATION_MSG_ENABLED"]
	});

    ZmPref.registerPref("VACATION_EXTERNAL_TYPE", {  // The inside content been left empty, as we just need to register this pref with settings.
    });                                              // Depending upon the option the user has chosen in OOO vacation external select dropdown, on saving we add the relevant pref to the list that constructs the request, refer ZmPref.addOOOVacationExternalPrefToList

    ZmPref.registerPref("VACATION_EXTERNAL_SUPPRESS", {
        displayContainer:   ZmPref.TYPE_SELECT,
        displayOptions:     [ZmMsg.vacationExternalAllStandard, ZmMsg.vacationExternalAllCustom, ZmMsg.vacationExternalAllExceptABCustom, ZmMsg.vacationExternalReplySuppress],
        options:            [false, false, false, true],
        initFunction:       ZmPref.initOOOVacationExternalSuppress,
        setFunction:        ZmPref.addOOOVacationExternalPrefOnSave,
        changeFunction:     ZmPref.handleOOOVacationExternalOptionChange,
        validationFunction:	ZmMailApp.validateExternalVacationMsg,
        errorMessage:		ZmMsg.missingAwayMessage
    });

    ZmPref.registerPref("VACATION_CALENDAR_TYPE", {
		displayName:		ZmMsg.vacationExternalType,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		[ZmMsg.outOfOffice,ZmMsg.busy],
		options:			 ["OUTOFOFFICE","BUSY"]
	});

    ZmPref.registerPref("VACATION_EXTERNAL_MSG", {
		displayName:		ZmMsg.externalAwayMessage,
		displayContainer:	ZmPref.TYPE_TEXTAREA,
		maxLength:			ZmPref.MAX_LENGTH[ZmSetting.AWAY_MESSAGE],
        precondition:		ZmSetting.VACATION_MSG_FEATURE_ENABLED
	});

	ZmPref.registerPref("VACATION_EXTERNAL_MSG_ENABLED", {  // The content been left empty, as we just need to register this pref with settings.
    });                                                     // Depending upon the option the user has chosen in OOO external select dropdown, on saving we add the relevant pref to the list that constructs the request, refer ZmPref.addOOOVacationExternalPrefToList

	AjxDispatcher.require("Alert");
	var notifyText = ZmDesktopAlert.getInstance().getDisplayText();
	ZmPref.registerPref("MAIL_NOTIFY_TOASTER", {
		displayFunc:		function() { return notifyText; },
		precondition:		!!notifyText,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	if (appCtxt.isOffline) {
		ZmPref.registerPref("OFFLINE_NOTIFY_NEWMAIL_ON_INBOX", {
			displayContainer:	ZmPref.TYPE_RADIO_GROUP,
			displayOptions:		[ZmMsg.notifyNewMailOnInbox, ZmMsg.notifyNewMailOnAny],
			options:			[true, false]
		});
	}
};

ZmMailApp.prototype.formatKeySeq = function(keySeq) {
	// Make sure the modifierKey list is created.  This will create the modifierKeys and cache them, but not display them
	new ZmShortcutList({cols:[]});
	return ZmShortcutList._formatDisplay(keySeq);
}

/**
 * @private
 */
ZmMailApp.validateForwardEmail =
function(emailStr) {
	if (!emailStr || emailStr == "") {
		var section = ZmPref.getPrefSectionWithPref(ZmSetting.MAIL_FORWARDING_ADDRESS);
		if (!section) { return false; }
		var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView();
		var checkbox = view.getView(section.id).getFormObject(ZmSetting.MAIL_LOCAL_DELIVERY_DISABLED);
		if (checkbox && checkbox.isSelected()) {
			checkbox.setSelected(false);
		}
	}
	return ZmPref.validateEmail(emailStr);
};

/**
 * @private
 */
ZmMailApp.validateMailLocalDeliveryDisabled =
function(checked) {
	if (!checked) { return true; }
	var section = ZmPref.getPrefSectionWithPref(ZmSetting.MAIL_FORWARDING_ADDRESS);
	if (!section) { return false; }
	var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView();
	var input = view.getView(section.id).getFormObject(ZmSetting.MAIL_FORWARDING_ADDRESS);
	return (input != null && input.isValid());
};

/**
 * Make sure the server won't be sending out a blank away msg for the user. Check for a
 * combination of an empty away msg and a checked box for "send away message". Since a
 * pref is validated only if it changes, we have to have validation functions for both
 * prefs.
 *
 * @private
 */
ZmMailApp.validateVacationMsg =
function(awayMsg) {
	if (awayMsg && (awayMsg.length > 0)) { return true; }
	var section = ZmPref.getPrefSectionWithPref(ZmSetting.VACATION_MSG_ENABLED);
	if (!section) { return false; }
	var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView();
	var input = view.getView(section.id).getFormObject(ZmSetting.VACATION_MSG_ENABLED);
    var isValid = (input && !(input.getSelectedValue() == "true"));
    if (!isValid)
        ZmPref.SETUP["VACATION_MSG"].errorMessage = ZmMsg.missingAwayMessage;

	return isValid
};

/**
 * @private
 */
ZmMailApp.validateVacationMsgEnabled =
function(checked) {
    if (!checked) { return true; }
    var section = ZmPref.getPrefSectionWithPref(ZmSetting.VACATION_MSG);
    if (!section) { return false; }
    var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView();
    var input = view.getView(section.id).getFormObject(ZmSetting.VACATION_MSG);
    if (!input) { return false; }
    var awayMsg = input.getValue();
    return (awayMsg && (awayMsg.length > 0));
};

/**
 * Make sure the server won't be sending out a blank away msg for the external user.
 * We are ignoring this validation in two cases :
 * a) when 'Do not send auto replies' radio button is selected
 * b) in OOO vacation external sender type, first and last option is selected, as in this case the
 * OOO external message container is not visible
 * @private
 */
ZmMailApp.validateExternalVacationMsg =
function() {
    var section = ZmPref.getPrefSectionWithPref(ZmSetting.VACATION_MSG_ENABLED);
    if (!section) { return false; }
    var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView().getView(section.id);
    var cbox = view.getFormObject(ZmSetting.VACATION_MSG_ENABLED);
    if (cbox && cbox.getSelectedValue()==="false"){ // 'Do not send auto replies' radio button is selected ..
        return true;
    }
    var externalSelect =  view.getFormObject(ZmSetting.VACATION_EXTERNAL_SUPPRESS);
    var selectOptionValue = externalSelect.getText();
    if (selectOptionValue.indexOf(ZmMsg.vacationExternalAllStandard) >=0 || selectOptionValue.indexOf(ZmMsg.vacationExternalReplySuppress) >=0) {
        return true;
    }
    var externalTxtArea = view.getFormObject(ZmSetting.VACATION_EXTERNAL_MSG);
    var awayMsg = externalTxtArea.getValue();
    return (awayMsg && (awayMsg.length > 0));
};

/**
 * @private
 */
ZmMailApp.validateExternalVacationMsgEnabled =
function(checked) {
    if (!checked) { return true; }
    var section = ZmPref.getPrefSectionWithPref(ZmSetting.VACATION_EXTERNAL_MSG);
    if (!section) { return false; }
    var view = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController().getPrefsView();
    var input = view.getView(section.id).getFormObject(ZmSetting.VACATION_EXTERNAL_MSG);
    if (!input) { return false; }
    var awayMsg = input.getValue();
    return (awayMsg && (awayMsg.length > 0));
};

/**
 * @private
 */
ZmMailApp.prototype._registerOperations =
function() {
	ZmOperation.registerOp(ZmId.OP_ADD_FILTER_RULE, {textKey:"createFilter", image:"Plus"}, ZmSetting.FILTERS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_ADD_TO_FILTER_RULE, {textKey: "addToFilter", image: "MailRule"}, ZmSetting.FILTERS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_ADD_SIGNATURE, {textKey:"signature", image:"AddSignature", tooltipKey:"chooseSignature"}, ZmSetting.SIGNATURES_ENABLED);
	ZmOperation.registerOp(ZmId.OP_CHECK_MAIL, {textKey:"checkMail", tooltipKey:"checkMailPrefDefault", image:"Refresh", textPrecedence:90, showImageInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_CREATE_APPT, {textKey:"createAppt", image:"NewAppointment"}, ZmSetting.CALENDAR_ENABLED);
	ZmOperation.registerOp(ZmId.OP_CREATE_TASK, {textKey:"createTask", image:"NewTask"}, ZmSetting.TASKS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_DELETE_CONV, {textKey:"delConv", image:"DeleteConversation"}, ZmSetting.CONVERSATIONS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_DELETE_MSG, {textKey:"delMsg", image:"DeleteMessage"});
	ZmOperation.registerOp(ZmId.OP_DELETE_MENU, {textKey:"del", image:"Delete", tooltipKey:"deleteTooltip"});
	ZmOperation.registerOp(ZmId.OP_DETACH_COMPOSE, {tooltipKey:"detachComposeTooltip", image:"OpenInNewWindow"});
	ZmOperation.registerOp(ZmId.OP_DRAFT, null, ZmSetting.SAVE_DRAFT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_EDIT_FILTER_RULE, {textKey:"filterEdit", image:"Edit"}, ZmSetting.FILTERS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_FORWARD, {textKey:"forward", tooltipKey:"forwardTooltip", image:"Forward", shortcut:ZmKeyMap.FORWARD, textPrecedence:46});
	ZmOperation.registerOp(ZmId.OP_FORWARD_ATT, {textKey:"forwardAtt", tooltipKey:"forwardAtt", image:"Forward"});
	ZmOperation.registerOp(ZmId.OP_FORWARD_CONV, {textKey:"forwardConv", tooltipKey:"forwardConv", image:"Forward"});
	ZmOperation.registerOp(ZmId.OP_FORWARD_INLINE, {textKey:"forwardInline", tooltipKey:"forwardTooltip", image:"Forward"});
	ZmOperation.registerOp(ZmId.OP_INC_ATTACHMENT, {textKey:"includeMenuAttachment"});
    ZmOperation.registerOp(ZmId.OP_INC_BODY, {textKey:"includeMenuBody"});
	ZmOperation.registerOp(ZmId.OP_INC_NONE, {textKey:"includeMenuNone"});
	ZmOperation.registerOp(ZmId.OP_INC_SMART, {textKey:"includeMenuSmart"});
	ZmOperation.registerOp(ZmId.OP_INCLUDE_HEADERS, {textKey:"includeHeaders"});
	ZmOperation.registerOp(ZmId.OP_KEEP_READING, {textKey:"keepReading", tooltipKey:"keepReadingTooltip", shortcut:ZmKeyMap.KEEP_READING});
	ZmOperation.registerOp(ZmId.OP_MARK_READ, {textKey:"markAsRead", image:"ReadMessage", shortcut:ZmKeyMap.MARK_READ});
	ZmOperation.registerOp(ZmId.OP_MARK_UNREAD, {textKey:"markAsUnread", image:"UnreadMessage", shortcut:ZmKeyMap.MARK_UNREAD});
	ZmOperation.registerOp(ZmId.OP_FLAG, {textKey:"flag", image:"FlagRed", shortcut:ZmKeyMap.FLAG}, ZmSetting.FLAGGING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_UNFLAG, {textKey:"unflag", image:"FlagDis", shortcut:ZmKeyMap.FLAG}, ZmSetting.FLAGGING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_MOVE_DOWN_FILTER_RULE, {textKey:"filterMoveDown", image:"DownArrow"}, ZmSetting.FILTERS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_MOVE_TO_BCC, {textKey:"moveToBcc"});
	ZmOperation.registerOp(ZmId.OP_MOVE_TO_CC, {textKey:"moveToCc"});
	ZmOperation.registerOp(ZmId.OP_MOVE_TO_TO, {textKey:"moveToTo"});
	ZmOperation.registerOp(ZmId.OP_MOVE_UP_FILTER_RULE, {textKey:"filterMoveUp", image:"UpArrow"}, ZmSetting.FILTERS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_NEW_MESSAGE, {textKey:"newEmail", tooltipKey:"newMessageTooltip", image:"NewMessage", shortcut:ZmKeyMap.NEW_MESSAGE});
	ZmOperation.registerOp(ZmId.OP_NEW_MESSAGE_WIN, {textKey:"newEmail", tooltipKey:"newMessageTooltip", image:"NewMessage", shortcut:ZmKeyMap.NEW_MESSAGE_WIN});
	ZmOperation.registerOp(ZmId.OP_PRIORITY_HIGH, {textKey:"priorityHigh", image:"PriorityHigh_list"});
	ZmOperation.registerOp(ZmId.OP_PRIORITY_LOW, {textKey:"priorityLow", image:"PriorityLow_list"});
	ZmOperation.registerOp(ZmId.OP_PRIORITY_NORMAL, {textKey:"priorityNormal", image:"PriorityNormal_list"});
	ZmOperation.registerOp(ZmId.OP_REMOVE_FILTER_RULE, {textKey:"filterRemove", image:"Delete"}, ZmSetting.FILTERS_ENABLED);
    ZmOperation.registerOp(ZmId.OP_REDIRECT, {textKey:"mailRedirect", tooltipKey:"mailRedirectTooltip", image:"Redirect"});
	ZmOperation.registerOp(ZmId.OP_REPLY, {textKey:"reply", tooltipKey:"replyTooltip", image:"Reply", shortcut:ZmKeyMap.REPLY, textPrecedence:50});
	ZmOperation.registerOp(ZmId.OP_REPLY_ALL, {textKey:"replyAll", tooltipKey:"replyAllTooltip", image:"ReplyAll", shortcut:ZmKeyMap.REPLY_ALL, textPrecedence:48});
	ZmOperation.registerOp(ZmId.OP_REQUEST_READ_RECEIPT, {textKey:"requestReadReceipt", image:"ReadMessage"});
	ZmOperation.registerOp(ZmId.OP_RESET, {textKey:"reset", image:"Refresh", tooltipKey: "refreshFilters"});
	ZmOperation.registerOp(ZmId.OP_RUN_FILTER_RULE, {textKey:"filterRun", image:"SwitchFormat"}, [ ZmSetting.MAIL_ENABLED, ZmSetting.FILTERS_ENABLED ]);
	ZmOperation.registerOp(ZmId.OP_SAVE_DRAFT, {textKey:"saveDraft", tooltipKey:"saveDraftTooltip", image:"DraftFolder", shortcut:ZmKeyMap.SAVE}, ZmSetting.SAVE_DRAFT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SEND_MENU, {textKey:"send", tooltipKey:"sendTooltip", image:"Send"}, ZmSetting.SAVE_DRAFT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SEND_LATER, {textKey:"sendLater", tooltipKey:"sendLaterTooltip", image:"SendLater"}, ZmSetting.SAVE_DRAFT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SHOW_BCC, {textKey:"showBcc"});
	ZmOperation.registerOp(ZmId.OP_SHOW_CONV, {textKey:"showConv", image:"Conversation"});
	ZmOperation.registerOp(ZmId.OP_SHOW_ORIG, {textKey:"showOrig", image:"Message"});
	ZmOperation.registerOp(ZmId.OP_SPAM, {textKey:"junkLabel", tooltipKey:"junkTooltip", image:"JunkMail", shortcut:ZmKeyMap.SPAM, textPrecedence:70}, ZmSetting.SPAM_ENABLED);
	ZmOperation.registerOp(ZmId.OP_USE_PREFIX, {textKey:"usePrefix"});
};

/**
 * @private
 */
ZmMailApp.prototype._registerItems =
function() {
	ZmItem.registerItem(ZmItem.CONV,
						{app:			ZmApp.MAIL,
						 nameKey:		"conversation",
						 icon:			"Conversation",
						 soapCmd:		"ConvAction",
						 itemClass:		"ZmConv",
						 node:			"c",
						 organizer:		ZmOrganizer.FOLDER,
						 dropTargets:	[ZmOrganizer.FOLDER, ZmOrganizer.TAG, ZmOrganizer.ZIMLET],
						 searchType:	"conversation",
						 resultsList:
		AjxCallback.simpleClosure(function(search) {
			AjxDispatcher.require("MailCore");
			return new ZmMailList(ZmItem.CONV, search);
		}, this)
						});

	ZmItem.registerItem(ZmItem.MSG,
						{app:			ZmApp.MAIL,
						 nameKey:		"message",
						 icon:			"Message",
						 soapCmd:		"MsgAction",
						 itemClass:		"ZmMailMsg",
						 node:			"m",
						 organizer:		ZmOrganizer.FOLDER,
						 dropTargets:	[ZmOrganizer.FOLDER, ZmOrganizer.TAG, ZmOrganizer.ZIMLET],
						 searchType:	"message",
						 resultsList:
		AjxCallback.simpleClosure(function(search) {
			AjxDispatcher.require("MailCore");
			return new ZmMailList(ZmItem.MSG, search);
		}, this)
						});

	ZmItem.registerItem(ZmItem.ATT,
						{app:			ZmApp.MAIL,
						 nameKey:		"attachment",
						 icon:			"Attachment",
						 itemClass:		"ZmMimePart",
						 node:			"mp",
						 resultsList:
		AjxCallback.simpleClosure(function(search) {
			return new ZmMailList(ZmItem.ATT, search);
		}, this)
						});
};

/**
 * @private
 */
ZmMailApp.prototype._setupSearchToolbar =
function() {
	if (appCtxt.get(ZmSetting.MAIL_ENABLED)) {
		ZmSearchToolBar.addMenuItem(ZmId.SEARCH_MAIL,
									{msgKey:		"mail",
									 tooltipKey:	"searchMail",
									 icon:			"Message",
									 shareIcon:		"SharedMailFolder",
									 id:			ZmId.getMenuItemId(ZmId.SEARCH, ZmId.SEARCH_MAIL)
									});
	}
};

ZmMailApp.prototype._registerApp =
function() {
	var newItemOps = {};
	newItemOps[ZmOperation.NEW_MESSAGE] = "message";

	var actionCodes = {};
	actionCodes[ZmKeyMap.NEW_MESSAGE]		= ZmOperation.NEW_MESSAGE;
	actionCodes[ZmKeyMap.NEW_MESSAGE_WIN]	= ZmOperation.NEW_MESSAGE_WIN;

	ZmApp.registerApp(ZmApp.MAIL, {
				mainPkg:			"MailCore",
				nameKey:			"mail",
				icon:				"MailApp",
				textPrecedence:		70,
				chooserTooltipKey:	"goToMail",
				viewTooltipKey:		"displayMailToolTip",
				defaultSearch:		appCtxt.isChildWindow ? null : ZmId.SEARCH_MAIL,
				organizer:			ZmOrganizer.FOLDER,
				overviewTrees:		[ZmOrganizer.FOLDER, ZmOrganizer.SEARCH, ZmOrganizer.TAG],
				searchTypes:		[ZmItem.MSG, ZmItem.CONV],
				newItemOps:			newItemOps,
				actionCodes:		actionCodes,
				gotoActionCode:		ZmKeyMap.GOTO_MAIL,
				newActionCode:		ZmKeyMap.NEW_MESSAGE,
				qsViews:			["compose", "msg"],
				chooserSort:		10,
				defaultSort:		10,
				upsellUrl:			ZmSetting.MAIL_UPSELL_URL,
                //quickCommandType:	ZmQuickCommand[ZmId.ITEM_MSG],
				searchResultsTab:	true
			});
};

// App API

ZmMailApp.prototype.startup =
function(result) {
};

/**
 * Normalize the notifications that occur when a virtual conv gets promoted to a real conv.
 * For example, a virtual conv with ID -676 and one msg (ID 676) receives a second msg (ID 677)
 * and becomes a real conv with an ID of 678. The following notifications will arrive:
 *
 *		deleted:	-676
 *		created:	c {id:678, n:2}
 *					m {id:677, cid:678}
 *		modified:	m {id:676, cid:678}
 *
 * Essentially, we want to handle this as:
 *
 * 		created:	m {id:677, cid:678}
 *		modified:	c {id:-676, _newId: 678}
 * 					m {id:676, cid:678}
 *
 * @private
 */
ZmMailApp.prototype.preNotify =
function(notify) {

	if (!(notify.deleted && notify.created && notify.modified))	{ return notify; }

	// first, see if we are deleting any virtual convs (which have negative IDs)
	var virtConvDeleted = false;
	var deletedIds = notify.deleted.id && notify.deleted.id.split(",");
	var virtConv = {};
	var newDeletedIds = [];
	if (deletedIds && deletedIds.length) {
		for (var i = 0; i < deletedIds.length; i++) {
			var id = deletedIds[i];
			var nId = ZmOrganizer.normalizeId(id);
			if (nId < 0) {
				virtConv[nId] = true;
				virtConvDeleted = true;
			} else {
				newDeletedIds.push(id);
			}
		}
	}
	if (!virtConvDeleted) {
		return notify;
	}

	// look for creates of convs that mean a virtual conv got promoted
	var gotNewConv = false;
	var createdMsgs = {};
	var createdConvs = {};
	for (var name in notify.created) {
		var list = notify.created[name];
		if (list && list.length) {
			for (var i = 0; i < list.length; i++) {
				var create = list[i];
				var id = create.id;
				var extra = (name == "m") ? "|cid=" + create.cid + "|l=" + create.l : "|n=" + create.n;
				AjxDebug.println(AjxDebug.NOTIFY, name + ": id=" + id + "|su='" + create.su + "'|f=" + create.f + "|d=" + create.d + extra);
				if (name == "m") {
					createdMsgs[id] = create;
				} else if (name == "c" && (create.n > 1)) {
					// this is *probably* a create for a real conv from a virtual conv
					createdConvs[id] = create;
					gotNewConv = true;
				}
			}
		}
	}
	if (!gotNewConv) {
		return notify;
	}

	// last thing to confirm virt conv promotion is msg changing cid
	var msgMoved = false;
	var newToOldCid = {};
	var movedMsgs = {};
	var list = notify.modified.m;
	if (list && list.length) {
		for (var i = 0; i < list.length; i++) {
			var mod = list[i];
			var id = mod.id;
			var nId = ZmOrganizer.normalizeId(id);
			var virtCid = nId * -1;
			if (virtConv[virtCid] && createdConvs[mod.cid]) {
				msgMoved = true;
				movedMsgs[id] = mod;
				newToOldCid[mod.cid] = appCtxt.multiAccounts ? ZmOrganizer.getSystemId(virtCid) : virtCid;
				createdConvs[mod.cid]._wasVirtConv = true;
				// go ahead and update the msg cid, since it's used in
				// notification processing for creates
				var msg = appCtxt.getById(id),
					folderId;
				if (msg) {
					msg.cid = mod.cid;
					folderId = msg.folderId;
				}
				createdConvs[mod.cid].m = [{
					id: id,
					l:  folderId
				}];
			}
		}
	}
	if (!msgMoved) {
		return notify;
	}

	// We're promoting a virtual conv. Normalize the notifications object, and
	// process a preliminary notif that will update the virtual conv's ID to its
	// new value.

	// First, remove the virt conv from the list of deleted IDs
	if (newDeletedIds.length) {
		notify.deleted.id = newDeletedIds.join(",");
	} else {
		delete notify.deleted;
	}

	// get rid of creates for virtual convs, since they aren't really creates
	var tmp = [];
	var list = notify.created.c;
	if (list && list.length) {
		for (var i = 0; i < list.length; i++) {
			var create = list[i];
			var c = createdConvs[create.id];
			if (!(c && c._wasVirtConv)) {
				tmp.push(create);
			}
		}
	}
	if (tmp && tmp.length) {
		notify.created.c = tmp;
	} else {
		delete notify.created.c;
	}

	// if the second msg matched the current search, we'll want to use the conv
	// create node to create the conv later, so save it
	for (var id in createdMsgs) {
		var msgCreate = createdMsgs[id];
		var convCreate = createdConvs[msgCreate.cid];
		if (convCreate && convCreate._wasVirtConv) {
			msgCreate._convCreateNode = convCreate;
		}
	}

	// create modified notifs for the virtual convs that have been promoted, using
	// the create notif for the conv as a base
	var newMods = [];
	for (var cid in newToOldCid) {
		var node = createdConvs[cid];
		node.id = newToOldCid[cid];
		node._newId = cid;
		newMods.push(node);
	}

	// Go ahead and process these changes, which will change the ID of each promoted conv
	// from its virtual (negative) ID to its real (positive) one. That will replace the DOM
	// IDs of that conv's elements with ones that reflect the new conv ID.
	if (newMods.length) {
		var mods = {};
		mods["c"] = newMods;
		appCtxt.getRequestMgr()._handleModifies(mods);
	}
};

/**
 * For mail creates, there is no authoritative list (mail lists are always the result
 * of a search), so we notify each ZmMailList that we know about. To make life easier,
 * we figure out which folder(s) a conv spans before we hand it off.
 * <p>
 * Since the offline client may receive hundreds of create notifications at a time, we
 * make sure a create notification is relevant before creating a mail item.</p>
 *
 * @param creates	[hash]		hash of create notifications
 * 
 * @private
 */
ZmMailApp.prototype.createNotify =
function(creates, force) {
	if (!creates["m"] && !creates["c"] && !creates["link"]) { return; }
	if (!force && !this._noDefer && this._deferNotifications("create", creates)) {
		AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: skipping/deferring notifications"); 
		return;
	}

	if (creates["link"]) {
		var list = creates["link"];
		for (var i = 0; i < list.length; i++) {
			var create = list[i];
			if (appCtxt.cacheGet(create.id)) { continue; }
			this._handleCreateLink(create, ZmOrganizer.FOLDER);
		}
	}

	var controllers = this.getAllControllers();

	// Move currentController to the end of the list if it's not there already
	var currentController = this._getCurrentViewController();
	if (currentController && controllers[controllers.length - 1] !== currentController) {
		AjxUtil.arrayRemove(controllers, currentController);
		controllers.push(currentController);
	}

	// give each controller a chance to handle the creates
	for (var i = 0; i < controllers.length; i++) {
		var controller = controllers[i];
		if (controller && controller.isZmDoublePaneController) {
			this._checkList(creates, controller.getList(), controller, i == controllers.length - 1);
		}
	}

	this._handleAlerts(creates);
};

ZmMailApp.prototype._handleAlerts =
function(creates) {
	var mailCreates = creates["m"] || [];
	if (mailCreates.length == 0) { return; }

	AjxDispatcher.require("Alert");

	var activeAcct = appCtxt.getActiveAccount();
	var didAppAlert, didSoundAlert, didBrowserAlert = false;

	var toasterCount = 0;

	for (var i = 0; i < mailCreates.length; i++) {
		var mc = mailCreates[i];
		var parsed = (mc && mc.f && (mc.f.indexOf(ZmItem.FLAG_UNREAD) != -1))
			? ZmOrganizer.parseId(mc.l) : null;

		// don't process alerts while account is undergoing initial sync
		var acct = parsed && parsed.account;
		if (!acct || (acct && acct.isOfflineInitialSync())) { continue; }

		// offline: check whether to show new-mail notification icon
		// Skip spam/trash folders and the local account
		if (appCtxt.isOffline && parsed && !acct.isMain) {
			var doIt = (appCtxt.get(ZmSetting.OFFLINE_NOTIFY_NEWMAIL_ON_INBOX))
				? (parsed.id == ZmOrganizer.ID_INBOX)
				: (parsed.id != ZmOrganizer.ID_SPAM && parsed.id != ZmOrganizer.ID_TRASH);

			if (doIt) {
				this.globalMailCount++;
				acct.inNewMailMode = true;
				var allContainers = appCtxt.getOverviewController()._overviewContainer;
				for (var j in allContainers) {
					allContainers[j].updateAccountInfo(acct, true, true);
				}
			}
		}

		if (appCtxt.get(ZmSetting.MAIL_NOTIFY_ALL) || (parsed && parsed.id == ZmOrganizer.ID_INBOX)) {
			// for multi-account, highlite the non-active accordion item
			if (appCtxt.accountList.size() > 1) {
				ZmAccountAlert.get(acct).start(this);
			}

			// alert mail app tab for the active account and set flag so we only do it *once*
			if (!didAppAlert && acct == activeAcct &&
				appCtxt.get(ZmSetting.MAIL_NOTIFY_APP, null, acct))
			{
				this.startAlert();
				didAppAlert = true;
			}

			// do audible alert for this account and set flag so we only do it *once*
			if (!didSoundAlert && appCtxt.get(ZmSetting.MAIL_NOTIFY_SOUNDS, null, acct)) {
				ZmSoundAlert.getInstance().start();
				didSoundAlert = true;
			}

			// do browser alert for this account and set flag so we only do it *once*
			if (!didBrowserAlert && appCtxt.get(ZmSetting.MAIL_NOTIFY_BROWSER, null, acct)) {
				ZmBrowserAlert.getInstance().start(ZmMsg.newMessage);
				didBrowserAlert = true;
			}

			// generate toaster message if applicable
			if (appCtxt.get(ZmSetting.MAIL_NOTIFY_TOASTER, null, acct) &&
				toasterCount < 5)
			{
				var msg = appCtxt.getById(mc.id) || ZmMailMsg.createFromDom(mc, {});
				var text = (msg.subject)
					? ([msg.subject, " - ", (msg.fragment || "")].join(""))
					: (msg.fragment || "");

				var from = msg.getAddress(AjxEmailAddress.FROM);
				var email = (from && from instanceof AjxEmailAddress) ? from.getName() || from.getAddress() :
							(from && typeof from == "string") ? from : ZmMsg.unknown;
				var title = (appCtxt.accountList.size() > 1)
					? AjxMessageFormat.format(ZmMsg.newMailWithAccount, [email, acct.getDisplayName()])
					: AjxMessageFormat.format(ZmMsg.newMail, email);
				ZmDesktopAlert.getInstance().start(title, text);
				toasterCount++;
			}
		}
	}
};

/**
 * We can only handle new mail notifications if:
 *  	- we are currently in a mail view
 *		- the view is the result of a matchable search
 *
 * @param {Hash}					creates		the JSON create objects
 * @param {ZmMailList}				list		the mail list to notify
 * @param {ZmMailListController}	controller	the controller that owns list
 * @param {boolean}					last		if true, okay to mark creates as handled
 * 
 * @private
 */
ZmMailApp.prototype._checkList =
function(creates, list, controller, last) {

	AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: handling mail creates for view " + controller.getCurrentViewId());

	if (!(list && list instanceof ZmMailList)) {
		AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: list is not a ZmMailList: " + list);
		return;
	}

	var convs = {};
	var msgs = {};

	var sortBy = list.search.sortBy;

	var convResults = this._checkType(creates, ZmItem.CONV, convs, list, sortBy, null, last);
	var msgResults  = this._checkType(creates, ZmItem.MSG, msgs, list, sortBy, convs, last);

	if (convResults.gotMail || msgResults.gotMail) {
		list.notifyCreate(convs, msgs);
	}

	// bug: 30546
	if (convResults.hasMore || msgResults.hasMore) {
		var controller = this._getCurrentViewController();
		
		if (controller) {
			controller.setHasMore(true);
		}
	}
};

ZmMailApp.prototype._getCurrentViewController =
function() {
	var controller;
	var viewType = appCtxt.getCurrentViewType();
	if (viewType == ZmId.VIEW_CONVLIST) {
		controller = this.getConvListController();
	} else if (viewType == ZmId.VIEW_TRAD) {
		controller = this.getTradController();
	}
	return controller;
};

/**
 * Handles the creates for the given type of mail item.
 *
 * @param {Array}		creates		a list of JSON create nodes
 * @param {constant}	type		the mail item type
 * @param {Hash}		items		a hash of created mail items
 * @param {ZmMailList}	currList	the list currently being displayed to user
 * @param {constant}	sortBy		the sort order
 * @param {Hash}		convs		the convs, so we can update folders from msgs
 * @param {boolean}		last		if true, okay to mark creates as handled
 *
 * @return	{Hash}	a hash with booleans gotItem and gotAlertMessage
 * 
 * @private
 */
ZmMailApp.prototype._checkType =
function(creates, type, items, currList, sortBy, convs, last) {

	var result = { gotMail:false, hasMore:false };
	var nodeName = ZmList.NODE[type];
	var list = creates[nodeName];
	if (!(list && list.length)) { return result; }

	var throttle;
	if (appCtxt.isOffline) {
		throttle = (appCtxt.get(ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES))
			? appCtxt.accountList.isInitialSyncing()
			: appCtxt.getActiveAccount().isOfflineInitialSync();
	}
	if (throttle) {
		if (!this._maxEntries) {
			var mlv = this.getMailListController().getCurrentView().getMailListView();
			this._maxEntries = mlv && mlv.calculateMaxEntries();
		}
		if (this.numEntries > this._maxEntries) {
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: too many creates: num=" + this.numEntries + ", max=" + this._maxEntries);
			return result;
		}
	}

	var INTERVAL_LENGTH = 10 * 1000; //10 seconds
	var INTERVAL_THRESHOLD = 20; //throttle more than 20 messages.
	for (var i = 0; i < list.length; i++) {
		var create = list[i];

		// generic throttling mechanism. Do it per folder. reset every 10 seconds. If more than 40 creates arrive in this interval, stop handling them. 
		// This is used to throttle external accounts syncs but also good in general to prevent the client from hanging in case of a huge burst of updates.
		var folder = create.l || "conv"; //I bundle all conv creates together (since they don't provide folder) to make it simple. There are NOT a lot of conv creates at this stage. we mostly create them in ZmMailList.prototype.notifyCreate from messages.
		var now = new Date();
		var data = this._throttleStats[folder];
		if (!data || now.getTime() - data.intervalStart.getTime() > INTERVAL_LENGTH) {
			data = this._throttleStats[folder] = {
				intervalStart: now,
				count: 0
			}
		}
		data.count++;
		if (data.count > INTERVAL_THRESHOLD) {
			if (data.count == INTERVAL_THRESHOLD + 1) {
				DBG.println(AjxDebug.DBG1, "folder " + folder + " starting to throttle at  " + now);
			}
			result.hasMore = true;
			continue;
		}


		AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: process create notification:");
		var extra = (type == ZmItem.MSG) ? "|cid=" + create.cid + "|l=" + create.l : "|n=" + create.n;
		AjxDebug.println(AjxDebug.NOTIFY, type + ": id=" + create.id + "|su='" + create.su + "'|f=" + create.f + "|d=" + create.d + extra);
		if (create._handled) {
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: create already handled " + create.id);
			continue;
		}
		if (last) {
			create._handled = true;
		}

		// new conv does not affect a list of msgs
		if (currList.type == ZmItem.MSG && type == ZmItem.CONV) {
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: msg list ignoring conv create");
			continue;
		}

		// perform stricter checking if we're in offline mode
		if (appCtxt.isOffline) {
			if ((ZmList.ITEM_TYPE[nodeName] != currList.type) && (currList.type != ZmItem.CONV)) {
				AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: type mismatch: " + ZmList.ITEM_TYPE[nodeName] + " / " + currList.type);
				continue;
			}
		}

		// throttle influx of CREATE notifications during offline initial sync
		if (throttle && this.numEntries > this._maxEntries) {
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: throttling");
			result.hasMore = true;
			break;
		}

		DBG.println(AjxDebug.DBG1, "ZmMailApp: handling CREATE for node: " + nodeName);

		var item = appCtxt.getById(create.id);
		if (!item) {
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailApp: create " + type + " object " + create.id);
			var itemClass = eval(ZmList.ITEM_CLASS[type]);
			item = itemClass.createFromDom(create, {list: currList});
		}
		else if (item.type == ZmItem.MSG) {
			// bug 47589: make sure conv knows its folders
			var conv = appCtxt.getById(item.cid);
			if (conv) {
				conv.folders[item.folderId] = true;
			}
		}
		items[item.id] = item;
		result.gotMail = true;
	}
	return result;
};

ZmMailApp.prototype.modifyNotify =
function(modifies, force) {
	if (!modifies["m"] && !modifies["c"]) { return; }
	if (!force && !this._noDefer && this._deferNotifications("modify", modifies)) { return; }

	this._batchNotify(modifies["m"]);
	this._batchNotify(modifies["c"]);
};

ZmMailApp.prototype.postNotify =
function(notify) {
	var lv = this._checkReplenishListView;
	if (lv && !lv._isPageless) {
		lv._checkReplenish();
		this._checkReplenishListView = null;
	}
};

ZmMailApp.prototype.refresh =
function(refresh) {

	var inbox = appCtxt.getById(ZmFolder.ID_INBOX);
	if (inbox) {
		this.setNewMailNotice(inbox);
	}

	if (!appCtxt.inStartup) {
		this.resetOverview(this.getOverviewId());
 
		// mark all existing mail list views as stale
		var viewIds = [ZmId.VIEW_TRAD, ZmId.VIEW_CONVLIST, ZmId.VIEW_CONV];
		var avm = appCtxt.getAppViewMgr();
		for (var i = 0; i < viewIds.length; i++) {
			var views = avm.getViewsByType(viewIds[i]);
			for (var j = 0; j < views.length; j++) {
				var dpv = avm.getViewComponent(ZmAppViewMgr.C_APP_CONTENT, views[j].id);
				if (dpv && dpv.isZmDoublePaneView) {
					dpv.isStale = true;
				}
			}
		}
		// view is normally updated when user returns to it (from whatever view
		// results from the current request); if the request doesn't result in a
		// view change, use a timer to check if it still needs to be updated
		var curViewId = appCtxt.getCurrentViewId();
		AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._checkRefresh, [curViewId]), 1000);
	}
};

ZmMailApp.prototype._checkRefresh =
function(lastViewId) {

	// if the request that prompted the refresh didn't result in a view change
	// (eg NoOpRequest), rerun its underlying search
	if (appCtxt.getCurrentViewId() == lastViewId) {
		var curView = appCtxt.getCurrentView();
		if (curView && curView.isStale && curView._staleHandler) {
			curView._staleHandler();
		}
	}
};

ZmMailApp.prototype.handleOp =
function(op, params) {
	var inNewWindow = false;
	var showLoadingPage = true;
	if ((op == ZmOperation.NEW_MESSAGE_WIN) || (op == ZmOperation.NEW_MESSAGE)) {
		if (!appCtxt.isWebClientOffline()) {
			inNewWindow = (op == ZmOperation.NEW_MESSAGE_WIN) ? true : this._inNewWindow(params && params.ev);
			showLoadingPage = false;	// don't show "Loading ..." page since main window view doesn't change
		}
		var loadCallback = new AjxCallback(this, this.compose, {action: ZmOperation.NEW_MESSAGE, inNewWindow:inNewWindow});
		AjxDispatcher.require(["ContactsCore", "Contacts"], false, loadCallback, null, showLoadingPage);
	}
};

// Public methods

ZmMailApp.prototype.getOverviewPanelContent =
function() {
	var firstTime = !this._overviewPanelContent;

	var overview = ZmApp.prototype.getOverviewPanelContent.apply(this, arguments);

	// bug: 42455 - highlight folder now that overview exists
	if (firstTime) {
		appCtxt.getSearchController().updateOverview();
	}

	return overview;
};

ZmMailApp.prototype.getOverviewContainer =
function() {
	var firstTime = !this._overviewContainer;

	var container = ZmApp.prototype.getOverviewContainer.apply(this, arguments);

	// bug: 42455 - highlight folder now that overview exists
	if (firstTime && !appCtxt.get(ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES)) {
		appCtxt.getSearchController().updateOverview();
	}

	return container;
};

ZmMailApp.prototype.getNewButtonProps =
function() {
	return {
		text:		ZmMsg.newMessage,
		tooltip:	ZmMsg.compose,
		icon:		"NewMessage",
		iconDis:	"NewMessageDis",
		defaultId:	ZmOperation.NEW_MESSAGE,
        disabled:   !this.containsWritableFolder()
	};
};

ZmMailApp.prototype.launch =
function(params, callback) {
	this._setLaunchTime(this.toString(), new Date());

    if (appCtxt.isExternalAccount()) {
        var loadCallback = this._handleLoadLaunch.bind(this, params, callback);
	    AjxDispatcher.require(["MailCore", "Mail", "Startup2"], true, loadCallback, null, true);
    }
    else {
        this._handleLoadLaunch(params, callback);
    }
};

ZmMailApp.prototype._handleLoadLaunch =
function(params, callback) {
	// set type for initial search
	this._groupBy = appCtxt.get(ZmSetting.GROUP_MAIL_BY);

	var query;
	params = params || {};

	if (params.qsParams) {
		var view = params.qsParams.view, id = params.qsParams.id;
		if (view == "compose") {
			this._showComposeView(callback);
			return;
		} else if (id) {
			view = view || "msg";
			if (view == "list") {
				query = ["item:", id].join("");
				params.searchResponse = null;
				this._forceMsgView = true;
			} else if (view == "msg") {

				var list = new ZmMailList(ZmItem.MSG);
				var msg = new ZmMailMsg(id, list, true);
				list.add(msg);

				var msgParams = {getHtml:			appCtxt.get(ZmSetting.VIEW_AS_HTML),
								 markRead:			(appCtxt.get(ZmSetting.MARK_MSG_READ) == ZmSetting.MARK_READ_NOW),
								 callback:			new AjxCallback(this, this._handleResponseMsgLoad, [msg, callback]),
								 errorCallback:		new AjxCallback(this, this._handleErrorMsgLoad, callback)};
				msg.load(msgParams);
				return;
			}
		}
	}

	this.mailSearch(query, callback, params.searchResponse);
};

ZmMailApp.prototype._handleErrorLaunch =
function(params, ex) {
	if (ex.code == ZmCsfeException.MAIL_NO_SUCH_FOLDER ||
		ex.code == ZmCsfeException.MAIL_NO_SUCH_TAG ||
		ex.code == ZmCsfeException.MAIL_QUERY_PARSE_ERROR)
	{
		// reset the params so we default to searching the inbox which *will* work
		var newParams = {query:"in:inbox", callback:params.callback, errorCallback:null, types:params.types};
		appCtxt.getSearchController().search(newParams);
	}
};

/**
 * If we can't show the given msg, just do regular mail launch and show initial search. Make sure to
 * run the callback so that the rest of the UI is drawn.
 *
 * @param callback
 * @param ex
 * 
 * @private
 */
ZmMailApp.prototype._handleErrorMsgLoad =
function(callback, ex) {
	this.mailSearch();
	if (callback) {
		callback.run();
	}
	this._notifyRendered();
	return false;
};

ZmMailApp.prototype._handleResponseMsgLoad =
function(msg, callback) {
	AjxDispatcher.require("Startup2");
	var msgCtlr = AjxDispatcher.run("GetMsgController");
	if (msgCtlr) {
		msgCtlr.show(msg, null, null, null, true); // Show the message without pagination buttons
		if (callback) {
			callback.run();
		}
		this._notifyRendered();

		appCtxt.notifyZimlets('onMsgView', [msg, null, appCtxt.getCurrentView()], {waitUntilLoaded:true});
	}
};

/**
 * Performs a mail search.
 * 
 * @param	{String}	query		the query
 * @param	{AjxCallback}	callback		the callback
 * @param	{Object}	response	the response
 * @param	{constant}	type		the type
 */
ZmMailApp.prototype.mailSearch =
function(query, callback, response, type) {
	var account = appCtxt.isOffline && appCtxt.inStartup && appCtxt.accountList.defaultAccount;
	if (account) {
		appCtxt.accountList.setActiveAccount(account);
	}

	var sc = appCtxt.getSearchController();
	var queryHint, noUpdateOverview;
	if (appCtxt.get(ZmSetting.OFFLINE_SHOW_ALL_MAILBOXES) &&
		appCtxt.accountList.size() > 2)
	{
		query = null;
		queryHint = appCtxt.accountList.generateQuery(ZmOrganizer.ID_INBOX);
		noUpdateOverview = true;
		sc.searchAllAccounts = true;
	}
	else if(appCtxt.isExternalAccount()) {
        query = "inid:" + this.getDefaultFolderId();
    } else if (appCtxt.isWebClientOffline()) {
        query = query || "in:inbox";
    } else {
		query = query || appCtxt.get(ZmSetting.INITIAL_SEARCH, null, account);
	}

	var types = new AjxVector();
	types.add(type || this.getGroupMailBy());
	var sortBy = AjxUtil.get(response, "Body", "SearchResponse", "sortBy") || ZmSearch.DATE_DESC;

	var params = {
		searchFor:			ZmId.SEARCH_MAIL,
		query:				query,
		queryHint:			queryHint,
		types:				types,
		limit:				this.getLimit(),
		getHtml:			appCtxt.get(ZmSetting.VIEW_AS_HTML, null, account),
		noUpdateOverview:	noUpdateOverview,
        offlineCache:       true,
		accountName:		(account && account.name),
		callback:			callback,
		response:			response,
		sortBy:             sortBy
	};
	params.errorCallback = new AjxCallback(this, this._handleErrorLaunch, params);
	sc.search(params);
};

/**
 * Shows the search results.
 * 
 * @param	{Object}					results						the results
 * @param	{AjxCallback}				callback					the callback
 * @param 	{ZmSearchResultsController}	searchResultsController		owning controller
 */
ZmMailApp.prototype.showSearchResults =
function(results, callback, searchResultsController) {
	var loadCallback = this._handleLoadShowSearchResults.bind(this, results, callback, searchResultsController);
	AjxDispatcher.require("MailCore", false, loadCallback, null, true);
};

ZmMailApp.prototype._handleLoadShowSearchResults =
function(results, callback, searchResultsController) {

	var sessionId = searchResultsController ? searchResultsController.getCurrentViewId() : ZmApp.MAIN_SESSION;
	var controller = ((results.type == ZmItem.MSG) || !appCtxt.get(ZmSetting.CONVERSATIONS_ENABLED)) ? this.getTradController(sessionId, searchResultsController) :
													this.getConvListController(sessionId, searchResultsController);
	controller.show(results);
	this._setLoadedTime(this.toString(), new Date());
	
	if (this._forceMsgView) {
		controller.selectFirstItem();
		this._forceMsgView = false;
	}

	if (callback) {
		callback.run(controller);
	}
	this._notifyRendered();

	// update the title to reflect the new search results
	appCtxt.getAppViewMgr().updateTitle();
};

ZmMailApp.prototype._parseComposeUrl =
function(urlQueryStr){

	urlQueryStr = urlQueryStr || '';
	urlQueryStr.replace(/^mailto:/i, "");

	//Decode the whole query string. Components will be decoded as well, but that's okay since it should do no harm and the query string may have been double-encoded as well (once by user to trick crawlers, then again by the browser in constructing the mailto URL).
	urlQueryStr = AjxStringUtil.urlComponentDecode(urlQueryStr);

	var match = urlQueryStr.match(/\bto=([^&]+)/i);
	var to = match ? AjxStringUtil.urlComponentDecode(match[1].replace(/\+/g, " ")) : null;
	to = to && AjxEmailAddress.isValid(to) ? AjxStringUtil.urlComponentDecode(to) : AjxStringUtil.htmlEncode(to);
	
	match = urlQueryStr.match(/\bsubject=([^&]+)/i);
	var subject = match ? (AjxStringUtil.urlComponentDecode(match[1]).replace(/\+/g, " ")) : null;

	match = urlQueryStr.match(/\bcc=([^&]+)/i);
	var cc = match ? AjxStringUtil.urlComponentDecode(match[1].replace(/\+/g, " ")) : null;
	cc = cc && AjxEmailAddress.isValid(cc) ? cc : AjxStringUtil.htmlEncode(cc);
	
	match = urlQueryStr.match(/\bbcc=([^&]+)/i);
	var bcc = match ? AjxStringUtil.urlComponentDecode(match[1].replace(/\+/g, " ")) : null;
	bcc = bcc && AjxEmailAddress.isValid(bcc) ? bcc : AjxStringUtil.htmlEncode(bcc);
	
	match = urlQueryStr.match(/\bbody=([^&]+)/i);
	var body = match ? (AjxStringUtil.urlComponentDecode(match[1]).replace(/\+/g, " ")) : null;

	return {
		to: to,
		subject: AjxStringUtil.htmlEncode(subject),
		cc: cc,
		bcc: bcc,
		body: AjxStringUtil.htmlEncode(body)
	};
};

ZmMailApp.prototype._showComposeView =
function(callback, queryStr) {
	var qs = queryStr || location.search;

	AjxDispatcher.require("Startup2");
	var composeController = AjxDispatcher.run("GetComposeController");

	// RFC 2368 = mailto:user@zimbra.com?(headers=values)*
	var composeParams = this._parseComposeUrl(qs);
	var to = composeParams.to;
	if (to && to.indexOf('mailto') == 0) {
		to = to.replace(/mailto:/,'');
		var mailtoQuery = to.split('?');
		composeParams.to = mailtoQuery[0];
		if (mailtoQuery.length > 1) {
			//mailto:xyz@abc.com?....
			mailtoQuery = mailtoQuery[1];
			var mailtoParams = this._parseComposeUrl(mailtoQuery);
			// mailto:user@abc.com?to=xyz@abc.com&... or mailto:?to=xyz@abc.com
			composeParams.to = composeParams.to
					? (mailtoParams.to ? [composeParams.to, ','+mailtoParams.to].join('') : composeParams.to )
					:  mailtoParams.to;
			composeParams.subject = mailtoParams.subject || composeParams.subject;
			composeParams.cc = mailtoParams.cc || composeParams.cc;
			composeParams.bcc = mailtoParams.bcc || composeParams.bcc;
			composeParams.body = mailtoParams.body || composeParams.body;
		}
	}

	var params = {
		action: ZmOperation.NEW_MESSAGE,
		toOverride: composeParams.to,
		ccOverride: composeParams.cc,
		bccOverride: composeParams.bcc,
		subjOverride: composeParams.subject,
		extraBodyText: composeParams.body,
		extraBodyTextIsExternal: Boolean(composeParams.body),
		callback: callback
	};

	// this can happen in offlie where user clicks on mailto link and we're
	// already in compose view
	if (appCtxt.isOffline &&
		appCtxt.get(ZmSetting.OFFLINE_SUPPORTS_MAILTO) &&
		appCtxt.getCurrentViewId() == ZmId.VIEW_COMPOSE)
	{
		composeController.resetComposeForMailto(params);
	}
	else {
		composeController.doAction(params);
	}

	this._notifyRendered();
    return composeController;
};

/**
 * Returns a conversation list controller.
 * 
 * @return	{ZmConvListController}	conversation list controller
 */
ZmMailApp.prototype.getConvListController =
function(sessionId, searchResultsController) {
	return this.getSessionController({controllerClass:			"ZmConvListController",
									  sessionId:				sessionId || ZmApp.MAIN_SESSION,
									  searchResultsController:	searchResultsController});
};

/**
 * Returns a conversation controller.
 * 
 * @return	{ZmConvController}		conversation controller
 */
ZmMailApp.prototype.getConvController =
function(sessionId) {
	return this.getSessionController({controllerClass:	"ZmConvController",
									  sessionId:		sessionId});
};

/**
 * Gets the traditional (msg list) controller.
 * 
 * @return	{ZmTradController}	traditional controller
 */
ZmMailApp.prototype.getTradController =
function(sessionId, searchResultsController) {
	return this.getSessionController({controllerClass:			"ZmTradController",
									  sessionId:				sessionId || ZmApp.MAIN_SESSION,
									  searchResultsController:	searchResultsController});
};

/**
 * Gets the message controller.
 * 
 * @return	{ZmMsgController}		message controller
 */
ZmMailApp.prototype.getMsgController =
function(sessionId) {

    // if message is already open get that session controller
    var controllers = this._sessionController[ZmId.VIEW_MSG];
    var controller;
    for (var id in controllers) {
        if (!controllers[id].isHidden && controllers[id].getMsg() && controllers[id].getMsg().nId == sessionId) {
            controller = controllers[id];
            break;
        }
    }

    if (controller) {
        sessionId = controller.getSessionId();
        this._curSessionId[ZmId.VIEW_MSG] = sessionId;
        controller.inactive = false;
        return controller;
    }
        
	return this.getSessionController({controllerClass:	"ZmMsgController",
									  sessionId:		sessionId});
};

/**
 * Returns a compose controller.
 * 
 * @return	{ZmComposeController}	compose controller
 */
ZmMailApp.prototype.getComposeController =
function(sessionId) {
	return this.getSessionController({controllerClass:	"ZmComposeController",
									  sessionId:		sessionId});
};

ZmMailApp.prototype.getConfirmController =
function(sessionId) {
	return this.getSessionController({controllerClass:	"ZmMailConfirmController",
									  sessionId:		sessionId});
};

/**
 * Gets the current mail list controller, which may be conversation list or msg list (traditional).
 * 
 * @return	{ZmTradController|ZmConvListController}	mail list controller
 */
ZmMailApp.prototype.getMailListController =
function() {
	var groupMailBy = appCtxt.get(ZmSetting.GROUP_MAIL_BY) ;
	return (groupMailBy == ZmSetting.GROUP_BY_CONV) ? AjxDispatcher.run("GetConvListController") :
													  AjxDispatcher.run("GetTradController");
};

ZmMailApp.prototype.runRefresh =
function() {
	this.getMailListController().runRefresh();
};

/**
 * Begins a compose session by presenting a form to the user.
 *
 * @param	{Hash}	params			a hash of parameters
 * @param {constant}	params.action		the new message, reply, forward, or an invite action
 * @param {Boolean}	params.inNewWindow		if <code>true</code>, we are in detached window
 * @param {ZmMailMsg}	params.msg			the original message (reply/forward), or address (new message)
 * @param {String}	params.toOverride 	the initial value for To: field
 * @param {String}	params.subjOverride 	the initial value for Subject: field
 * @param {String}	params.extraBodyText the canned text to prepend to body (invites)
 * @param {AjxCallback}	params.callback		the callback to run after view has been set
 * @param {String}	params.accountName	the on-behalf-of From address
 */
ZmMailApp.prototype.compose =
function(params) {
	Dwt.setLoadingTime("ZmMailApp-compose");
	params = params || {};
	if (!params.sessionId) {
		// see if we already have a compose session for this message
		var controllers = this._sessionController[ZmId.VIEW_COMPOSE];
		var controller;
		var msgId = params.msg && params.msg.nId;
		for (var id in controllers) {
			  if (controllers[id].getMsg() && controllers[id].getMsg().nId == msgId){
				 controller = controllers[id];
				 break;
			  }
		}
	}
	
    if (!controller) {
	    controller = AjxDispatcher.run("GetComposeController", params.sessionId);
    }

    appCtxt.composeCtlrSessionId = controller.getSessionId();	// help new window dispose components
	controller.doAction(params);
	Dwt.setLoadedTime("ZmMailApp-compose");
};

/**
 * Sets the new mail notice.
 * 
 * @param	{ZmOrganizer}	organizer		the organizer
 */
ZmMailApp.prototype.setNewMailNotice =
function(organizer) {
	var appChooser = appCtxt.getAppChooser();
	if (appChooser) {
		var mb = appChooser.getButton(ZmApp.MAIL);
		var icon = (organizer.numUnread > 0) ? "EnvelopeOpen" : "MailApp";
		mb.setImage(icon);
	}
    if(organizer.id == ZmOrganizer.ID_INBOX) {
        this._setFavIcon(organizer.numUnread);
    }
	this._setNewMailBadge();
};

ZmMailApp.prototype._setNewMailBadge =
function() {
	if (appCtxt.isOffline && appCtxt.get(ZmSetting.OFFLINE_SUPPORTS_DOCK_UPDATE)) {
		if (AjxEnv.isMac && window.platform) {
			window.platform.icon().badgeText = (this.globalMailCount > 0)
				? this.globalMailCount : null;
		}
		else if (AjxEnv.isWindows) {
			window.platform.icon().imageSpec = (this.globalMailCount > 0)
				? "resource://webapp/icons/default/newmail.png"
				: "resource://webapp/icons/default/launcher.ico";
			window.platform.icon().title = (this.globalMailCount > 0)
				? AjxMessageFormat.format(ZmMsg.unreadCount, this.globalMailCount) : null;
		}
	}
};

ZmMailApp.prototype.clearNewMailBadge =
function() {
	this.globalMailCount = 0;
	this._setNewMailBadge();
};

ZmMailApp.prototype._setFavIcon =
function(unread) {
    var url;
    if (unread == 0) {
        url = [appContextPath, "/img/logo/favicon.ico"].join("");
    } else if (unread > 9) {
        url = [appContextPath,"/img/logo/favicon_plus.ico"].join("");
    } else {
        url = [appContextPath, "/img/logo/favicon_", unread, ".ico"].join("");
    }
    Dwt.setFavIcon(url);
};

/**
 * Gets the "group mail by" setting. This is a convenience method to
 * convert "group mail by" between server (string) and client (int constant) versions.
 * 
 * @return	{String}	the group by mail setting
 */
ZmMailApp.prototype.getGroupMailBy =
function() {
	var setting = this._groupBy || appCtxt.get(ZmSetting.GROUP_MAIL_BY);
	return setting ? ZmMailApp.GROUP_MAIL_BY_ITEM[setting] : ZmItem.MSG;
};

ZmMailApp.prototype.setGroupMailBy =
function(groupBy, skipNotify) {
	this._groupBy = groupBy;
	appCtxt.set(ZmSetting.GROUP_MAIL_BY, groupBy, null, false, skipNotify);
};

// return enough for us to get a scroll bar since we are pageless
ZmMailApp.prototype.getLimit =
function(offset) {
	var limit = appCtxt.get(ZmSetting.PAGE_SIZE);
	return offset ? limit : 2 * limit;
};

/**
 * Adds a "Reply" submenu for replying to sender or all.
 *
 * @param {ZmToolBar|ZmActionMenu}	parent		the parent widget (a toolbar or action menu)
 * @return	{ZmActionMenu}	the menu
 */
ZmMailApp.addReplyMenu =
function(parent) {
	var list = [ZmOperation.REPLY, ZmOperation.REPLY_ALL];
	var menu = new ZmActionMenu({parent:parent, menuItems:list});
	parent.setMenu(menu);
	return menu;
};

/**
 * Adds a "Forward" submenu for forwarding inline or as attachment.
 *
 * @param {ZmToolBar|ZmActionMenu}	parent		the parent widget (a toolbar or action menu)
 * @return	{ZmActionMenu}	the menu
 */
ZmMailApp.addForwardMenu =
function(parent) {
	var list = [ZmOperation.FORWARD_INLINE, ZmOperation.FORWARD_ATT];
	var menu = new ZmActionMenu({parent:parent, menuItems:list});
	parent.setMenu(menu);
	return menu;
};

/**
 * Adds a data source collection.
 * 
 * @param	{ZmAccount}		account		the account
 * @return	{ZmDataSourceCollection}	the data source collection
 */
ZmMailApp.prototype.getDataSourceCollection =
function(account) {
	var appCtxt = window.parentAppCtxt || window.appCtxt;
	var activeAcct = account ? account.name : appCtxt.getActiveAccount().name;

	if (!this._dataSourceCollection[activeAcct]) {
		this._dataSourceCollection[activeAcct] = new ZmDataSourceCollection();
		if (appCtxt.getActiveAccount().isMain) {
			this._dataSourceCollection[activeAcct].initialize(appCtxt.getSettings().getInfoResponse.dataSources);
		}
	}
	return this._dataSourceCollection[activeAcct];
};

/**
 * Gets the identity collection.
 * 
 * @param	{ZmAccount}		account		the account
 * @return	{ZmIdentityCollection}	the identity collection
 */
ZmMailApp.prototype.getIdentityCollection =
function(account) {
	// child window always gets its own identitiy collection
	if (appCtxt.isChildWindow) {
		if (!this._identityCollection) {
			this._identityCollection = new ZmIdentityCollection();
		}
		return this._identityCollection;
	}

	var activeAcct = account ? account.name : appCtxt.getActiveAccount().name;

	if (!this._identityCollection[activeAcct]) {
		var ic = this._identityCollection[activeAcct] = new ZmIdentityCollection();
		var settings = appCtxt.getSettings(account);
		if (settings)
			ic.initialize(settings.getInfoResponse.identities);
	}
	return this._identityCollection[activeAcct];
};

/**
 * Gets the signature collection.
 * 
 * @param	{ZmAccount}		account		the account
 * @return	{ZmSignatureCollection}	the signature collection
 */
ZmMailApp.prototype.getSignatureCollection =
function(account) {
	var appCtxt = window.parentAppCtxt || window.appCtxt;
    account = account || appCtxt.getActiveAccount();
	var activeAcct = account.name;
    var settings = appCtxt.getSettings(account);
	if (!this._signatureCollection[activeAcct] && settings) {
		var sc = this._signatureCollection[activeAcct] = new ZmSignatureCollection();
		sc.initialize(settings.getInfoResponse.signatures);
	}
	return this._signatureCollection[activeAcct];
};

ZmMailApp.prototype._addSettingsChangeListeners =
function() {
	ZmApp.prototype._addSettingsChangeListeners.call(this);

	if (!this._settingsListener) {
		this._settingsListener = new AjxListener(this, this._settingsChangeListener);
	}

	var settings = appCtxt.getSettings();
	settings.getSetting(ZmSetting.VIEW_AS_HTML).addChangeListener(this._settingListener);
	settings.getSetting(ZmSetting.TRUSTED_ADDR_LIST).addChangeListener(this._settingListener);
	settings.addChangeListener(this._settingsListener);
};

/**
 * Individual setting listener.
 */
ZmMailApp.prototype._settingChangeListener =
function(ev) {
	ZmApp.prototype._settingChangeListener.call(this, ev);

	if (ev.type != ZmEvent.S_SETTING) { return; }

	var setting = ev.source;
	var mlc = this.getMailListController();

	if (mlc && (setting.id == ZmSetting.VIEW_AS_HTML || setting.id == ZmSetting.TRUSTED_ADDR_LIST)) {
        this.resetTrustedSendersList();
		var dpv = mlc._doublePaneView;
		var msg = dpv ? dpv.getMsg() : null;
		if (msg) {
			dpv.reset();
			dpv.setItem(msg);
		}
	}
};

/**
 * Settings listener. Process changed settings as a group, so that we
 * don't redo the search more than once if more than one relevant mail
 * setting has changed.
 * 
 * @private
 */
ZmMailApp.prototype._settingsChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_SETTINGS) { return; }

	var list = ev.getDetail("settings");
	if (!(list && list.length)) { return; }

	var mlc = this.getMailListController();
	if (!mlc) { return; }

	var curView = mlc.getCurrentViewType();
	var newView, groupByView;

	for (var i = 0; i < list.length; i++) {
		var setting = list[i];
		if (setting.id == ZmSetting.SHOW_FRAGMENTS) {
			if (curView != ZmId.VIEW_MSG) {
				newView = groupByView || curView;
			}
		}
	}
	newView = groupByView || newView;

	if (newView) {
		mlc.switchView(newView, true);
	}
};

ZmMailApp.prototype.getTrustedSendersList =
function() {
    if(!this._trustedList) {
        var trustedList = appCtxt.get(ZmSetting.TRUSTED_ADDR_LIST);
        if(trustedList) {
            this._trustedList = AjxVector.fromArray(trustedList);
        }
        else {
            this._trustedList = new AjxVector();
        }
    }
    return this._trustedList;
};

ZmMailApp.prototype.resetTrustedSendersList =
function() {
    this._trustedList = null;
};

ZmMailApp._handleOOORemindResponse = function(dialog,isTurnOff){
   ZmMailApp._hideOOORemindDialog(dialog);
   var dontRemind = document.getElementById(dialog._htmlElId + "_dontRemind");

   if(isTurnOff || dontRemind.checked){
        ZmMailApp._saveRemindStatus(isTurnOff,dontRemind.checked);
   }

};

ZmMailApp._hideOOORemindDialog=function(dialog){
    if(dialog){
        dialog.popdown();
    }
};

ZmMailApp._saveRemindStatus = function(turnOff,dontRemind) {
    var soapDoc = AjxSoapDoc.create("ModifyPrefsRequest", "urn:zimbraAccount");

    if(turnOff){
        var node = soapDoc.set("pref", "FALSE");
        node.setAttribute("name", "zimbraPrefOutOfOfficeReplyEnabled");
    }
    else if(dontRemind){
        var node = soapDoc.set("pref", "FALSE");
        node.setAttribute("name", "zimbraPrefOutOfOfficeStatusAlertOnLogin");
    }

    var paramsObj = {soapDoc:soapDoc, asyncMode:true};
    if(turnOff){paramsObj.callback=ZmMailApp._oooReplyCallback;}

    appCtxt.getAppController().sendRequest(paramsObj);
};

ZmMailApp._oooReplyCallback = function(){
    appCtxt.set(ZmSetting.VACATION_MSG_ENABLED,false);
}

ZmMailApp.prototype._isOnVacation = function() {
	if (!appCtxt.get(ZmSetting.VACATION_MSG_ENABLED)) {
		return false;  //no vacation
	}
	var from = appCtxt.get(ZmSetting.VACATION_FROM);
	var to = appCtxt.get(ZmSetting.VACATION_UNTIL);

	if (!from) {
		return true; //unlimited vacation (if from is empty, so is to)
	}

	var today = new Date();
	var formatter = new AjxDateFormat("yyyyMMddHHmmss'Z'");
	var fromDate = formatter.parse(AjxDateUtil.dateGMT2Local(from));
	var toDate = formatter.parse(AjxDateUtil.dateGMT2Local(to));
	return fromDate < today && today < toDate;
};


ZmMailApp.prototype._checkVacationReplyEnabled = function(){
    if (!appCtxt.get(ZmSetting.VACATION_MSG_REMIND_ON_LOGIN)) {
		return; //reminder not enabled
	}

	if (!this._isOnVacation()) {
		return;
	}

	var ynDialog = new DwtMessageDialog({parent:appCtxt.getShell(), buttons:[DwtDialog.YES_BUTTON, DwtDialog.NO_BUTTON], id: "VacationDialog"});
	var content = AjxTemplate.expand("mail.Message#VacationRemindDialog", {id:ynDialog._htmlElId});
	ynDialog.setTitle(ZmMsg.OOORemindDialogTitle);
	ynDialog.setContent(content);
	var dontRemind = document.getElementById(ynDialog._htmlElId + "_dontRemind");
	dontRemind.checked = false;
	ynDialog.registerCallback(DwtDialog.YES_BUTTON, ZmMailApp._handleOOORemindResponse, null, [ynDialog, true]);
	ynDialog.registerCallback(DwtDialog.NO_BUTTON, ZmMailApp._handleOOORemindResponse, null, [ynDialog, false]);
	ynDialog.popup();
};

ZmMailApp.prototype._createVirtualFolders =
function() {
    ZmOffline.addOutboxFolder();
};

ZmMailApp.prototype.resetWebClientOfflineOperations =
function() {
	ZmApp.prototype.resetWebClientOfflineOperations.apply(this);
    //Refreshing the mail list both for online and offline mode
	var isWebClientOnline = !appCtxt.isWebClientOffline();
	this.refresh();
	var folders = appCtxt.getFolderTree().getByType(ZmOrganizer.FOLDER);
	var overview = this.getOverview();
	if (folders && overview) {
		for (var i = 0; i < folders.length; i++) {
			var folder = folders[i];
			var treeItem = folder && overview.getTreeItemById(folder.id);
			if (!treeItem) {
				continue;
			}
			if (isWebClientOnline) {
				treeItem.setVisible(true);
			}
			else {
				//Don't hide ROOT folder and OUTBOX folder
				if (folder.id != ZmFolder.ID_ROOT && folder.rid != ZmFolder.ID_ROOT && folder.id != ZmFolder.ID_OUTBOX && folder.webOfflineSyncDays === 0) {
					treeItem.setVisible(false);
				}
			}
		}
	}
};

/*
 * Enables Mail preferences in case of Admin viewing user account keeping Mail App is disabled.
 */
ZmMailApp.prototype.enableMailPrefs =
function() {
	// ZmPref is unavailable, hence we load it, register settings, operations & preferences.
	AjxDispatcher.require("PreferencesCore");
	this._registerSettings();
	this._registerOperations();
	this._registerPrefs();
};

// Folders to ignore when displaying a conv's messages
ZmMailApp.FOLDERS_TO_OMIT = [ZmFolder.ID_TRASH, ZmFolder.ID_SPAM];

// returns lookup hash of folders (starting with Trash/Junk) whose messages aren't included when
// viewing or replying a conv; if we're in one of those, we still show its messages
ZmMailApp.getFoldersToOmit = function(search) {

	search = search || appCtxt.getCurrentSearch();

	var folders = ZmMailApp.FOLDERS_TO_OMIT,
		omit = [],
		curFolderId = search && search.folderId;

	var isUserInitiatedSearch = search && search.userInitiated;

	for (var i = 0; i < folders.length; i++) {
		if (!isUserInitiatedSearch && folders[i] != curFolderId) {
			omit.push(folders[i]);
		}
	}
	return AjxUtil.arrayAsHash(omit);
};

/*
returns the folders to omit in case of reply/reply-all/forward - this includes DRAFTS always in addition to the others as returned by ZmMailApp.getFoldersToOmit
(the others depend on current folder, but DRAFTS should always be ignored when replying/forwarding, even under Drafts folder)
 */
ZmMailApp.getReplyFoldersToOmit = function(search) {
	var omit = ZmMailApp.getFoldersToOmit(search);
	omit[ZmFolder.ID_DRAFTS] = true;
	return omit;
};
}
if (AjxPackage.define("zimbraMail.calendar.ZmCalendarApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the calendar application class.
 */

/**
 * Creates and initializes the calendar application.
 * @class
 * The calendar application manages the creation and display of appointments.
 *
 * @param	{DwtControl}	container		the container
 * @param	{ZmController}	parentController	the parent window controller (set by the child window)
 *
 * @author Conrad Damon
 * 
 * @extends		ZmApp
 */
ZmCalendarApp = function(container, parentController) {

	ZmApp.call(this, ZmApp.CALENDAR, container, parentController);

	this._addSettingsChangeListeners();

	// resource cache
	this._resByName = {};
	this._resByEmail = {};
};

ZmCalendarApp.prototype = new ZmApp;
ZmCalendarApp.prototype.constructor = ZmCalendarApp;

ZmCalendarApp.prototype.isZmCalendarApp = true;
ZmCalendarApp.prototype.toString = function() {	return "ZmCalendarApp"; };


// Organizer and item-related constants
ZmEvent.S_APPT				= ZmId.ITEM_APPOINTMENT;
ZmEvent.S_RESOURCE			= ZmId.ITEM_RESOURCE;
ZmItem.APPT					= ZmEvent.S_APPT;
ZmItem.RESOURCE				= ZmEvent.S_RESOURCE;
/**
 * Defines the "calendar" organizer.
 */
ZmOrganizer.CALENDAR		= ZmId.ORG_CALENDAR;

// App-related constants
/**
 * Defines the "calendar" application.
 */
ZmApp.CALENDAR							= ZmId.APP_CALENDAR;
ZmApp.CLASS[ZmApp.CALENDAR]				= "ZmCalendarApp";
ZmApp.SETTING[ZmApp.CALENDAR]			= ZmSetting.CALENDAR_ENABLED;
ZmApp.UPSELL_SETTING[ZmApp.CALENDAR]	= ZmSetting.CALENDAR_UPSELL_ENABLED;
ZmApp.LOAD_SORT[ZmApp.CALENDAR]			= 40;
ZmApp.QS_ARG[ZmApp.CALENDAR]			= "calendar";

// ms to wait before fetching reminders
ZmCalendarApp.REMINDER_START_DELAY = 10000;
ZmCalendarApp.MINICAL_DELAY = 5000;

ZmCalendarApp.VIEW_FOR_SETTING = {};
ZmCalendarApp.VIEW_FOR_SETTING[ZmSetting.CAL_DAY]		= ZmId.VIEW_CAL_DAY;
ZmCalendarApp.VIEW_FOR_SETTING[ZmSetting.CAL_WEEK]		= ZmId.VIEW_CAL_WEEK;
ZmCalendarApp.VIEW_FOR_SETTING[ZmSetting.CAL_WORK_WEEK]	= ZmId.VIEW_CAL_WORK_WEEK;
ZmCalendarApp.VIEW_FOR_SETTING[ZmSetting.CAL_MONTH]		= ZmId.VIEW_CAL_MONTH;
ZmCalendarApp.VIEW_FOR_SETTING[ZmSetting.CAL_LIST]		= ZmId.VIEW_CAL_LIST;

ZmCalendarApp.COLORS = [];
// these need to match CSS rules
ZmCalendarApp.COLORS[ZmOrganizer.C_ORANGE]	= "Orange";
ZmCalendarApp.COLORS[ZmOrganizer.C_BLUE]	= "Blue";
ZmCalendarApp.COLORS[ZmOrganizer.C_CYAN]	= "Cyan";
ZmCalendarApp.COLORS[ZmOrganizer.C_GREEN]	= "Green";
ZmCalendarApp.COLORS[ZmOrganizer.C_PURPLE]	= "Purple";
ZmCalendarApp.COLORS[ZmOrganizer.C_RED]		= "Red";
ZmCalendarApp.COLORS[ZmOrganizer.C_YELLOW]	= "Yellow";
ZmCalendarApp.COLORS[ZmOrganizer.C_PINK]	= "Pink";
ZmCalendarApp.COLORS[ZmOrganizer.C_GRAY]	= "Gray";

ZmCalendarApp.CUTYPE_INDIVIDUAL			= "IND";
ZmCalendarApp.CUTYPE_GROUP				= "GRO";
ZmCalendarApp.CUTYPE_RESOURCE			= "RES";
ZmCalendarApp.CUTYPE_ROOM				= "ROO";
ZmCalendarApp.CUTYPE_UNKNOWN			= "UNK";

ZmCalendarApp.STATUS_CANC				= "CANC";		// vevent, vtodo
ZmCalendarApp.STATUS_COMP				= "COMP";		// vtodo
ZmCalendarApp.STATUS_CONF				= "CONF";		// vevent
ZmCalendarApp.STATUS_DEFR				= "DEFERRED";	// vtodo					[outlook]
ZmCalendarApp.STATUS_INPR				= "INPR";		// vtodo
ZmCalendarApp.STATUS_NEED				= "NEED";		// vtodo
ZmCalendarApp.STATUS_TENT				= "TENT";		// vevent
ZmCalendarApp.STATUS_WAIT				= "WAITING";	// vtodo					[outlook]

ZmCalendarApp.METHOD_CANCEL				= "CANCEL";
ZmCalendarApp.METHOD_PUBLISH			= "PUBLISH";
ZmCalendarApp.METHOD_REPLY				= "REPLY";
ZmCalendarApp.METHOD_REQUEST			= "REQUEST";
ZmCalendarApp.METHOD_COUNTER			= "COUNTER";

ZmCalendarApp.DEFAULT_WORKING_HOURS			= "1:N:0800:1700,2:Y:0800:1700,3:Y:0800:1700,4:Y:0800:1700,5:Y:0800:1700,6:Y:0800:1700,7:N:0800:1700";
ZmCalendarApp.DEFAULT_APPT_DURATION         = "60"; //60minutes

ZmCalendarApp.reminderTimeWarningDisplayMsgs = [
	ZmMsg.apptRemindNever,
    ZmMsg.apptRemindAtEventTime,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNMinutesBefore,
	ZmMsg.apptRemindNHoursBefore,
	ZmMsg.apptRemindNHoursBefore,
	ZmMsg.apptRemindNHoursBefore,
	ZmMsg.apptRemindNHoursBefore,
	ZmMsg.apptRemindNHoursBefore,
	ZmMsg.apptRemindNDaysBefore,
	ZmMsg.apptRemindNDaysBefore,
	ZmMsg.apptRemindNDaysBefore,
	ZmMsg.apptRemindNDaysBefore,
	ZmMsg.apptRemindNWeeksBefore,
	ZmMsg.apptRemindNWeeksBefore
];

ZmCalendarApp.reminderTimeWarningValues = [-1, 0, 1, 5, 10, 15, 30, 45, 60, 120, 180, 240, 300, 1080, 1440, 2880, 4320, 5760, 10080, 20160];
ZmCalendarApp.reminderTimeWarningLabels = [-1, 0, 1, 5, 10, 15, 30, 45, 60, 2, 3, 4, 5, 18, 1, 2, 3, 4, 1, 2];

// Construction

ZmCalendarApp.prototype._defineAPI =
function() {
	AjxDispatcher.setPackageLoadFunction("CalendarCore", new AjxCallback(this, this._postLoadCore));
	AjxDispatcher.setPackageLoadFunction("Calendar", new AjxCallback(this, this._postLoad, ZmOrganizer.CALENDAR));
	AjxDispatcher.registerMethod("GetCalController", ["MailCore","CalendarCore"], new AjxCallback(this, this.getCalController));
	AjxDispatcher.registerMethod("GetReminderController", ["MailCore","CalendarCore"], new AjxCallback(this, this.getReminderController));
	AjxDispatcher.registerMethod("ShowMiniCalendar", ["MailCore","CalendarCore"], new AjxCallback(this, this.showMiniCalendar));
	AjxDispatcher.registerMethod("GetApptComposeController", ["MailCore","CalendarCore", "Calendar", "CalendarAppt"], new AjxCallback(this, this.getApptComposeController));
};

ZmCalendarApp.prototype._registerSettings =
function(settings) {
	var settings = settings || appCtxt.getSettings();
	settings.registerSetting("CAL_ALWAYS_SHOW_MINI_CAL",	{name: "zimbraPrefCalendarAlwaysShowMiniCal", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal:true});
	settings.registerSetting("CAL_APPT_VISIBILITY",			{name: "zimbraPrefCalendarApptVisibility", type: ZmSetting.T_PREF, dataType: ZmSetting.D_STRING, defaultValue: "public", isGlobal:true});
    settings.registerSetting("CAL_EMAIL_REMINDERS_ADDRESS",	{name: "zimbraPrefCalendarReminderEmail", type:ZmSetting.T_PREF});
    settings.registerSetting("CAL_DEVICE_EMAIL_REMINDERS_ADDRESS",	{name: "zimbraCalendarReminderDeviceEmail", type:ZmSetting.T_PREF});
    settings.registerSetting("CAL_DEVICE_EMAIL_REMINDERS_ENABLED",	{name: "zimbraFeatureCalendarReminderDeviceEmailEnabled", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("CAL_EXPORT",					{type: ZmSetting.T_PREF, dataType: ZmSetting.D_NONE});
	settings.registerSetting("CAL_FIRST_DAY_OF_WEEK",		{name: "zimbraPrefCalendarFirstDayOfWeek", type: ZmSetting.T_PREF, dataType: ZmSetting.D_INT, defaultValue: 0, isGlobal:true});
	settings.registerSetting("CAL_FREE_BUSY_ACL",			{type: ZmSetting.T_PREF, defaultValue:ZmSetting.ACL_ALL});
	settings.registerSetting("CAL_FREE_BUSY_ACL_USERS",		{type: ZmSetting.T_PREF});
    settings.registerSetting("CAL_IMPORT",					{type: ZmSetting.T_PREF, dataType: ZmSetting.D_NONE});
	settings.registerSetting("CAL_INVITE_ACL",				{type: ZmSetting.T_PREF, defaultValue:ZmSetting.ACL_ALL});
	settings.registerSetting("CAL_INVITE_ACL_USERS",		{type: ZmSetting.T_PREF});
	settings.registerSetting("CAL_REMINDER_NOTIFY_SOUNDS",	{name: "zimbraPrefCalendarReminderSoundsEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	settings.registerSetting("CAL_REMINDER_NOTIFY_BROWSER",	{name: "zimbraPrefCalendarReminderFlashTitle", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:true, isGlobal:true});
	settings.registerSetting("CAL_REMINDER_NOTIFY_TOASTER",	{name: "zimbraPrefCalendarToasterEnabled", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue:false, isGlobal:true});
	settings.registerSetting("CAL_REMINDER_WARNING_TIME",	{name: "zimbraPrefCalendarApptReminderWarningTime", type: ZmSetting.T_PREF, dataType: ZmSetting.D_INT, defaultValue: 0, isGlobal:true});
    settings.registerSetting("CAL_SHOW_DECLINED_MEETINGS",  {name: "zimbraPrefCalendarShowDeclinedMeetings", type: ZmSetting.T_PREF,dataType:ZmSetting.D_BOOLEAN, defaultValue:true});
	settings.registerSetting("CAL_SHOW_TIMEZONE",			{name: "zimbraPrefUseTimeZoneListInCalendar", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal:true});
	settings.registerSetting("CAL_USE_QUICK_ADD",			{name: "zimbraPrefCalendarUseQuickAdd", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: true, isGlobal:true});
	settings.registerSetting("CALENDAR_INITIAL_VIEW",		{name: "zimbraPrefCalendarInitialView", type: ZmSetting.T_PREF, defaultValue: ZmSetting.CAL_DAY, isGlobal:true});
    settings.registerSetting("CAL_WORKING_HOURS",           {name: "zimbraPrefCalendarWorkingHours", type: ZmSetting.T_PREF, defaultValue: ZmCalendarApp.DEFAULT_WORKING_HOURS, isGlobal:true});
    settings.registerSetting("FREE_BUSY_VIEW_ENABLED",      {name: "zimbraFeatureFreeBusyViewEnabled", type:ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("DELETE_INVITE_ON_REPLY",		{name: "zimbraPrefDeleteInviteOnReply",type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: true, isGlobal:true});
    settings.registerSetting("ENABLE_APPL_ICAL_DELEGATION", {name: "zimbraPrefAppleIcalDelegationEnabled",type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal:true});
	settings.registerSetting("CAL_AUTO_ADD_INVITES",		{name: "zimbraPrefCalendarAutoAddInvites",type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: true});
	settings.registerSetting("CAL_SEND_INV_DENIED_REPLY",	{name: "zimbraPrefCalendarSendInviteDeniedAutoReply",type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false});
	settings.registerSetting("CAL_INV_FORWARDING_ADDRESS",	{name: "zimbraPrefCalendarForwardInvitesTo", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LIST, isGlobal:true});
	settings.registerSetting("CAL_SHOW_PAST_DUE_REMINDERS",	{name: "zimbraPrefCalendarShowPastDueReminders", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue: true, isGlobal:true});
	settings.registerSetting("CAL_SHOW_CALENDAR_WEEK",		{name: "zimbraPrefShowCalendarWeek", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal:true});
	settings.registerSetting("CAL_APPT_ALLOW_ATTENDEE_EDIT",    {name: "zimbraPrefCalendarApptAllowAtendeeEdit", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue: true, isGlobal:true});
	settings.registerSetting("CAL_RESOURCE_DBL_BOOKING_ALLOWED",	{name: "zimbraCalendarResourceDoubleBookingAllowed", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue: true, isGlobal:true});
	settings.registerSetting("CAL_SHOW_RESOURCE_TABS",	    {name: "zimbraCalendarShowResourceTabs", type:ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue: true, isGlobal:true});
    settings.registerSetting("CAL_DEFAULT_APPT_DURATION",   {name: "zimbraPrefCalendarDefaultApptDuration", type:ZmSetting.T_PREF, dataType:ZmSetting.D_LDAP_TIME, defaultValue:ZmCalendarApp.DEFAULT_APPT_DURATION, isGlobal:true});
    settings.registerSetting("CAL_EXCEPTION_ON_SERIES_TIME_CHANGE",	    {name: "zimbraCalendarKeepExceptionsOnSeriesTimeChange", type:ZmSetting.T_COS, dataType:ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal:true});
    settings.registerSetting("CAL_LOCATION_FIELDS_DISABLED",{name: "zimbraCalendarLocationDisabledFields", type: ZmSetting.T_COS, dataType: ZmSetting.D_STRING, defaultValue: false, isGlobal:true});
};

ZmCalendarApp.prototype._registerPrefs =
function() {
	var sections = {
		CALENDAR: {
			title: ZmMsg.calendar,
			icon: "CalendarApp",
			templateId: "prefs.Pages#Calendar",
			priority: 80,
			precondition: ZmSetting.CALENDAR_ENABLED,
			prefs: [
				ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL,
				ZmSetting.CAL_AUTO_ADD_INVITES,
				ZmSetting.CAL_SEND_INV_DENIED_REPLY,
				ZmSetting.CAL_APPT_VISIBILITY,
				ZmSetting.CAL_EXPORT,
				ZmSetting.CAL_FIRST_DAY_OF_WEEK,
                ZmSetting.CAL_IMPORT,
				ZmSetting.CAL_REMINDER_WARNING_TIME,
				ZmSetting.CAL_REMINDER_NOTIFY_SOUNDS,
				ZmSetting.CAL_REMINDER_NOTIFY_BROWSER,
				ZmSetting.CAL_SHOW_DECLINED_MEETINGS,
				ZmSetting.CAL_SHOW_TIMEZONE,
				ZmSetting.CAL_USE_QUICK_ADD,
				ZmSetting.CALENDAR_INITIAL_VIEW,
				ZmSetting.CAL_WORKING_HOURS,
				ZmSetting.DELETE_INVITE_ON_REPLY,
				ZmSetting.ENABLE_APPL_ICAL_DELEGATION,
				ZmSetting.CAL_FREE_BUSY_ACL,
				ZmSetting.CAL_FREE_BUSY_ACL_USERS,
				ZmSetting.CAL_INVITE_ACL,
				ZmSetting.CAL_INVITE_ACL_USERS,
				ZmSetting.CAL_REMINDER_NOTIFY_TOASTER,
				ZmSetting.CAL_INV_FORWARDING_ADDRESS,
				ZmSetting.CAL_SHOW_PAST_DUE_REMINDERS,
				ZmSetting.CAL_SHOW_CALENDAR_WEEK,
                ZmSetting.CAL_DEFAULT_APPT_DURATION,
                ZmSetting.CAL_LOCATION_FIELDS_DISABLED
			],
			manageDirty: true,
			createView: function(parent, section, controller) {
				AjxDispatcher.require("Alert");
				return new ZmCalendarPrefsPage(parent, section, controller);
			}
		}
	};

	for (var id in sections) {
		ZmPref.registerPrefSection(id, sections[id]);
	}

	ZmPref.registerPref("CAL_ALWAYS_SHOW_MINI_CAL", {
		displayName:		ZmMsg.alwaysShowMiniCal,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

    ZmPref.registerPref("CAL_WORKING_HOURS", {
		displayContainer:	ZmPref.TYPE_CUSTOM
	});

	ZmPref.registerPref("CAL_AUTO_ADD_INVITES", {
		displayName:		ZmMsg.autoAddInvites,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_SEND_INV_DENIED_REPLY", {
		displayName:		ZmMsg.sendInvDeniedAutoReply,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_EMAIL_REMINDERS_ADDRESS", {
		displayName:		ZmMsg.emailNotificationsDescription,
		displayContainer:	ZmPref.TYPE_INPUT,
//		validationFunction: ZmMailApp.validateForwardEmail,
		errorMessage:       ZmMsg.invalidEmail,
		hint:				ZmMsg.enterEmailAddress
	});

    ZmPref.registerPref("CAL_DEVICE_EMAIL_REMINDERS_ADDRESS", {
        displayName:		ZmMsg.deviceEmailNotificationsDescription,
        displayContainer:	ZmPref.TYPE_INPUT,
//		validationFunction: ZmMailApp.validateForwardEmail,
        errorMessage:       ZmMsg.invalidEmail,
        hint:				ZmMsg.enterEmailAddress
    });

	ZmPref.registerPref("CAL_EXPORT", {
		displayName:		ZmMsg.exportToICS,
		displayContainer:	ZmPref.TYPE_EXPORT
	});

	ZmPref.registerPref("CAL_FIRST_DAY_OF_WEEK", {
		displayName:		ZmMsg.calendarFirstDayOfWeek,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		AjxDateUtil.WEEKDAY_LONG,
		options:			[0,1,2,3,4,5,6]
	});

	ZmPref.registerPref("CAL_FREE_BUSY_ACL", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayOptions:		[ZmMsg.freeBusyAllowAll, ZmMsg.freeBusyAllowLocal, ZmMsg.freeBusyAllowDomain, ZmMsg.freeBusyAllowNone, ZmMsg.freeBusyAllowSome],
		options:			[ZmSetting.ACL_PUBLIC, ZmSetting.ACL_AUTH, ZmSetting.ACL_DOMAIN, ZmSetting.ACL_NONE, ZmSetting.ACL_USER]
	});

	ZmPref.registerPref("CAL_FREE_BUSY_ACL_USERS", {
		displayContainer:	ZmPref.TYPE_TEXTAREA,
		hint: ZmMsg.enterEmailAddresses
	});

	ZmPref.registerPref("CAL_IMPORT", {
		displayName:		ZmMsg.importFromICS,
		displayContainer:	ZmPref.TYPE_IMPORT
	});

	ZmPref.registerPref("CAL_INVITE_ACL", {
		displayContainer:	ZmPref.TYPE_RADIO_GROUP,
		displayOptions:		[ZmMsg.invitesAllowAll, ZmMsg.invitesAllowLocal, ZmMsg.invitesAllowNone, ZmMsg.invitesAllowSome],
		options:			[ZmSetting.ACL_PUBLIC, ZmSetting.ACL_AUTH, ZmSetting.ACL_NONE, ZmSetting.ACL_USER]
	});

	ZmPref.registerPref("CAL_INVITE_ACL_USERS", {
		displayContainer:	ZmPref.TYPE_TEXTAREA,
		hint: ZmMsg.enterEmailAddresses
	});

	ZmPref.registerPref("CAL_REMINDER_WARNING_TIME", {
		displayName:		ZmMsg.numberOfMinutes,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		ZmCalendarApp.getReminderTimeWarningDisplayOptions(),
		options:            ZmCalendarApp.reminderTimeWarningValues,
        setFunction:        ZmCalendarApp.setDefaultReminderTimePrefValueOnSave,
        loadFunction:       ZmCalendarApp.postLoadSetDefaultReminderValue
	});

	ZmPref.registerPref("CAL_SHOW_DECLINED_MEETINGS", {
		displayName:        ZmMsg.showDeclinedMeetings,
		displayContainer:   ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_SHOW_TIMEZONE", {
		displayName:		ZmMsg.shouldShowTimezone,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_USE_QUICK_ADD", {
	 	displayName:		ZmMsg.useQuickAdd,
	 	displayContainer:	ZmPref.TYPE_CHECKBOX
	 });

	ZmPref.registerPref("CALENDAR_INITIAL_VIEW", {
		displayName:		ZmMsg.calendarInitialView,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		[ZmMsg.calViewDay, ZmMsg.calViewWorkWeek, ZmMsg.calViewWeek, ZmMsg.calViewMonth, ZmMsg.calViewList],
        options:			[ZmSetting.CAL_DAY, ZmSetting.CAL_WORK_WEEK, ZmSetting.CAL_WEEK, ZmSetting.CAL_MONTH, ZmSetting.CAL_LIST]
	});

	ZmPref.registerPref("CAL_REMINDER_NOTIFY_SOUNDS", {
		displayName:		ZmMsg.playSound,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_REMINDER_NOTIFY_BROWSER", {
		displayName:		ZmMsg.flashBrowser,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("DELETE_INVITE_ON_REPLY", {
		displayName: ZmMsg.deleteInviteOnReply,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("ENABLE_APPL_ICAL_DELEGATION", {
		displayName: ZmMsg.enableAppleICalDelegation,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	AjxDispatcher.require("Alert");
	var notifyText = ZmDesktopAlert.getInstance().getDisplayText();
	ZmPref.registerPref("CAL_REMINDER_NOTIFY_TOASTER", {
		displayFunc:		function() { return notifyText; },
		precondition:		!!notifyText,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_APPT_VISIBILITY", {
		displayName:		ZmMsg.calendarInitialApptVisibility,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		[ZmMsg._public, ZmMsg._private],
		options:			[ZmSetting.CAL_VISIBILITY_PUB, ZmSetting.CAL_VISIBILITY_PRIV]
	});

	ZmPref.registerPref("CAL_INV_FORWARDING_ADDRESS", {
		displayName:		ZmMsg.inviteForwardingAddress,
		displayContainer:	ZmPref.TYPE_INPUT,
		validationFunction: ZmPref.validateEmailList,
        valueFunction:      ZmPref.string2EmailList,
		errorMessage:		ZmMsg.invalidEmail,
		hint:				ZmMsg.enterEmailAddress
	});

	ZmPref.registerPref("CAL_SHOW_PAST_DUE_REMINDERS", {
		displayName: ZmMsg.apptPastDueReminderLabel,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("CAL_SHOW_CALENDAR_WEEK", {
		displayName: ZmMsg.showWeekNumber,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

    ZmPref.registerPref("CAL_DEFAULT_APPT_DURATION", {
		displayName:		ZmMsg.defaultApptDuration,
		displayContainer:	ZmPref.TYPE_SELECT,
		displayOptions:		["30","60","90","120"],
		options:			["1800", "3600", "5400", "7200"]
	});
};

ZmCalendarApp.prototype._registerOperations =
function() {
	ZmOperation.registerOp(ZmId.OP_CAL_LIST_VIEW, {textKey:"list", tooltipKey:"viewCalListTooltip", image:"CalListView", shortcut:ZmKeyMap.CAL_LIST_VIEW});
	ZmOperation.registerOp(ZmId.OP_CAL_REFRESH, {textKey:"refresh", tooltipKey:"calRefreshTooltip", image:"Refresh", shortcut:ZmKeyMap.REFRESH, showImageInToolbar: true});
	ZmOperation.registerOp(ZmId.OP_CAL_VIEW_MENU, {textKey:"view", image:"Appointment"}, null,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmCalendarApp.addCalViewMenu, parent);
	}));
	ZmOperation.registerOp(ZmId.OP_DAY_VIEW, {textKey:"viewDay", tooltipKey:"viewDayTooltip", image:"DayView", shortcut:ZmKeyMap.CAL_DAY_VIEW});
	ZmOperation.registerOp(ZmId.OP_EDIT_REPLY_ACCEPT, {textKey:"replyAccept", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_EDIT_REPLY_CANCEL);
	ZmOperation.registerOp(ZmId.OP_EDIT_REPLY_TENTATIVE, {textKey:"replyTentative", image:"QuestionMark"});
	ZmOperation.registerOp(ZmId.OP_EDIT_REPLY_DECLINE, {textKey:"replyDecline", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_INVITE_REPLY_ACCEPT, {textKey:"editReply", image:"Check"});
	ZmOperation.registerOp(ZmId.OP_INVITE_REPLY_DECLINE, {textKey:"editReply", image:"Cancel"});
	ZmOperation.registerOp(ZmId.OP_INVITE_REPLY_MENU, {textKey:"editReply", image:"Reply"}, ZmSetting.MAIL_ENABLED,
		AjxCallback.simpleClosure(function(parent) {
			ZmOperation.addDeferredMenu(ZmCalendarApp.addInviteReplyMenu, parent);
	}));
	ZmOperation.registerOp(ZmId.OP_INVITE_REPLY_TENTATIVE, {textKey:"editReply", image:"QuestionMark"});
	ZmOperation.registerOp(ZmId.OP_MONTH_VIEW, {textKey:"viewMonth", tooltipKey:"viewMonthTooltip", image:"MonthView", shortcut:ZmKeyMap.CAL_MONTH_VIEW});
	ZmOperation.registerOp(ZmId.OP_MOUNT_CALENDAR, {textKey:"mountCalendar", image:"GroupSchedule"});
	ZmOperation.registerOp(ZmId.OP_NEW_ALLDAY_APPT, {textKey:"newAllDayAppt", tooltipKey:"newAllDayApptTooltip", image:"NewAppointment"});
	ZmOperation.registerOp(ZmId.OP_NEW_APPT, {textKey:"newAppt", tooltipKey:"newApptTooltip", image:"NewAppointment", shortcut:ZmKeyMap.NEW_APPT});
	ZmOperation.registerOp(ZmId.OP_NEW_CALENDAR, {textKey:"newCalendar", image:"NewAppointment", tooltipKey: "newCalendarTooltip", shortcut:ZmKeyMap.NEW_CALENDAR});
	ZmOperation.registerOp(ZmId.OP_ADD_EXTERNAL_CALENDAR, {textKey:"addExternalCalendar", image:"NewAppointment", tooltipKey: "addExternalCalendarTooltip", shortcut:ZmKeyMap.ADD_EXTERNAL_CALENDAR});
    ZmOperation.registerOp(ZmId.OP_PRINT_CALENDAR, {textKey:"print", tooltipKey:"printTooltip", image:"Print", shortcut:ZmKeyMap.PRINT, textPrecedence:30, showImageInToolbar: true}, ZmSetting.PRINT_ENABLED);
    ZmOperation.registerOp(ZmId.OP_PROPOSE_NEW_TIME, {textKey:"proposeNewTime", image:"ProposeTime", showTextInToolbar: true, showImageInToolbar: true});
    ZmOperation.registerOp(ZmId.OP_REINVITE_ATTENDEES, {textKey:"reinviteAttendees", image:"MeetingRequest"});
    ZmOperation.registerOp(ZmId.OP_FB_VIEW, {textKey:"viewFB", tooltipKey:"viewFBTooltip", image:"GroupSchedule", shortcut:ZmKeyMap.CAL_FB_VIEW});
	ZmOperation.registerOp(ZmId.OP_SEARCH_MAIL, {textKey:"searchMail", image:"SearchMail"}, ZmSetting.MAIL_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SHARE_CALENDAR, {textKey:"shareCalendar", image:"CalendarFolder"});
	ZmOperation.registerOp(ZmId.OP_TODAY, {textKey:"today", tooltipKey:"todayTooltip", image:"Date", shortcut:ZmKeyMap.TODAY});
	ZmOperation.registerOp(ZmId.OP_VIEW_APPOINTMENT, {textKey:"viewAppointment", image:"Appointment"});
	ZmOperation.registerOp(ZmId.OP_OPEN_APPT_INSTANCE, {textKey:"openApptInstance", image:"Appointment"});
	ZmOperation.registerOp(ZmId.OP_OPEN_APPT_SERIES, {textKey:"openApptSeries", image:"Appointment"});
	ZmOperation.registerOp(ZmId.OP_DELETE_APPT_INSTANCE, {textKey:"deleteApptInstance", image:"Delete"});
	ZmOperation.registerOp(ZmId.OP_DELETE_APPT_SERIES, {textKey:"deleteApptSeries", image:"Delete"});
	ZmOperation.registerOp(ZmId.OP_VIEW_APPT_INSTANCE, {textKey:"apptInstance", image:"Appointment"});
	ZmOperation.registerOp(ZmId.OP_VIEW_APPT_SERIES, {textKey:"apptSeries", image:"Appointment"});
	ZmOperation.registerOp(ZmId.OP_WEEK_VIEW, {textKey:"viewWeek", tooltipKey:"viewWeekTooltip", image:"WeekView", shortcut:ZmKeyMap.CAL_WEEK_VIEW});
	ZmOperation.registerOp(ZmId.OP_WORK_WEEK_VIEW, {textKey:"viewWorkWeek", tooltipKey:"viewWorkWeekTooltip", image:"WorkWeekView", shortcut:ZmKeyMap.CAL_WORK_WEEK_VIEW});
	ZmOperation.registerOp(ZmId.OP_FORWARD_APPT, {textKey:"forward", tooltipKey:"forward", image:"Forward"});
	ZmOperation.registerOp(ZmId.OP_FORWARD_APPT_INSTANCE, {textKey:"forwardInstance", tooltipKey:"forwardInstance", image:"Forward"});
	ZmOperation.registerOp(ZmId.OP_FORWARD_APPT_SERIES, {textKey:"forwardSeries", tooltipKey:"forwardSeries", image:"Forward"});
	ZmOperation.registerOp(ZmId.OP_DUPLICATE_APPT, {textKey:"createCopy", tooltipKey:"createCopy", image:"Copy"});
    ZmOperation.registerOp(ZmId.OP_INVITE_ATTENDEES, {textKey:"inviteAttendees", tooltipKey:"inviteAttendees", image:"Group"});
    ZmOperation.registerOp(ZmId.OP_SEND_INVITE, {textKey:"send", tooltipKey:"sendInvites", image:"MeetingRequest"});
};

ZmCalendarApp.prototype._registerItems =
function() {
	ZmItem.registerItem(ZmItem.APPT,
						{app:			ZmApp.CALENDAR,
						 nameKey:		"appointment",
						 icon:			"Appointment",
						 soapCmd:		"ItemAction",
						 itemClass:		"ZmAppt",
						 node:			"appt",
						 organizer:		ZmOrganizer.CALENDAR,
						 dropTargets:	[ZmOrganizer.TAG, ZmOrganizer.CALENDAR],
						 searchType:	"appointment",
						 resultsList:
	   AjxCallback.simpleClosure(function(search) {
		   AjxDispatcher.require(["MailCore", "CalendarCore"]);
		   return new ZmApptList(ZmItem.APPT, search);
	   }, this)
						});

	ZmItem.registerItem(ZmItem.RESOURCE,
						{app:			ZmApp.CALENDAR,
						 itemClass:		"ZmResource",
						 node:			"calResource",
						 resultsList:
		AjxCallback.simpleClosure(function(search) {
			AjxDispatcher.require(["MailCore", "CalendarCore"]);
			return new ZmResourceList(null, search);
		}, this)
						});
};

ZmCalendarApp.prototype._registerOrganizers =
function() {
	ZmOrganizer.registerOrg(ZmOrganizer.CALENDAR,
							{app:				ZmApp.CALENDAR,
							 nameKey:			"calendar",
							 defaultFolder:		ZmOrganizer.ID_CALENDAR,
							 soapCmd:			"FolderAction",
							 firstUserId:		256,
							 orgClass:			"ZmCalendar",
							 orgPackage:		"CalendarCore",
							 treeController:	"ZmCalendarTreeController",
							 labelKey:			"calendars",
							 itemsKey:			"appointments",
							 hasColor:			true,
                             defaultColor:      ZmOrganizer.C_BLUE,
							 treeType:			ZmOrganizer.FOLDER,
							 views:				["appointment"],
							 folderKey:			"calendar",
							 mountKey:			"mountCalendar",
							 createFunc:		"ZmCalendar.create",
							 compareFunc:		"ZmFolder.sortCompareNonMail",
							 newOp:				ZmOperation.NEW_CALENDAR,
							 displayOrder:		100,
							 deferrable:		true,
							 childWindow:		true
							});
};

ZmCalendarApp.prototype._setupSearchToolbar =
function() {
    var params = {
        msgKey:		"appointments",
        tooltipKey:	"searchAppts",
        icon:			"Appointment",
        shareIcon:		"SharedCalendarFolder",
        id:			ZmId.getMenuItemId(ZmId.SEARCH, ZmId.ITEM_APPOINTMENT)
    };
    // always enable appt search for offline
    if(!appCtxt.isOffline) {
        params["setting"] = ZmSetting.CALENDAR_ENABLED;
    }
	ZmSearchToolBar.addMenuItem(ZmItem.APPT, params);
};

ZmCalendarApp.prototype._registerApp =
function() {
	var newItemOps = {};
	newItemOps[ZmOperation.NEW_APPT] = "appointment";

	var newOrgOps = {};
	newOrgOps[ZmOperation.NEW_CALENDAR] = "calendar";

	var actionCodes = {};
	actionCodes[ZmKeyMap.NEW_APPT]		= ZmOperation.NEW_APPT;
	actionCodes[ZmKeyMap.NEW_CALENDAR]	= ZmOperation.NEW_CALENDAR;
	actionCodes[ZmKeyMap.ADD_EXTERNAL_CALENDAR]	= ZmOperation.ADD_EXTERNAL_CALENDAR;

	ZmApp.registerApp(ZmApp.CALENDAR,
							 {mainPkg:				"Calendar",
							  nameKey:				"calendar",
							  icon:					"CalendarApp",
							  textPrecedence:		60,
							  chooserTooltipKey:	"goToCalendar",
							  viewTooltipKey:		"displayCalendar",
							  defaultSearch:		ZmItem.APPT,
							  organizer:			ZmOrganizer.CALENDAR,
							  overviewTrees:		[ZmOrganizer.CALENDAR, ZmOrganizer.SEARCH, ZmOrganizer.TAG],
							  newItemOps:			newItemOps,
							  newOrgOps:			newOrgOps,
							  actionCodes:			actionCodes,
							  searchTypes:			[ZmItem.APPT],
							  gotoActionCode:		ZmKeyMap.GOTO_CALENDAR,
							  newActionCode:		ZmKeyMap.NEW_APPT,
							  chooserSort:			30,
							  defaultSort:			20,
							  upsellUrl:			ZmSetting.CALENDAR_UPSELL_URL,
                              //quickCommandType:		ZmQuickCommand[ZmId.ITEM_APPOINTMENT],
							  searchResultsTab:		true
							  });
};

ZmCalendarApp.prototype._getRefreshButtonTooltip =
function() {
	return ZmMsg.showAllEventsFromSelectedCalendars;
};

// App API

ZmCalendarApp.prototype.startup =
function(result) {
};

ZmCalendarApp.prototype.refresh =
function(refresh) {
	if (!appCtxt.inStartup) {
        this.resetOverview(this.getOverviewId());
		AjxDispatcher.run("GetCalController").refreshHandler(refresh);
	}
};

ZmCalendarApp.prototype.runRefresh =
function() {
	appCtxt.getCalManager().getCalViewController().runRefresh();
};


ZmCalendarApp.prototype.deleteNotify =
function(ids, force) {
	if (!force && this._deferNotifications("delete", ids)) { return; }
	AjxDispatcher.run("GetCalController").notifyDelete(ids);
};

/**
 * Checks for the creation of a calendar or a mount point to one, or an
 * appointment.
 *
 * @param {Hash}	creates	a hash of create notifications
 * 
 * @private
 */
ZmCalendarApp.prototype.createNotify =
function(creates, force) {
	if (!creates["folder"] && !creates["appt"] && !creates["link"]) { return; }
	if (!force && !this._noDefer && this._deferNotifications("create", creates)) { return; }

	var ctlr = AjxDispatcher.run("GetCalController");
	for (var name in creates) {
		var list = creates[name];
		for (var i = 0; i < list.length; i++) {
			var create = list[i];
			if (appCtxt.cacheGet(create.id)) { continue; }

			if (name == "folder") {
				this._handleCreateFolder(create, ZmOrganizer.CALENDAR);
			} else if (name == "link") {
				this._handleCreateLink(create, ZmOrganizer.CALENDAR);
			} else if (name == "appt") {
				ctlr.notifyCreate(create);
			}

			if ((name == "folder" || name == "link") && ctlr) {
				ctlr._updateCheckedCalendars();
			}
		}
	}
};

ZmCalendarApp.prototype.modifyNotify =
function(modifies, force) {
	if (!force && !this._noDefer && this._deferNotifications("modify", modifies)) { return; }
	AjxDispatcher.run("GetCalController").notifyModify(modifies);
};

ZmCalendarApp.prototype.preNotify =
function(notify) {
	var ctlr = AjxDispatcher.run("GetCalController");
	if (ctlr) {
		ctlr.preNotify(notify);
	}
};

ZmCalendarApp.prototype.postNotify =
function(notify) {
	var ctlr = AjxDispatcher.run("GetCalController");
	if (ctlr) {
		ctlr.postNotify(notify);
	}
};

ZmCalendarApp.prototype.handleOp =
function(op) {
	if (!appCtxt.isWebClientOffline()) {
		switch (op) {
			case ZmOperation.NEW_APPT: {
				var loadCallback = new AjxCallback(this, this._handleLoadNewAppt);
				AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar"], false, loadCallback, null, true);
				break;
			}
			case ZmOperation.NEW_CALENDAR: {
				var loadCallback = new AjxCallback(this, this._handleLoadNewCalendar);
				AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar"], false, loadCallback, null, true);
				break;
			}
			case ZmOperation.ADD_EXTERNAL_CALENDAR: {
				var loadCallback = new AjxCallback(this, this._handleLoadExternalCalendar);
				AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar"], false, loadCallback, null, true);
				break;
			}
		}
	}
};

ZmCalendarApp.prototype._handleLoadNewAppt =
function() {
	Dwt.setLoadingTime("ZmCalendarApp-newAppt");
	AjxDispatcher.run("GetCalController").newAppointment(null, null, null, null);
	Dwt.setLoadedTime("ZmCalendarApp-newAppt");
};

ZmCalendarApp.prototype._handleLoadNewCalendar =
function() {
	appCtxt.getAppViewMgr().popView(true, ZmId.VIEW_LOADING);	// pop "Loading..." page
	var dialog = appCtxt.getNewCalendarDialog();
	if (!this._newCalendarCb) {
		this._newCalendarCb = new AjxCallback(this, this._newCalendarCallback);
	}
	ZmController.showDialog(dialog, this._newCalendarCb);
};

ZmCalendarApp.prototype._handleLoadExternalCalendar =
function() {
    appCtxt.getAppViewMgr().popView(true, ZmId.VIEW_LOADING);
	var oc = appCtxt.getOverviewController();
    var tc = oc.getTreeController(ZmOrganizer.CALENDAR);
    if(tc) {
        tc._addExternalCalendarListener();
    }
};

// Public methods

ZmCalendarApp.prototype.launch =
function(params, callback) {
	this._setLaunchTime(this.toString(), new Date());
	var loadCallback = new AjxCallback(this, this._handleLoadLaunch, [params, callback]);
	AjxDispatcher.require(["MailCore", "ContactsCore", "CalendarCore", "Calendar"], true, loadCallback, null, true);
};

ZmCalendarApp.prototype._handleLoadLaunch =
function(params, callback) {
	var cc = AjxDispatcher.run("GetCalController");
	var view = cc.getDefaultViewType();
	var sd = null;

	params = params || {};
	if (params.qsParams) {
		var viewArg = params.qsParams.view;
		if (viewArg) {
			var viewId = ZmCalendarApp.VIEW_FOR_SETTING[viewArg];
			if (viewId) {
				view = viewId;
				var date = params.qsParams.date;
				if (date) {
					date = AjxDateUtil.parseServerDateTime(date);
					if (date && !isNaN(date)) {
						sd = new Date((date).setHours(0,0,0,0));
					}
				}
			}
		}
	}

	if (appCtxt.get(ZmSetting.CONTACTS_ENABLED)) {
		this.initResources();
	}
    ZmCalendarApp.postLoadSetDefaultReminderValue();
	cc.show(view, sd);
	this._setLoadedTime(this.toString(), new Date());
	if (callback) {
		callback.run();
	}
	this._setRefreshButtonTooltip();
};

ZmCalendarApp.prototype.getNewButtonProps =
function() {
	return {
		text:		ZmMsg.newAppt,
		tooltip:	ZmMsg.createNewAppt,
		icon:		"NewAppointment",
		iconDis:	"NewAppointmentDis",
		defaultId:	ZmOperation.NEW_APPT,
		disabled:	!this.containsWritableFolder()
	};
};

ZmCalendarApp.prototype.showSearchResults =
function(results, callback) {
	// calls ZmSearchController's _handleLoadShowResults
	if (callback) {
		callback.run(AjxDispatcher.run("GetCalController"));
	}
};

ZmCalendarApp.prototype.activate =
function(active, viewId) {
    this._createDeferredFolders(ZmApp.CALENDAR);
	ZmApp.prototype.activate.apply(this, arguments);

	if (appCtxt.get(ZmSetting.CALENDAR_ENABLED)) {
		var avm = appCtxt.getAppViewMgr();
		var show = (active || appCtxt.get(ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL)) && !avm.isHidden(ZmAppViewMgr.C_TREE_FOOTER, viewId);
		AjxDispatcher.run("ShowMiniCalendar", show);
	}
};

// Online to Offline or Offline to Online; Called from ZmApp.activate and from ZmOffline.enableApps, disableApps
ZmCalendarApp.prototype.resetWebClientOfflineOperations =
function() {
	ZmApp.prototype.resetWebClientOfflineOperations.apply(this);
	var controller = this.getCalController();
	if (controller) {
		controller._resetToolbarOperations();
		controller._clearViewActionMenu();
	}
};

/**
 * Shows the mini-calendar.
 *
 * @param	{Boolean}	show		if <code>true</code>, show the mini-calendar
 * @param	{int}	delay			the delay (in seconds)
 */
ZmCalendarApp.prototype.showMiniCalendar =
function(show, delay) {
	var mc = AjxDispatcher.run("GetCalController").getMiniCalendar(delay);
	mc.setSkipNotifyOnPage(show && !this._active);
	if (!this._active) {
		mc.setSelectionMode(DwtCalendar.DAY);
	}
	appCtxt.getAppViewMgr().displayComponent(ZmAppViewMgr.C_TREE_FOOTER, show);
};

// common API shared by tasks app
/**
 * Gets the list controller.
 *
 * @return	{ZmCalViewController}		the controller
 *
 * @see		#getCalController
 */
ZmCalendarApp.prototype.getListController =
function() {
	return AjxDispatcher.run("GetCalController");
};

/**
 * Gets the calendar controller.
 * 
 * @return	{ZmCalViewController}		the controller
 */
ZmCalendarApp.prototype.getCalController =
function(sessionId, searchResultsController) {
	AjxDispatcher.require(["Startup2", "MailCore", "CalendarCore"]);
	return this.getSessionController({controllerClass:			"ZmCalViewController",
									  sessionId:				sessionId || ZmApp.MAIN_SESSION,
									  searchResultsController:	searchResultsController});
};

/**
 * Gets the free busy cache.
 *
 * @return	{ZmFreeBusyCache} free busy cache object
 */
ZmCalendarApp.prototype.getFreeBusyCache =
function() {
	if (!this._freeBusyCache) {
		AjxDispatcher.require(["MailCore", "CalendarCore"]);
		this._freeBusyCache = new ZmFreeBusyCache(this);
	}
	return this._freeBusyCache;
};

/**
 * Gets the reminder controller.
 *
 * @return	{ZmReminderController}	the controller
 */
ZmCalendarApp.prototype.getReminderController =
function() {
	if (!this._reminderController) {
		AjxDispatcher.require(["MailCore", "CalendarCore"]);
		var calMgr = appCtxt.getCalManager();
		this._reminderController = calMgr.getReminderController();
		this._reminderController._calController = AjxDispatcher.run("GetCalController");
	}
	return this._reminderController;
};

/**
 * Gets the appointment compose controller.
 * 
 * @return	{ZmApptComposeController}	the controller
 */
ZmCalendarApp.prototype.getApptComposeController =
function(sessionId) {
	AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar", "CalendarAppt"]);
	return this.getSessionController({controllerClass:	"ZmApptComposeController",
									  sessionId:		sessionId});
};

ZmCalendarApp.prototype.getSimpleApptComposeController =
function() {
	AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar", "CalendarAppt"]);
	return this.getSessionController({controllerClass:	"ZmSimpleApptComposeController"});
};

ZmCalendarApp.prototype.getApptViewController =
function(sessionId) {
	AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar", "CalendarAppt"]);
	return this.getSessionController({controllerClass:	"ZmApptController",
									  sessionId:		sessionId});
};

ZmCalendarApp.prototype.initResources =
function() {
	if (!this._locations) {
		this._locations = new ZmResourceList(ZmCalBaseItem.LOCATION);
		this._locations.isCanonical = true;
	}

	if (!this._equipment) {
		this._equipment = new ZmResourceList(ZmCalBaseItem.EQUIPMENT);
		this._equipment.isCanonical = true;
	}
};

ZmCalendarApp.prototype.loadResources =
function() {
	this.initResources();

	if (appCtxt.get(ZmSetting.GAL_ENABLED)) {
		var batchCmd = new ZmBatchCommand();
		if (!this._locations.isLoaded) {
			batchCmd.add(new AjxCallback(this._locations, this._locations.load));
		}
		if (!this._equipment.isLoaded) {
			batchCmd.add(new AjxCallback(this._equipment, this._equipment.load));
		}
		if (batchCmd._cmds.length) {
			batchCmd.run();
		}
	}
};

/**
 * Gets a list of locations.
 * 
 * @return	{ZmResourceList}	the resource list
 */
ZmCalendarApp.prototype.getLocations =
function() {
	this.initResources();
	return this._locations;
};

/**
 * Gets a list of equipment.
 * 
 * @return	{ZmResourceList}	the resource list
 */
ZmCalendarApp.prototype.getEquipment =
function() {
	this.initResources();
	return this._equipment;
};

/**
 * Gets the list of calendar ids for reminders. If calendar packages are not loaded,
 * gets the list from deferred folder ids.
 *
 * @return	{Array}	an array of ids
 */
ZmCalendarApp.prototype.getReminderCalendarFolderIds =
function() {
	var folderIds = [];
	if (AjxDispatcher.loaded("CalendarCore")) {
		folderIds = AjxDispatcher.run("GetCalController").getReminderCalendarFolderIds();
	} else {
		// will be used in reminder dialog
		this._folderNames = {};
		for (var i = 0; i < this._deferredFolders.length; i++) {
			var params = this._deferredFolders[i];
			folderIds.push(params.obj.id);
			// _folderNames are used when deferred folders are not created
			// and calendar name is required. example: calendar name
			// requirement in reminder module
			this._folderNames[params.obj.id] = params.obj.name;
		}
	}
	return folderIds;
};

/**
 * Gets the list of checked calendar ids. If calendar packages are not loaded,
 * gets the list from deferred folder ids.
 *
 * @param	{Boolean}		localOnly	if <code>true</code>, use local calendar only
 * @return	{Array}	an array of ids
 */
ZmCalendarApp.prototype.getCheckedCalendarFolderIds =
function(localOnly, includeTrash) {
	var folderIds = [];
	if (AjxDispatcher.loaded("CalendarCore")) {
		folderIds = AjxDispatcher.run("GetCalController").getCheckedCalendarFolderIds(localOnly, includeTrash);
	} else {
		// will be used in reminder dialog
		this._folderNames = {};
		for (var i = 0; i < this._deferredFolders.length; i++) {
			var params = this._deferredFolders[i];
			var str = (params && params.obj && params.obj.f) ? params.obj.f : "";
			if (str && (str.indexOf(ZmOrganizer.FLAG_CHECKED) != -1)) {
				if (localOnly && params.obj.zid != null) {
					continue;
				}
                if (params.obj.id == ZmOrganizer.ID_TRASH && !includeTrash) {
                    continue;
                }
				folderIds.push(params.obj.id);
				// _folderNames are used when deferred folders are not created
				// and calendar name is required. example: calendar name
				// requirement in reminder module
				this._folderNames[params.obj.id] = params.obj.name;
			}
		}
	}
	return folderIds;
};

/**
 * Gets the name of the calendar with specified id.
 *
 * @param	{String}	id		the id of the calendar
 * @return	{String}	the name
 */
ZmCalendarApp.prototype.getCalendarName =
function(id) {
	// _folderNames are used when deferred folders are not created and calendar
	// name is required. example: calendar name requirement in reminder module
	return appCtxt.getById(id) ? appCtxt.getById(id).name : this._folderNames[id];
};

/**
 * Creates a new button with a {@link DwtCalendar} as the menu.
 * 
 * @param	{DwtComposite}	parent						the parent
 * @param	{String}	buttonId 					the button id to fetch inside DOM and append DwtButton to
 * @param	{AjxListener}	dateButtonListener			the listener to call when date button is pressed
 * @param	{AjxListener}	dateCalSelectionListener	the listener to call when date is selected in {@link DwtCalendar}
 */
ZmCalendarApp.createMiniCalButton =
function(parent, buttonId, dateButtonListener, dateCalSelectionListener, reparent) {
	// create button
	var params = {parent:parent};
	if (reparent === false) {
		params.id = buttonId;
	}
	var dateButton = new DwtButton(params);
	dateButton.addDropDownSelectionListener(dateButtonListener);
	//make sure to listen to the tiny left-edge(thats not part of drop-down menu)
	dateButton.addSelectionListener(dateButtonListener);
    //to keep the image unchanged on hover
    dateButton.setDropDownHovImage(null);
	dateButton.setData(Dwt.KEY_ID, buttonId);
	if (AjxEnv.isIE) {
		dateButton.setSize("20");
	}

	// create menu for button
	var calMenu = new DwtMenu({parent:dateButton, style:DwtMenu.CALENDAR_PICKER_STYLE});
	calMenu.setSize("150");
	calMenu._table.width = "100%";
	dateButton.setMenu(calMenu, true);

	// create mini cal for menu for button
	var cal = new DwtCalendar({parent:calMenu});
	cal.setData(Dwt.KEY_ID, buttonId);
	cal.setSkipNotifyOnPage(true);
	var fdow = appCtxt.get(ZmSetting.CAL_FIRST_DAY_OF_WEEK) || 0;
	cal.setFirstDayOfWeek(fdow);
	cal.addSelectionListener(dateCalSelectionListener);
	// add settings change listener on mini cal in case first day of week setting changes
	// safety check since this is static code (may not have loaded calendar)
	var fdowSetting = appCtxt.getSettings().getSetting(ZmSetting.CAL_FIRST_DAY_OF_WEEK);
	if (fdowSetting) {
		var listener = new AjxListener(null, ZmCalendarApp._settingChangeListener, cal);
		fdowSetting.addChangeListener(listener);
	}

	if (reparent !== false) {
		dateButton.reparentHtmlElement(buttonId);
	}

	return dateButton;
};

/**
 * Creates a new button with a reminder options as its menu.
 * 
 * @param	{DwtComposite}	parent						the parent
 * @param	{String}	buttonId 					the button id to fetch inside DOM and append DwtButton to
 * @param	{AjxListener}	buttonListener			the listener to call when date button is pressed
 * @param	{AjxListener}	menuSelectionListener	the listener to call when date is selected in {@link DwtCalendar}
 */
ZmCalendarApp.createReminderButton =
function(parent, buttonId, buttonListener, menuSelectionListener) {
	// create button
	var reminderButton = new DwtButton({parent:parent});
	reminderButton.addDropDownSelectionListener(buttonListener);
	reminderButton.setData(Dwt.KEY_ID, buttonId);
	if (AjxEnv.isIE) {
		reminderButton.setSize("20");
	}

	// create menu for button
	var reminderMenu = new DwtMenu({parent:reminderButton, style:DwtMenu.DROPDOWN_STYLE});
	reminderMenu.setSize("150");
	reminderButton.setMenu(reminderMenu, true);

	var defaultWarningTime = appCtxt.get(ZmSetting.CAL_REMINDER_WARNING_TIME);

	for (var i = 0; i < ZmCalendarApp.reminderTimeWarningDisplayMsgs.length; i++) {
		var optLabel = ZmCalendarApp.__formatLabel(ZmCalendarApp.reminderTimeWarningDisplayMsgs[i], ZmCalendarApp.reminderTimeWarningLabels[i]);
		var mi = new DwtMenuItem({parent: reminderMenu, style: DwtMenuItem.NO_STYLE});
		mi.setText(optLabel);
		mi.setData("value",ZmCalendarApp.reminderTimeWarningValues[i]);
		if(menuSelectionListener) mi.addSelectionListener(menuSelectionListener);
	}

	// reparent and cleanup
	reminderButton.reparentHtmlElement(buttonId);
	delete buttonId;

	return reminderButton;
};

/**
 * Gets the summary of reminder info from the reminder minutes.
 * 
 * @param {int}	reminderMinutes		the number of minutes before which reminder should be shown
 * @return	{String}		the summary
 */
ZmCalendarApp.getReminderSummary =
function(reminderMinutes) {

	var hoursConvertable = ((reminderMinutes%60) == 0);
	var daysConvertable  = ((reminderMinutes%(60*24)) == 0);
	var weeksConvertable = ((reminderMinutes%(60*24*7)) == 0);

    if (reminderMinutes === -1)	{ return ZmMsg.apptRemindNever; }
    if (reminderMinutes === 0)	{ return ZmMsg.apptRemindAtEventTime; }
	if (weeksConvertable)		{ return ZmCalendarApp.__formatLabel(ZmMsg.apptRemindNWeeksBefore, reminderMinutes/(60*24*7)); }
	if (daysConvertable)		{ return ZmCalendarApp.__formatLabel(ZmMsg.apptRemindNDaysBefore, reminderMinutes/(60*24)); }
	if (hoursConvertable)		{ return ZmCalendarApp.__formatLabel(ZmMsg.apptRemindNHoursBefore, reminderMinutes/60); }

	return ZmCalendarApp.__formatLabel(ZmMsg.apptRemindNMinutesBefore, reminderMinutes);
};

ZmCalendarApp._settingChangeListener =
function(cal, ev) {
	if (ev.type != ZmEvent.S_SETTING) { return; }

	var setting = ev.source;
	if (setting.id == ZmSetting.CAL_FIRST_DAY_OF_WEEK) {
		cal.setFirstDayOfWeek(setting.getValue());
	}
};

ZmCalendarApp.prototype._newCalendarCallback =
function(parent, name, color, url, excludeFb) {
	// REVISIT: Do we really want to close the dialog before we
	//          know if the create succeeds or fails?
	var dialog = appCtxt.getNewCalendarDialog();
	dialog.popdown();

	var oc = appCtxt.getOverviewController();
	oc.getTreeController(ZmOrganizer.CALENDAR)._doCreate(parent, name, color, url, excludeFb);
};

/**
 * Adds an invite actions submenu for accept/decline/tentative.
 *
 * @param {ZmButtonToolBar|ZmActionMenu}	parent		the parent widget
 * @return	{ZmActionMenu}	the action menu
 */
ZmCalendarApp.addInviteReplyMenu =
function(parent) {
	var list = [ZmOperation.EDIT_REPLY_ACCEPT, ZmOperation.EDIT_REPLY_TENTATIVE, ZmOperation.EDIT_REPLY_DECLINE];
	var menu = new ZmActionMenu({parent:parent, menuItems:list});
	parent.setMenu(menu);
	return menu;
};

/**
 * Adds an invite actions submenu for accept/decline/tentative.
 *
 * @param {ZmButtonToolBar|ZmActionMenu}	parent		the parent widget
 * @return	{ZmActionMenu}	the action menu
 */
ZmCalendarApp.addCalViewMenu =
function(parent) {
	var list = [
		ZmOperation.DAY_VIEW, ZmOperation.WORK_WEEK_VIEW, ZmOperation.WEEK_VIEW,
		ZmOperation.MONTH_VIEW, ZmOperation.CAL_LIST_VIEW
	];
    if(appCtxt.get(ZmSetting.FREE_BUSY_VIEW_ENABLED)) {
        list.push(ZmOperation.FB_VIEW);    
    }
	var menu = new ZmActionMenu({parent:parent, menuItems:list});
	parent.setMenu(menu);
	return menu;
};

ZmCalendarApp.__formatLabel =
function(prefLabel, prefValue) {
	prefLabel = prefLabel || "";
	return prefLabel.match(/\{/) ? AjxMessageFormat.format(prefLabel, prefValue) : prefLabel;
};

/**
 * Parses the given string and return reminder info containing units and exact value
 *
 * @param reminderString 	reminder string eg. "20 minutes before"
 * 
 * @private
 */
ZmCalendarApp.parseReminderString =
function(reminderString) {
	var reminderFormats = {};
	reminderFormats[ZmMsg.apptRemindNDaysBefore]	= ZmCalItem.REMINDER_UNIT_DAYS;
	reminderFormats[ZmMsg.apptRemindNMinutesBefore]	= ZmCalItem.REMINDER_UNIT_MINUTES;
	reminderFormats[ZmMsg.apptRemindNHoursBefore]	= ZmCalItem.REMINDER_UNIT_HOURS;
	reminderFormats[ZmMsg.apptRemindNWeeksBefore]	= ZmCalItem.REMINDER_UNIT_WEEKS;

	reminderString = AjxStringUtil.trim(reminderString);
	var formattedString = reminderString;
	var reminderValue = formattedString.replace(/\D/g, "");
	reminderValue = AjxStringUtil.trim(reminderValue);
    if (reminderString === ZmMsg.apptRemindAtEventTime) {
        return {
            reminderValue: 0,
            reminderUnits: ZmCalItem.REMINDER_UNIT_MINUTES
        }
    }

	// junk content returns empty reminder (None)
	if (reminderValue == "") {
		return {
			reminderValue: "",
			reminderUnits: ZmCalItem.REMINDER_NONE
		};
	}
	if (reminderValue.indexOf(" ") >= 0) {
		reminderValue = reminderValue.split(" ")[0];
	}

	// look for standard reminder formats strings
	for (var pattern in  reminderFormats) {
		var formattedContent = ZmCalendarApp.__formatLabel(pattern, reminderValue);
		if(formattedContent != "" && formattedContent.toLowerCase() == reminderString.toLowerCase()) {
            //Fix for bug: 80651 - set and return object to determine before snooze
			return  {reminderValue: reminderValue, reminderUnits: reminderFormats[pattern], before: true};
		}
	}

	var reminderHours = parseInt(reminderValue);

    // parse the reminder string for singular units like minute, hour, day etc
	var remUnitStrings = {};
	remUnitStrings[ZmCalItem.REMINDER_UNIT_MINUTES] = AjxMsg.minute;
	remUnitStrings[ZmCalItem.REMINDER_UNIT_HOURS] = AjxMsg.hour;
	remUnitStrings[ZmCalItem.REMINDER_UNIT_DAYS] = AjxMsg.day;
	remUnitStrings[ZmCalItem.REMINDER_UNIT_WEEKS] = AjxMsg.week;

	//look for matching units
    // default unit is hours
	var reminderUnits = ZmCalItem.REMINDER_UNIT_HOURS;

	for(var i in remUnitStrings) {
		if(formattedString.indexOf(remUnitStrings[i]) >= 0) {
			reminderUnits = i;
            return {reminderValue: reminderHours ? reminderHours : 0,  reminderUnits: reminderUnits};
		}
	}

    // parse the reminder string for plural units like minutes, hours, days etc
    var remUnitPluralStrings = {};
    remUnitPluralStrings[ZmCalItem.REMINDER_UNIT_MINUTES] = AjxMsg.minutes;
    remUnitPluralStrings[ZmCalItem.REMINDER_UNIT_HOURS] = AjxMsg.hours;
    remUnitPluralStrings[ZmCalItem.REMINDER_UNIT_DAYS] = AjxMsg.days;
    remUnitPluralStrings[ZmCalItem.REMINDER_UNIT_WEEKS] = AjxMsg.weeks;

    for(var i in remUnitPluralStrings) {
        if(formattedString.indexOf(remUnitPluralStrings[i]) >= 0) {
            reminderUnits = i;
            return {reminderValue: reminderHours ? reminderHours : 0,  reminderUnits: reminderUnits};
        }
    }
    // fall back to hours if no matching string found
	return {reminderValue: reminderHours ? reminderHours : 0,  reminderUnits: reminderUnits};
};

ZmCalendarApp.convertReminderUnits =
function(reminderValue, reminderUnits) {
	switch (reminderUnits) {
		case ZmCalItem.REMINDER_UNIT_MINUTES:	return reminderValue;
		case ZmCalItem.REMINDER_UNIT_HOURS:		return reminderValue*60;
		case ZmCalItem.REMINDER_UNIT_DAYS:		return reminderValue*60*24;
		case ZmCalItem.REMINDER_UNIT_WEEKS:		return reminderValue*60*24*7;
		default: 								return 0;
	}
};

ZmCalendarApp.prototype.updateResourceCache =
function(resource) {
	var name = resource.getFullName();
	if (name) {
		this._resByName[name.toLowerCase()] = resource;
	}
	var email = resource.getEmail();
	if (email) {
		this._resByEmail[email.toLowerCase()] = resource;
	}
};

ZmCalendarApp.prototype._addSettingsChangeListeners =
function() {

    ZmApp.prototype._addSettingsChangeListeners.call(this);

	if (!this._settingsListener) {
		this._settingsListener = new AjxListener(this, this._settingsChangeListener);
	}

    var settings = appCtxt.getSettings();
	var setting = settings.getSetting(ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL);
	if (setting) {
		setting.addChangeListener(this._settingListener);
	}
	setting = settings.getSetting(ZmSetting.CAL_FIRST_DAY_OF_WEEK);
	if (setting) {
		setting.addChangeListener(this._settingListener);
	}
    setting = settings.getSetting(ZmSetting.CAL_WORKING_HOURS);
	if (setting) {
		setting.addChangeListener(this._settingListener);
	}
    setting = settings.getSetting(ZmSetting.CAL_SHOW_DECLINED_MEETINGS);
	if (setting) {
		setting.addChangeListener(this._settingListener);
	}

	var settings = appCtxt.getSettings();
	settings.getSetting(ZmSetting.CAL_SHOW_CALENDAR_WEEK).addChangeListener(this._settingListener);
	settings.addChangeListener(this._settingsListener);
};

/**
 * Settings listener to process changed settings.
 */
ZmCalendarApp.prototype._settingChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_SETTING) { return; }

	var setting = ev.source;
    if (setting.id == ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL) {
		if (setting.getValue()) {
			var avm = appCtxt.getAppViewMgr();
			var show = !avm.isHidden(ZmAppViewMgr.C_TREE_FOOTER, avm.getCurrentViewId());
			AjxDispatcher.run("ShowMiniCalendar", show);
		} else if (!this._active) {
			AjxDispatcher.run("ShowMiniCalendar", false);
		}
	} else if (setting.id == ZmSetting.CAL_FIRST_DAY_OF_WEEK) {
		var controller = AjxDispatcher.run("GetCalController");
		var minical = controller.getMiniCalendar();

		var firstDayOfWeek = setting.getValue();
		minical.setFirstDayOfWeek(firstDayOfWeek);

		var date = minical.getDate();
		controller.setDate(date, 0, true);
	}
    else if (setting.id == ZmSetting.CAL_WORKING_HOURS) {
        var controller = AjxDispatcher.run("GetCalController");
		var viewMgr = controller.getViewMgr();
        if(viewMgr) {
            viewMgr.layoutWorkingHours();
        }
    }  else if (setting.id == ZmSetting.CAL_SHOW_DECLINED_MEETINGS) {
        var controller = AjxDispatcher.run("GetCalController");
        controller.refreshCurrentView();
	}
};

ZmCalendarApp.prototype._settingsChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_SETTINGS) { return; }

	var list = ev.getDetail("settings");
	if (!(list && list.length)) { return; }

	for (var i = 0; i < list.length; i++) {
		var setting = list[i];
		if (setting.id == ZmSetting.CAL_SHOW_CALENDAR_WEEK) {
			var controller = AjxDispatcher.run("GetCalController").recreateMiniCalendar();
			var calMgr = appCtxt.getCalManager();
			calMgr.highlightMiniCal();
		}
	}
};

ZmCalendarApp.prototype.showDayView =
function(date) {
	var calController = AjxDispatcher.run("GetCalController");
	var miniCalendar = calController.getMiniCalendar();
	calController.setDate(date, 0, miniCalendar.getForceRollOver());
	if (!calController._viewVisible) {
		calController.show(ZmId.VIEW_CAL_DAY);
	}
};

ZmCalendarApp.prototype.getDateToolTip =
function(date, getSimpleToolTip) {
	var cc = AjxDispatcher.run("GetCalController");
	return cc.getDayToolTipText(date, null, null, true, getSimpleToolTip);
};

ZmCalendarApp.prototype.importAppointment =
function(msgId, partId,name) {
	var loadCallback = new AjxCallback(this, this._handleImportAppointment, [msgId, partId, name]);
	AjxDispatcher.require(["MailCore", "CalendarCore","Calendar"], false, loadCallback);
};

ZmCalendarApp.prototype._handleImportAppointment =
function(msgId, partId, name) {
	if (this._deferredFolders.length != 0) {
		this._createDeferredFolders(ZmApp.CALENDAR);
	}
	var dlg = this._copyToDialog = appCtxt.getChooseFolderDialog();
	var chooseCb = new AjxCallback(this, this._chooserCallback, [msgId, partId, name]);
	ZmController.showDialog(dlg, chooseCb, this._getCopyParams(dlg, msgId, partId));
};

ZmCalendarApp.prototype._getCopyParams =
function(dlg, msgId, partId) {
	return {
		data:			{msgId:msgId,partId:partId},
		treeIds:		[ZmOrganizer.CALENDAR],
		overviewId:		dlg.getOverviewId(this._name),
		title:			ZmMsg.addToCalendar,
		description:	ZmMsg.targetFolder,
		appName:		ZmApp.CALENDAR
	};
};

ZmCalendarApp.prototype._chooserCallback =
function(msgId, partId, name, folder) {


    var jsonObj = {ImportAppointmentsRequest:{_jsns:"urn:zimbraMail"}};
    var request = jsonObj.ImportAppointmentsRequest;
    request.l = folder.id;
    request.ct = "text/calendar";

    var m = request.content = {};
    m.mid = msgId;
    m.part = partId;

    var params = {
        jsonObj: jsonObj,
        asyncMode: true,
        callback: (new AjxCallback(this, this._handleImportApptResponse, [folder.id])),
        errorCallback: (new AjxCallback(this, this._handleImportApptError))
    };
    appCtxt.getAppController().sendRequest(params);

};

ZmCalendarApp.prototype._handleImportApptResponse =
function(folderId,response) {
	appCtxt.getAppController().setStatusMsg(ZmMsg.addedToCalendar);
	appCtxt.getChooseFolderDialog().popdown();

    var ac = window.parentAppCtxt || window.appCtxt;
    if(ac.get(ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL)) {
        var calMgr = ac.getCalManager();
        calMgr.getMiniCalCache().clearCache();
        calMgr.highlightMiniCal();
    }
};

ZmCalendarApp.prototype._handleImportApptError =
function(ex) {
	appCtxt.getAppController().setStatusMsg(ZmMsg.errorImportAppt, ZmStatusView.LEVEL_CRITICAL);
};

/**
 * Returns the reminder warning time display options formatted for preferences
 * we create preferences reminder button here .
 */
ZmCalendarApp.getReminderTimeWarningDisplayOptions = 
function() {
	var returnArr = [];
	for (var i = 0; i < ZmCalendarApp.reminderTimeWarningDisplayMsgs.length; i++) {
		returnArr.push(ZmCalendarApp.__formatLabel(ZmCalendarApp.reminderTimeWarningDisplayMsgs[i], ZmCalendarApp.reminderTimeWarningLabels[i]));
		
	}
	return returnArr;
};

/**
 * On doing save, we modify the request and map zimbraPrefCalendarApptReminderWarningTimevalue
 * so that the value of never, 0, is not changed at server.
 * If never is selected in reminder dropdown, we map never value -1 to previous value, 0
 * and if 'at time of event' is chosen, we map 0 to -1 while constructing request.
 **/

ZmCalendarApp.setDefaultReminderTimePrefValueOnSave =
function(pref, value, list) {
    value === 0 ? (value = -1) : (value  === -1 ? value =0 : '');
    pref.setValue(value);
    list.push(pref);
};

/**
 *  Client side mapping of never is -1 and 'at time of event' is 0.
 * If never is chosen in default reminder dropdown, user saves his preferences. We then modify the request
 * and set the pref zimbraPrefCalendarApptReminderWarningTimevalue value to 0, to make the behaviour
 * backward compatible, as earlier never was mapped to 0. Now, after reload, the value of pref zimbraPrefCalendarApptReminderWarningTimevalue
 * in client side i.e ZmSetting.CAL_REMINDER_WARNING_TIME, is 0 as the server returns me this value.
 * This was causing issue in the view of reminder option in pref section and while composing a new appt.
 * So, here we map default reminder pref to its client side mapping.
 * Same thing with 'at time of event'.
 */

ZmCalendarApp.postLoadSetDefaultReminderValue = function() {
    /**
     * This function is called when after reload, when you click on calendar tab or click on calendar icon
     * in preferences. And, after reload, we want to set the value of default reminder pref only one time when
     * the calendar tab is clicked or calendar pref is clicked. So, we have used global variable postLoadSetReminderCalled
     * as a check for that. Other option for doing that would be to call this function from ZmApp.prototype._postLoad
     * and then no need for doing check based on variable postLoadSetReminderCalled, but that be
     * something calling during the initial page's load, so I avoided that .
     */

    if (ZmCalendarApp.postLoadSetReminderCalled) {
        return;
    }
    var defaultWarningTime = appCtxt.get(ZmSetting.CAL_REMINDER_WARNING_TIME);
    if (defaultWarningTime === -1 || defaultWarningTime === 0) { // never or 'at time of event' was chosen in defaultreminderpref dropdown before load
        defaultWarningTime === -1 ? (defaultWarningTime = 0) : (defaultWarningTime = -1);
        appCtxt.set(ZmSetting.CAL_REMINDER_WARNING_TIME,defaultWarningTime);
    }
    ZmCalendarApp.postLoadSetReminderCalled = true;
};
}
if (AjxPackage.define("zimbraMail.tasks.ZmTasksApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the task application class.
 */

/**
 * Creates the task application.
 * @class
 * This class represents the task application.
 * 
 * @param	{DwtControl}	container		the container
 * 
 * @extends		ZmApp
 */
ZmTasksApp = function(container) {
	ZmApp.call(this, ZmApp.TASKS, container);
};

ZmTasksApp.prototype = new ZmApp;
ZmTasksApp.prototype.constructor = ZmTasksApp;

ZmTasksApp.prototype.isZmTasksApp = true;
ZmTasksApp.prototype.toString = function() { return "ZmTasksApp"; };


// Organizer and item-related constants
ZmEvent.S_TASK			= ZmId.ITEM_TASK;
ZmItem.TASK				= ZmEvent.S_TASK;
ZmOrganizer.TASKS		= ZmEvent.S_TASK;

// App-related constants
ZmApp.TASKS						= ZmId.APP_TASKS;
ZmApp.CLASS[ZmApp.TASKS]		= "ZmTasksApp";
ZmApp.SETTING[ZmApp.TASKS]		= ZmSetting.TASKS_ENABLED;
ZmApp.LOAD_SORT[ZmApp.TASKS]	= 45;
ZmApp.QS_ARG[ZmApp.TASKS]		= "tasks";

ZmTasksApp.REMINDER_START_DELAY = 10000;


// Construction

ZmTasksApp.prototype._defineAPI =
function() {
	AjxDispatcher.setPackageLoadFunction("TasksCore", new AjxCallback(this, this._postLoadCore));
	AjxDispatcher.setPackageLoadFunction("Tasks", new AjxCallback(this, this._postLoad, ZmOrganizer.TASKS));
	AjxDispatcher.registerMethod("GetTaskListController", ["TasksCore", "Tasks"], new AjxCallback(this, this.getTaskListController));
	AjxDispatcher.registerMethod("GetTaskController", ["TasksCore", "Tasks"], new AjxCallback(this, this.getTaskController));
};

ZmTasksApp.prototype._registerOperations =
function() {
//	ZmOperation.registerOp(ZmId.OP_MOUNT_TASK_FOLDER, {textKey:"mountTaskFolder", image:"TaskList"});
	ZmOperation.registerOp(ZmId.OP_NEW_TASK, {textKey:"newTask", tooltipKey:"newTaskTooltip", image:"NewTask", shortcut:ZmKeyMap.NEW_TASK});
	ZmOperation.registerOp(ZmId.OP_NEW_TASK_FOLDER, {textKey:"newTaskFolder", tooltipKey:"newTaskFolderTooltip", image:"NewTaskList"});
	ZmOperation.registerOp(ZmId.OP_SHARE_TASKFOLDER, {textKey:"shareTaskFolder", image:"TaskList"});
	ZmOperation.registerOp(ZmId.OP_PRINT_TASK, {textKey:"printTask", image:"Print", shortcut:ZmKeyMap.PRINT}, ZmSetting.PRINT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_PRINT_TASKFOLDER, {textKey:"printTaskFolder", image:"Print"}, ZmSetting.PRINT_ENABLED);
    ZmOperation.registerOp(ZmId.OP_SORTBY_MENU, {tooltipKey:"viewTooltip", textKey:"taskFilterBy", image:"SplitPane", textPrecedence:80});
    ZmOperation.registerOp(ZmId.OP_MARK_AS_COMPLETED, {tooltipKey:"markAsCompleted", textKey:"markAsCompleted", image:"CheckboxChecked", textPrecedence:80});
};

ZmTasksApp.prototype._registerSettings =
function(settings) {
	settings = settings || appCtxt.getSettings();
	settings.registerSetting("READING_PANE_LOCATION_TASKS",		{name:"zimbraPrefTasksReadingPaneLocation", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmSetting.RP_BOTTOM, isImplicit:true});
    settings.registerSetting("TASKS_FILTERBY",		{name:"zimbraPrefTasksFilterBy", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmSetting.TASK_FILTER_ALL, isImplicit:true});
    if (!appCtxt.get(ZmSetting.HIGHLIGHT_OBJECTS))
        settings.registerSetting("HIGHLIGHT_OBJECTS",               {name:"zimbraMailHighlightObjectsMaxSize", type:ZmSetting.T_COS, dataType:ZmSetting.D_INT, defaultValue:70});
};

ZmTasksApp.prototype._registerItems =
function() {
	ZmItem.registerItem(ZmItem.TASK,
						{app:			ZmApp.TASKS,
						 nameKey:		"task",
						 icon:			"TasksApp",
						 soapCmd:		"ItemAction",
						 itemClass:		"ZmTask",
						 node:			"task",
						 organizer:		ZmOrganizer.TASKS,
						 dropTargets:	[ZmOrganizer.TAG, ZmOrganizer.TASKS],
						 searchType:	"task",
						 resultsList:
	   AjxCallback.simpleClosure(function(search) {
           AjxDispatcher.require("TasksCore");
		   return new ZmList(ZmItem.TASK, search);
	   }, this)
						});
};

ZmTasksApp.prototype._registerOrganizers =
function() {
	ZmOrganizer.registerOrg(ZmOrganizer.TASKS,
							{app:				ZmApp.TASKS,
							 nameKey:			"tasksFolder",
							 defaultFolder:		ZmFolder.ID_TASKS,
							 soapCmd:			"FolderAction",
							 firstUserId:		256,
							 orgClass:			"ZmTaskFolder",
							 orgPackage:		"TasksCore",
							 treeController:	"ZmTaskTreeController",
							 labelKey:			"taskLists",
							 itemsKey:			"tasks",
                             folderKey:			"tasksFolder",   
                             hasColor:			true,
							 defaultColor:		ZmOrganizer.C_NONE,
							 treeType:			ZmOrganizer.FOLDER,
							 views:				["task"],
							 createFunc:		"ZmOrganizer.create",
							 compareFunc:		"ZmFolder.sortCompareNonMail",
							 deferrable:		true,
							 newOp:				ZmOperation.NEW_TASK_FOLDER,
							 displayOrder:		100
							});
};

ZmTasksApp.prototype._setupSearchToolbar =
function() {
	ZmSearchToolBar.addMenuItem(ZmItem.TASK,
								{msgKey:		"tasks",
								 tooltipKey:	"searchTasks",
								 icon:			"TasksApp",
								 shareIcon:		"SharedTaskList",
								 setting:		ZmSetting.TASKS_ENABLED,
								 id:			ZmId.getMenuItemId(ZmId.SEARCH, ZmId.ITEM_TASK),
								 disableOffline:true
								});
};

ZmTasksApp.prototype._registerApp =
function() {
	var newItemOps = {};
	newItemOps[ZmOperation.NEW_TASK] = "task";

	var newOrgOps = {};
	newOrgOps[ZmOperation.NEW_TASK_FOLDER] = "tasksFolder";

	var actionCodes = {};
	actionCodes[ZmKeyMap.NEW_TASK] = ZmOperation.NEW_TASK;

	ZmApp.registerApp(ZmApp.TASKS,
							 {mainPkg:				"Tasks",
							  nameKey:				"tasks",
							  icon:					"TasksApp",
							  textPrecedence:		20,
							  chooserTooltipKey:	"goToTasks",
							  defaultSearch:		ZmItem.TASK,
							  organizer:			ZmOrganizer.TASKS,
							  overviewTrees:		[ZmOrganizer.TASKS, ZmOrganizer.SEARCH, ZmOrganizer.TAG],
							  newItemOps:			newItemOps,
							  newOrgOps:			newOrgOps,
							  actionCodes:			actionCodes,
							  searchTypes:			[ZmItem.TASK],
							  gotoActionCode:		ZmKeyMap.GOTO_TASKS,
							  newActionCode:		ZmKeyMap.NEW_TASK,
							  chooserSort:			35,
							  defaultSort:			25,
							  searchResultsTab:		true
							  });
};

// App API

ZmTasksApp.prototype.postNotify =
function(notify) {
	if (this._checkReplenishListView) {
		var tasks = notify.modified && notify.modified.task;
		var item;
		if (tasks) {
			item = tasks[0].items[0];
		}
		this._checkReplenishListView._checkReplenish(item, true);
		this._checkReplenishListView = null;
	}
};

ZmTasksApp.prototype.handleOp =
function(op, params) {
	switch (op) {
		case ZmOperation.NEW_TASK: {
            params = params || {};
			var loadCallback = new AjxCallback(this, this._handleLoadNewTask, [params]);
			AjxDispatcher.require(["TasksCore", "Tasks"], false, loadCallback, null, true);
			break;
		}
		case ZmOperation.NEW_TASK_FOLDER: {
			var loadCallback = new AjxCallback(this, this._handleLoadNewTaskFolder);
			AjxDispatcher.require(["TasksCore", "Tasks"], false, loadCallback, null, true);
			break;
		}
	}
};

ZmTasksApp.prototype._handleLoadNewTask =
function(params) {
	params.folderId = params.folderId || this.getTaskListController()._folderId;
	AjxDispatcher.run("GetTaskController").show((new ZmTask(null, null, params && params.folderId)));
};

ZmTasksApp.prototype._handleLoadNewTaskFolder =
function() {
	appCtxt.getAppViewMgr().popView(true, ZmId.VIEW_LOADING);	// pop "Loading..." page
	var dialog = appCtxt.getNewTaskFolderDialog();
	if (!this._newTaskFolderCb) {
		this._newTaskFolderCb = new AjxCallback(this, this._newTaskFolderCallback);
	}
	ZmController.showDialog(dialog, this._newTaskFolderCb);
};

/**
 * Checks for the creation of a tasks folder or a mount point to one.
 *
 * @param {Hash}	creates		a hash of create notifications
 * @param	{Boolean}	force	if <code>true</code>, force the create
 * 
 */
ZmTasksApp.prototype.createNotify =
function(creates, force) {
	if (!creates["folder"] && !creates["task"] && !creates["link"]) { return; }
	if (!force && this._deferNotifications("create", creates)) { return; }

	for (var name in creates) {
		var list = creates[name];
		if (!list) { continue; }

		for (var i = 0; i < list.length; i++) {
			var create = list[i];
			if (appCtxt.cacheGet(create.id)) { continue; }
	
			if (name == "folder") {
				this._handleCreateFolder(create, ZmOrganizer.TASKS);
			} else if (name == "link") {
				this._handleCreateLink(create, ZmOrganizer.TASKS);
			} else if (name == "task") {
				// bug fix #29833 - always attempt to process new tasks
				var taskList = AjxDispatcher.run("GetTaskListController").getList();
				if (taskList &&
				!AjxUtil.isEmpty(create.inv) &&
				!AjxUtil.isEmpty(create.inv[0].comp)) {
					var filter = taskList.controller.getAllowableTaskStatus();
					var taskStatus = create.inv[0].comp[0].status;
					if (!filter || filter.indexOf(taskStatus) !== -1) {
						taskList.notifyCreate(create);
					}
				}
			}
		}
	}
};

// Public methods

ZmTasksApp.prototype.launch =
function(params, callback) {
	this._setLaunchTime(this.toString(), new Date());
	var loadCallback = new AjxCallback(this, this._handleLoadLaunch, callback);
	AjxDispatcher.require(["TasksCore", "Tasks"], true, loadCallback, null, true);
};

ZmTasksApp.prototype._handleLoadLaunch =
function(callback) {
	var acct = this._getExternalAccount();
	this.search(null, null, null, null, (acct && acct.name));
	if (callback) { callback.run(); }
};

ZmTasksApp.prototype.getNewButtonProps =
function() {
	return {
		text:		ZmMsg.newTask,
		tooltip:	ZmMsg.createNewTask,
		icon:		"NewTask",
		iconDis:	"NewTaskDis",
		defaultId:	ZmOperation.NEW_TASK,
        disabled:	!this.containsWritableFolder()
	};
};

/**
 * Shows the search results.
 * 
 * @param	{Hash}	results		the search results
 * @param	{AjxCallback}	callback		the callback
 */
ZmTasksApp.prototype.showSearchResults =
function(results, callback, searchResultsController) {
	var loadCallback = this._handleLoadShowSearchResults.bind(this, results, callback, searchResultsController);
	AjxDispatcher.require("Tasks", false, loadCallback, null, true);
};

ZmTasksApp.prototype._handleLoadShowSearchResults =
function(results, callback, searchResultsController) {
	var folderId = results && results.search && results.search.isSimple() && results.search.folderId || null;
	var sessionId = searchResultsController ? searchResultsController.getCurrentViewId() : ZmApp.MAIN_SESSION;
	var controller = AjxDispatcher.run("GetTaskListController", sessionId, searchResultsController);
	controller.show(results, folderId);
	this._setLoadedTime(this.toString(), new Date());
	if (callback) {
		callback.run(controller);
	}
};

ZmTasksApp.prototype.runRefresh =
function() {
	if (window.ZmTaskListController === undefined) { //app not loaded yet - no need to update anything.
		return;
	}
	AjxDispatcher.run("GetTaskListController").runRefresh();
};


// common API shared by calendar app

/**
 * Gets the list controller.
 * 
 * @return	{ZmTaskListController}	the controller
 */
ZmTasksApp.prototype.getListController =
function() {
	return AjxDispatcher.run("GetTaskListController");
};

/**
 * Gets the list controller.
 * 
 * @return	{ZmTaskListController}	the controller
 */
ZmTasksApp.prototype.getTaskListController =
function(sessionId, searchResultsController) {
	return this.getSessionController({controllerClass:			"ZmTaskListController",
									  sessionId:				sessionId || ZmApp.MAIN_SESSION,
									  searchResultsController:	searchResultsController});
};

/**
 * Gets the controller.
 * 
 * @return	{ZmTaskController}	the controller
 */
ZmTasksApp.prototype.getTaskController =
function(sessionId) {
	return this.getSessionController({controllerClass:	"ZmTaskController",
									  sessionId:		sessionId});
};

/**
 * Creates a task from a mail item.
 * 
 * @param	{ZmMailMsg}		msg		the message
 * @param	{Date}			date	the date
 */
ZmTasksApp.prototype.newTaskFromMailItem =
function(msg, date) {
	var subject = msg.subject || "";
	if (msg instanceof ZmConv) {
		msg = msg.getFirstHotMsg();
	}
	msg.load({getHtml:false, callback:new AjxCallback(this, this._msgLoadedCallback, [msg, date, subject])});
};

/**
 * @private
 */
ZmTasksApp.prototype._msgLoadedCallback =
function(mailItem, date, subject) {
	var t = new ZmTask();
	t.setEndDate(AjxDateUtil.roundTimeMins(date, 30));
	t.setFromMailMessage(mailItem, subject);
	this.getTaskController().show(t, ZmCalItem.MODE_NEW, true);
};

/**
 * Performs a search.
 * 
 * @param	{ZmFolder}		folder		the folder
 * @param	{Date}			startDate	the start date
 * @param	{Date}			endDate		the end date
 * @param	{AjxCallback}	callback	the callback
 * @param	{String}		accountName	the account name
 */
ZmTasksApp.prototype.search =
function(folder, startDate, endDate, callback, accountName) {
    var query = folder ? folder.createQuery() : "";
    query = query || (appCtxt.isExternalAccount() ? "inid:" + this.getDefaultFolderId() : "in:tasks");

	var params = {
		query:			query,
		types:			[ZmItem.TASK],
		limit:			this.getLimit(),
		searchFor:		ZmItem.TASK,
		callback:		callback,
		accountName:	(accountName || (folder && folder.getAccount().name))
	};
	var sc = appCtxt.getSearchController();
	sc.searchAllAccounts = false;
	sc.search(params);
};

/**
 * @private
 */
ZmTasksApp.prototype._newTaskFolderCallback =
function(parent, name, color) {
	var dialog = appCtxt.getNewTaskFolderDialog();
	dialog.popdown();
	var oc = appCtxt.getOverviewController();
	oc.getTreeController(ZmOrganizer.TASKS)._doCreate(parent, name, color);
};

/**
 * Gets the list of checked calendar ids. If calendar packages are not loaded,
 * gets the list from deferred folder ids.
 *
 * @param	{Boolean}		localOnly	if <code>true</code>, use local calendar only
 * @return	{Array}	an array of ids
 */
ZmTasksApp.prototype.getTaskFolderIds =
function(localOnly) {
	var folderIds = [];
	if (AjxDispatcher.loaded("TasksCore")) {
		folderIds = AjxDispatcher.run("GetTaskListController").getTaskFolderIds(localOnly);
	} else {
		// will be used in reminder dialog
		this._folderNames = {};
		for (var i = 0; i < this._deferredFolders.length; i++) {
			var params = this._deferredFolders[i];
			//var str = (params && params.obj && params.obj.f) ? params.obj.f : "";
			//if (str && (str.indexOf(ZmOrganizer.FLAG_CHECKED) != -1)) {
				if (localOnly && params.obj.zid != null) {
					continue;
				}
				folderIds.push(params.obj.id);
				// _folderNames are used when deferred folders are not created
				// and calendar name is required. example: calendar name
				// requirement in reminder module
				this._folderNames[params.obj.id] = params.obj.name;
			//}
		}
	}
	return folderIds;
};

/**
 * Gets the name of the calendar with specified id.
 *
 * @param	{String}	id		the id of the task
 * @return	{String}	the name
 */
ZmTasksApp.prototype.getTaskFolderName =
function(id) {
	return appCtxt.getById(id) ? appCtxt.getById(id).name : this._folderNames[id];
};


/**
 * Gets the reminder controller.
 *
 * @return	{ZmReminderController}	the controller
 */
ZmTasksApp.prototype.getReminderController =
function() {
	if (!this._reminderController) {
		AjxDispatcher.require("TasksCore");
		var taskMgr = appCtxt.getTaskManager();
		this._reminderController = taskMgr.getReminderController();
        this._reminderController._calController = taskMgr;
		this._reminderController.refresh();
	}
	return this._reminderController;
};


/**
 * Creates a new button with a reminder options as its menu.
 *
 * @param	{DwtComposite}	parent						the parent
 * @param	{String}	buttonId 					the button id to fetch inside DOM and append DwtButton to
 * @param	{AjxListener}	buttonListener			the listener to call when date button is pressed
 * @param	{AjxListener}	menuSelectionListener	the listener to call when date is selected in {@link DwtCalendar}
 */
ZmTasksApp.createpCompleteButton =
function(parent, buttonId, buttonListener, menuSelectionListener) {
	// create button
	var pCompleteButton = new DwtButton({parent:parent});
	pCompleteButton.addDropDownSelectionListener(buttonListener);
	pCompleteButton.setData(Dwt.KEY_ID, buttonId);
	pCompleteButton.setSize("25");

	// create menu for button
	var pCompleteMenu = new DwtMenu({parent:pCompleteButton, style:DwtMenu.DROPDOWN_STYLE});
	pCompleteMenu.setSize("100");
	pCompleteButton.setMenu(pCompleteMenu, true);

    var formatter = new AjxMessageFormat(AjxMsg.percentageString);
	for (var i = 0; i <= 100; i += ZmTask.PCOMPLETE_INT) {
		var mi = new DwtMenuItem({parent: pCompleteMenu, style: DwtMenuItem.NO_STYLE});
		mi.setText((formatter.format(i)));
		mi.setData("value", i);
		if(menuSelectionListener) mi.addSelectionListener(menuSelectionListener);
	}
    
	// reparent and cleanup
	pCompleteButton.reparentHtmlElement(buttonId);
	delete buttonId;

	return pCompleteButton;
};
}
if (AjxPackage.define("zimbraMail.abook.ZmContactsApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the contacts application class.
 */

/**
 * Creates and initializes the contacts application.
 * @class
 * The contacts app manages the creation and display of contacts, which are grouped
 * into address books.
 * 
 * @param	{DwtControl}	container		the container
 * @param	{ZmController}	parentController	the parent controller
 * 
 * @author Conrad Damon
 * 
 * @extends		ZmApp
 */
ZmContactsApp = function(container, parentController) {

	ZmApp.call(this, ZmApp.CONTACTS, container, parentController);

	this.contactsLoaded = {};
	this._contactList = {};		// canonical list by acct ID
	this._initialized = false;

	// contact lookup caches
	this._byEmail	= {};
	this._byPhone	= {};

	// cache fetched distribution lists
	this._dlCache	= {};
};

ZmContactsApp.prototype = new ZmApp;
ZmContactsApp.prototype.constructor = ZmContactsApp;

ZmContactsApp.prototype.isZmContactsApp = true;
ZmContactsApp.prototype.toString = function() { return "ZmContactsApp"; };


// Organizer and item-related constants
ZmEvent.S_CONTACT				= ZmId.ITEM_CONTACT;
ZmEvent.S_GROUP					= ZmId.ITEM_GROUP;
ZmItem.CONTACT					= ZmEvent.S_CONTACT;
ZmItem.GROUP					= ZmEvent.S_GROUP;
ZmItem.GAL						= ZmId.ITEM_GAL_CONTACT;
/**
 * Defines the "address book" organizer.
 */
ZmOrganizer.ADDRBOOK			= ZmId.ORG_ADDRBOOK;

// App-related constants
/**
 * Defines the "address book" application.
 */
ZmApp.CONTACTS							= ZmId.APP_CONTACTS;
ZmApp.CLASS[ZmApp.CONTACTS]				= "ZmContactsApp";
ZmApp.SETTING[ZmApp.CONTACTS]			= ZmSetting.CONTACTS_ENABLED;
ZmApp.UPSELL_SETTING[ZmApp.CONTACTS]	= ZmSetting.CONTACTS_UPSELL_ENABLED;
ZmApp.LOAD_SORT[ZmApp.CONTACTS]			= 30;
ZmApp.QS_ARG[ZmApp.CONTACTS]			= "contacts";

// search menu
ZmContactsApp.SEARCHFOR_CONTACTS 	= 1;
ZmContactsApp.SEARCHFOR_GAL 		= 2;
ZmContactsApp.SEARCHFOR_PAS			= 3; // PAS = personal and shared
ZmContactsApp.SEARCHFOR_FOLDERS		= 4;

ZmContactsApp.SEARCHFOR_MAX 		= 50;


// Construction

/**
 * @private
 */
ZmContactsApp.prototype._defineAPI =
function() {
	AjxDispatcher.setPackageLoadFunction("ContactsCore", new AjxCallback(this, this._postLoadCore));
	AjxDispatcher.setPackageLoadFunction("Contacts", new AjxCallback(this, this._postLoad, ZmOrganizer.ADDRBOOK));
	AjxDispatcher.registerMethod("GetContacts", "ContactsCore", new AjxCallback(this, this.getContactList));
	AjxDispatcher.registerMethod("GetContactsForAllAccounts", "ContactsCore", new AjxCallback(this, this.getContactListForAllAccounts));
	AjxDispatcher.registerMethod("GetContactListController", ["ContactsCore", "Contacts"], new AjxCallback(this, this.getContactListController));
	AjxDispatcher.registerMethod("GetContactController", ["ContactsCore", "Contacts"], new AjxCallback(this, this.getContactController));
};

/**
 * @private
 */
ZmContactsApp.prototype._registerSettings =
function(settings) {
	var settings = settings || appCtxt.getSettings();
	settings.registerSetting("AUTO_ADD_ADDRESS",				{name: "zimbraPrefAutoAddAddressEnabled", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false, isGlobal: true});
	settings.registerSetting("AUTOCOMPLETE_LIMIT",				{name: "zimbraContactAutoCompleteMaxResults", type:ZmSetting.T_COS, dataType: ZmSetting.D_INT, defaultValue: 20});
	settings.registerSetting("AUTOCOMPLETE_ON_COMMA",			{name: "zimbraPrefAutoCompleteQuickCompletionOnComma", type: ZmSetting.T_PREF, dataType:ZmSetting.D_BOOLEAN, defaultValue: true});
	settings.registerSetting("AUTOCOMPLETE_SHARE",				{name: "zimbraPrefShareContactsInAutoComplete", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false});
	settings.registerSetting("AUTOCOMPLETE_SHARED_ADDR_BOOKS",	{name: "zimbraPrefSharedAddrBookAutoCompleteEnabled", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false});
	settings.registerSetting("EXPORT",							{type: ZmSetting.T_PREF, dataType: ZmSetting.D_NONE});
	settings.registerSetting("GAL_AUTOCOMPLETE",				{name: "zimbraPrefGalAutoCompleteEnabled", type: ZmSetting.T_PREF, dataType: ZmSetting.D_BOOLEAN, defaultValue: false});
	settings.registerSetting("IMPORT",							{type: ZmSetting.T_PREF, dataType: ZmSetting.D_NONE});
	settings.registerSetting("MAX_CONTACTS",					{name: "zimbraContactMaxNumEntries", type: ZmSetting.T_COS, dataType: ZmSetting.D_INT, defaultValue: 0});
	settings.registerSetting("NEW_ADDR_BOOK_ENABLED",			{name: "zimbraFeatureNewAddrBookEnabled", type:ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue: true});
    // TODO: Make real COS setting? 
	settings.registerSetting("PHONETIC_CONTACT_FIELDS",         {type: ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue: /^ja/.test(AjxEnv.DEFAULT_LOCALE)});
	settings.registerSetting("DETAILED_CONTACT_SEARCH_ENABLED",	{name: "zimbraFeatureContactsDetailedSearchEnabled", type: ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue: false});
};

/**
 * @private
 */
ZmContactsApp.prototype._registerPrefs =
function() {
	var sections = {
		CONTACTS: {
			title: ZmMsg.addressBook,
			icon: "ContactsApp",
			templateId: "prefs.Pages#Contacts",
			priority: 70,
			precondition: ZmSetting.CONTACTS_ENABLED,
			prefs: [
				ZmSetting.AUTO_ADD_ADDRESS,
				ZmSetting.AUTOCOMPLETE_ON_COMMA,
				ZmSetting.AUTOCOMPLETE_SHARE,
				ZmSetting.AUTOCOMPLETE_SHARED_ADDR_BOOKS,
				ZmSetting.EXPORT,
				ZmSetting.GAL_AUTOCOMPLETE,
				ZmSetting.INITIALLY_SEARCH_GAL,
				ZmSetting.IMPORT
			]
		}
	};
	for (var id in sections) {
		ZmPref.registerPrefSection(id, sections[id]);
	}

	ZmPref.registerPref("AUTO_ADD_ADDRESS", {
		displayName:		ZmMsg.autoAddContacts,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("AUTOCOMPLETE_ON_COMMA", {
		displayName:		ZmMsg.autocompleteOnComma,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("AUTOCOMPLETE_SHARE", {
		displayName:		ZmMsg.autocompleteShare,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("AUTOCOMPLETE_SHARED_ADDR_BOOKS", {
		displayName:		ZmMsg.autocompleteSharedAddrBooks,
		displayContainer:	ZmPref.TYPE_CHECKBOX
	});

	ZmPref.registerPref("EXPORT", {
		loadFunction:		ZmPref.loadCsvFormats,
		displayContainer:	ZmPref.TYPE_EXPORT
	});

	ZmPref.registerPref("GAL_AUTOCOMPLETE", {
		displayName:		ZmMsg.galAutocomplete,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:       [ ZmSetting.GAL_AUTOCOMPLETE_ENABLED, ZmSetting.GAL_ENABLED ]
	});

	ZmPref.registerPref("IMPORT", {
		displayName:		ZmMsg.importFromCSV,
		displayContainer:	ZmPref.TYPE_IMPORT
	});

	ZmPref.registerPref("INITIALLY_SEARCH_GAL", {
		displayName:		ZmMsg.initiallySearchGal,
		displayContainer:	ZmPref.TYPE_CHECKBOX,
		precondition:       function() {
								return appCtxt.get(ZmSetting.GAL_ENABLED) && appCtxt.getActiveAccount().isZimbraAccount;
							}
	});
};

/**
 * @private
 */
ZmContactsApp.prototype._createVirtualFolders =
function() {
	if (!window.ZmContactList || !window.ZmAddrBook) {
		return; //do it only if it's loaded. If not, it will be loaded when called from ZmContactList.prototype._handleResponseLoad
	}
	ZmContactList.addDlFolder();
};


/**
 * @private
 */
ZmContactsApp.prototype._registerOperations =
function() {
	ZmOperation.registerOp(ZmId.OP_CONTACT);	// placeholder
	ZmOperation.registerOp(ZmId.OP_EDIT_CONTACT, {textKey:"AB_EDIT_CONTACT", image:"Edit", shortcut:ZmKeyMap.EDIT});
//	ZmOperation.registerOp(ZmId.OP_MOUNT_ADDRBOOK, {textKey:"mountAddrBook", image:"ContactsFolder"});
	ZmOperation.registerOp(ZmId.OP_NEW_ADDRBOOK, {textKey:"newAddrBook", tooltipKey:"newAddrBookTooltip", image:"NewContactsFolder"}, ZmSetting.NEW_ADDR_BOOK_ENABLED);
	ZmOperation.registerOp(ZmId.OP_NEW_CONTACT, {textKey:"newContact", tooltipKey:"newContactTooltip", image:"NewContact", shortcut:ZmKeyMap.NEW_CONTACT}, ZmSetting.CONTACTS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_NEW_GROUP, {textKey:"newGroup", tooltipKey:"newGroupTooltip", image:"NewGroup"}, ZmSetting.CONTACTS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_NEW_DISTRIBUTION_LIST, {textKey:"newDistList", tooltipKey:"newDistListTooltip", image:"NewGroup"}, ZmSetting.CONTACTS_ENABLED);
	ZmOperation.registerOp(ZmId.OP_PRINT_CONTACT, {textKey:"printContact", image:"Print", shortcut:ZmKeyMap.PRINT}, ZmSetting.PRINT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_PRINT_ADDRBOOK, {textKey:"printAddrBook", image:"Print"}, ZmSetting.PRINT_ENABLED);
	ZmOperation.registerOp(ZmId.OP_SHARE_ADDRBOOK, {textKey:"shareAddrBook", image:"SharedContactsFolder"});
};

/**
 * @private
 */
ZmContactsApp.prototype._registerItems =
function() {
	ZmItem.registerItem(ZmItem.CONTACT,
						{app:			ZmApp.CONTACTS,
						 nameKey:		"contact",
						 icon:			"Contact",
						 soapCmd:		"ContactAction",
						 itemClass:		"ZmContact",
						 node:			"cn",
						 organizer:		ZmOrganizer.ADDRBOOK,
						 dropTargets:	[ZmOrganizer.TAG, ZmOrganizer.ZIMLET, ZmOrganizer.ADDRBOOK],
						 searchType:	"contact",
						 resultsList:
		AjxCallback.simpleClosure(function(search) {
			AjxDispatcher.require("ContactsCore");
			return new ZmContactList(search, search ? search.isGalSearch || search.isGalAutocompleteSearch : null);
		}, this)
						});

	ZmItem.registerItem(ZmItem.GROUP,
						{nameKey:	"group",
						 icon:		"Group",
						 soapCmd:	"ContactAction"
						});

	ZmItem.registerItem(ZmItem.GAL, {app: ZmApp.CONTACTS});
};

/**
 * @private
 */
ZmContactsApp.prototype._registerOrganizers =
function() {
	var orgColor = {};
//	orgColor[ZmFolder.ID_AUTO_ADDED] = ZmOrganizer.C_YELLOW;
	
	ZmOrganizer.registerOrg(ZmOrganizer.ADDRBOOK,
							{app:				ZmApp.CONTACTS,
							 nameKey:			"addressBook",
							 defaultFolder:		ZmOrganizer.ID_ADDRBOOK,
							 soapCmd:			"FolderAction",
							 firstUserId:		256,
							 orgClass:			"ZmAddrBook",
							 orgPackage:		"ContactsCore",
							 treeController:	"ZmAddrBookTreeController",
							 labelKey:			"contactLists",
							 itemsKey:			"contacts",
							 hasColor:			true,
							 defaultColor:		ZmOrganizer.C_NONE,
							 orgColor:			orgColor,
							 treeType:			ZmOrganizer.FOLDER,
							 dropTargets:		[ZmOrganizer.ADDRBOOK],
							 views:				["contact"],
							 folderKey:			"contactsFolder",
							 mountKey:			"mountAddrBook",
							 createFunc:		"ZmOrganizer.create",
							 compareFunc:		"ZmFolder.sortCompareNonMail",
							 displayOrder:		100,
							 newOp:             ZmOperation.NEW_ADDRBOOK,
							 deferrable:		true
							});
};

/**
 * @private
 */
ZmContactsApp.prototype._setupSearchToolbar =
function() {
	ZmSearchToolBar.addMenuItem(ZmItem.CONTACT,
								{msgKey:		"contacts",
								 tooltipKey:	"searchPersonalContacts",
								 icon:			"Contact",
								 shareIcon:		"SharedContactsFolder",
								 id:			ZmId.getMenuItemId(ZmId.SEARCH, ZmId.ITEM_CONTACT)
								});

	ZmSearchToolBar.addMenuItem(ZmId.SEARCH_GAL,
								{msgKey:		"GAL",
								 tooltipKey:	"searchGALContacts",
								 icon:			"GAL",
								 setting:		ZmSetting.GAL_ENABLED,
								 id:			ZmId.getMenuItemId(ZmId.SEARCH, ZmId.SEARCH_GAL),
								 disableOffline:true
								});
};

/**
 * @private
 */
ZmContactsApp.prototype._registerApp =
function() {
	var newItemOps = {};
	newItemOps[ZmOperation.NEW_CONTACT]	= "contact";
	newItemOps[ZmOperation.NEW_GROUP]	= "group";
	if (appCtxt.createDistListAllowed) {
		newItemOps[ZmOperation.NEW_DISTRIBUTION_LIST] = "distributionList";
	}

	var newOrgOps = {};
	newOrgOps[ZmOperation.NEW_ADDRBOOK] = "contactsFolder";

	var actionCodes = {};
	actionCodes[ZmKeyMap.NEW_CONTACT] = ZmOperation.NEW_CONTACT;

	ZmApp.registerApp(ZmApp.CONTACTS,
							 {mainPkg:				"Contacts",
							  nameKey:				"addressBook",
							  icon:					"ContactsApp",
							  textPrecedence:		40,
							  chooserTooltipKey:	"goToContacts",
							  viewTooltipKey:		"displayContacts",
							  defaultSearch:		ZmItem.CONTACT,
							  organizer:			ZmOrganizer.ADDRBOOK,
							  overviewTrees:		[ZmOrganizer.ADDRBOOK, ZmOrganizer.SEARCH, ZmOrganizer.TAG],
							  searchTypes:			[ZmItem.CONTACT],
							  newItemOps:			newItemOps,
							  newOrgOps:			newOrgOps,
							  actionCodes:			actionCodes,
							  gotoActionCode:		ZmKeyMap.GOTO_CONTACTS,
							  newActionCode:		ZmKeyMap.NEW_CONTACT,
							  trashViewOp:			ZmOperation.SHOW_ONLY_CONTACTS,
							  chooserSort:			20,
							  defaultSort:			40,
							  upsellUrl:			ZmSetting.CONTACTS_UPSELL_URL,
							  //quickCommandType:		ZmQuickCommand[ZmId.ITEM_CONTACT],
							  searchResultsTab:		true
							  });
};


// App API

/**
 * Checks for the creation of an address book or a mount point to one. Regular
 * contact creates are handed to the canonical list.
 * 
 * @param {Hash}	creates	a hash of create notifications
 * 
 * @private
 */
ZmContactsApp.prototype.createNotify =
function(creates, force) {
	if (!creates["folder"] && !creates["cn"] && !creates["link"]) { return; }
	if (!force && !this._noDefer && this._deferNotifications("create", creates)) { return; }

	for (var name in creates) {
		var list = creates[name];
		if (list && list.length) {
			for (var i = 0; i < list.length; i++) {
				var create = list[i];
				if (appCtxt.cacheGet(create.id)) { continue; }

				if (name == "folder") {
					this._handleCreateFolder(create, ZmOrganizer.ADDRBOOK);
				} else if (name == "link") {
					this._handleCreateLink(create, ZmOrganizer.ADDRBOOK);
				} else if (name == "cn") {
					//note- this is updating the view list. The canonical is upadated
					// in ZmContact.prototype._handleResponseCreate. See bug 81055
					var clc = AjxDispatcher.run("GetContactListController");
					if (clc._folderId == ZmFolder.ID_DLS) {
						//the simplest solution I could think of to the messy problem that the clcList in this case is GAL and thus
						//the contact becomes GAL (in memory) even though it's not on the server. Then it's cached and when going to the contacts it would get an exeption when clicked
						//if the user is viewing the DLs folder, they will see the new contact they created anyway when clicking on the "contacts" folder (or whatever other folder they created it in)
						continue;
					}
					var clcList = (clc && clc.getFolderId()) ? clc.getList() : new ZmContactList(null);
					if (appCtxt.multiAccounts && clcList.search && clcList.search.folderId != create.l) {
						continue;
					}
					clcList.notifyCreate(create);
					var context = window.parentAppCtxt || window.appCtxt;
					context.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);
					create._handled = true;
				}
			}
		}
	}
};

ZmContactsApp.prototype.modifyNotify =
function(modifies, force) {
	if (!modifies["cn"]) { return; }
	if (!force && !this._noDefer && this._deferNotifications("modify", modifies)) { return; }

	this._batchNotify(modifies["cn"]);
};

/**
 * @private
 */
ZmContactsApp.prototype.postNotify =
function(notify) {
	if (this._checkReplenishListView) {
		this._checkReplenishListView._checkReplenish();
		this._checkReplenishListView = null;
	}
};

/**
 * @private
 */
ZmContactsApp.prototype.handleOp =
function(op) {
	if (!appCtxt.isWebClientOffline()) {
		switch (op) {
			case ZmOperation.NEW_CONTACT:
			case ZmOperation.NEW_DISTRIBUTION_LIST:
			case ZmOperation.NEW_GROUP: {
				var type = (op == ZmOperation.NEW_CONTACT) ? null : ZmItem.GROUP;
				var loadCallback = new AjxCallback(this, this._handleLoadNewItem, [type, op == ZmOperation.NEW_DISTRIBUTION_LIST]);
				AjxDispatcher.require(["ContactsCore", "Contacts"], false, loadCallback, null, true);
				break;
			}
			case ZmOperation.NEW_ADDRBOOK: {
				var loadCallback = new AjxCallback(this, this._handleLoadNewAddrBook);
				AjxDispatcher.require(["ContactsCore", "Contacts"], false, loadCallback, null, true);
				break;
			}
		}
	}
};

/**
 * @private
 */
ZmContactsApp.prototype._handleLoadNewItem =
function(type, isDl) {
	var contact = new ZmContact(null, null, type, isDl);
	AjxDispatcher.run("GetContactController").show(contact);
};

/**
 * @private
 */
ZmContactsApp.prototype._handleLoadNewAddrBook =
function() {
	appCtxt.getAppViewMgr().popView(true, ZmId.VIEW_LOADING);	// pop "Loading..." page
	var dialog = appCtxt.getNewAddrBookDialog();
	if (!this._newAddrBookCb) {
		this._newAddrBookCb = new AjxCallback(this, this._newAddrBookCallback);
	}
	ZmController.showDialog(dialog, this._newAddrBookCb);
};

// Public methods

/**
 * Activates the application.
 * 
 * @param	{Object}	active 	(not used)
 * 
 */
ZmContactsApp.prototype.activate =
function(active) {
	ZmApp.prototype.activate.apply(this, arguments);
};

ZmContactsApp.prototype.getNewButtonProps =
function() {
	return {
		text:		ZmMsg.newContact,
		tooltip:	ZmMsg.createNewContact,
		icon:		"NewContact",
		iconDis:	"NewContactDis",
		defaultId:	ZmOperation.NEW_CONTACT,
        disabled:   !this.containsWritableFolder()
	};
};

/**
 * Launches the application.
 * 
 * @param	{Object}	params		(not used)
 * @param	{AjxCallback}	callback	the callback
 */
ZmContactsApp.prototype.launch =
function(params, callback) {
	this._setLaunchTime(this.toString(), new Date());
    var loadCallback = new AjxCallback(this, this._handleLoadLaunch, callback);
    // sync load to prevent race condition
	AjxDispatcher.require(["ContactsCore", "Contacts"], false, loadCallback, null, true);
};

/**
 * @private
 */
ZmContactsApp.prototype._handleLoadLaunch =
function(callback) {
    var query = "in:contacts";
    if(appCtxt.isExternalAccount()) {
        query = "inid:" + this.getDefaultFolderId();

    }
	this._contactsSearch(query, callback);
};

/**
 * @private
 */
ZmContactsApp.prototype._contactsSearch =
function(query, callback) {
	var params = {
		searchFor:	ZmId.ITEM_CONTACT,
		query:		query,
		limit:		this.getLimit(),
		types:		[ZmId.ITEM_CONTACT],
		callback:	callback
	};
	var sc = appCtxt.getSearchController();
	sc.searchAllAccounts = false;
	sc.search(params);
};

/**
 * Gets the limit for the search triggered by the application launch or an overview click.
 * 
 * @param	{Boolean}	offset	if <code>true</code> app has offset
 * @return	{int}	the limit
 */
ZmContactsApp.prototype.getLimit =
function(offset) {
	// return enough for us to get a scroll bar since we are pageless
	var limit = appCtxt.get(ZmSetting.PAGE_SIZE);
	return offset ? limit : 2 * limit;
};

/**
 * Gets the initial search type.
 * 
 * @return	{constant}	the search (see {@link ZmId}<code>.SEARCH_</code> constants)
 */
ZmContactsApp.prototype.getInitialSearchType =
function() {
	var list = appCtxt.getCurrentList();
	return (list && (list instanceof ZmContactList) && list.isGal)
		? ZmId.SEARCH_GAL : null;
};

/**
 * Shows the search results.
 * 
 * @param	{Object}					results					the results
 * @param	{AjxCallback}				callback				the callback
 * @param 	{ZmSearchResultsController}	searchResultsController	owning controller
 */
ZmContactsApp.prototype.showSearchResults =
function(results, callback, searchResultsController) {
	var loadCallback = this._handleLoadShowSearchResults.bind(this, results, callback, searchResultsController);
	AjxDispatcher.require("Contacts", false, loadCallback, null, true);
};

/**
 * @private
 */
ZmContactsApp.prototype._handleLoadShowSearchResults =
function(results, callback, searchResultsController) {
	var search = results && results.search;
	var folderId = search && search.isSimple() && search.folderId;
	var isInGal = search && (search.contactSource == ZmId.SEARCH_GAL);
	var sessionId = searchResultsController ? searchResultsController.getCurrentViewId() : ZmApp.MAIN_SESSION;
	var controller = AjxDispatcher.run("GetContactListController", sessionId, searchResultsController);
	controller.show(results, isInGal, folderId);
	this._setLoadedTime(this.toString(), new Date());
	if (callback) {
		callback.run(controller);
	}
};

ZmContactsApp.prototype.runRefresh =
function() {
	var clc = AjxDispatcher.run("GetContactListController");
	clc.runRefresh();
};


/**
 * Sets the app as active.
 * 
 * @param	{Boolean}	active	if <code>true</code> active and shows application
 */
ZmContactsApp.prototype.setActive =
function(active) {
	if (active) {
		var clc = AjxDispatcher.run("GetContactListController");
		clc.show();
	}
};

/**
 * Checks if the contact list is loaded for the specified account.
 * 
 * @param	{String}	acctId	the account id
 * @return	{Boolean}	<code>true</code> if contact list is loaded
 */
ZmContactsApp.prototype.isContactListLoaded =
function(acctId) {
	var aid = (acctId || appCtxt.getActiveAccount().id);
	return (this._contactList[aid] && this._contactList[aid].isLoaded);
};

/**
 * Gets the contact with the given address, if any. If it's not in our cache
 * and we are given a callback, we do a search. If a search is performed then any
 * addresses in the Address Lookup Group are also searched for.
 *
 * @param {String}	address			an email address
 * @param {AjxCallback}	callback	the callback to run
 * @return	{ZmContact}	the contact
 * 
 * @see		#setAddrLookupGroup
 */
ZmContactsApp.prototype.getContactByEmail =
function(address, callback) {
	if (!address) { return null; }
	var addr = address.toLowerCase();
	var contact = this._byEmail[addr];

	// if we have a failed search for this address, or have loaded all contacts,
	// don't bother doing a search
	if (!contact && this._notFound(addr)) {
		this._removeAddrFromLookupGroup(addr);
		if (callback) { callback.run(null); }
		return null;
	}

	// found a cached contact, return it
	if (contact) {
		this._removeAddrFromLookupGroup(addr);
		contact = this._realizeContact(contact);
		contact._lookupEmail = address;	// so caller knows which address matched
		if (callback) { callback.run(contact); }
		return contact;
	}

	// search for contact
	if (callback) {
		var search = null,
			isGroupSearch = false,
			lookupAddrs = [];
		if (this._addrLookupHash && this._addrLookupHash[addr]) {
			if (this._addrLookupList) {
				for (var i = 0; i < this._addrLookupList.length; i++) {
					lookupAddrs.push(this._addrLookupList[i]);
				}
				search = this._getSearchForAddresses(this._addrLookupList);
				isGroupSearch = true;
				this._addrLookupList = null;
			}
			this._addrLookupHash[addr].push(callback);
		} else {
			search = this._getSearchForAddresses([address]);
		}

		if (search) {
			var respCallback = new AjxCallback(this, this._handleResponseSearch, [isGroupSearch ? lookupAddrs : addr, isGroupSearch, callback]);
			search.execute({callback:respCallback, noBusyOverlay:true});
		}
	}
};

/**
 * @private
 */
ZmContactsApp.prototype._handleResponseSearch =
function(addr, isGroupSearch, callback, result) {
	var resp = result.getResponse();
	var contactList = resp && resp.getResults(ZmItem.CONTACT);
	if (isGroupSearch) {
		var list = contactList.getArray();
		for (var i = 0; i < list.length; i++) {
			this._updateLookupCache(list[i]);
		}
		for (var i = 0; i < addr.length; i++) {
			var a = addr[i];
			if (!this._byEmail[a]) {
				this._updateLookupCache(null, a); // Make sure there's a null entry in the map for the address.	
			}
			var callbacks = this._addrLookupHash[a];
			if (callbacks && callbacks.length) {
				for (var j = 0; j < callbacks.length; j++) {
					callbacks[j].run(this._byEmail[a]);
				}
			}
			this._removeAddrFromLookupGroup(a);
		}
	} else {
		var contact = contactList ? contactList.get(0) : null;	// return null if not found
		this._updateLookupCache(contact, addr);
		this._byEmail[addr] = contact;
		callback.run(contact);
	}
};

/**
 * Gets the contacts with the given addresses, if any. If there are addresses not in our cache
 * and we are given a callback, we do a search. Unlike {@link #getContactByEmail}, this method does not
 * use or modify the Address Lookup Group.
 *
 * @param {Array}	addresses	an array of {@link AjxEmailAddress} objects
 * @param {AjxCallback}	callback	the callback to run
 * @return	{Array}	an array of [{@link AjxEmailAddress}, {@link ZmContact}] pairs.
 * 
 * @see		#setAddrLookupGroup
 */
ZmContactsApp.prototype.getContactsByEmails =
function(addresses, callback) {
	// Go through the addresses, separating known ones from unknown.
	var resultArray = [],
		searchAddresses = null,
		searchAddressStrings = null;
	for (var i = 0, count = addresses.length; i < count; i++) {
		var address = addresses[i];
		var contact = this.getContactByEmail(address.getAddress());
		if (contact || contact === null) {
			resultArray.push({ address: address, contact: contact });
		} else {
			searchAddresses = searchAddresses || [];
			searchAddressStrings = searchAddressStrings || [];
			searchAddresses.push(address);
			searchAddressStrings.push(address.getAddress());
		}
	}

	// See if we can exit without performing a search.
	if (!callback) {
		return resultArray;
	}
	if (!searchAddresses) {
		callback.run(resultArray);
		return resultArray;
	}

	// Perform the search.
	var search = this._getSearchForAddresses(searchAddressStrings);
	var respCallback = new AjxCallback(this, this._handleResponseSearchByEmails, [searchAddresses, resultArray, callback]);
	search.execute({callback:respCallback});
};

/**
 * @private
 */
ZmContactsApp.prototype._handleResponseSearchByEmails =
function(addresses, resultArray, callback, result) {
	// get contact list
	var resp = result.getResponse();
	var list = resp && resp.getResults(ZmItem.CONTACT);
	if (!list) callback.run(resultArray);

	// get contact emails
	for (var index = 0, count = list.size(); index < count; index++) {
		var contact = list.get(index);
		for (var i = 1; true; i++) {
			var aname = ZmContact.getAttributeName(ZmContact.F_email, i);
			var avalue = contact.getAttr(aname);
			if (!avalue) break;
			this._byEmail[avalue] = contact;
		}
	}

	// Fill in the results.
	for (var i = 0, count = addresses.length; i < count; i++) {
		var address = addresses[i];
		var contact = this.getContactByEmail(address.getAddress());
		resultArray.push({ address: address, contact: contact });
	}
	callback.run(resultArray);
};

/**
 * @private
 */
ZmContactsApp.prototype._getSearchForAddresses =
function(addrs) {
	var buffer;
	if (addrs.length == 1) {
		buffer = ["to:", addrs[0], " not #type:group"];
	} else {
		buffer = ["("];
		for (var i = 0, count = addrs.length; i < count; i++) {
			if (i > 0) {
				buffer.push(" OR ");
			}
			buffer.push("to:");
			buffer.push(addrs[i]);
		}
		buffer.push(") not #type:group");
	}
	var params = {
		query: buffer.join(""),
		limit: addrs.length * 2,
		types: AjxVector.fromArray([ZmItem.CONTACT])
	};
	return new ZmSearch(params);
};

ZmContactsApp.prototype._notFound =
function(contact) {
	return (contact === null || Boolean(this._contactList[appCtxt.getActiveAccount().id]));
};

/**
 * Sets up a list of email addresses to use to find their contacts with a single search. The addresses passed
 * in can either be raw email addresses (strings), or {@link AjxEmailAddress} objects. A list of the addresses is kept
 * so that it can later be used to create a single search query. Each address will also keep track of the
 * callbacks that will need to be run with its search result (it's a list of callbacks since the same address
 * may be used in more than one context).
 * <p>
 * One example of this group approach is in rendering a message header, where each email address in the header
 * is rendered based on whether it maps to a contact. The group approach lets us do a single search rather than
 * several.
 * </p>
 *
 * @param {Array}	addrs		a list of email addresses to look up
 */
ZmContactsApp.prototype.setAddrLookupGroup =
function(addrs) {
	this._addrLookupList = [];
	this._addrLookupHash = {};
	if (addrs && addrs.length) {
		for (var i = 0; i < addrs.length; i++) {
			if (addrs[i]) {
				var addr = addrs[i].address || addrs[i];
				addr = (addr && AjxUtil.isString(addr)) ? addr.toLowerCase() : null;
				if (addr && !this._addrLookupHash[addr]) {
					this._addrLookupList.push(addr);
					this._addrLookupHash[addr] = [];
				}
			}
		}
	}
};

/**
 * @private
 */
ZmContactsApp.prototype._removeAddrFromLookupGroup =
function(addr) {
	if (!(this._addrLookupList && this._addrLookupList.length)) { return; }
	AjxUtil.arrayRemove(this._addrLookupList, addr);
	delete this._addrLookupHash[addr];
};

/**
 * @private
 */
ZmContactsApp.prototype._updateLookupCache =
function(contact, addr) {
	if (addr) {
		this._byEmail[addr] = contact;
	}
	if (contact) {
		for (var i = 1; true; i++) {
			var aname = ZmContact.getAttributeName(ZmContact.F_email, i);
			var avalue = contact.getAttr(aname);
			if (!avalue) break;
			this._byEmail[avalue.toLowerCase()] = contact;
		}
	}
};

/**
 * Gets information about the contact with the given phone number, if any.
 * Canonical list only.
 *
 * @param {String}	phone	the phone number
 * @return	{Object}	an object with contact = the contact & field = the field with the matching phone number
 */
ZmContactsApp.prototype.getContactByPhone =
function(phone) {
	if (!phone) { return null; }
	var digits = phone.replace(/[^\d]/g, '');
	var data = this._phoneToContact[digits];
	if (data) {
		data.contact = this._realizeContact(data.contact);
	}
	return data;
};

/**
 * @private
 */
ZmContactsApp.prototype._realizeContact =
function(contact) {
	var acctId = appCtxt.getActiveAccount().id;
	var cl = this._contactList[acctId];
	return cl ? cl._realizeContact(contact) : contact;
};

/**
 * @private
 */
ZmContactsApp.prototype.updateCache =
function(contact, doAdd) {

	this._updateHash(contact, doAdd, ZmContact.EMAIL_FIELDS, this._byEmail);
	if (appCtxt.get(ZmSetting.VOICE_ENABLED)) {
		this._updateHash(contact, doAdd, ZmContact.PHONE_FIELDS, this._byPhone, true, true);
	}
};

/**
 * @private
 */
ZmContactsApp.prototype._updateHash =
function(contact, doAdd, fields, hash, includeField, isNumeric) {

	for (var index = 0; index < fields.length; index++) {
		var field = fields[index];
		for (var i = 1; true; i++) {
			var aname = ZmContact.getAttributeName(field, i);
			var avalue = ZmContact.getAttr(contact, aname);
			if (!avalue) break;
			avalue = isNumeric ? avalue.replace(/[^\d]/g, '') : avalue.toLowerCase();
			if (doAdd) {
				hash[avalue] = includeField ? {contact:contact, field:aname} : contact;
			} else {
				delete hash[avalue];
			}
		}
	}
};

/**
 * Used in multi-account to load contacts for all of user's accounts.
 * 
 * @private
 */
ZmContactsApp.prototype.getContactListForAllAccounts =
function() {
	var enabled = [];
	var list = appCtxt.accountList.visibleAccounts;
	for (var i = 0; i < list.length; i++) {
		if (appCtxt.get(ZmSetting.CONTACTS_ENABLED, null, list[i])) {
			enabled.push(list[i]);
		}
	}

	if (enabled.length > 0) {
		this._loadContactsForAccount(enabled);
	}
};

/**
 * @private
 */
ZmContactsApp.prototype._loadContactsForAccount =
function(accounts) {
	var acct = accounts.shift();
	if (acct) {
		var callback = new AjxCallback(this, this._loadContactsForAccount, [accounts]);
		this.getContactList(callback, null, acct);
	}
};

/**
 * Gets a {@link ZmContactList} with all of the user's local contacts. If that's a
 * large number, performance may be slow.
 * 
 * @param {AjxCallback}	callback			the callback to trigger after contact list loaded
 * @param {AjxCallback}	errorCallback		the callback to trigger in the event of an error
 * @param {ZmZimbraAccount}	account		the account to fetch contacts for
 * @return	{ZmContactList}	the contact list
 */
ZmContactsApp.prototype.getContactList =
function(callback, errorCallback, account) {
	var acctId = (account && account.id) || appCtxt.getActiveAccount().id;
	if (!this._contactList[acctId]) {
		try {
			// check if a parent controller exists and ask it for the contact list
			if (this._parentController) {
				this._contactList[acctId] = this._parentController.getApp(ZmApp.CONTACTS).getContactList();
			} else {
				this._contactList[acctId] = new ZmContactList(null);
				var respCallback = new AjxCallback(this, this._handleResponseGetContactList, [callback]);
				var accountName = (account && account.getEmail());
				this._contactList[acctId].load(respCallback, errorCallback, accountName);
			}
			return this._contactList[acctId];
		} catch (ex) {
			this._contactList[acctId] = null;
			throw ex;
		}
	} else {
		if (callback && callback.isAjxCallback) {
			callback.run(this._contactList[acctId]);
		}
		return this._contactList[acctId];
	}
};

/**
 * @private
 */
ZmContactsApp.prototype._handleResponseGetContactList =
function(callback) {
	var acctId = appCtxt.getActiveAccount().id;
	this.contactsLoaded[acctId] = true;

	if (callback) {
		callback.run(this._contactList[acctId]);
	}
};

/**
 * Gets the GAL contact list. NOTE: calling method should handle exceptions.
 * 
 * @return	{ZmContactList}	the contact list
 */
ZmContactsApp.prototype.getGalContactList =
function() {
	if (!this._galContactList) {
		try {
			this._galContactList = new ZmContactList(null, true);
			this._galContactList.load();
		} catch (ex) {
			this._galContactList = null;
			throw ex;
		}
	}
	return this._galContactList;
};

/**
 * @private
 */
ZmContactsApp.prototype.createFromVCard =
function(msgId, vcardPartId) {
	var contact = new ZmContact(null);
	contact.createFromVCard(msgId, vcardPartId);
};

/**
 * Gets the contact list controller.
 * 
 * @return	{ZmContactListController}	the controller
 */
ZmContactsApp.prototype.getContactListController =
function(sessionId, searchResultsController) {
	return this.getSessionController({controllerClass:			"ZmContactListController",
									  sessionId:				sessionId || ZmApp.MAIN_SESSION,
									  searchResultsController:	searchResultsController});
};

/**
 * Gets the contact controller.
 *
 * @return	{ZmContactController}	the controller
 */
ZmContactsApp.prototype.getContactController =
function(sessionId) {
	return this.getSessionController({controllerClass:	"ZmContactController",
									  sessionId:		sessionId});
};

/**
 * @private
 */
ZmContactsApp.prototype._newAddrBookCallback =
function(parent, name, color) {
	// REVISIT: Do we really want to close the dialog before we
	//          know if the create succeeds or fails?
	var dialog = appCtxt.getNewAddrBookDialog();
	dialog.popdown();

	var oc = appCtxt.getOverviewController();
	oc.getTreeController(ZmOrganizer.ADDRBOOK)._doCreate(parent, name, color);
};

ZmContactsApp.prototype.getDL =
function(addr) {
	return this._dlCache[addr];
};

ZmContactsApp.prototype.cacheDL =
function(addr, dl) {
	this._dlCache[addr] = dl;
};

/**
 * Adds/remove contacts from the contact list hash
 * @param contact  {Object}     contact object
 * @param doDelete {boolean}    true to delete from hash
 */
ZmContactsApp.prototype.updateIdHash =
function(contact, doDelete) {
	var id = contact.id;
	var hash = this.getContactList().getIdHash();
	if (!doDelete) {
		hash[id] = contact;
	}
	else {
		delete hash[id];
	}
};

/**
 * Online to Offline or Offline to Online; Called from ZmApp.activate and from ZmOffline.enableApps, disableApps
 */
ZmContactsApp.prototype.resetWebClientOfflineOperations =
function() {
	ZmApp.prototype.resetWebClientOfflineOperations.apply(this);
	var contactListController = this.getContactListController();
    var currentToolbar = contactListController && contactListController.getCurrentToolbar();
    if (contactListController && currentToolbar) {
	    contactListController._resetOperations(currentToolbar);
    }
	var overview = this.getOverview();
	var distributionList = overview && overview.getTreeItemById(ZmFolder.ID_DLS);// Distribution Lists folder Id
	if (distributionList) {
		distributionList.setVisible(!appCtxt.isWebClientOffline());
	}
};
}
if (AjxPackage.define("zimbraMail.share.ZmSearchApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the search application class.
 */

/**
 * Creates and initializes the search application.
 * @constructor
 * @class
 * The search app manages user-initiated searches.
 *
 * @param	{DwtControl}	container		the container
 * @param	{ZmController}	parentController	the parent window controller (set by the child window)
 * 
 * @author Conrad Damon
 * 
 * @extends		ZmApp
 */
ZmSearchApp = function(container, parentController) {

	ZmApp.call(this, ZmApp.SEARCH, container, parentController);

	this._groupBy = appCtxt.get(ZmSetting.GROUP_MAIL_BY);
};

ZmSearchApp.prototype = new ZmApp;
ZmSearchApp.prototype.constructor = ZmSearchApp;

ZmSearchApp.prototype.isZmSearchApp = true;
ZmSearchApp.prototype.toString = function() {	return "ZmSearchApp"; };

ZmApp.SEARCH					= ZmId.APP_SEARCH;
ZmApp.CLASS[ZmApp.SEARCH]		= "ZmSearchApp";
ZmApp.SETTING[ZmApp.SEARCH]		= ZmSetting.SEARCH_ENABLED;

ZmSearchApp.CONTROLLER_CLASS = "ZmSearchResultsController";

ZmSearchApp.prototype.getSearchResultsController =
function(sessionId, appName) {
	return this.getSessionController({
				controllerClass:	ZmSearchApp.CONTROLLER_CLASS,
				sessionId:			sessionId,
				appName:			appName
			});
};

// override so we don't try to set overview panel content
ZmSearchApp.prototype.activate =
function(active) {
	this._active = active;
};

// Not hooked up for activate, but it will be called after displaying the search results
ZmSearchApp.prototype.resetWebClientOfflineOperations =
function(searchResultsController) {
	ZmApp.prototype.resetWebClientOfflineOperations.apply(this);
	if (!searchResultsController) {
		var controllerType = this.getTypeFromController(ZmSearchApp.CONTROLLER_CLASS);
		var sessionId = this.getCurrentSessionId(controllerType);
		searchResultsController = this.getSearchResultsController(sessionId);
	}
	// Only Save affected currently
	var searchResultsToolBar = searchResultsController && searchResultsController._toolbar;
	var saveButton = searchResultsToolBar && searchResultsToolBar.getButton(ZmSearchToolBar.SAVE_BUTTON);
	if (saveButton) {
		saveButton.setEnabled(!appCtxt.isWebClientOffline());
	}
};

// search app maintains its own "group mail by" setting
ZmSearchApp.prototype.getGroupMailBy = function() {
	return ZmMailApp.prototype.getGroupMailBy.call(this);
};

ZmSearchApp.prototype.setGroupMailBy = 	function(groupBy) {
	this._groupBy = groupBy;
};
}
if (AjxPackage.define("zimbraMail.abook.model.ZmContact")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the contact class.
 */

if (!window.ZmContact) {
/**
 * Creates an empty contact.
 * @class
 * This class represents a contact (typically a person) with all its associated versions
 * of email address, home and work addresses, phone numbers, etc. Contacts can be filed/sorted
 * in different ways, with the default being Last, First. A contact is an item, so
 * it has tagging and flagging support, and belongs to a list.
 * <p>
 * Most of a contact's data is kept in attributes. These include name, phone, etc. Meta-data and
 * data common to items are not kept in attributes. These include flags, tags, folder, and
 * modified/created dates. Since the attribute data for contacts is loaded only once, a contact
 * gets its attribute values from that canonical list.
 * </p>
 *
 * @param {int}	id		the unique ID
 * @param {ZmContactList}	list		the list that contains this contact
 * @param {constant}	type		the item type
 * @param {object}	newDl		true if this is a new DL
 *
 * @extends		ZmItem
 */
ZmContact = function(id, list, type, newDl) {
	if (arguments.length == 0) { return; }

	type = type || ZmItem.CONTACT;
	ZmItem.call(this, type, id, list);

	this.attr = {};
	this.isGal = (this.list && this.list.isGal) || newDl;
	if (newDl) {
		this.folderId = ZmFolder.ID_DLS;
		this.dlInfo = {	isMember: false,
						isOwner: true,
						subscriptionPolicy: null,
						unsubscriptionPolicy: null,
						description: "",
						displayName: "",
						notes: "",
						hideInGal: false,
						mailPolicy: null,
						owners: [appCtxt.get(ZmSetting.USERNAME)]
		};

	}

	this.participants = new AjxVector(); // XXX: need to populate this guy (see ZmConv)
};

ZmContact.prototype = new ZmItem;
ZmContact.prototype.constructor = ZmContact;
ZmContact.prototype.isZmContact = true;

// fields
ZmContact.F_anniversary				= "anniversary";
ZmContact.F_assistantPhone			= "assistantPhone";
ZmContact.F_attachment				= "attachment";
ZmContact.F_birthday				= "birthday";
ZmContact.F_callbackPhone			= "callbackPhone";
ZmContact.F_carPhone				= "carPhone";
ZmContact.F_company					= "company";
ZmContact.F_companyPhone			= "companyPhone";
ZmContact.F_custom					= "custom";
ZmContact.F_description				= "description";
ZmContact.F_department				= "department";
ZmContact.F_dlist					= "dlist";				// Group fields
ZmContact.F_dlDisplayName			= "dldisplayname"; //DL
ZmContact.F_dlDesc					= "dldesc";  //DL
ZmContact.F_dlHideInGal				= "dlhideingal";  //DL
ZmContact.F_dlNotes					= "dlnotes";  //DL
ZmContact.F_dlSubscriptionPolicy	= "dlsubspolicy";  //DL
ZmContact.F_dlMailPolicy			= "dlmailpolicy";  //DL
ZmContact.F_dlMailPolicySpecificMailers	= "dlmailpolicyspecificmailers";  //DL
ZmContact.F_dlUnsubscriptionPolicy	= "dlunsubspolicy";  //DL
ZmContact.F_dlListOwners			= "dllistowners";  //DL
ZmContact.F_email					= "email";
ZmContact.F_email2					= "email2";
ZmContact.F_email3					= "email3";
ZmContact.F_email4					= "email4";
ZmContact.F_email5					= "email5";
ZmContact.F_email6					= "email6";
ZmContact.F_email7					= "email7";
ZmContact.F_email8					= "email8";
ZmContact.F_email9					= "email9";
ZmContact.F_email10					= "email10";
ZmContact.F_email11					= "email11";
ZmContact.F_email12					= "email12";
ZmContact.F_email13					= "email13";
ZmContact.F_email14					= "email14";
ZmContact.F_email15					= "email15";
ZmContact.F_email16					= "email16";
ZmContact.F_fileAs					= "fileAs";
ZmContact.F_firstName				= "firstName";
ZmContact.F_folderId				= "folderId";
ZmContact.F_groups                  = "groups";         //group members
ZmContact.F_homeCity				= "homeCity";
ZmContact.F_homeCountry				= "homeCountry";
ZmContact.F_homeFax					= "homeFax";
ZmContact.F_homePhone				= "homePhone";
ZmContact.F_homePhone2				= "homePhone2";
ZmContact.F_homePostalCode			= "homePostalCode";
ZmContact.F_homeState				= "homeState";
ZmContact.F_homeStreet				= "homeStreet";
ZmContact.F_homeURL					= "homeURL";
ZmContact.F_image					= "image";				// contact photo
ZmContact.F_imAddress 				= "imAddress";			// IM addresses
ZmContact.F_imAddress1 				= "imAddress1";			// IM addresses
ZmContact.F_imAddress2 				= "imAddress2";
ZmContact.F_imAddress3				= "imAddress3";
ZmContact.F_jobTitle				= "jobTitle";
ZmContact.F_lastName				= "lastName";
ZmContact.F_maidenName				= "maidenName";
ZmContact.F_memberC                 = "memberC";
ZmContact.F_memberG                 = "memberG";
ZmContact.F_memberI                 = "memberI";
ZmContact.F_middleName				= "middleName";
ZmContact.F_mobilePhone				= "mobilePhone";
ZmContact.F_namePrefix				= "namePrefix";
ZmContact.F_nameSuffix				= "nameSuffix";
ZmContact.F_nickname				= "nickname";
ZmContact.F_notes					= "notes";
ZmContact.F_otherCity				= "otherCity";
ZmContact.F_otherCountry			= "otherCountry";
ZmContact.F_otherFax				= "otherFax";
ZmContact.F_otherPhone				= "otherPhone";
ZmContact.F_otherPostalCode			= "otherPostalCode";
ZmContact.F_otherState				= "otherState";
ZmContact.F_otherStreet				= "otherStreet";
ZmContact.F_otherURL				= "otherURL";
ZmContact.F_pager					= "pager";
ZmContact.F_phoneticFirstName       = "phoneticFirstName";
ZmContact.F_phoneticLastName        = "phoneticLastName";
ZmContact.F_phoneticCompany         = "phoneticCompany";
ZmContact.F_type					= "type";
ZmContact.F_workAltPhone			= "workAltPhone";
ZmContact.F_workCity				= "workCity";
ZmContact.F_workCountry				= "workCountry";
ZmContact.F_workEmail1				= "workEmail1";
ZmContact.F_workEmail2				= "workEmail2";
ZmContact.F_workEmail3				= "workEmail3";
ZmContact.F_workFax					= "workFax";
ZmContact.F_workMobile				= "workMobile";
ZmContact.F_workPhone				= "workPhone";
ZmContact.F_workPhone2				= "workPhone2";
ZmContact.F_workPostalCode			= "workPostalCode";
ZmContact.F_workState				= "workState";
ZmContact.F_workStreet				= "workStreet";
ZmContact.F_workURL					= "workURL";
ZmContact.F_imagepart               = "imagepart";          // New field for bug 73146 - Contacts call does not return the image information
ZmContact.F_zimletImage				= "zimletImage";
ZmContact.X_fileAs					= "fileAs";				// extra fields
ZmContact.X_firstLast				= "firstLast";
ZmContact.X_fullName				= "fullName";
ZmContact.X_vcardXProps             = "vcardXProps";
ZmContact.X_outlookUserField        = "outlookUserField";
ZmContact.MC_cardOwner				= "cardOwner";			// My card fields
ZmContact.MC_workCardMessage		= "workCardMessage";
ZmContact.MC_homeCardMessage		= "homeCardMessage";
ZmContact.MC_homePhotoURL			= "homePhotoURL";
ZmContact.MC_workPhotoURL			= "workPhotoURL";
ZmContact.GAL_MODIFY_TIMESTAMP		= "modifyTimeStamp";	// GAL fields
ZmContact.GAL_CREATE_TIMESTAMP		= "createTimeStamp";
ZmContact.GAL_ZIMBRA_ID				= "zimbraId";
ZmContact.GAL_OBJECT_CLASS			= "objectClass";
ZmContact.GAL_MAIL_FORWARD_ADDRESS	= "zimbraMailForwardingAddress";
ZmContact.GAL_CAL_RES_TYPE			= "zimbraCalResType";
ZmContact.GAL_CAL_RES_LOC_NAME		= "zimbraCalResLocationDisplayName";

// file as
(function() {
	var i = 1;
	ZmContact.FA_LAST_C_FIRST			= i++;
	ZmContact.FA_FIRST_LAST 			= i++;
	ZmContact.FA_COMPANY 				= i++;
	ZmContact.FA_LAST_C_FIRST_COMPANY	= i++;
	ZmContact.FA_FIRST_LAST_COMPANY		= i++;
	ZmContact.FA_COMPANY_LAST_C_FIRST	= i++;
	ZmContact.FA_COMPANY_FIRST_LAST		= i++;
	ZmContact.FA_CUSTOM					= i++;
})();

// Field information

ZmContact.ADDRESS_FIELDS = [
    // NOTE: sync with field order in ZmEditContactView's templates
	ZmContact.F_homeCity,
	ZmContact.F_homeCountry,
	ZmContact.F_homePostalCode,
	ZmContact.F_homeState,
	ZmContact.F_homeStreet,
	ZmContact.F_workCity,
	ZmContact.F_workCountry,
	ZmContact.F_workPostalCode,
	ZmContact.F_workState,
	ZmContact.F_workStreet,
    ZmContact.F_otherCity,
    ZmContact.F_otherCountry,
    ZmContact.F_otherPostalCode,
    ZmContact.F_otherState,
    ZmContact.F_otherStreet
];
ZmContact.EMAIL_FIELDS = [
	ZmContact.F_email,
	ZmContact.F_workEmail1,
	ZmContact.F_workEmail2,
	ZmContact.F_workEmail3
];
ZmContact.IM_FIELDS = [
	ZmContact.F_imAddress
];
ZmContact.OTHER_FIELDS = [
    // NOTE: sync with field order in ZmEditContactView's templates
	ZmContact.F_birthday,
    ZmContact.F_anniversary,
	ZmContact.F_custom
];
ZmContact.PHONE_FIELDS = [
    // NOTE: sync with field order in ZmEditContactView's templates
    ZmContact.F_mobilePhone,
    ZmContact.F_workPhone,
    ZmContact.F_workFax,
    ZmContact.F_companyPhone,
    ZmContact.F_homePhone,
    ZmContact.F_homeFax,
    ZmContact.F_pager,
    ZmContact.F_callbackPhone,
	ZmContact.F_assistantPhone,
	ZmContact.F_carPhone,
	ZmContact.F_otherPhone,
    ZmContact.F_otherFax,
	ZmContact.F_workAltPhone,
	ZmContact.F_workMobile
];
ZmContact.PRIMARY_FIELDS = [
    // NOTE: sync with field order in ZmEditContactView's templates
    ZmContact.F_image,
    ZmContact.F_namePrefix,
    ZmContact.F_firstName,
    ZmContact.F_phoneticFirstName,
    ZmContact.F_middleName,
	ZmContact.F_maidenName,
    ZmContact.F_lastName,
    ZmContact.F_phoneticLastName,
    ZmContact.F_nameSuffix,
    ZmContact.F_nickname,
    ZmContact.F_jobTitle,
    ZmContact.F_department,
	ZmContact.F_company,
    ZmContact.F_phoneticCompany,
	ZmContact.F_fileAs,
	ZmContact.F_folderId,
	ZmContact.F_notes
];
ZmContact.URL_FIELDS = [
    // NOTE: sync with field order in ZmEditContactView's templates
	ZmContact.F_homeURL,
	ZmContact.F_workURL,
	ZmContact.F_otherURL
];
ZmContact.GAL_FIELDS = [
	ZmContact.GAL_MODIFY_TIMESTAMP,
	ZmContact.GAL_CREATE_TIMESTAMP,
	ZmContact.GAL_ZIMBRA_ID,
	ZmContact.GAL_OBJECT_CLASS,
	ZmContact.GAL_MAIL_FORWARD_ADDRESS,
	ZmContact.GAL_CAL_RES_TYPE,
	ZmContact.GAL_CAL_RES_LOC_NAME,
	ZmContact.F_type
];
ZmContact.MYCARD_FIELDS = [
	ZmContact.MC_cardOwner,
	ZmContact.MC_homeCardMessage,
	ZmContact.MC_homePhotoURL,
	ZmContact.MC_workCardMessage,
	ZmContact.MC_workPhotoURL
];
ZmContact.X_FIELDS = [
	ZmContact.X_firstLast,
	ZmContact.X_fullName,
    ZmContact.X_vcardXProps
];


ZmContact.IGNORE_NORMALIZATION = [];

ZmContact.ADDR_PREFIXES = ["work","home","other"];
ZmContact.ADDR_SUFFIXES = ["Street","City","State","PostalCode","Country"];

ZmContact.updateFieldConstants = function() {

	for (var i = 0; i < ZmContact.ADDR_PREFIXES.length; i++) {
		for (var j = 0; j < ZmContact.ADDR_SUFFIXES.length; j++) {
			ZmContact.IGNORE_NORMALIZATION.push(ZmContact.ADDR_PREFIXES[i] + ZmContact.ADDR_SUFFIXES[j]);
		}
	}

ZmContact.DISPLAY_FIELDS = [].concat(
	ZmContact.ADDRESS_FIELDS,
	ZmContact.EMAIL_FIELDS,
	ZmContact.IM_FIELDS,
	ZmContact.OTHER_FIELDS,
	ZmContact.PHONE_FIELDS,
	ZmContact.PRIMARY_FIELDS,
	ZmContact.URL_FIELDS
);

ZmContact.IGNORE_FIELDS = [].concat(
	ZmContact.GAL_FIELDS,
	ZmContact.MYCARD_FIELDS,
	ZmContact.X_FIELDS,
	[ZmContact.F_imagepart]
);

ZmContact.ALL_FIELDS = [].concat(
	ZmContact.DISPLAY_FIELDS, ZmContact.IGNORE_FIELDS
);

ZmContact.IS_DATE = {};
ZmContact.IS_DATE[ZmContact.F_birthday] = true;
ZmContact.IS_DATE[ZmContact.F_anniversary] = true;

ZmContact.IS_IGNORE = AjxUtil.arrayAsHash(ZmContact.IGNORE_FIELDS);

// number of distribution list members to fetch at a time
ZmContact.DL_PAGE_SIZE = 100;

ZmContact.GROUP_CONTACT_REF = "C";
ZmContact.GROUP_GAL_REF = "G";
ZmContact.GROUP_INLINE_REF = "I";	
}; // updateFieldConstants()
ZmContact.updateFieldConstants();

/**
 * This structure can be queried to determine if the first
 * entry in a multi-value entry is suffixed with "1". Most
 * attributes add a numerical suffix to all but the first
 * entry.
 * <p>
 * <strong>Note:</strong>
 * In most cases, {@link ZmContact#getAttributeName} is a better choice.
 */
ZmContact.IS_ADDONE = {};
ZmContact.IS_ADDONE[ZmContact.F_custom] = true;
ZmContact.IS_ADDONE[ZmContact.F_imAddress] = true;
ZmContact.IS_ADDONE[ZmContact.X_outlookUserField] = true;

/**
 * Gets an indexed attribute name taking into account if the field
 * with index 1 should append the "1" or not. Code should call this
 * function in lieu of accessing {@link ZmContact.IS_ADDONE} directly.
 */
ZmContact.getAttributeName = function(name, index) {
	index = index || 1;
	return index > 1 || ZmContact.IS_ADDONE[name] ? name+index : name;
};

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmContact.prototype.toString =
function() {
	return "ZmContact";
};

// Class methods

/**
 * Creates a contact from an XML node.
 *
 * @param {Object}	node		a "cn" XML node
 * @param {Hash}	args		args to pass to the constructor
 * @return	{ZmContact}	the contact
 */
ZmContact.createFromDom =
function(node, args) {
	// check global cache for this item first
	var contact = appCtxt.cacheGet(node.id);

	// make sure the revision hasnt changed, otherwise contact is out of date
	if (contact == null || (contact && contact.rev != node.rev)) {
		contact = new ZmContact(node.id, args.list);
		if (args.isGal) {
			contact.isGal = args.isGal;
		}
		contact._loadFromDom(node);
		//update the canonical list
		appCtxt.getApp(ZmApp.CONTACTS).getContactList().add(contact);
	} else {
		if (node.m) {
			contact.attr[ZmContact.F_groups] = node.m;
		}
		if (node.ref) {
			contact.ref = node.ref;
		}
		if (node.tn) {
			contact._parseTagNames(node.tn);
		}
		AjxUtil.hashUpdate(contact.attr, node._attrs);	// merge new attrs just in case we don't have them
		contact.list = args.list || new ZmContactList(null);
		contact._list = {};
		contact._list[contact.list.id] = true;
	}

	return contact;
};

/**
 * Compares two contacts based on how they are filed. Intended for use by
 * sort methods.
 *
 * @param {ZmContact}		a		a contact
 * @param {ZmContact}		b		a contact
 * @return	{int}	0 if the contacts are the same; 1 if "a" is before "b"; -1 if "b" is before "a"
 */
ZmContact.compareByFileAs =
function(a, b) {
	var aFileAs = (a instanceof ZmContact) ? a.getFileAs(true) : ZmContact.computeFileAs(a._attrs).toLowerCase();
	var bFileAs = (b instanceof ZmContact) ? b.getFileAs(true) : ZmContact.computeFileAs(b._attrs).toLowerCase();

	if (!bFileAs || (aFileAs > bFileAs)) return 1;
	if (aFileAs < bFileAs) return -1;
	return 0;
};

/**
 * Figures out the filing string for the contact according to the chosen method.
 *
 * @param {ZmContact|Hash}	contact		a contact or a hash of contact attributes
 */
ZmContact.computeFileAs =
function(contact) {
	/*
	 * Bug 98176: To keep the same logic of generating the FileAs contact
	 *    label string between the Ajax client, and HTML client, when the
	 *    computeFileAs(), and fileAs*() functions are modified, please
	 *    change the corresponding functions defined in the autoComplete.tag
	 */
	var attr = (contact instanceof ZmContact) ? contact.getAttrs() : contact;
	if (!attr) return;

	if (attr[ZmContact.F_dlDisplayName]) {
		//this is only DL case. But since this is sometimes just the attrs,
		//I can't always use isDistributionList method.
		return attr[ZmContact.F_dlDisplayName];
	}

	var val = parseInt(attr.fileAs);
	var fa;
	var idx = 0;

	switch (val) {
		case ZmContact.FA_LAST_C_FIRST: 										// Last, First
		default: {
			// if GAL contact, use full name instead (bug fix #4850,4009)
			if (contact && contact.isGal) {
				if (attr.fullName) { // bug fix #27428 - if fullName is Array, return first
					return (attr.fullName instanceof Array) ? attr.fullName[0] : attr.fullName;
				}
				return ((attr.email instanceof Array) ? attr.email[0] : attr.email);
			}
			fa = ZmContact.fileAsLastFirst(attr.firstName, attr.lastName, attr.fullName, attr.nickname);
		}
		break;

		case ZmContact.FA_FIRST_LAST: { 										// First Last
			fa = ZmContact.fileAsFirstLast(attr.firstName, attr.lastName, attr.fullName, attr.nickname);
		}
		break;

		case ZmContact.FA_COMPANY: {											// Company
			if (attr.company) fa = attr.company;
		}
		break;

		case ZmContact.FA_LAST_C_FIRST_COMPANY: {								// Last, First (Company)
			var name = ZmContact.fileAsLastFirst(attr.firstName, attr.lastName, attr.fullName, attr.nickname);
			fa = ZmContact.fileAsNameCompany(name, attr.company);
		}
		break;

		case ZmContact.FA_FIRST_LAST_COMPANY: {									// First Last (Company)
			var name = ZmContact.fileAsFirstLast(attr.firstName, attr.lastName, attr.fullName, attr.nickname);
			fa = ZmContact.fileAsNameCompany(name, attr.company);
		}
		break;

		case ZmContact.FA_COMPANY_LAST_C_FIRST: {								// Company (Last, First)
			var name = ZmContact.fileAsLastFirst(attr.firstName, attr.lastName);
			fa = ZmContact.fileAsCompanyName(name, attr.company);
		}
		break;

		case ZmContact.FA_COMPANY_FIRST_LAST: {									// Company (First Last)
			var name = ZmContact.fileAsFirstLast(attr.firstName, attr.lastName);
			fa = ZmContact.fileAsCompanyName(name, attr.company);
		}
		break;

		case ZmContact.FA_CUSTOM: {												// custom looks like this: "8:foobar"
			return attr.fileAs.substring(2);
		}
		break;
	}
	return fa || attr.fullName || "";
};

/**
 * Name printing helper "First Last".
 * 
 * @param	{String}	first		the first name
 * @param	{String}	last		the last name
 * @param	{String}	fullname		the fullname
 * @param	{String}	nickname		the nickname
 * @return	{String}	the name format
 */
ZmContact.fileAsFirstLast =
function(first, last, fullname, nickname) {
	if (first && last)
		return AjxMessageFormat.format(ZmMsg.fileAsFirstLast, [first, last]);
	return first || last || fullname || nickname || "";
};

/**
 * Name printing helper "Last, First".
 * 
 * @param	{String}	first		the first name
 * @param	{String}	last		the last name
 * @param	{String}	fullname		the fullname
 * @param	{String}	nickname		the nickname
 * @return	{String}	the name format
 */
ZmContact.fileAsLastFirst =
function(first, last, fullname, nickname) {
	if (first && last)
		return AjxMessageFormat.format(ZmMsg.fileAsLastFirst, [first, last]);
	return last || first || fullname || nickname || "";
};

/**
 * Name printing helper "Name (Company)".
 *
 * @param	{String}	name		the contact name
 * @param	{String}	company		the company
 * @return	{String}	the name format
 */
ZmContact.fileAsNameCompany =
function(name, company) {
	if (name && company)
		return AjxMessageFormat.format(ZmMsg.fileAsNameCompany, [name, company]);
	if (company)
		return AjxMessageFormat.format(ZmMsg.fileAsCompanyAsSecondaryOnly, [company]);
	return name;
};

/**
 * Name printing helper "Company (Name)".
 * 
 * @param	{String}	name		the contact name
 * @param	{String}	company		the company
 * @return	{String}	the name format
 */
ZmContact.fileAsCompanyName =
function(name, company) {
	if (company && name)
		return AjxMessageFormat.format(ZmMsg.fileAsCompanyName, [name, company]);
	if (name)
		return AjxMessageFormat.format(ZmMsg.fileAsNameAsSecondaryOnly, [name]);
	return company;
};

/**
 * Computes the custom file as string by prepending "8:" to the given custom fileAs string.
 * 
 * @param {Hash}	customFileAs	a set of contact attributes
 * @return	{String}	the name format
 */
ZmContact.computeCustomFileAs =
function(customFileAs) {
	return [ZmContact.FA_CUSTOM, ":", customFileAs].join("");
};

/*
 * 
 * These next few static methods handle a contact that is either an anonymous
 * object or an actual ZmContact. The former is used to optimize loading. The
 * anonymous object is upgraded to a ZmContact when needed.
 *  
 */

/**
 * Gets an attribute.
 * 
 * @param	{ZmContact}	contact		the contact
 * @param	{String}	attr		the attribute
 * @return	{Object}	the attribute value or <code>null</code> for none
 */
ZmContact.getAttr =
function(contact, attr) {
	return (contact instanceof ZmContact)
		? contact.getAttr(attr)
		: (contact && contact._attrs) ? contact._attrs[attr] : null;
};

/**
 * returns the prefix of a string in the format "abc123". (would return "abc"). If the string is all number, it's a special case and returns the string itself. e.g. "234" would return "234".
 */
ZmContact.getPrefix = function(s) {
	var trimmed = s.replace(/\d+$/, "");
	if (trimmed === "") {
		//number only - don't trim. The number is the prefix.
		return s;
	}
	return trimmed;
};

/**
 * Normalizes the numbering of the given attribute names and
 * returns a new object with the re-numbered attributes. For
 * example, if the attributes contains a "foo2" but no "foo",
 * then the "foo2" attribute will be renamed to "foo" in the
 * returned object.
 *
 * @param {Hash}	attrs  a hash of attributes to normalize.
 * @param {String}	[prefix] if specified, only the the attributes that match the given prefix will be returned
 * @param {Array}	[ignore] if specified, the attributes that are present in the array will not be normalized
 * @return	{Hash}	a hash of normalized attributes
 */
ZmContact.getNormalizedAttrs = function(attrs, prefix, ignore) {
	var nattrs = {};
	if (attrs) {
		// normalize attribute numbering
		var names = AjxUtil.keys(attrs);
		names.sort(ZmContact.__BY_ATTRIBUTE);
		var a = {};
		for (var i = 0; i < names.length; i++) {
			var name = names[i];
			// get current count
			var nprefix = ZmContact.getPrefix(name);
			if (prefix && prefix != nprefix) continue;
			if (AjxUtil.isArray(ignore) && AjxUtil.indexOf(ignore, nprefix)!=-1) {
				nattrs[name] = attrs[name];
			} else {
				if (!a[nprefix]) a[nprefix] = 0;
				// normalize, if needed
				var nname = ZmContact.getAttributeName(nprefix, ++a[nprefix]);
				nattrs[nname] = attrs[name];
			}
		}
	}
	return nattrs;
};

ZmContact.__RE_ATTRIBUTE = /^(.*?)(\d+)$/;
ZmContact.__BY_ATTRIBUTE = function(a, b) {
	var aa = a.match(ZmContact.__RE_ATTRIBUTE) || [a,a,1];
	var bb = b.match(ZmContact.__RE_ATTRIBUTE) || [b,b,1];
	return aa[1] == bb[1] ? Number(aa[2]) - Number(bb[2]) : aa[1].localeCompare(bb[1]);
};

/**
 * Sets the attribute.
 * 
 * @param	{ZmContact}	contact		the contact
 * @param	{String}	attr		the attribute
 * @param	{Object}	value		the attribute value
 */
ZmContact.setAttr =
function(contact, attr, value) {
	if (contact instanceof ZmContact)
		contact.setAttr(attr, value);
	else
		contact._attrs[attr] = value;
};

/**
 * Checks if the contact is in the trash.
 * 
 * @param	{ZmContact}	contact		the contact
 * @return	{Boolean}	<code>true</code> if in trash
 */
ZmContact.isInTrash =
function(contact) {
	var folderId = (contact instanceof ZmContact) ? contact.folderId : contact.l;
	var folder = appCtxt.getById(folderId);
	return (folder && folder.isInTrash());
};

/**
 * @private
 */
ZmContact.prototype.load =
function(callback, errorCallback, batchCmd, deref) {
	var jsonObj = {GetContactsRequest:{_jsns:"urn:zimbraMail"}};
	if (deref) {
		jsonObj.GetContactsRequest.derefGroupMember = "1";
	}
	var request = jsonObj.GetContactsRequest;
	request.cn = [{id:this.id}];

	var respCallback = new AjxCallback(this, this._handleLoadResponse, [callback]);

	if (batchCmd) {
		var jsonObj = {GetContactsRequest:{_jsns:"urn:zimbraMail"}};
		if (deref) {
			jsonObj.GetContactsRequest.derefGroupMember = "1";
		}
		jsonObj.GetContactsRequest.cn = {id:this.id};
		batchCmd.addRequestParams(jsonObj, respCallback, errorCallback);
	} else {
		appCtxt.getAppController().sendRequest({jsonObj:jsonObj,
												asyncMode:true,
												callback:respCallback,
												errorCallback:errorCallback});
	}
};

/**
 * @private
 */
ZmContact.prototype._handleLoadResponse =
function(callback, result) {
	var resp = result.getResponse().GetContactsResponse;

	// for now, we just assume only one contact was requested at a time
	var contact = resp.cn[0];
	this.attr = contact._attrs;
	if (contact.m) {
		for (var i = 0; i < contact.m.length; i++) {
			//cache contacts from contact groups (e.g. GAL contacts, shared contacts have not already been cached)
			var member = contact.m[i];
			var isGal = false;
			if (member.type == ZmContact.GROUP_GAL_REF) {
				isGal = true;
			}
			if (member.cn && member.cn.length > 0) {
				var memberContact = member.cn[0];
				memberContact.ref = memberContact.ref || (isGal && member.value); //we sometimes don't get "ref" but the "value" for GAL is the ref.
				var loadMember = ZmContact.createFromDom(memberContact, {list: this.list, isGal: isGal}); //pass GAL so fileAS gets set correctly
				loadMember.isDL = isGal && loadMember.attr[ZmContact.F_type] == "group";
				appCtxt.cacheSet(member.value, loadMember);
			}
			
		}
		this._loadFromDom(contact); //load group
	}
	this.isLoaded = true;
	if (callback) {
		callback.run(contact, this);
	}
};

/**
 * @private
 */
ZmContact.prototype.clear =
function() {
	// bug fix #41666 - override base class method and do nothing
};

/**
 * Checks if the contact attributes are empty.
 * 
 * @return	{Boolean}	<code>true</code> if empty
 */
ZmContact.prototype.isEmpty =
function() {
	for (var i in this.attr) {
		return false;
	}
	return true;
};

/**
 * Checks if the contact is shared.
 * 
 * @return	{Boolean}	<code>true</code> if shared
 */
ZmContact.prototype.isShared =
function() {
	return this.addrbook && this.addrbook.link;
};

/**
 * Checks if the contact is read-only.
 * 
 * @return	{Boolean}	<code>true</code> if read-only
 */
ZmContact.prototype.isReadOnly =
function() {
	if (this.isGal) { return true; }

	return this.isShared()
		? this.addrbook && this.addrbook.isReadOnly()
		: false;
};

/**
 * Checks if the contact is locked. This is different for DLs than read-only.
 *
 * @return	{Boolean}	<code>true</code> if read-only
 */
ZmContact.prototype.isLocked =
function() {
	if (!this.isDistributionList()) {
		return this.isReadOnly();
	}
	if (!this.dlInfo) {
		return false; //rare case after editing by an owner if the fileAsChanged, the new dl Info still not read, and the layout re-done. So don't show the lock.
	}
	var dlInfo = this.dlInfo;
	if (dlInfo.isOwner) {
		return false;
	}
	if (dlInfo.isMember) {
    	return dlInfo.unsubscriptionPolicy == ZmContactSplitView.SUBSCRIPTION_POLICY_REJECT;
	}
	return dlInfo.subscriptionPolicy == ZmContactSplitView.SUBSCRIPTION_POLICY_REJECT;
};

/**
 * Checks if the contact is a group.
 * 
 * @return	{Boolean}	<code>true</code> if a group
 */
ZmContact.prototype.isGroup =
function() {
	return this.getAttr(ZmContact.F_type) == "group" || this.type == ZmItem.GROUP;
};

/**
 * Checks if the contact is a DL.
 *
 * @return	{Boolean}	<code>true</code> if a group
 */
ZmContact.prototype.isDistributionList =
function() {
	return this.isGal && this.isGroup();
};


// parses "groups" attr into AjxEmailAddress objects stored in 3 vectors (all, good, and bad)
/**
 * Gets the group members.
 *
 * @return	{AjxVector}		the group members or <code>null</code> if not group
 */
ZmContact.prototype.getGroupMembers =
function() {
	var allMembers = this.getAllGroupMembers();
	var addrs = [];
	for (var i = 0; i < allMembers.length; i++) {
		addrs.push(allMembers[i].toString());
	}
	return AjxEmailAddress.parseEmailString(addrs.join(", "));
};	

/**
 * parses "groups" attr into an AjxEmailAddress with a few extra attributes (see ZmContactsHelper._wrapInlineContact)
 * 
 * @return	{AjxVector}		the group members or <code>null</code> if not group
 */
ZmContact.prototype.getAllGroupMembers =
function() {

	if (this.isDistributionList()) {
		return this.dlMembers;
	}

	var addrs = [];

	var groupMembers = this.attr[ZmContact.F_groups];
	if (!groupMembers){
		return AjxEmailAddress.parseEmailString(this.attr[ZmContact.F_email]);  //I doubt this is needed or works correctly, but I keep this logic from before. If we don't have the group members, how can we return the group email instead?
	}
	for (var i = 0; i < groupMembers.length; i++) {
		var member = groupMembers[i];
		var type = member.type;
		var value = member.value;
		if (type == ZmContact.GROUP_INLINE_REF) {
			addrs.push(ZmContactsHelper._wrapInlineContact(value));
		}
		else {
			var contact = ZmContact.getContactFromCache(value);	 //TODO: handle contacts not cached?
			if (!contact) {
				DBG.println(AjxDebug.DBG1, "Disregarding uncached contact: " + value);
				continue;
			}
			var ajxEmailAddress = ZmContactsHelper._wrapContact(contact);
			if (ajxEmailAddress && type === ZmContact.GROUP_CONTACT_REF) {
				ajxEmailAddress.groupRefValue = value; //don't normalize value
			}
			if (ajxEmailAddress) {
				addrs.push(ajxEmailAddress);
			}
		}
	}
	return addrs;
};


ZmContact.prototype.gatherExtraDlStuff =
function(callback) {
	if (this.dlInfo && !this.dlInfo.isMinimal) {
		//already there, skip to next step, loading DL Members
		this.loadDlMembers(callback);
		return;
	}
	var callbackFromGettingInfo = this._handleGetDlInfoResponse.bind(this, callback);
	this.loadDlInfo(callbackFromGettingInfo);
};


ZmContact.prototype._handleGetDlInfoResponse =
function(callback, result) {
	var response = result._data.GetDistributionListResponse;
	var dl = response.dl[0];
	var attrs = dl._attrs;
	var isMember = dl.isMember;
	var isOwner = dl.isOwner;
	var mailPolicySpecificMailers = [];
	this.dlInfo = {	isMember: isMember,
						isOwner: isOwner,
						subscriptionPolicy: attrs.zimbraDistributionListSubscriptionPolicy,
						unsubscriptionPolicy: attrs.zimbraDistributionListUnsubscriptionPolicy,
						description: attrs.description || "",
						displayName: attrs.displayName || "",
						notes: attrs.zimbraNotes || "",
						hideInGal: attrs.zimbraHideInGal == "TRUE",
						mailPolicy: isOwner && this._getMailPolicy(dl, mailPolicySpecificMailers),
						owners: isOwner && this._getOwners(dl)};
	this.dlInfo.mailPolicySpecificMailers = mailPolicySpecificMailers;

	this.loadDlMembers(callback);
};

ZmContact.prototype.loadDlMembers =
function(callback) {
	if ((!appCtxt.get("EXPAND_DL_ENABLED") || this.dlInfo.hideInGal) && !this.dlInfo.isOwner) {
		// can't get members if dl has zimbraHideInGal true, and not owner
		//also, if zimbraFeatureDistributionListExpandMembersEnabled is false - also do not show the members (again unless it's the owner)
		this.dlMembers = [];
		if (callback) {
			callback();
		}
		return;
	}
	if (this.dlMembers) {
		//already there - just callback
		if (callback) {
			callback();
		}
		return;
	}
	var respCallback = this._handleGetDlMembersResponse.bind(this, callback);
	this.getAllDLMembers(respCallback);
};


ZmContact.prototype._handleGetDlMembersResponse =
function(callback, result) {
	var list = result.list;
	if (!list) {
		this.dlMembers = [];
		callback();
		return;
	}
	var members = [];
	for (var i = 0; i < list.length; i++) {
		members.push({type: ZmContact.GROUP_INLINE_REF,
						value: list[i],
						address: list[i]});
	}

	this.dlMembers = members;
	callback();
};

ZmContact.prototype._getOwners =
function(dl) {
	var owners = dl.owners[0].owner;
	var ownersArray = [];
	for (var i = 0; i < owners.length; i++) {
		var owner = owners[i].name;
		ownersArray.push(owner); //just the email address, I think and hope.
	}
	return ownersArray;
};

ZmContact.prototype._getMailPolicy =
function(dl, specificMailers) {
	var mailPolicy;

	var rights = dl.rights[0].right;
	var right = rights[0];
	var grantees = right.grantee;
	if (!grantees) {
		return ZmGroupView.MAIL_POLICY_ANYONE;
	}
	for (var i = 0; i < grantees.length; i++) {
		var grantee = grantees[i];

		mailPolicy = ZmGroupView.GRANTEE_TYPE_TO_MAIL_POLICY_MAP[grantee.type];

		if (mailPolicy == ZmGroupView.MAIL_POLICY_SPECIFIC) {
			specificMailers.push(grantee.name);
		}
		else if (mailPolicy == ZmGroupView.MAIL_POLICY_ANYONE) {
			break;
		}
		else if (mailPolicy == ZmGroupView.MAIL_POLICY_INTERNAL) {
			break;
		}
		else if (mailPolicy == ZmGroupView.MAIL_POLICY_MEMBERS) {
			if (grantee.name == this.getEmail()) {
				//this means only members of this DL can send.
				break;
			}
			else {
				//must be another DL, and we do allow it, so treat it as regular user.
				specificMailers.push(grantee.name);
				mailPolicy = ZmGroupView.MAIL_POLICY_SPECIFIC;
			}
		}
	}
	mailPolicy = mailPolicy || ZmGroupView.MAIL_POLICY_ANYONE;

	return mailPolicy;
};


ZmContact.prototype.loadDlInfo =
function(callback) {
	var soapDoc = AjxSoapDoc.create("GetDistributionListRequest", "urn:zimbraAccount", null);
	soapDoc.setMethodAttribute("needOwners", "1");
	soapDoc.setMethodAttribute("needRights", "sendToDistList");
	var elBy = soapDoc.set("dl", this.getEmail());
	elBy.setAttribute("by", "name");

	appCtxt.getAppController().sendRequest({soapDoc: soapDoc, asyncMode: true, callback: callback});
};

ZmContact.prototype.toggleSubscription =
function(callback) {
	var soapDoc = AjxSoapDoc.create("SubscribeDistributionListRequest", "urn:zimbraAccount", null);
	soapDoc.setMethodAttribute("op", this.dlInfo.isMember ? "unsubscribe" : "subscribe");
	var elBy = soapDoc.set("dl", this.getEmail());
	elBy.setAttribute("by", "name");
	appCtxt.getAppController().sendRequest({soapDoc: soapDoc, asyncMode: true, callback: callback});
};



/**
 *  Returns the contact id.  If includeUserZid is true it will return the format zid:id
 * @param includeUserZid {boolean} true to include the zid prefix for the contact id
 * @return {String} contact id string
 */
ZmContact.prototype.getId = 
function(includeUserZid) {

	if (includeUserZid) {
		return this.isShared() ? this.id : appCtxt.accountList.mainAccount.id + ":" + this.id; 
	}
	
	return this.id;
};
/**
 * Gets the icon.
 * @param 	{ZmAddrBook} addrBook	address book of contact 
 * @return	{String}	the icon
 */
ZmContact.prototype.getIcon =
function(addrBook) {
	if (this.isDistributionList()) 						{ return "DistributionList"; }
	if (this.isGal)										{ return "GALContact"; }
	if (this.isShared() || (addrBook && addrBook.link))	{ return "SharedContact"; }
	if (this.isGroup())									{ return "Group"; }
	return "Contact";
};

ZmContact.prototype.getIconLarge =
function() {
	if (this.isDistributionList()) {
		return "Group_48";
	}
	//todo - get a big version of ImgGalContact.png
//	if (this.isGal) {
//	}
	return "Person_48";
};

/**
 * Gets the folder id.
 * 
 * @return	{String}		the folder id	
 */
ZmContact.prototype.getFolderId =
function() {
	return this.isShared()
		? this.folderId.split(":")[0]
		: this.folderId;
};

/**
 * Gets the attribute.
 * 
 * @param	{String}	name		the attribute name
 * @return	{String}	the value
 */
ZmContact.prototype.getAttr =
function(name) {
	var val = this.attr[name];
	return val ? ((val instanceof Array) ? val[0] : val) : "";
};

/**
 * Sets the attribute.
 * 
 * @param	{String}	name		the attribute name
 * @param	{String}	value		the attribute value
 */
ZmContact.prototype.setAttr =
function(name, value) {
	this.attr[name] = value;
};

/**
 * Sets the participant status.
 *
 * @param	{String}	value the participant status value
 */
ZmContact.prototype.setParticipantStatus =
function(ptst) {
	this.participantStatus = ptst;
};

/**
 * gets the participant status.
 *
 * @return	{String}    the value
 */
ZmContact.prototype.getParticipantStatus =
function() {
	return this.participantStatus;
};

/**
 * Sets the participant role.
 *
 * @param	{String}	value the participant role value
 */
ZmContact.prototype.setParticipantRole =
function(role) {
	this.participantRole = role;
};

/**
 * gets the participant role.
 *
 * @return	{String}    the value
 */
ZmContact.prototype.getParticipantRole =
function() {
	return this.participantRole;
};

/**
 * Removes the attribute.
 * 
 * @param	{String}	name		the attribute name
 */
ZmContact.prototype.removeAttr =
function(name) {
	delete this.attr[name];
};

/**
 * Gets the contact attributes.
 *
 * @param {String}	[prefix] if specified, only the the attributes that match the given prefix will be returned
 * @return	{Hash}	a hash of attribute/value pairs
 */
ZmContact.prototype.getAttrs = function(prefix) {
	var attrs = this.attr;
	if (prefix) {
		attrs = {};
		for (var aname in this.attr) {
			var namePrefix = ZmContact.getPrefix(aname);
			if (namePrefix === prefix) {
				attrs[aname] = this.attr[aname];
			}
		}
	}
	return attrs;
};

/**
 * Gets a normalized set of attributes where the attribute
 * names have been re-numbered as needed. For example, if the
 * attributes contains a "foo2" but no "foo", then the "foo2"
 * attribute will be renamed to "foo" in the returned object.
 * <p>
 * <strong>Note:</strong>
 * This method is expensive so should be called once and
 * cached temporarily as needed instead of being called
 * for each normalized attribute that is needed.
 * 
 * @param {String}	[prefix]		if specified, only the
 *                        the attributes that match the given
 *                        prefix will be returned.
 * @return	{Hash}	a hash of attribute/value pairs
 */
ZmContact.prototype.getNormalizedAttrs = function(prefix) {
	return ZmContact.getNormalizedAttrs(this.attr, prefix, ZmContact.IGNORE_NORMALIZATION);
};

/**
* Creates a contact from the given set of attributes. Used to create contacts on
* the fly (rather than by loading them). This method is called by a list's <code>create()</code>
* method.
* <p>
* If this is a GAL contact, we assume it is being added to the contact list.</p>
*
* @param {Hash}	attr			the attribute/value pairs for this contact
* @param {ZmBatchCommand}	batchCmd	the batch command that contains this request
* @param {boolean} isAutoCreate true if this is a auto create and toast message should not be shown
*/
ZmContact.prototype.create =
function(attr, batchCmd, isAutoCreate) {

	if (this.isDistributionList()) {
		this._createDl(attr);
		return;
	}

	var jsonObj = {CreateContactRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.CreateContactRequest;
	var cn = request.cn = {};

	var folderId = attr[ZmContact.F_folderId] || ZmFolder.ID_CONTACTS;
	var folder = appCtxt.getById(folderId);
	if (folder && folder.isRemote()) {
		folderId = folder.getRemoteId();
	}
	cn.l = folderId;
	cn.a = [];
	cn.m = [];

	for (var name in attr) {
		if (name == ZmContact.F_folderId ||
			name == "objectClass" ||
			name == "zimbraId" ||
			name == "createTimeStamp" ||
			name == "modifyTimeStamp") { continue; }

		if (name == ZmContact.F_groups) {
			this._addContactGroupAttr(cn, attr);
		}
		else {
			this._addRequestAttr(cn, name, attr[name]);
		}
	}

	this._addRequestAttr(cn, ZmContact.X_fullName, ZmContact.computeFileAs(attr));

	var respCallback = new AjxCallback(this, this._handleResponseCreate, [attr, batchCmd != null, isAutoCreate]);

	if (batchCmd) {
		batchCmd.addRequestParams(jsonObj, respCallback);
	} else {
		appCtxt.getAppController().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
	}
};

/**
 * @private
 */
ZmContact.prototype._handleResponseCreate =
function(attr, isBatchMode, isAutoCreate, result) {
	// dont bother processing creates when in batch mode (just let create
	// notifications handle them)
	if (isBatchMode) { return; }

	var resp = result.getResponse().CreateContactResponse;
	cn = resp ? resp.cn[0] : null;
	var id = cn ? cn.id : null;
	if (id) {
		this._fileAs = null;
		this._fullName = null;
		this.id = id;
		this.modified = cn.md;
		this.folderId = cn.l || ZmOrganizer.ID_ADDRBOOK;
		for (var a in attr) {
			if (!(attr[a] == undefined || attr[a] == ''))
				this.setAttr(a, attr[a]);
		}
		var groupMembers = cn ? cn.m : null;
		if (groupMembers) {
			this.attr[ZmContact.F_groups] = groupMembers;
			cn._attrs[ZmContact.F_groups] = groupMembers;
		}
		if (!isAutoCreate) {
			var msg = this.isGroup() ? ZmMsg.groupCreated : ZmMsg.contactCreated;
			appCtxt.getAppController().setStatusMsg(msg);
		}
		//update the canonical list. (this includes adding to the _idHash like before (bug 44132) calling updateIdHash. But calling that left the list inconcistant.
		appCtxt.getApp(ZmApp.CONTACTS).getContactList().add(cn);
	} else {
		var msg = this.isGroup() ? ZmMsg.errorCreateGroup : ZmMsg.errorCreateContact;
		var detail = ZmMsg.errorTryAgain + "\n" + ZmMsg.errorContact;
		appCtxt.getAppController().setStatusMsg(msg, ZmStatusView.LEVEL_CRITICAL, detail);
	}
};

/**
 * Creates a contct from a VCF part of a message.
 * 
 * @param	{String}	msgId		the message
 * @param	{String}	vcardPartId	the vcard part id
 */
ZmContact.prototype.createFromVCard =
function(msgId, vcardPartId) {
	var jsonObj = {CreateContactRequest:{_jsns:"urn:zimbraMail"}};
	var cn = jsonObj.CreateContactRequest.cn = {l:ZmFolder.ID_CONTACTS};
	cn.vcard = {mid:msgId, part:vcardPartId};

	var params = {
		jsonObj: jsonObj,
		asyncMode: true,
		callback: (new AjxCallback(this, this._handleResponseCreateVCard)),
		errorCallback: (new AjxCallback(this, this._handleErrorCreateVCard))
	};

	appCtxt.getAppController().sendRequest(params);
};

/**
 * @private
 */
ZmContact.prototype._handleResponseCreateVCard =
function(result) {
	appCtxt.getAppController().setStatusMsg(ZmMsg.contactCreated);
};

/**
 * @private
 */
ZmContact.prototype._handleErrorCreateVCard =
function(ex) {
	appCtxt.getAppController().setStatusMsg(ZmMsg.errorCreateContact, ZmStatusView.LEVEL_CRITICAL);
};

/**
 * Updates contact attributes.
 *
 * @param {Hash}	attr		a set of attributes and new values
 * @param {AjxCallback}	callback	the callback
 * @param {boolean} isAutoSave  true if it is a auto save and toast should not be displayed.
 */
ZmContact.prototype.modify =
function(attr, callback, isAutoSave, batchCmd) {
	if (this.isDistributionList()) {
		this._modifyDl(attr);
		return;
	}
	if (this.list.isGal) { return; }

	// change force to 0 and put up dialog if we get a MODIFY_CONFLICT fault?
	var jsonObj = {ModifyContactRequest:{_jsns:"urn:zimbraMail", replace:"0", force:"1"}};
	var cn = jsonObj.ModifyContactRequest.cn = {id:this.id};
	cn.a = [];
	cn.m = [];
	var continueRequest = false;
	
	for (var name in attr) {
		if (name == ZmContact.F_folderId) { continue; }
		if (name == ZmContact.F_groups) {
			this._addContactGroupAttr(cn, attr);	
		}
		else {
			this._addRequestAttr(cn, name, (attr[name] && attr[name].value) || attr[name]);
		}
		continueRequest = true;
	}

    // bug: 45026
    if (ZmContact.F_firstName in attr || ZmContact.F_lastName in attr || ZmContact.F_company in attr || ZmContact.X_fileAs in attr) {
        var contact = {};
        var fields = [ZmContact.F_firstName, ZmContact.F_lastName, ZmContact.F_company, ZmContact.X_fileAs];
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var value = attr[field];
            contact[field] = value != null ? value : this.getAttr(field);
        }
        var fullName = ZmContact.computeFileAs(contact); 
        this._addRequestAttr(cn, ZmContact.X_fullName, fullName);
    }

	if (continueRequest) {
		if (batchCmd) {
			batchCmd.addRequestParams(jsonObj, null, null); //no need for response callback for current use-case (batch modifying zimlet image)
		}
		else {
			var respCallback = this._handleResponseModify.bind(this, attr, callback, isAutoSave);
			appCtxt.getAppController().sendRequest({jsonObj: jsonObj, asyncMode: true, callback: respCallback});
		}

	} else {
		if (attr[ZmContact.F_folderId]) {
			this._setFolder(attr[ZmContact.F_folderId]);
		}
	}
};

ZmContact.prototype._createDl =
function(attr) {

	this.attr = attr; //this is mainly important for the email. attr is not set before this.

	var createDlReq = this._getCreateDlReq(attr);

	var reqs = [];

	this._addMemberModsReqs(reqs, attr);

	this._addMailPolicyAndOwnersReqs(reqs, attr);

	var jsonObj = {
		BatchRequest: {
			_jsns: "urn:zimbra",
			CreateDistributionListRequest: createDlReq,
			DistributionListActionRequest: reqs
		}
	};
	var respCallback = this._createDlResponseHandler.bind(this);
	appCtxt.getAppController().sendRequest({jsonObj: jsonObj, asyncMode: true, callback: respCallback});
	
};

ZmContact.prototype._addMailPolicyAndOwnersReqs =
function(reqs, attr) {

	var mailPolicy = attr[ZmContact.F_dlMailPolicy];
	if (mailPolicy) {
		reqs.push(this._getSetMailPolicyReq(mailPolicy, attr[ZmContact.F_dlMailPolicySpecificMailers]));
	}

	var listOwners = attr[ZmContact.F_dlListOwners];
	if (listOwners) {
		reqs.push(this._getSetOwnersReq(listOwners));
	}


};



ZmContact.prototype._addMemberModsReqs =
function(reqs, attr) {
	var memberModifications = attr[ZmContact.F_groups];
	var adds = [];
	var removes = [];
	if (memberModifications) {
		for (var i = 0; i < memberModifications.length; i++) {
			var mod = memberModifications[i];
			var col = (mod.op == "+" ? adds : removes);
			col.push(mod);
		}
	}

	if (adds.length > 0) {
		reqs.push(this._getAddOrRemoveReq(adds, true));
	}
	if (removes.length > 0) {
		reqs.push(this._getAddOrRemoveReq(removes, false));
	}
};

ZmContact.prototype._modifyDl =
function(attr) {
	var reqs = [];

	var newEmail = attr[ZmContact.F_email];

	var emailChanged = false;
	if (newEmail !== undefined) {
		emailChanged = true;
		reqs.push(this._getRenameDlReq(newEmail));
		this.setAttr(ZmContact.F_email, newEmail);
	}

	var modDlReq = this._getModifyDlAttributesReq(attr);
	if (modDlReq) {
		reqs.push(modDlReq);
	}

	var displayName = attr[ZmContact.F_dlDisplayName];
	if (displayName !== undefined) {
		this.setAttr(ZmContact.F_dlDisplayName, displayName);
	}

	var oldFileAs = this.getFileAs();
	this._resetCachedFields();
	var fileAsChanged = oldFileAs != this.getFileAs();

	this._addMemberModsReqs(reqs, attr);

	this._addMailPolicyAndOwnersReqs(reqs, attr);

	if (reqs.length == 0) {
		this._modifyDlResponseHandler(false, null); //pretend it was saved
		return;
	}
	var jsonObj = {
		BatchRequest: {
			_jsns: "urn:zimbra",
			DistributionListActionRequest: reqs
		}
	};
	var respCallback = this._modifyDlResponseHandler.bind(this, fileAsChanged || emailChanged); //there's some issue with fileAsChanged so adding the emailChanged to be on safe side
	appCtxt.getAppController().sendRequest({jsonObj: jsonObj, asyncMode: true, callback: respCallback});

};

ZmContact.prototype._getAddOrRemoveReq =
function(members, add) {
	var req = {
		_jsns: "urn:zimbraAccount",
		dl: {by: "name",
			 _content: this.getEmail()
		},
		action: {
			op: add ? "addMembers" : "removeMembers",
			dlm: []
		}
	};
	for (var i = 0; i < members.length; i++) {
		var member = members[i];
		req.action.dlm.push({_content: member.email});
	}
	return req;

};


ZmContact.prototype._getRenameDlReq =
function(name) {
	return {
		_jsns: "urn:zimbraAccount",
		dl: {by: "name",
			 _content: this.getEmail()
		},
		action: {
			op: "rename",
			newName: {_content: name}
		}
	};
};

ZmContact.prototype._getSetOwnersReq =
function(owners) {
	var ownersPart = [];
	for (var i = 0; i < owners.length; i++) {
		ownersPart.push({
			type: ZmGroupView.GRANTEE_TYPE_USER,
			by: "name",
			_content: owners[i]
		});
	}
	return {
		_jsns: "urn:zimbraAccount",
		dl: {by: "name",
			 _content: this.getEmail()
		},
		action: {
			op: "setOwners",
			owner: ownersPart
		}
	};
};

ZmContact.prototype._getSetMailPolicyReq =
function(mailPolicy, specificMailers) {
	var grantees = [];
	if (mailPolicy == ZmGroupView.MAIL_POLICY_SPECIFIC) {
		for (var i = 0; i < specificMailers.length; i++) {
			grantees.push({
				type: ZmGroupView.GRANTEE_TYPE_EMAIL,
				by: "name",
				_content: specificMailers[i]
			});
		}
	}
	else if (mailPolicy == ZmGroupView.MAIL_POLICY_ANYONE) {
		grantees.push({
			type: ZmGroupView.GRANTEE_TYPE_PUBLIC
		});
	}
	else if (mailPolicy == ZmGroupView.MAIL_POLICY_INTERNAL) {
		grantees.push({
			type: ZmGroupView.GRANTEE_TYPE_ALL
		});
	}
	else if (mailPolicy == ZmGroupView.MAIL_POLICY_MEMBERS) {
		grantees.push({
			type: ZmGroupView.GRANTEE_TYPE_GROUP,
			by: "name",
			_content: this.getEmail()
		});
	}
	else {
		throw "invalid mailPolicy value " + mailPolicy;
	}

	return {
		_jsns: "urn:zimbraAccount",
		dl: {by: "name",
			 _content: this.getEmail()
		},
		action: {
			op: "setRights",
			right: {
				right: "sendToDistList",
				grantee: grantees
			}
		}
	};

};

ZmContact.prototype._addDlAttribute =
function(attrs, mods, name, soapAttrName) {
	var attr = mods[name];
	if (attr === undefined) {
		return;
	}
	attrs.push({n: soapAttrName, _content: attr});
};

ZmContact.prototype._getDlAttributes =
function(mods) {
	var attrs = [];
	this._addDlAttribute(attrs, mods, ZmContact.F_dlDisplayName, "displayName");
	this._addDlAttribute(attrs, mods, ZmContact.F_dlDesc, "description");
	this._addDlAttribute(attrs, mods, ZmContact.F_dlNotes, "zimbraNotes");
	this._addDlAttribute(attrs, mods, ZmContact.F_dlHideInGal, "zimbraHideInGal");
	this._addDlAttribute(attrs, mods, ZmContact.F_dlSubscriptionPolicy, "zimbraDistributionListSubscriptionPolicy");
	this._addDlAttribute(attrs, mods, ZmContact.F_dlUnsubscriptionPolicy, "zimbraDistributionListUnsubscriptionPolicy");

	return attrs;
};


ZmContact.prototype._getCreateDlReq =
function(attr) {
	return {
		_jsns: "urn:zimbraAccount",
		name: attr[ZmContact.F_email],
		a: this._getDlAttributes(attr),
		dynamic: false
	};
};

ZmContact.prototype._getModifyDlAttributesReq =
function(attr) {
	var modAttrs = this._getDlAttributes(attr);
	if (modAttrs.length == 0) {
		return null;
	}
	return {
		_jsns: "urn:zimbraAccount",
		dl: {by: "name",
			 _content: this.getEmail()
		},
		action: {
			op: "modify",
			a: modAttrs
		}
	};
};

ZmContact.prototype._modifyDlResponseHandler =
function(fileAsChanged, result) {
	if (this._handleErrorDl(result)) {
		return;
	}
	appCtxt.setStatusMsg(ZmMsg.dlSaved);

	//for DLs we reload from the server since the server does not send notifications.
	this.clearDlInfo();

	var details = {
		fileAsChanged: fileAsChanged
	};

	this._popView(fileAsChanged);

	this._notify(ZmEvent.E_MODIFY, details);
};

ZmContact.prototype._createDlResponseHandler =
function(result) {
	if (this._handleErrorDl(result, true)) {
		this.attr = {}; //since above in _createDl, we set it to new values prematurely. which would affect next gathering of modified attributes.
		return;
	}
	appCtxt.setStatusMsg(ZmMsg.distributionListCreated);

	this._popView(true);
};

ZmContact.prototype._popView =
function(updateDlList) {
	var controller = AjxDispatcher.run("GetContactController");
	controller.popView(true);
	if (!updateDlList) {
		return;
	}
	var clc = AjxDispatcher.run("GetContactListController");
	if (clc.getFolderId() != ZmFolder.ID_DLS) {
		return;
	}
	ZmAddrBookTreeController.dlFolderClicked(); //This is important in case of new DL created OR a renamed DL, so it would reflect in the list.
};

ZmContact.prototype._handleErrorDl =
function(result, creation) {
	if (!result) {
		return false;
	}
	var batchResp = result.getResponse().BatchResponse;
	var faults = batchResp.Fault;
	if (!faults) {
		return false;
	}
	var ex = ZmCsfeCommand.faultToEx(faults[0]);
	var controller = AjxDispatcher.run("GetContactController");
	controller.popupErrorDialog(creation ? ZmMsg.dlCreateFailed : ZmMsg.dlModifyFailed, ex);
	return true;

};

ZmContact.prototype.clearDlInfo =
function () {
	this.dlMembers = null;
	this.dlInfo = null;
	var app = appCtxt.getApp(ZmApp.CONTACTS);
	app.cacheDL(this.getEmail(), null); //clear the cache for this DL.
	appCtxt.cacheRemove(this.getId()); //also some other cache.
};

/**
 * @private
 */
ZmContact.prototype._handleResponseModify =
function(attr, callback, isAutoSave, result) {
	var resp = result.getResponse().ModifyContactResponse;
	var cn = resp ? resp.cn[0] : null;
	var id = cn ? cn.id : null;
	var groupMembers = cn ? cn.m : null;
	if (groupMembers) {
		this.attr[ZmContact.F_groups] = groupMembers;
		cn._attrs[ZmContact.F_groups] = groupMembers;	
	}

	if (id && id == this.id) {
		if (!isAutoSave) {
			appCtxt.setStatusMsg(this.isGroup() ? ZmMsg.groupSaved : ZmMsg.contactSaved);
		}
		// was this contact moved to another folder?
		if (attr[ZmContact.F_folderId] && this.folderId != attr[ZmContact.F_folderId]) {
			this._setFolder(attr[ZmContact.F_folderId]);
		}
		appCtxt.getApp(ZmApp.CONTACTS).updateIdHash(cn, false);
	} else {
        var detail = ZmMsg.errorTryAgain + "\n" + ZmMsg.errorContact;
        appCtxt.getAppController().setStatusMsg(ZmMsg.errorModifyContact, ZmStatusView.LEVEL_CRITICAL, detail);
	}
	// NOTE: we no longer process callbacks here since notification handling
	//       takes care of everything
};

/**
 * @private
 */
ZmContact.prototype._handleResponseMove =
function(newFolderId, resp) {
	var newFolder = newFolderId && appCtxt.getById(newFolderId);
	var count = 1;
	if (newFolder) {
		appCtxt.setStatusMsg(ZmList.getActionSummary({
			actionTextKey:  'actionMove',
			numItems:       count,
			type:           ZmItem.CONTACT,
			actionArg:      newFolder.name
		}));
	}

	this._notify(ZmEvent.E_MODIFY, resp);
};

/**
 * @private
 */
ZmContact.prototype._setFolder =
function(newFolderId) {
	var folder = appCtxt.getById(this.folderId);
	var fId = folder ? folder.nId : null;
	if (fId == newFolderId) { return; }

	// moving out of a share or into one is handled differently (create then hard delete)
	var newFolder = appCtxt.getById(newFolderId);
	if (this.isShared() || (newFolder && newFolder.link)) {
		if (this.list) {
			this.list.moveItems({items:[this], folder:newFolder});
		}
	} else {
		var jsonObj = {ContactActionRequest:{_jsns:"urn:zimbraMail"}};
		jsonObj.ContactActionRequest.action = {id:this.id, op:"move", l:newFolderId};
		var respCallback = new AjxCallback(this, this._handleResponseMove, [newFolderId]);
		var accountName = appCtxt.multiAccounts && appCtxt.accountList.mainAccount.name;
		appCtxt.getAppController().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback, accountName:accountName});
	}
};

/**
 * @private
 */
ZmContact.prototype.notifyModify =
function(obj, batchMode) {

	var result = ZmItem.prototype.notifyModify.apply(this, arguments);

	var context = window.parentAppCtxt || window.appCtxt;
	context.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);

	if (result) {
		return result;
	}

	// cache old fileAs/fullName before resetting them
	var oldFileAs = this.getFileAs();
	var oldFullName = this.getFullName();
	this._resetCachedFields();

	var oldAttrCache = {};
	if (obj._attrs) {
		// remove attrs that were not returned back from the server
		var oldAttrs = this.getAttrs();
		for (var a in oldAttrs) {
			oldAttrCache[a] = oldAttrs[a];
			if (obj._attrs[a] == null)
				this.removeAttr(a);
		}

		// set attrs returned by server
		for (var a in obj._attrs) {
			this.setAttr(a, obj._attrs[a]);
		}
		if (obj.m) {
			this.setAttr(ZmContact.F_groups, obj.m);
		}
	}

	var details = {
		attr: obj._attrs,
		oldAttr: oldAttrCache,
		fullNameChanged: (this.getFullName() != oldFullName),
		fileAsChanged: (this.getFileAs() != oldFileAs),
		contact: this
	};

	// update this contact's list per old/new attrs
	for (var listId in this._list) {
		var list = listId && appCtxt.getById(listId);
		if (!list) { continue; }
		list.modifyLocal(obj, details);
	}

	this._notify(ZmEvent.E_MODIFY, obj);
};

/**
 * @private
 */
ZmContact.prototype.notifyDelete =
function() {
	ZmItem.prototype.notifyDelete.call(this);
	var context = window.parentAppCtxt || window.appCtxt;
	context.clearAutocompleteCache(ZmAutocomplete.AC_TYPE_CONTACT);
};

/**
 * Initializes this contact using an email address.
 *
 * @param {AjxEmailAddress|String}	email		an email address or an email string
 * @param {Boolean}	strictName	if <code>true</code>, do not try to set name from user portion of address
 */
ZmContact.prototype.initFromEmail =
function(email, strictName) {
	if (email instanceof AjxEmailAddress) {
		this.setAttr(ZmContact.F_email, email.getAddress());
		this._initFullName(email, strictName);
	} else {
		this.setAttr(ZmContact.F_email, email);
	}
};

/**
 * Initializes this contact using a phone number.
 *
 * @param {String}	phone		the phone string
 * @param {String}	field		the field or company phone if <code>null</code>
 */
ZmContact.prototype.initFromPhone =
function(phone, field) {
	this.setAttr(field || ZmContact.F_companyPhone, phone);
};

/**
 * Gets the email address.
 * 
 * @param {boolean}		asObj	if true, return an AjxEmailAddress
 * 
 * @return	the email address
 */
ZmContact.prototype.getEmail =
function(asObj) {

	var email = (this.getAttr(ZmContact.F_email) ||
				 this.getAttr(ZmContact.F_workEmail1) ||
				 this.getAttr(ZmContact.F_email2) ||
				 this.getAttr(ZmContact.F_workEmail2) ||
				 this.getAttr(ZmContact.F_email3) ||
				 this.getAttr(ZmContact.F_workEmail3));
	
	if (asObj) {
		email = AjxEmailAddress.parse(email);
        if(email){
		    email.isGroup = this.isGroup();
		    email.canExpand = this.canExpand;
        }
	}
	
	return email;
};

/**
 * Returns user's phone number
 * @return {String} phone number
 */
ZmContact.prototype.getPhone = 
function() {
	var phone = (this.getAttr(ZmContact.F_mobilePhone) ||
				this.getAttr(ZmContact.F_workPhone) || 
				this.getAttr(ZmContact.F_homePhone) ||
				this.getAttr(ZmContact.F_otherPhone));
	return phone;
};

    
/**
 * Gets the lookup email address, when an contact object is located using email address we store
 * the referred email address in this variable for easy lookup
 *
 * @param {boolean}		asObj	if true, return an AjxEmailAddress
 *
 * @return	the lookup address
 */
ZmContact.prototype.getLookupEmail =
function(asObj) {
    var email = this._lookupEmail;

    if (asObj && email) {
        email = AjxEmailAddress.parse(email);
        email.isGroup = this.isGroup();
        email.canExpand = this.canExpand;
    }

	return  email;
};

/**
 * Gets the emails.
 * 
 * @return	{Array}	 an array of all valid emails for this contact
 */
ZmContact.prototype.getEmails =
function() {
	var emails = [];
	var attrs = this.getAttrs();
	for (var index = 0; index < ZmContact.EMAIL_FIELDS.length; index++) {
		var field = ZmContact.EMAIL_FIELDS[index];
		for (var i = 1; true; i++) {
			var aname = ZmContact.getAttributeName(field, i);
			if (!attrs[aname]) break;
			emails.push(attrs[aname]);
		}
	}
	return emails;
};

/**
 * Gets the full name.
 * 
 * @return	{String}	the full name
 */
ZmContact.prototype.getFullName =
function(html) {
    var fullNameHtml = null;
	if (!this._fullName || html) {
		var fullName = this.getAttr(ZmContact.X_fullName); // present if GAL contact
		if (fullName) {
			this._fullName = (fullName instanceof Array) ? fullName[0] : fullName;
		}
        else {
            this._fullName = this.getFullNameForDisplay(false);
        }

        if (html) {
            fullNameHtml = this.getFullNameForDisplay(html);
        }
	}

	// as a last resort, set it to fileAs
	if (!this._fullName) {
		this._fullName = this.getFileAs();
	}

	return fullNameHtml || this._fullName;
};

/*
* Gets the fullname for display -- includes (if applicable): prefix, first, middle, maiden, last, suffix
*
* @param {boolean}  if phonetic fields should be used
* @return {String}  the fullname for display
*/
ZmContact.prototype.getFullNameForDisplay =
function(html){
	if (this.isDistributionList()) {
		//I'm not sure where that fullName is set sometime to the display name. This is so complicated
		// I'm trying to set attr[ZmContact.F_dlDisplayName] to the display name but in soem cases it's not.
		return this.getAttr(ZmContact.F_dlDisplayName) || this.getAttr("fullName");
	}
    var prefix = this.getAttr(ZmContact.F_namePrefix);
    var first = this.getAttr(ZmContact.F_firstName);
    var middle = this.getAttr(ZmContact.F_middleName);
    var maiden = this.getAttr(ZmContact.F_maidenName);
    var last = this.getAttr(ZmContact.F_lastName);
    var suffix = this.getAttr(ZmContact.F_nameSuffix);
    var pattern = ZmMsg.fullname;
    if (suffix) {
        pattern = maiden ? ZmMsg.fullnameMaidenSuffix : ZmMsg.fullnameSuffix;
    }
    else if (maiden) {
        pattern = ZmMsg.fullnameMaiden;
    }
    if (appCtxt.get(ZmSetting.LOCALE_NAME) === "ja") {
        var fileAsId = this.getAttr(ZmContact.F_fileAs);
        if (!AjxUtil.isEmpty(fileAsId) && fileAsId !== "1" && fileAsId !== "4" && fileAsId !== "6") {
            /* When Japanese locale is selected, in the most every case, the name should be
             * displayed as "Last First" which is set by the default pattern (ZmMsg_ja.fullname).
             * But if the contact entry's fileAs field explicitly specifies the display
             * format as "First Last", we should override the pattern to lay it out so.
             * For other locales, it is not necessary to override the pattern: The default pattern is
             * already set as "First Last", and even the FileAs specifies as "Last, First", the display
             * name is always expected to be displayed as "First Last".
             */
            pattern = "{0} {1} {2} {4}";
        }
    }
    var formatter = new AjxMessageFormat(pattern);
    var args = [prefix,first,middle,maiden,last,suffix];
    if (!html){
        return AjxStringUtil.trim(formatter.format(args), true);
    }

    return this._getFullNameHtml(formatter, args);
};

/**
 * @param formatter
 * @param parts {Array} Name parts: [prefix,first,middle,maiden,last,suffix]
 */
ZmContact.prototype._getFullNameHtml = function(formatter, parts) {
    var a = [];
    var segments = formatter.getSegments();
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment instanceof AjxFormat.TextSegment) {
            a.push(segment.format());
            continue;
        }
        // NOTE: Assume that it's a AjxMessageFormat.MessageSegment
        // NOTE: if not a AjxFormat.TextSegment.
        var index = segment.getIndex();
        var base = parts[index];
        var text = ZmContact.__RUBY_FIELDS[index] && this.getAttr(ZmContact.__RUBY_FIELDS[index]);
        a.push(AjxStringUtil.htmlRubyEncode(base, text));
    }
    return a.join("");
};
ZmContact.__RUBY_FIELDS = [
    null, ZmContact.F_phoneticFirstName, null, null,
    ZmContact.F_phoneticLastName, null
];

/**
 * Gets the tool tip for this contact.
 * 
 * @param	{String}	email		the email address
 * @param	{Boolean}	isGal		(not used)
 * @param	{String}	hint		the hint text
 * @return	{String}	the tool tip in HTML
 */
ZmContact.prototype.getToolTip =
function(email, isGal, hint) {
	// XXX: we dont cache tooltip info anymore since its too dynamic :/
	// i.e. IM status can change anytime so always rebuild tooltip and bug 13834
	var subs = {
		contact: this,
		entryTitle: this.getFileAs(),
		hint: hint
	};

	return (AjxTemplate.expand("abook.Contacts#Tooltip", subs));
};

/**
 * Gets the filing string for this contact, computing it if necessary.
 * 
 * @param	{Boolean}	lower		<code>true</code> to use lower case
 * @return	{String}	the file as string
 */
ZmContact.prototype.getFileAs =
function(lower) {
	// update/null if modified
	if (!this._fileAs) {
		this._fileAs = ZmContact.computeFileAs(this);
		this._fileAsLC = this._fileAs ? this._fileAs.toLowerCase() : null;
	}
	// if for some reason fileAsLC is not set even though fileAs is, reset it
	if (lower && !this._fileAsLC) {
		this._fileAsLC = this._fileAs.toLowerCase();
	}
	return lower ? this._fileAsLC : this._fileAs;
};

/**
 * Gets the filing string for this contact, from the email address (used in case no name exists).
 * todo - maybe return this from getFileAs, but there are a lot of callers to getFileAs, and not sure
 * of the implications on all the use-cases.
 *
 * @return	{String}	the file as string
 */
ZmContact.prototype.getFileAsNoName = function() {
	return [ZmMsg.noName, this.getEmail()].join(" ");
};

/**
 * Gets the header.
 * 
 * @return	{String}	the header
 */
ZmContact.prototype.getHeader =
function() {
	return this.id ? this.getFileAs() : ZmMsg.newContact;
};

ZmContact.NO_MAX_IMAGE_WIDTH = ZmContact.NO_MAX_IMAGE_HEIGHT = - 1;

/**
 * Get the image URL.
 *
 * Please note that maxWidth and maxHeight are hints, as they have no
 * effect on Zimlet-supplied images.
 *
 * maxWidth {int} max pixel width (optional - default 48, or pass ZmContact.NO_MAX_IMAGE_WIDTH if full size image is required)
 * maxHeight {int} max pixel height (optional - default to maxWidth, or pass ZmContact.NO_MAX_IMAGE_HEIGHT if full size image is required)
 * @return	{String}	the image URL
 */
ZmContact.prototype.getImageUrl =
function(maxWidth, maxHeight) {
  	var image = this.getAttr(ZmContact.F_image);
	var imagePart  = image && image.part || this.getAttr(ZmContact.F_imagepart); //see bug 73146

	if (!imagePart) {
		return this.getAttr(ZmContact.F_zimletImage);  //return zimlet populated image only if user-uploaded image is not there.
	}
  	var msgFetchUrl = appCtxt.get(ZmSetting.CSFE_MSG_FETCHER_URI);
	var maxWidthStyle = "";
	if (maxWidth !== ZmContact.NO_MAX_IMAGE_WIDTH) {
		maxWidth = maxWidth || 48;
		maxWidthStyle = ["&max_width=", maxWidth].join("");
	}
	var maxHeightStyle = "";
	if (maxHeight !== ZmContact.NO_MAX_IMAGE_HEIGHT) {
		maxHeight = maxHeight ||
			(maxWidth !== ZmContact.NO_MAX_IMAGE_WIDTH ? maxWidth : 48);
		maxHeightStyle = ["&max_height=", maxHeight].join("");
	}
  	return  [msgFetchUrl, "&id=", this.id, "&part=", imagePart, maxWidthStyle, maxHeightStyle, "&t=", (new Date()).getTime()].join("");
};

ZmContact.prototype.addModifyZimletImageToBatch =
function(batchCmd, image) {
	var attr = {};
	if (this.getAttr(ZmContact.F_zimletImage) === image) {
		return; //no need to update if same
	}
	attr[ZmContact.F_zimletImage] = image;
	batchCmd.add(this.modify.bind(this, attr, null, true));
};

/**
 * Gets the company field. Company field has a getter b/c fileAs may be the Company name so
 * company field should return "last, first" name instead *or* prepend the title
 * if fileAs is not Company (assuming it exists).
 * 
 * @return	{String}	the company
 */
ZmContact.prototype.getCompanyField =
function() {

	var attrs = this.getAttrs();
	if (attrs == null) return null;

	var fa = parseInt(attrs.fileAs);
	var val = [];
	var idx = 0;

	if (fa == ZmContact.FA_LAST_C_FIRST || fa == ZmContact.FA_FIRST_LAST) {
		// return the title, company name
		if (attrs.jobTitle) {
			val[idx++] = attrs.jobTitle;
			if (attrs.company)
				val[idx++] = ", ";
		}
		if (attrs.company)
			val[idx++] = attrs.company;

	} else if (fa == ZmContact.FA_COMPANY) {
		// return the first/last name
		if (attrs.lastName) {
			val[idx++] = attrs.lastName;
			if (attrs.firstName)
				val[idx++] = ", ";
		}

		if (attrs.firstName)
			val[idx++] = attrs.firstName;

		if (attrs.jobTitle)
			val[idx++] = " (" + attrs.jobTitle + ")";

	} else {
		// just return the title
		if (attrs.jobTitle) {
			val[idx++] = attrs.jobTitle;
			// and/or company name if applicable
			if (attrs.company && (attrs.fileAs == null || fa == ZmContact.FA_LAST_C_FIRST || fa == ZmContact.FA_FIRST_LAST))
				val[idx++] = ", ";
		}
		if (attrs.company && (attrs.fileAs == null || fa == ZmContact.FA_LAST_C_FIRST || fa == ZmContact.FA_FIRST_LAST))
			 val[idx++] = attrs.company;
	}
	if (val.length == 0) return null;
	return val.join("");
};

/**
 * Gets the work address.
 * 
 * @param	{Object}	instance		(not used)
 * @return	{String}	the work address
 */
ZmContact.prototype.getWorkAddrField =
function(instance) {
	var attrs = this.getAttrs();
	return this._getAddressField(attrs.workStreet, attrs.workCity, attrs.workState, attrs.workPostalCode, attrs.workCountry);
};

/**
 * Gets the home address.
 * 
 * @param	{Object}	instance		(not used)
 * @return	{String}	the home address
 */
ZmContact.prototype.getHomeAddrField =
function(instance) {
	var attrs = this.getAttrs();
	return this._getAddressField(attrs.homeStreet, attrs.homeCity, attrs.homeState, attrs.homePostalCode, attrs.homeCountry);
};

/**
 * Gets the other address.
 * 
 * @param	{Object}	instance		(not used)
 * @return	{String}	the other address
 */
ZmContact.prototype.getOtherAddrField =
function(instance) {
	var attrs = this.getAttrs();
	return this._getAddressField(attrs.otherStreet, attrs.otherCity, attrs.otherState, attrs.otherPostalCode, attrs.otherCountry);
};

/**
 * Gets the address book.
 * 
 * @return	{ZmAddrBook}	the address book
 */
ZmContact.prototype.getAddressBook =
function() {
	if (!this.addrbook) {
		this.addrbook = appCtxt.getById(this.folderId);
	}
	return this.addrbook;
};

/**
 * @private
 */
ZmContact.prototype._getAddressField =
function(street, city, state, zipcode, country) {
	if (street == null && city == null && state == null && zipcode == null && country == null) return null;

	var html = [];
	var idx = 0;

	if (street) {
		html[idx++] = street;
		if (city || state || zipcode)
			html[idx++] = "\n";
	}

	if (city) {
		html[idx++] = city;
		if (state)
			html[idx++] = ", ";
		else if (zipcode)
			html[idx++] = " ";
	}

	if (state) {
		html[idx++] = state;
		if (zipcode)
			html[idx++] = " ";
	}

	if (zipcode)
		html[idx++] = zipcode;

	if (country)
		html[idx++] = "\n" + country;

	return html.join("");
};

/**
 * Sets the full name based on an email address.
 * 
 * @private
 */
ZmContact.prototype._initFullName =
function(email, strictName) {
	var name = email.getName();
	name = AjxStringUtil.trim(name.replace(AjxEmailAddress.commentPat, '')); // strip comment (text in parens)

	if (name && name.length) {
		this._setFullName(name, [" "]);
	} else if (!strictName) {
		name = email.getAddress();
		if (name && name.length) {
			var i = name.indexOf("@");
			if (i == -1) return;
			name = name.substr(0, i);
			this._setFullName(name, [".", "_"]);
		}
	}
};

/**
 * Tries to extract a set of name components from the given text, with the
 * given list of possible delimiters. The first delimiter contained in the
 * text will be used. If none are found, the first delimiter in the list is used.
 * 
 * @private
 */
ZmContact.prototype._setFullName =
function(text, delims) {
	var delim = delims[0];
	for (var i = 0; i < delims.length; i++) {
		if (text.indexOf(delims[i]) != -1) {
			delim = delims[i];
			break;
		}
	}
    var parts = text.split(delim);
    var func = this["__setFullName_"+AjxEnv.DEFAULT_LOCALE] || this.__setFullName;
    func.call(this, parts, text, delims);
};

ZmContact.prototype.__setFullName = function(parts, text, delims) {
    this.setAttr(ZmContact.F_firstName, parts[0]);
    if (parts.length == 2) {
        this.setAttr(ZmContact.F_lastName, parts[1]);
    } else if (parts.length == 3) {
        this.setAttr(ZmContact.F_middleName, parts[1]);
        this.setAttr(ZmContact.F_lastName, parts[2]);
    }
};
ZmContact.prototype.__setFullName_ja = function(parts, text, delims) {
    if (parts.length > 2) {
        this.__setFullName(parts, text, delims);
        return;
    }
    // TODO: Perhaps do some analysis to auto-detect Japanese vs.
    // TODO: non-Japanese names. For example, if the name text is
    // TODO: comprised of kanji, treat it as "last first"; else if
    // TODO: first part is all uppercase, treat it as "last first";
    // TODO: else treat it as "first last".
    this.setAttr(ZmContact.F_lastName, parts[0]);
    if (parts.length > 1) {
        this.setAttr(ZmContact.F_firstName, parts[1]);
    }
};
ZmContact.prototype.__setFullName_ja_JP = ZmContact.prototype.__setFullName_ja;

/**
 * @private
 */
ZmContact.prototype._addRequestAttr =
function(cn, name, value) {
	var a = {n:name};
	if (name == ZmContact.F_image && AjxUtil.isString(value) && value.length) {
		// handle contact photo
		if (value.indexOf("aid_") != -1) {
			a.aid = value.substring(4);
		} else {
			a.part = value.substring(5);
		}
	} else {
		a._content = value || "";
	}

    if (value instanceof Array) {
        if (!cn._attrs)
            cn._attrs = {};
        cn._attrs[name] = value || "";
    }
    else  {
        if (!cn.a)
            cn.a = [];
        cn.a.push(a);
    }
};
	
ZmContact.prototype._addContactGroupAttr = 
function(cn, group) {
	var groupMembers = group[ZmContact.F_groups];
	for (var i = 0; i < groupMembers.length; i++) {
		var member = groupMembers[i];
		if (!cn.m) {
			cn.m = [];
		}

		var m = {type: member.type,	value: member.value}; //for the JSON object this is all we need.
		if (member.op) {
			m.op = member.op; //this is only for modify, not for create.
		}
		cn.m.push(m);
	}
};

/**
 * Reset computed fields.
 * 
 * @private
 */
ZmContact.prototype._resetCachedFields =
function() {
	this._fileAs = this._fileAsLC = this._fullName = null;
};

/**
 * Parse contact node.
 * 
 * @private
 */
ZmContact.prototype._loadFromDom =
function(node) {
	this.isLoaded = true;
	this.rev = node.rev;
	this.sf = node.sf || node._attrs.sf;
	if (!this.isGal) {
		this.folderId = node.l;
	}
	this.created = node.cd;
	this.modified = node.md;

	this.attr = node._attrs || {};
	if (node.m) {
		this.attr[ZmContact.F_groups] = node.m;
	}

	this.ref = node.ref || this.attr.dn; //bug 78425
	
	// for shared contacts, we get these fields outside of the attr part
	if (node.email)		{ this.attr[ZmContact.F_email] = node.email; }
	if (node.email2)	{ this.attr[ZmContact.F_email2] = node.email2; }
	if (node.email3)	{ this.attr[ZmContact.F_email3] = node.email3; }

	// in case attrs are coming in from an external GAL, make an effort to map them, including multivalued ones
	this.attr = ZmContact.mapAttrs(this.attr);

    //the attr groups is returned as [] so check both null and empty array to set the type
    var groups = this.attr[ZmContact.F_groups];
    if(!groups || (groups instanceof Array && groups.length == 0)) {
        this.type = ZmItem.CONTACT;
    }
    else {
        this.type = ZmItem.GROUP;
    }

	// check if the folderId is found in our address book (otherwise, we assume
	// this contact to be a shared contact)
	var ac = window.parentAppCtxt || window.appCtxt;
	this.addrbook = ac.getById(this.folderId);

	this._parseTagNames(node.tn);

	// dont process flags for shared contacts until we get server support
	if (!this.isShared()) {
		this._parseFlags(node.f);
	} else {
		// shared contacts are never fully loaded since we never cache them
		this.isLoaded = false;
	}

	// bug: 22174
	// We ignore the server's computed file-as property and instead
	// format it based on the user's locale.
	this._fileAs = ZmContact.computeFileAs(this);

	// Is this a distribution list?
	this.isDL = this.isDistributionList();
	if (this.isDL) {
		this.dlInfo = { //this is minimal DL info, available mainly to allow to know whether to show the lock or not.
			isMinimal: true,
			isMember: node.isMember,
			isOwner: node.isOwner,
			subscriptionPolicy: this.attr.zimbraDistributionListSubscriptionPolicy,
			unsubscriptionPolicy: this.attr.zimbraDistributionListUnsubscriptionPolicy,
			displayName: node.d || "",
			hideInGal: this.attr.zimbraHideInGal == "TRUE"
		};

		this.canExpand = node.exp !== false; //default to true, since most cases this is implicitly true if not returned. See bug 94867
		var emails = this.getEmails();
		var ac = window.parentAppCtxt || window.appCtxt;
		for (var i = 0; i < emails.length; i++) {
			ac.setIsExpandableDL(emails[i], this.canExpand);
		}
	}
};

/**
 * Gets display text for an attendee. Prefers name over email.
 *
 * @param {constant}	type		the attendee type
 * @param {Boolean}	shortForm		if <code>true</code>, return only name or email
 * @return	{String}	the attendee
 */
ZmContact.prototype.getAttendeeText =
function(type, shortForm) {
	var email = this.getEmail(true);
	return (email?email.toString(shortForm || (type && type != ZmCalBaseItem.PERSON)):"");
};

/**
 * Gets display text for an attendee. Prefers name over email.
 *
 * @param {constant}	type		the attendee type
 * @param {Boolean}	shortForm		if <code>true</code>, return only name or email
 * @return	{String}	the attendee
 */
ZmContact.prototype.getAttendeeKey =
function() {
	var email = this.getLookupEmail() || this.getEmail();
	var name = this.getFullName();
	return email ? email : name;
};

/**
 * Gets the unknown fields.
 * 
 * @param	{function}	[sortByNameFunc]	sort by function
 * @return	{Array}	an array of field name/value pairs
 */
ZmContact.prototype.getUnknownFields = function(sortByNameFunc) {
	var map = ZmContact.__FIELD_MAP;
	if (!map) {
		map = ZmContact.__FIELD_MAP = {};
		for (var i = 0; i < ZmContact.DISPLAY_FIELDS; i++) {
			map[ZmContact.DISPLAY_FIELDS[i]] = true;
		}
	}
	var fields = [];
	var attrs = this.getAttrs();
	for (var aname in attrs) {
		var field = ZmContact.getPrefix(aname);
		if (map[aname]) continue;
		fields.push(field);
	}
	return this.getFields(fields, sortByNameFunc);
};

/**
 * Gets the fields.
 * 
 * @param	{Array}	field		the fields
 * @param	{function}	[sortByNameFunc]	sort by function
 * @return	{Array}	an array of field name/value pairs
 */
ZmContact.prototype.getFields =
function(fields, sortByNameFunc) {
	// TODO: [Q] Should sort function handle just the field names or the attribute names?
	var selection;
	var attrs = this.getAttrs();
	for (var index = 0; index < fields.length; index++) {
		for (var i = 1; true; i++) {
			var aname = ZmContact.getAttributeName(fields[index], i);
			if (!attrs[aname]) break;
			if (!selection) selection = {};
			selection[aname] = attrs[aname];
		}
	}
	if (sortByNameFunc && selection) {
		var keys = AjxUtil.keys(selection);
		keys.sort(sortByNameFunc);
		var nfields = {};
		for (var i = 0; i < keys; i++) {
			var key = keys[i];
			nfields[key] = fields[key];
		}
		selection = nfields;
	}
	return selection;
};

/**
 * Returns a list of distribution list members for this contact. Only the
 * requested range is returned.
 *
 * @param offset	{int}			offset into list to start at
 * @param limit		{int}			number of members to fetch and return
 * @param callback	{AjxCallback}	callback to run with results
 */
ZmContact.prototype.getDLMembers =
function(offset, limit, callback) {

	var result = {list:[], more:false, isDL:{}};
	if (!this.isDL) { return result; }

	var email = this.getEmail();
	var app = appCtxt.getApp(ZmApp.CONTACTS);
	var dl = app.getDL(email);
	if (!dl) {
		dl = result;
		dl.more = true;
		app.cacheDL(email, dl);
	}

	limit = limit || ZmContact.DL_PAGE_SIZE;
	var start = offset || 0;
	var end = (offset + limit) - 1;

	// see if we already have the requested members, or know that we don't
	if (dl.list.length >= end + 1 || !dl.more) {
		var list = dl.list.slice(offset, end + 1);
		result = {list:list, more:dl.more || (dl.list.length > end + 1), isDL:dl.isDL};
		DBG.println("dl", "found cached DL members");
		this._handleResponseGetDLMembers(start, limit, callback, result);
		return;
	}

	DBG.println("dl", "server call " + offset + " / " + limit);
	if (!dl.total || (offset < dl.total)) {
		var jsonObj = {GetDistributionListMembersRequest:{_jsns:"urn:zimbraAccount", offset:offset, limit:limit}};
		var request = jsonObj.GetDistributionListMembersRequest;
		request.dl = {_content: this.getEmail()};
		var respCallback = new AjxCallback(this, this._handleResponseGetDLMembers, [offset, limit, callback]);
		appCtxt.getAppController().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
	} else {
		this._handleResponseGetDLMembers(start, limit, callback, result);
	}
};

ZmContact.prototype._handleResponseGetDLMembers =
function(offset, limit, callback, result, resp) {

	if (resp || !result.list) {
		var list = [];
		resp = resp || result.getResponse();  //if response is passed, take it. Otherwise get it from result
		resp = resp.GetDistributionListMembersResponse;
		var dl = appCtxt.getApp(ZmApp.CONTACTS).getDL(this.getEmail());
		var more = dl.more = resp.more;
		var isDL = {};
		var members = resp.dlm;
		if (members && members.length) {
			for (var i = 0, len = members.length; i < len; i++) {
				var member = members[i]._content;
				list.push(member);
				dl.list[offset + i] = member;
				if (members[i].isDL) {
					isDL[member] = dl.isDL[member] = true;
				}
			}
		}
		dl.total = resp.total;
		DBG.println("dl", list.join("<br>"));
		var result = {list:list, more:more, isDL:isDL};
	}
	DBG.println("dl", "returning list of " + result.list.length + ", more is " + result.more);
	if (callback) {
		callback.run(result);
	}
	else { //synchronized case - see ZmContact.prototype.getDLMembers above
		return result;
	}
};

/**
 * Returns a list of all the distribution list members for this contact.
 *
 * @param callback	{AjxCallback}	callback to run with results
 */
ZmContact.prototype.getAllDLMembers =
function(callback) {

	var result = {list:[], more:false, isDL:{}};
	if (!this.isDL) { return result; }

	var dl = appCtxt.getApp(ZmApp.CONTACTS).getDL(this.getEmail());
	if (dl && !dl.more) {
		result = {list:dl.list.slice(), more:false, isDL:dl.isDL};
		callback.run(result);
		return;
	}

	var nextCallback = new AjxCallback(this, this._getNextDLChunk, [callback]);
	this.getDLMembers(dl ? dl.list.length : 0, null, nextCallback);
};

ZmContact.prototype._getNextDLChunk =
function(callback, result) {

	var dl = appCtxt.getApp(ZmApp.CONTACTS).getDL(this.getEmail());
	if (result.more) {
		var nextCallback = new AjxCallback(this, this._getNextDLChunk, [callback]);
		this.getDLMembers(dl.list.length, null, nextCallback);
	} else {
		result.list = dl.list.slice();
		callback.run(result);
	}
};

/**
 * Gets the contact from cache handling parsing of contactId
 * 
 * @param contactId {String} contact id
 * @return contact {ZmContact} contact or null
 * @private
 */
ZmContact.getContactFromCache =
function(contactId) {
	var userZid = appCtxt.accountList.mainAccount.id;
	var contact = null;
	if (contactId && contactId.indexOf(userZid + ":") !=-1) {
		//strip off the usersZid to pull from cache
		var arr = contactId.split(userZid + ":");
		contact = arr && arr.length > 1 ? appCtxt.cacheGet(arr[1]) : appCtxt.cacheGet(contactId);
	}
	else {
		contact = appCtxt.cacheGet(contactId);
	}
	if (contact instanceof ZmContact) {
		return contact;
	}
	return null;
};

// For mapAttrs(), prepare a hash where each key is the base name of an attr (without an ending number and lowercased),
// and the value is a numerically sorted list of attr names in their original form.
ZmContact.ATTR_VARIANTS = {};
ZmContact.IGNORE_ATTR_VARIANT = {};
ZmContact.IGNORE_ATTR_VARIANT[ZmContact.F_groups] = true;

ZmContact.initAttrVariants = function(attrClass) {
	var keys = Object.keys(attrClass),
		len = keys.length, key, i, attr,
		attrs = [];

	// first, grab all the attr names
	var ignoreVariant = attrClass.IGNORE_ATTR_VARIANT || {};
	for (i = 0; i < len; i++) {
		key = keys[i];
		if (key.indexOf('F_') === 0) {
			attr = attrClass[key];
			if (!ignoreVariant[attr]) {
				attrs.push(attr);
			}
		}
	}

	// sort numerically, eg so that we get ['email', 'email2', 'email10'] in right order
	var numRegex = /^([a-zA-Z]+)(\d+)$/;
	attrs.sort(function(a, b) {
		var aMatch = a.match(numRegex),
			bMatch = b.match(numRegex);
		// check if both are numbered attrs with same base
		if (aMatch && bMatch && aMatch[1] === bMatch[1]) {
			return aMatch[2] - bMatch[2];
		}
		else {
			return a > b ? 1 : (a < b ? -1 : 0);
		}
	});

	// construct hash mapping generic base name to its iterated attr names
	var attr, base;
	for (i = 0; i < attrs.length; i++) {
		attr = attrs[i];
		base = attr.replace(/\d+$/, '').toLowerCase();
		if (!ZmContact.ATTR_VARIANTS[base]) {
			ZmContact.ATTR_VARIANTS[base] = [];
		}
		ZmContact.ATTR_VARIANTS[base].push(attr);
	}
};
ZmContact.initAttrVariants(ZmContact);

/**
 * Takes a hash of attrs and values and maps it to our attr names as best as it can. Scalar attrs will map if they
 * have the same name or only differ by case. A multivalued attr will map to a set of our attributes that share the
 * same case-insensitive base name. Some examples:
 *
 *      FIRSTNAME: "Mildred"    =>      firstName: "Mildred"
 *      email: ['a', 'b']       =>      email: 'a',
 *                                      email2: 'b'
 *      WorkEmail: ['y', 'z']   =>      workEmail1: 'y',
 *                                      workEmail2: 'z'
 *      IMaddress: ['f', 'g']   =>      imAddress1: 'f',
 *                                      imAddress2: 'g'
 *
 * @param   {Object}    attrs       hash of attr names/values
 *
 * @returns {Object}    hash of attr names/values using known attr names ZmContact.F_*
 */
ZmContact.mapAttrs = function(attrs) {

	var attr, value, baseAttrs, newAttrs = {};
	for (attr in attrs) {
		value = attrs[attr];
		if (value) {
			baseAttrs = ZmContact.ATTR_VARIANTS[attr.toLowerCase()];
			if (baseAttrs) {
				value = AjxUtil.toArray(value);
				var len = Math.min(value.length, baseAttrs.length), i;
				for (i = 0; i < len; i++) {
					newAttrs[baseAttrs[i]] = value[i];
				}
			} else {
				// Any overlooked/ignored attributes are simply passed along
				newAttrs[attr] = value;
			}
		}
	}
	return newAttrs;
};

// these need to be kept in sync with ZmContact.F_*
ZmContact._AB_FIELD = {
	firstName:				ZmMsg.AB_FIELD_firstName,		// file as info
	lastName:				ZmMsg.AB_FIELD_lastName,
	middleName:				ZmMsg.AB_FIELD_middleName,
	fullName:				ZmMsg.AB_FIELD_fullName,
	jobTitle:				ZmMsg.AB_FIELD_jobTitle,
	company:				ZmMsg.AB_FIELD_company,
	department:				ZmMsg.AB_FIELD_department,
	email:					ZmMsg.AB_FIELD_email,			// email addresses
	email2:					ZmMsg.AB_FIELD_email2,
	email3:					ZmMsg.AB_FIELD_email3,
	imAddress1:				ZmMsg.AB_FIELD_imAddress1,		// IM addresses
	imAddress2:				ZmMsg.AB_FIELD_imAddress2,
	imAddress3:				ZmMsg.AB_FIELD_imAddress3,
	image: 					ZmMsg.AB_FIELD_image,			// contact photo
	attachment:				ZmMsg.AB_FIELD_attachment,
	workStreet:				ZmMsg.AB_FIELD_street,			// work address info
	workCity:				ZmMsg.AB_FIELD_city,
	workState:				ZmMsg.AB_FIELD_state,
	workPostalCode:			ZmMsg.AB_FIELD_postalCode,
	workCountry:			ZmMsg.AB_FIELD_country,
	workURL:				ZmMsg.AB_FIELD_URL,
	workPhone:				ZmMsg.AB_FIELD_workPhone,
	workPhone2:				ZmMsg.AB_FIELD_workPhone2,
	workFax:				ZmMsg.AB_FIELD_workFax,
	assistantPhone:			ZmMsg.AB_FIELD_assistantPhone,
	companyPhone:			ZmMsg.AB_FIELD_companyPhone,
	callbackPhone:			ZmMsg.AB_FIELD_callbackPhone,
	homeStreet:				ZmMsg.AB_FIELD_street,			// home address info
	homeCity:				ZmMsg.AB_FIELD_city,
	homeState:				ZmMsg.AB_FIELD_state,
	homePostalCode:			ZmMsg.AB_FIELD_postalCode,
	homeCountry:			ZmMsg.AB_FIELD_country,
	homeURL:				ZmMsg.AB_FIELD_URL,
	homePhone:				ZmMsg.AB_FIELD_homePhone,
	homePhone2:				ZmMsg.AB_FIELD_homePhone2,
	homeFax:				ZmMsg.AB_FIELD_homeFax,
	mobilePhone:			ZmMsg.AB_FIELD_mobilePhone,
	pager:					ZmMsg.AB_FIELD_pager,
	carPhone:				ZmMsg.AB_FIELD_carPhone,
	otherStreet:			ZmMsg.AB_FIELD_street,			// other info
	otherCity:				ZmMsg.AB_FIELD_city,
	otherState:				ZmMsg.AB_FIELD_state,
	otherPostalCode:		ZmMsg.AB_FIELD_postalCode,
	otherCountry:			ZmMsg.AB_FIELD_country,
	otherURL:				ZmMsg.AB_FIELD_URL,
	otherPhone:				ZmMsg.AB_FIELD_otherPhone,
	otherFax:				ZmMsg.AB_FIELD_otherFax,
	notes:					ZmMsg.notes,					// misc fields
	birthday:				ZmMsg.AB_FIELD_birthday
};

ZmContact._AB_FILE_AS = {
	1:						ZmMsg.AB_FILE_AS_lastFirst,
	2:						ZmMsg.AB_FILE_AS_firstLast,
	3:						ZmMsg.AB_FILE_AS_company,
	4:						ZmMsg.AB_FILE_AS_lastFirstCompany,
	5:						ZmMsg.AB_FILE_AS_firstLastCompany,
	6:						ZmMsg.AB_FILE_AS_companyLastFirst,
	7:						ZmMsg.AB_FILE_AS_companyFirstLast
};

} // if (!window.ZmContact)
}
if (AjxPackage.define("zimbraMail.abook.model.ZmContactList")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the contact list class.
 * 
 */

/**
 * Create a new, empty contact list.
 * @class
 * This class represents a list of contacts. In general, the list is the result of a
 * search. It may be the result of a <code>&lt;GetContactsRequest&gt;</code>, which returns all of the user's
 * local contacts. That list is considered to be canonical.
 * <p>
 * Loading of all local contacts has been optimized by delaying the creation of {@link ZmContact} objects until
 * they are needed. That has a big impact on IE, and not much on Firefox. Loading a subset
 * of attributes did not have much impact on load time, probably because a large majority
 * of contacts contain only those minimal fields.</p>
 *
 * @author Conrad Damon
 *
 * @param {ZmSearch}	search	the search that generated this list
 * @param {Boolean}	isGal		if <code>true</code>, this is a list of GAL contacts
 * @param {constant}	type		the item type
 * 
 * @extends		ZmList
 */
ZmContactList = function(search, isGal, type) {

	if (arguments.length == 0) { return; }
	type = type || ZmItem.CONTACT;
	ZmList.call(this, type, search);

	this.isGal = (isGal === true);
	this.isCanonical = false;
	this.isLoaded = false;

	this._app = appCtxt.getApp(ZmApp.CONTACTS);
	if (!this._app) { 
		this._emailToContact = this._phoneToContact = {};
		return;
	}
	this._emailToContact = this._app._byEmail;
	this._phoneToContact = this._app._byPhone;

	this._alwaysUpdateHashes = true; // Should we update the phone & IM fast-lookup hashes even when account features don't require it? (bug #60411)
};

ZmContactList.prototype = new ZmList;
ZmContactList.prototype.constructor = ZmContactList;

ZmContactList.prototype.isZmContactList = true;
ZmContactList.prototype.toString = function() { return "ZmContactList"; };




// Constants

// Support for loading user's local contacts from a large string

ZmContactList.URL = "/Contacts";	// REST URL for loading user's local contacts
ZmContactList.URL_ARGS = { fmt: 'cf', t: 2, all: 'all' }; // arguments for the URL above
ZmContactList.CONTACT_SPLIT_CHAR	= '\u001E';	// char for splitting string into contacts
ZmContactList.FIELD_SPLIT_CHAR		= '\u001D';	// char for splitting contact into fields
// fields that belong to a contact rather than its attrs
ZmContactList.IS_CONTACT_FIELD = {"id":true, "l":true, "d":true, "fileAsStr":true, "rev":true};



/**
 * @private
 */
ZmContactList.prototype.addLoadedCallback =
function(callback) {
	if (this.isLoaded) {
		callback.run();
		return;
	}
	if (!this._loadedCallbacks) {
		this._loadedCallbacks = [];
	}
	this._loadedCallbacks.push(callback);
};

/**
 * @private
 */
ZmContactList.prototype._finishLoading =
function() {
	DBG.timePt("done loading " + this.size() + " contacts");
	this.isLoaded = true;
	if (this._loadedCallbacks) {
		var callback;
		while (callback = this._loadedCallbacks.shift()) {
			callback.run();
		}
	}
};

/**
 * Retrieves the contacts from the back end, and parses the response. The list is then sorted.
 * This method is used only by the canonical list of contacts, in order to load their content.
 * <p>
 * Loading a minimal set of attributes did not result in a significant performance gain.
 * </p>
 * 
 * @private
 */
ZmContactList.prototype.load =
function(callback, errorCallback, accountName) {
	// only the canonical list gets loaded
	this.isCanonical = true;
	var respCallback = new AjxCallback(this, this._handleResponseLoad, [callback]);
	DBG.timePt("requesting contact list", true);
    if(appCtxt.isExternalAccount()) {
        //Do not make a call in case of external user
        //The rest url constructed wont exist in case of external user
        if (callback) {
		    callback.run();
	    }
        return;
    }
	var args = ZmContactList.URL_ARGS;

	// bug 74609: suppress overzealous caching by IE
	if (AjxEnv.isIE) {
		args = AjxUtil.hashCopy(args);
		args.sid = ZmCsfeCommand.getSessionId();
	}

	var params = {asyncMode:true, noBusyOverlay:true, callback:respCallback, errorCallback:errorCallback, offlineCallback:callback};
	params.restUri = AjxUtil.formatUrl({
		path:["/home/", (accountName || appCtxt.getUsername()),
	          ZmContactList.URL].join(""),
	    qsArgs: args, qsReset:true
	});
	DBG.println(AjxDebug.DBG1, "loading contacts from " + params.restUri);
	appCtxt.getAppController().sendRequest(params);

	ZmContactList.addDlFolder();
	
};

/**
 * @private
 */
ZmContactList.prototype._handleResponseLoad =
function(callback, result) {
	DBG.timePt("got contact list");
	var text = result.getResponse();
    if (text && typeof text !== 'string'){
        text = text._data;
    }
	var derefList = [];
	if (text) {
		var contacts = text.split(ZmContactList.CONTACT_SPLIT_CHAR);
		var derefBatchCmd = new ZmBatchCommand(true, null, true);
		for (var i = 0, len = contacts.length; i < len; i++) {
			var fields = contacts[i].split(ZmContactList.FIELD_SPLIT_CHAR);
			var contact = {}, attrs = {};
			var groupMembers = [];
			var foundDeref = false;
			for (var j = 0, len1 = fields.length; j < len1; j += 2) {
				if (ZmContactList.IS_CONTACT_FIELD[fields[j]]) {
					contact[fields[j]] = fields[j + 1];
				} else {
					var value = fields[j+1];
					switch (fields[j]) {
						case ZmContact.F_memberC:
							groupMembers.push({type: ZmContact.GROUP_CONTACT_REF, value: value});
							foundDeref = true; //load shared contacts
							break;
						case ZmContact.F_memberG:
							groupMembers.push({type: ZmContact.GROUP_GAL_REF, value: value});
							foundDeref = true;
							break;
						case ZmContact.F_memberI:
							groupMembers.push({type: ZmContact.GROUP_INLINE_REF, value: value});
							foundDeref = true;
							break;
						default:
							attrs[fields[j]] = value;
					}
				}
			}
			if (attrs[ZmContact.F_type] === "group") { //set only for group.
				attrs[ZmContact.F_groups] = groupMembers;
			}
			if (foundDeref) {
				//batch group members for deref loading
				var dummy = new ZmContact(contact["id"], this);
				derefBatchCmd.add(new AjxCallback(dummy, dummy.load, [null, null, derefBatchCmd, true]));
			}
			contact._attrs = attrs;
			this._addContact(contact);
		}
		derefBatchCmd.run();
	}

	this._finishLoading();

	if (callback) {
		callback.run();
	}
};

/**
 * @static
 */
ZmContactList.addDlFolder =
function() {

	if (!appCtxt.get(ZmSetting.DLS_FOLDER_ENABLED)) {
		return;
	}

	var dlsFolder = appCtxt.getById(ZmOrganizer.ID_DLS);

	var root = appCtxt.getById(ZmOrganizer.ID_ROOT);
	if (!root) { return; }

	if (dlsFolder && root.getById(ZmOrganizer.ID_DLS)) {
		//somehow (after a refresh block, can be reprod using $set:refresh. ZmClientCmdHandler.prototype.execute_refresh) the DLs folder object is removed from under the root (but still cached in appCtxt). So making sure it's there.
		return;
	}

	if (!dlsFolder) {
		var params = {
			id: ZmOrganizer.ID_DLS,
			name: ZmMsg.distributionLists,
			parent: root,
			tree: root.tree,
			type: ZmOrganizer.ADDRBOOK,
			numTotal: null, //we don't know how many
			noTooltip: true //so don't show tooltip
		};

		dlsFolder = new ZmAddrBook(params);
		root.children.add(dlsFolder);
		dlsFolder._isDL = true;
	}
	else {
		//the dls folder object exists but no longer as a child of the root.
		dlsFolder.parent = root;
		root.children.add(dlsFolder); //any better way to do this?
	}

};

ZmContactList.prototype.add = 
function(item, index) {
	if (!item.id || !this._idHash[item.id]) {
		this._vector.add(item, index);
		if (item.id) {
			this._idHash[item.id] = item;
		}
		this._updateHashes(item, true);
	}
};

ZmContactList.prototype.cache = 
function(offset, newList) {
	var getId = function(){
		return this.id;
	}
	var exists = function(obj) {
		return this._vector.containsLike(obj, getId);
	}
	var unique = newList.sub(exists, this);

	this.getVector().merge(offset, unique);
	// reparent each item within new list, and add it to ID hash
	var list = unique.getArray();
	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		item.list = this;
		if (item.id) {
			this._idHash[item.id] = item;
		}
	}
};

/**
 * @private
 */
ZmContactList.prototype._addContact =
function(contact) {

	// note that we don't create a ZmContact here (optimization)
	contact.list = this;
	this._updateHashes(contact, true);
	var fn = [], fl = [];
	if (contact._attrs[ZmContact.F_firstName])	{ fn.push(contact._attrs[ZmContact.F_firstName]); }
	if (contact._attrs[ZmContact.F_middleName])	{ fn.push(contact._attrs[ZmContact.F_middleName]); }
	if (contact._attrs[ZmContact.F_lastName])	{ fn.push(contact._attrs[ZmContact.F_lastName]); }
	if (fn.length) {
		contact._attrs[ZmContact.X_fullName] = fn.join(" ");
	}
	if (contact._attrs[ZmContact.F_firstName])	{ fl.push(contact._attrs[ZmContact.F_firstName]); }
	if (contact._attrs[ZmContact.F_lastName])	{ fl.push(contact._attrs[ZmContact.F_lastName]); }
	contact._attrs[ZmContact.X_firstLast] = fl.join(" ");

	this.add(contact);
};

/**
 * Converts an anonymous contact object (contained by the JS returned by load request)
 * into a ZmContact, and updates the containing list if it is the canonical one.
 *
 * @param {Object}	contact		a contact
 * @param {int}	idx		the index of contact in canonical list
 * 
 * @private
 */
ZmContactList.prototype._realizeContact =
function(contact, idx) {

	if (contact instanceof ZmContact) { return contact; }
	if (contact && contact.type == ZmItem.CONTACT) { return contact; }	// instanceof often fails in new window

	var args = {list:this};
	var obj = eval(ZmList.ITEM_CLASS[this.type]);
	var realContact = obj && obj.createFromDom(contact, args);

	if (this.isCanonical) {
		var a = this.getArray();
		idx = idx || this.getIndexById(contact.id);
		a[idx] = realContact;
		this._updateHashes(realContact, true);
		this._idHash[contact.id] = realContact;
	}

	return realContact;
};

/**
 * Finds the array index for the contact with the given ID.
 *
 * @param {int}	id		the contact ID
 * @return	{int}	the index
 * @private
 */
ZmContactList.prototype.getIndexById =
function(id) {
	var a = this.getArray();
	for (var i = 0; i < a.length; i++) {
		if (a[i].id == id) {
			return i;
		}
	}
	return null;
};

/**
 * Override in order to make sure the contacts have been realized. We don't
 * call realizeContact() since this is not the canonical list.
 *
 * @param {int}	offset		the starting index
 * @param {int}	limit		the size of sublist
 * @return	{AjxVector}	a vector of {@link ZmContact} objects
 */
ZmContactList.prototype.getSubList =
function(offset, limit, folderId) {
	if (folderId && this.isCanonical) {
		// only collect those contacts that belong to the given folderId if provided
		var newlist = [];
		var sublist = this.getArray();
		var offsetCount = 0;
		this.setHasMore(false);

		for (var i = 0; i < sublist.length; i++) {
			sublist[i] = this._realizeContact(sublist[i], i);
			var folder = appCtxt.getById(sublist[i].folderId);
			if (folder && folder.nId == ZmOrganizer.normalizeId(folderId)) {
				if (offsetCount >= offset) {
					if (newlist.length == limit) {
						this.setHasMore(true);
						break;
					}
					newlist.push(sublist[i]);
				}
				offsetCount++;
			}
		}

		return AjxVector.fromArray(newlist);
	} else {
		var vec = ZmList.prototype.getSubList.call(this, offset, limit);
		if (vec) {
			var a = vec.getArray();
			for (var i = 0; i < a.length; i++) {
				a[i] = this._realizeContact(a[i], offset + i);
			}
		}

		return vec;
	}
};

/**
 * Override in order to make sure the contact has been realized. Canonical list only.
 *
 * @param {int}	id		the contact ID
 * @return	{ZmContact}	the contact or <code>null</code> if not found
 */
ZmContactList.prototype.getById =
function(id) {
	if (!id || !this.isCanonical) return null;

	var contact = this._idHash[id];
	return contact ? this._realizeContact(contact) : null;
};

/**
 * Gets the contact with the given address, if any (canonical list only).
 *
 * @param {String}	address	an email address
 * @return	{ZmContact}	the contact or <code>null</code> if not found
 */
ZmContactList.prototype.getContactByEmail =
function(address) {
	if (!address || !this.isCanonical) return null;

	var contact = this._emailToContact[address.toLowerCase()];
	if (contact) {
		contact = this._realizeContact(contact);
		contact._lookupEmail = address;	// so caller knows which address matched
		return contact;
	} else {
		return null;
	}
};

/**
 * Gets information about the contact with the given phone number, if any (canonical list only).
 *
 * @param {String}	phone	the phone number
 * @return	{Hash}	an object with <code>contact</code> = the contact & <code>field</code> = the field with the matching phone number
 */
ZmContactList.prototype.getContactByPhone =
function(phone) {
	if (!phone || !this.isCanonical) return null;

	var digits = this._getPhoneDigits(phone);
	var data = this._phoneToContact[digits];
	if (data) {
		data.contact = this._realizeContact(data.contact);
		return data;
	} else {
		return null;
	}
};

/**
 * Moves a list of items to the given folder.
 * <p>
 * This method calls the base class for normal "moves" UNLESS we're dealing w/
 * shared items (or folder) in which case we must send a CREATE request for the
 * given folder to the server followed by a hard delete of the shared contact.
 * </p>
 *
 * @param {Hash}	params		a hash of parameters
 * @param	{Array}       params.items			a list of items to move
 * @param	{ZmFolder}	params.folder		the destination folder
 * @param	{Hash}	       params.attrs		the additional attrs for SOAP command
 * @param	{Boolean}	params.outOfTrash	if <code>true</code>, we are moving contacts out of trash
 */
ZmContactList.prototype.moveItems =
function(params) {

	params = Dwt.getParams(arguments, ["items", "folder", "attrs", "outOfTrash"]);
	params.items = AjxUtil.toArray(params.items);

	var moveBatchCmd = new ZmBatchCommand(true, null, true);
	var loadBatchCmd = new ZmBatchCommand(true, null, true);
	var softMove = [];

	// if the folder we're moving contacts to is a shared folder, then dont bother
	// checking whether each item is shared or not
	if (params.items[0] && params.items[0] instanceof ZmItem) {
		for (var i = 0; i < params.items.length; i++) {
			var contact = params.items[i];

			if (contact.isReadOnly()) { continue; }

			softMove.push(contact);
		}
	} else {
		softMove = params.items;
	}

	// for "soft" moves, handle moving out of Trash differently
	if (softMove.length > 0) {
		var params1 = AjxUtil.hashCopy(params);
		params1.attrs = params.attrs || {};
		var toFolder = params.folder;
		params1.attrs.l = toFolder.isRemote() ? toFolder.getRemoteId() : toFolder.id;
		params1.action = "move";
        params1.accountName = appCtxt.multiAccounts && appCtxt.accountList.mainAccount.name;
        if (params1.folder.id == ZmFolder.ID_TRASH) {
            params1.actionTextKey = 'actionTrash';
            // bug: 47389 avoid moving to local account's Trash folder.
            params1.accountName = appCtxt.multiAccounts && params.items[0].getAccount().name;
        } else {
            params1.actionTextKey = 'actionMove';
            params1.actionArg = toFolder.getName(false, false, true);
        }
		params1.callback = params.outOfTrash && new AjxCallback(this, this._handleResponseMoveItems, params);

		this._itemAction(params1);
	}
};

/**
 * @private
 */
ZmContactList.prototype._handleResponseMoveBatchCmd =
function(result) {
	var resp = result.getResponse().BatchResponse.ContactActionResponse;
	// XXX: b/c the server does not return notifications for actions done on
	//      shares, we manually notify - TEMP UNTIL WE GET BETTER SERVER SUPPORT
	var ids = resp[0].action.id.split(",");
	for (var i = 0; i < ids.length; i++) {
		var contact = appCtxt.cacheGet(ids[i]);
		if (contact && contact.isShared()) {
			contact.notifyDelete();
			appCtxt.cacheRemove(ids[i]);
		}
	}
};

/**
 * @private
 */
ZmContactList.prototype._handleResponseLoadMove =
function(moveBatchCmd, params) {
	var deleteCmd = new AjxCallback(this, this._itemAction, [params]);
	moveBatchCmd.add(deleteCmd);

	var respCallback = new AjxCallback(this, this._handleResponseMoveBatchCmd);
	moveBatchCmd.run(respCallback);
};

/**
 * @private
 */
ZmContactList.prototype._handleResponseBatchLoad =
function(batchCmd, folder, result, contact) {
	batchCmd.add(this._getCopyCmd(contact, folder));
};

/**
 * @private
 */
ZmContactList.prototype._getCopyCmd =
function(contact, folder) {
	var temp = new ZmContact(null, this);
	for (var j in contact.attr) {
		temp.attr[j] = contact.attr[j];
	}
	temp.attr[ZmContact.F_folderId] = folder.id;

	return new AjxCallback(temp, temp.create, [temp.attr]);
};

/**
 * Deletes contacts after checking that this is not a GAL list.
 *
 * @param {Hash}	params		a hash of parameters
 * @param	{Array}	       params.items			the list of items to delete
 * @param	{Boolean}	params.hardDelete	if <code>true</code>, force physical removal of items
 * @param	{Object}	params.attrs			the additional attrs for SOAP command
 */
ZmContactList.prototype.deleteItems =
function(params) {
	if (this.isGal) {
		if (ZmContactList.deleteGalItemsAllowed(params.items)) {
			this._deleteDls(params.items);
			return;
		}
		DBG.println(AjxDebug.DBG1, "Cannot delete GAL contacts that are not DLs");
		return;
	}
	ZmList.prototype.deleteItems.call(this, params);
};

ZmContactList.deleteGalItemsAllowed =
function(items) {
	var deleteDomainsAllowed = appCtxt.createDistListAllowedDomainsMap;
	if (items.length == 0) {
		return false; //need a special case since we don't want to enable the "delete" button for 0 items.
	}
	for (var i = 0; i < items.length; i++) {
		var contact = items[i];
		var email = contact.getEmail();
		var domain = email.split("@")[1];
		var isDL = contact && contact.isDistributionList();
		//see bug 71368 and also bug 79672 - the !contact.dlInfo is in case somehow dlInfo is missing - so unfortunately if that happens (can't repro) - let's not allow to delete since we do not know if it's an owner
		if (!isDL || !deleteDomainsAllowed[domain] || !contact.dlInfo || !contact.dlInfo.isOwner) {
			return false;
		}
	}
	return true;
};

ZmContactList.prototype._deleteDls =
function(items, confirmDelete) {

	if (!confirmDelete) {
		var callback = this._deleteDls.bind(this, items, true);
		this._popupDeleteWarningDialog(callback, false, items.length);
		return;
	}

	var reqs = [];
	for (var i = 0; i < items.length; i++) {
		var contact = items[i];
		var email = contact.getEmail();
		reqs.push({
				_jsns: "urn:zimbraAccount",
				dl: {by: "name",
					 _content: contact.getEmail()
				},
				action: {
					op: "delete"
				}
			});
	}
	var jsonObj = {
		BatchRequest: {
			_jsns: "urn:zimbra",
			DistributionListActionRequest: reqs
		}
	};
	var respCallback = this._deleteDlsResponseHandler.bind(this, items);
	appCtxt.getAppController().sendRequest({jsonObj: jsonObj, asyncMode: true, callback: respCallback});

};

ZmContactList.prototype._deleteDlsResponseHandler =
function(items) {
	if (appCtxt.getCurrentView().isZmGroupView) {
		//this is the case we were editing the DL (different than viewing it in the DL list, in which case it's the contactListController).
		//so we now need to pop up the view.
		this.controller.popView();
	}

	appCtxt.setStatusMsg(items.length == 1 ? ZmMsg.dlDeleted : ZmMsg.dlsDeleted);

	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		item.clearDlInfo();
		item._notify(ZmEvent.E_DELETE);
	}
};



/**
 * Sets the is GAL flag.
 * 
 * @param	{Boolean}	isGal		<code>true</code> if contact list is GAL
 */
ZmContactList.prototype.setIsGal =
function(isGal) {
	this.isGal = isGal;
};

ZmContactList.prototype.notifyCreate =
function(node) {
	var obj = eval(ZmList.ITEM_CLASS[this.type]);
	if (obj) {
		var item = obj.createFromDom(node, {list:this});
		var index = this._sortIndex(item);
		// only add if it sorts into this list
		var listSize = this.size();
		var visible = false;
		if (index < listSize || listSize == 0 || (index==listSize && !this._hasMore)) {
			this.add(item, index);
			this.createLocal(item);
			visible = true;
		}
		this._notify(ZmEvent.E_CREATE, {items: [item], sortIndex: index, visible: visible});
	}
};

/**
 * Moves the items.
 * 
 * @param	{Array}	items		an array of {@link ZmContact} objects
 * @param	{String}	folderId	the folder id
 */
ZmContactList.prototype.moveLocal =
function(items, folderId) {
	// don't remove any contacts from the canonical list
	if (!this.isCanonical)
		ZmList.prototype.moveLocal.call(this, items, folderId);
	if (folderId == ZmFolder.ID_TRASH) {
		for (var i = 0; i < items.length; i++) {
			this._updateHashes(items[i], false);
		}
	}
};

/**
 * Deletes the items.
 * 
 * @param	{Array}	items		an array of {@link ZmContact} objects
 */
ZmContactList.prototype.deleteLocal =
function(items) {
	ZmList.prototype.deleteLocal.call(this, items);
	for (var i = 0; i < items.length; i++) {
		this._updateHashes(items[i], false);
	}
};

/**
 * Handle modified contact.
 * 
 * @private
 */
ZmContactList.prototype.modifyLocal =
function(item, details) {
	if (details) {
		// notify item's list
		this._evt.items = details.items = [item];
		this._evt.item = details.contact; //somehow this was set to something obsolete. What a mess. Also note that item is Object while details.contact is ZmContact
		this._notify(ZmEvent.E_MODIFY, details);
	}

	var contact = details.contact;
	if (this.isCanonical || contact.attr[ZmContact.F_email] != details.oldAttr[ZmContact.F_email]) {
		// Remove traces of old contact - NOTE: we pass in null for the ID on
		// PURPOSE to avoid overwriting the existing cached contact
		var oldContact = new ZmContact(null, this);
		oldContact.id = details.contact.id;
		oldContact.attr = details.oldAttr;
		this._updateHashes(oldContact, false);

		// add new contact to hashes
		this._updateHashes(contact, true);
	}

	// place in correct position in list
	if (details.fileAsChanged) {
		this.remove(contact);
		var index = this._sortIndex(contact);
		var listSize = this.size();
		if (index < listSize || listSize == 0 || (index == listSize && !this._hasMore)) {
			this.add(contact, index);
		}
	}

	// reset addrbook property
	if (contact.addrbook && (contact.addrbook.id != contact.folderId)) {
		contact.addrbook = appCtxt.getById(contact.folderId);
	}
};

/**
 * Creates the item local.
 * 
 * @param	{ZmContact}	item		the item
 */
ZmContactList.prototype.createLocal =
function(item) {
	this._updateHashes(item, true);
};

/**
 * @private
 */
ZmContactList.prototype._updateHashes =
function(contact, doAdd) {

	this._app.updateCache(contact, doAdd);

	// Update email hash.
	for (var index = 0; index < ZmContact.EMAIL_FIELDS.length; index++) {
		var field = ZmContact.EMAIL_FIELDS[index];
		for (var i = 1; true; i++) {
			var aname = ZmContact.getAttributeName(field, i);
			var avalue = ZmContact.getAttr(contact, aname);
			if (!avalue) break;
			if (doAdd) {
				this._emailToContact[avalue.toLowerCase()] = contact;
			} else {
				delete this._emailToContact[avalue.toLowerCase()];
			}
		}
	}

	// Update phone hash.
	if (appCtxt.get(ZmSetting.VOICE_ENABLED) || this._alwaysUpdateHashes) {
		for (var index = 0; index < ZmContact.PHONE_FIELDS.length; index++) {
			var field = ZmContact.PHONE_FIELDS[index];
			for (var i = 1; true; i++) {
				var aname = ZmContact.getAttributeName(field, i);
				var avalue = ZmContact.getAttr(contact, aname);
				if (!avalue) break;
				var digits = this._getPhoneDigits(avalue);
				if (digits) {
					if (doAdd) {
						this._phoneToContact[avalue] = {contact: contact, field: aname};
					} else {
						delete this._phoneToContact[avalue];
					}
				}
			}
		}
	}
};

/**
 * Strips all non-digit characters from a phone number.
 * 
 * @private
 */
ZmContactList.prototype._getPhoneDigits =
function(phone) {
	return phone.replace(/[^\d]/g, '');
};

/**
 * Returns the position at which the given contact should be inserted in this list.
 * 
 * @private
 */
ZmContactList.prototype._sortIndex =
function(contact) {
	var a = this._vector.getArray();
	for (var i = 0; i < a.length; i++) {
		if (ZmContact.compareByFileAs(a[i], contact) > 0) {
			return i;
		}
	}
	return a.length;
};

/**
 * Gets the list ID hash
 * @return idHash {Ojbect} list ID hash
 */
ZmContactList.prototype.getIdHash =
function() {
	return this._idHash;
}

/**
 * @private
 */
ZmContactList.prototype._handleResponseModifyItem =
function(item, result) {
	// NOTE: we overload and do nothing b/c base class does more than we want
	//       (since everything is handled by notifications)
};
}
if (AjxPackage.define("zimbraMail.briefcase.ZmBriefcaseApp")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains the briefcase application class.
 */

/**
 * Creates and initializes the briefcase application.
 * @class
 * The briefcase application manages the creation and display of briefcase items.
 * 
 * @param	{DwtControl}	container		the container
 * @param	{ZmController}	parentController	the parent controller
 * 
 * @author Conrad Damon
 * 
 * @extends		ZmApp
 */
ZmBriefcaseApp = function(container, parentController) {
	ZmApp.call(this, ZmApp.BRIEFCASE, container, parentController);
};

ZmBriefcaseApp.prototype = new ZmApp;
ZmBriefcaseApp.prototype.constructor = ZmBriefcaseApp;

ZmBriefcaseApp.prototype.isZmBriefcaseApp = true;
ZmBriefcaseApp.prototype.toString = function() { return "ZmBriefcaseApp"; };


// Constants

// Organizer and item-related constants
ZmEvent.S_BRIEFCASE_ITEM			= ZmId.ITEM_BRIEFCASE;
ZmItem.BRIEFCASE_ITEM				= ZmEvent.S_BRIEFCASE_ITEM;
ZmItem.BRIEFCASE					= ZmItem.BRIEFCASE_ITEM;	// back-compatibility

ZmEvent.S_BRIEFCASE_REVISION_ITEM			= ZmId.ITEM_BRIEFCASE_REV;
ZmItem.BRIEFCASE_REVISION_ITEM				= ZmEvent.S_BRIEFCASE_REVISION_ITEM;
ZmItem.BRIEFCASE_REVISION					= ZmItem.BRIEFCASE_REVISION_ITEM;	// back-compatibility

/**
 * Defines the "briefcase" organizer.
 */
ZmOrganizer.BRIEFCASE				= ZmId.ORG_BRIEFCASE;

// App-related constants
/**
 * Defines the "briefcase" application.
 */
ZmApp.BRIEFCASE						= ZmId.APP_BRIEFCASE;
ZmApp.CLASS[ZmApp.BRIEFCASE]		= "ZmBriefcaseApp";
ZmApp.SETTING[ZmApp.BRIEFCASE]		= ZmSetting.BRIEFCASE_ENABLED;
ZmApp.LOAD_SORT[ZmApp.BRIEFCASE]	= 65;
ZmApp.QS_ARG[ZmApp.BRIEFCASE]		= "briefcase";
ZmApp.BUTTON_ID[ZmApp.BRIEFCASE]	= ZmId.BRIEFCASE_APP;


ZmBriefcaseApp.prototype._defineAPI =
function() {
	AjxDispatcher.setPackageLoadFunction("BriefcaseCore", new AjxCallback(this, this._postLoadCore));
	AjxDispatcher.setPackageLoadFunction("Briefcase", new AjxCallback(this, this._postLoad, ZmOrganizer.BRIEFCASE));
	AjxDispatcher.registerMethod("GetBriefcaseController", ["BriefcaseCore", "Briefcase"], new AjxCallback(this, this.getBriefcaseController));
};

ZmBriefcaseApp.prototype._registerOperations =
function() {
	ZmOperation.registerOp(ZmId.OP_NEW_BRIEFCASE, {textKey:"newBriefcase", image:"NewFolder", tooltipKey:"newBriefcaseTooltip", shortcut:ZmKeyMap.NEW_BRIEFCASE});
	ZmOperation.registerOp(ZmId.OP_NEW_FILE, {textKey:"uploadNewFile", tooltipKey:"uploadNewFile", textPrecedence:70, showImageInToolbar:true, showTextInToolbar:true});
	ZmOperation.registerOp(ZmId.OP_NEW_DOC, {textKey:"newDocument", tooltipKey:"newDocument", image:"NewDoc", shortcut:ZmKeyMap.NEW_DOC, textPrecedence:12});
	ZmOperation.registerOp(ZmId.OP_SHARE_BRIEFCASE, {textKey:"shareFolder", image:"SharedMailFolder"}, ZmSetting.SHARING_ENABLED);
	ZmOperation.registerOp(ZmId.OP_OPEN_FILE, {textKey:"openFile", tooltipKey:"openFileTooltip", image:"NewDoc"});
	ZmOperation.registerOp(ZmId.OP_SAVE_FILE, {textKey:"saveFile", tooltipKey:"saveFileTooltip", image:"DownArrow"});
	ZmOperation.registerOp(ZmId.OP_VIEW_FILE_AS_HTML, {textKey:"viewFileAsHtml", tooltipKey:"viewAsHtml", image:"HtmlDoc"});
	ZmOperation.registerOp(ZmId.OP_SEND_FILE, {textKey:"sendLink", tooltipKey:"sendLink", image:"Send"});
	ZmOperation.registerOp(ZmId.OP_SEND_FILE_AS_ATT, {textKey:"sendAsAttachment", tooltipKey:"sendAsAttachment", image:"Attachment"});
	ZmOperation.registerOp(ZmId.OP_SEND_FILE_MENU, {textKey:"send", image:"Send", textPrecedence:75});
    ZmOperation.registerOp(ZmId.OP_EDIT_FILE, {textKey: "edit", image:"Edit"});
    ZmOperation.registerOp(ZmId.OP_RENAME_FILE, {textKey: "rename", image:"FileRename"});
    ZmOperation.registerOp(ZmId.OP_CHECKIN, {textKey: "checkInFile", image:"Checkin"});
    ZmOperation.registerOp(ZmId.OP_CHECKOUT, {textKey: "checkOutFile", image:"Checkout"});
    ZmOperation.registerOp(ZmId.OP_DISCARD_CHECKOUT, {textKey: "checkOutFileDiscard", image:"DiscardCheckout"});    
    ZmOperation.registerOp(ZmId.OP_VERSION_HISTORY, {textKey: "versionHistory", image:"VersionHistory"});
    ZmOperation.registerOp(ZmId.OP_RESTORE_VERSION, {textKey: "restoreCurrentVersion", image:"RestoreVersion"});
    ZmOperation.registerOp(ZmId.OP_DELETE_VERSION, {textKey: "deleteVersion", image:"Delete"});
};

ZmBriefcaseApp.prototype._registerSettings =
function(settings) {
	settings = settings || appCtxt.getSettings();
	settings.registerSetting("DOCS_ENABLED",		{name:"zimbraFeatureBriefcaseDocsEnabled", type:ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue:true});
    settings.registerSetting("PREVIEW_ENABLED",		{ type:ZmSetting.T_COS, dataType: ZmSetting.D_BOOLEAN, defaultValue:false});
	settings.registerSetting("READING_PANE_LOCATION_BRIEFCASE",		{name:"zimbraPrefBriefcaseReadingPaneLocation", type:ZmSetting.T_PREF, dataType:ZmSetting.D_STRING, defaultValue:ZmSetting.RP_BOTTOM, isImplicit:true});
};

ZmBriefcaseApp.prototype._registerItems =
function() {
	ZmItem.registerItem(ZmItem.BRIEFCASE_ITEM,
						{app:			ZmApp.BRIEFCASE,
						 nameKey:		"file",
						 icon:			"GenericDoc",
						 soapCmd:		"ItemAction",
						 itemClass:		"ZmBriefcaseItem",
						 node:			"doc",
						 organizer:		ZmOrganizer.BRIEFCASE,
						 dropTargets:	[ZmOrganizer.TAG, ZmOrganizer.BRIEFCASE],
						 searchType:	"document",
						 resultsList:
		AjxCallback.simpleClosure(function(search) {
            AjxDispatcher.require("BriefcaseCore");
			return new ZmList(ZmItem.BRIEFCASE_ITEM, search);
		}, this)
						});
};

ZmBriefcaseApp.prototype._registerOrganizers =
function() {
	ZmOrganizer.registerOrg(ZmOrganizer.BRIEFCASE,
							{app            : ZmApp.BRIEFCASE,
							 nameKey        : "folder",
							 defaultFolder  : ZmOrganizer.ID_BRIEFCASE,
							 soapCmd        : "FolderAction",
							 firstUserId    : 256,
							 orgClass       : "ZmBriefcase",
							 orgPackage     : "BriefcaseCore",
							 treeController : "ZmBriefcaseTreeController",
							 labelKey       : "briefcaseFolders",
							 itemsKey       : "files",
							 treeType       : ZmOrganizer.FOLDER,
							 views          : ["document"],
							 folderKey      : "briefcase",                                                      
							 mountKey       : "mountFolder",
							 createFunc     : "ZmOrganizer.create",
							 compareFunc    : "ZmFolder.sortCompareNonMail",
							 deferrable     : true,
							 newOp			: ZmOperation.NEW_BRIEFCASE,
							 displayOrder	: 100,
							 hasColor       : true,
							 defaultColor	: ZmOrganizer.C_NONE,
							 childWindow    : true
							});
};

ZmBriefcaseApp.prototype._setupSearchToolbar =
function() {
	//TODO:search for page alone
	ZmSearchToolBar.addMenuItem(ZmItem.BRIEFCASE_ITEM,
								{msgKey:		"files",
								 tooltipKey:	"searchForFiles",
								 icon:			"Doc",
								 shareIcon:		null, // the following doesn't work now, so keep the regular icon. doesn't really matter in my opinion --> "SharedBriefcase",
								 setting:		ZmSetting.BRIEFCASE_ENABLED,
								 id:			ZmId.getMenuItemId(ZmId.SEARCH, ZmId.ITEM_BRIEFCASE),
								 disableOffline:true
								});
};

ZmBriefcaseApp.prototype._registerApp =
function() {
	var newItemOps = {};
	newItemOps[ZmOperation.NEW_DOC]			= "document";

	var newOrgOps = {};
	newOrgOps[ZmOperation.NEW_BRIEFCASE]	 = "briefcase";

	var actionCodes = {};
	actionCodes[ZmKeyMap.NEW_FILE]			= ZmOperation.NEW_FILE;
	actionCodes[ZmKeyMap.NEW_BRIEFCASE]		= ZmOperation.NEW_BRIEFCASE;
	actionCodes[ZmKeyMap.NEW_DOC]			= ZmOperation.NEW_DOC;

	ZmApp.registerApp(ZmApp.BRIEFCASE,
					 {mainPkg:				"Briefcase",
					  nameKey:				"briefcase",
					  icon:					"Briefcase",
					  textPrecedence:		30,
					  chooserTooltipKey:	"gotoBriefcase",
					  defaultSearch:		ZmItem.BRIEFCASE_ITEM,
					  organizer:			ZmOrganizer.BRIEFCASE,
					  overviewTrees:		[ZmOrganizer.BRIEFCASE, ZmOrganizer.TAG],
					  searchTypes:			[ZmItem.BRIEFCASE_ITEM],
					  newItemOps:			newItemOps,
					  newOrgOps:			newOrgOps,
					  actionCodes:			actionCodes,
					  gotoActionCode:		ZmKeyMap.GOTO_BRIEFCASE,
					  newActionCode:		ZmKeyMap.NEW_DOC,
					  chooserSort:			70,
					  defaultSort:			60,
					  searchResultsTab:		true
					  });
};

// App API

/**
 * Checks for the creation of a briefcase or a mount point to one, or of an item
 *
 * @param {Hash}	creates		a hash of create notifications
 * 
 * @private
 */
ZmBriefcaseApp.prototype.createNotify =
function(creates, force) {

	if (!creates["folder"] && !creates["doc"] && !creates["link"]) { return; }
	if (!force && !this._noDefer && this._deferNotifications("create", creates)) { return; }

	for (var name in creates) {
		var clist = creates[name];
		for (var i = 0; (clist != null) && i < clist.length; i++) {
			var create = clist[i];
			if (appCtxt.cacheGet(create.id)) { continue; }

			if (name == "folder") {
				this._handleCreateFolder(create, ZmOrganizer.BRIEFCASE);
			} else if (name == "link") {
				this._handleCreateLink(create, ZmOrganizer.BRIEFCASE);
			} else if (name == "doc") {
				var bc = AjxDispatcher.run("GetBriefcaseController");
                bc.handleCreateNotify(create);
			}
		}
	}
};

ZmBriefcaseApp.prototype.modifyNotify =
function(modifies, force) {
    if (!modifies["doc"]) { return; }
	var bc = AjxDispatcher.run("GetBriefcaseController");
    bc.handleModifyNotify(modifies);
};

ZmBriefcaseApp.prototype.handleOp =
function(op) {

	switch (op) {
		case ZmOperation.NEW_FILE: {
			var loadCallback = new AjxCallback(this, this._handleNewItem);
			AjxDispatcher.require(["BriefcaseCore", "Briefcase"], false, loadCallback, null, true);
			break;
		}
		case ZmOperation.NEW_BRIEFCASE: {
			var loadCallback = new AjxCallback(this, this._handleLoadNewBriefcase);
			AjxDispatcher.require(["BriefcaseCore", "Briefcase"], false, loadCallback, null, true);
			break;
		}

		case ZmOperation.NEW_DOC: {
			var newDocCallback = new AjxCallback(this, this.newDoc, [ZmMimeTable.APP_ZIMBRA_DOC]);
			AjxDispatcher.require(["BriefcaseCore", "Briefcase"], true, newDocCallback, null);
			break;
		}
	}
};

/**
 * Creates a new document.
 * 
 * @param	{String}	contentType		the content type
 * @param	{String}	new				the document name
 * @param	{String}	winName			the name of the popup doc window
 */
ZmBriefcaseApp.prototype.newDoc =
function(contentType, name, winName) {
	var overviewController = appCtxt.getOverviewController();
	var treeController = overviewController.getTreeController(ZmOrganizer.BRIEFCASE);
	var folderId = ZmOrganizer.ID_BRIEFCASE;
	if (treeController) {
		var treeView = treeController.getTreeView(this.getOverviewId());
		var briefcase = treeView ? treeView.getSelected() : null;
		folderId = briefcase ? briefcase.id : ZmOrganizer.ID_BRIEFCASE;
	}

    if (AjxDispatcher.run("GetBriefcaseController").chkFolderPermission(folderId)) {
        if (contentType == ZmMimeTable.APP_ZIMBRA_DOC) {
            var win = appCtxt.getNewWindow(false, null, null, winName);
	        if (win) {
	            win.command = "documentEdit";
	            win.params = { name: name, folderId: folderId };
	        }
        }
    }
};

/**
 * Gets the popup doc window features.
 * 
 * @return	{String}	 the window features
 */
ZmBriefcaseApp.getDocWindowFeatures =
function() {
    return [
        "width=",(screen.width || 640),",",
        "height=",(screen.height || 480),",",
        "scrollbars=yes,",
        "resizable=yes"
    ].join("");
};

ZmBriefcaseApp.prototype._handleNewItem =
function() {
	appCtxt.getAppViewMgr().popView(true, ZmId.VIEW_LOADING);	// pop "Loading..." page
	AjxDispatcher.run("GetBriefcaseController").__popupUploadDialog(ZmMsg.uploadFileToBriefcase);
};

ZmBriefcaseApp.prototype._handleLoadNewBriefcase =
function() {
	appCtxt.getAppViewMgr().popView(true, ZmId.VIEW_LOADING); // pop "Loading..." page

	if (!this._newBriefcaseCb) {
		this._newBriefcaseCb = this._newBriefcaseCallback.bind(this);
	}
	ZmController.showDialog(appCtxt.getNewBriefcaseDialog(), this._newBriefcaseCb);
};


// Public methods

ZmBriefcaseApp.prototype.launch =
function(params, callback) {
	this._setLaunchTime(this.toString(), new Date());
	var loadCallback = this._handleLoadLaunch.bind(this, callback);
	AjxDispatcher.require(["BriefcaseCore","Briefcase"], true, loadCallback, null, true);

    // In case of external sharing we replace drop down button options with New Document button
    if (appCtxt.isExternalAccount()) {
        var newButton = appCtxt.getAppController().getNewButton();
        newButton.removePullDownMenuOptions();
    }
};

ZmBriefcaseApp.prototype._handleLoadLaunch =
function(callback) {
	this.search();
	if (callback) { callback.run(); }
};

ZmBriefcaseApp.prototype.getNewButtonProps =
function() {
	return {
		text:		ZmMsg.newDocument,
		tooltip:	ZmMsg.newDocument,
		icon:		"NewDoc",
		iconDis:	"NewDocDis",
		defaultId:	ZmOperation.NEW_DOC,
        disabled:	!this.containsWritableFolder()
	};
};

/**
 * Performs a search.
 * 
 * @param {Hash}	params			a hash of parameters
 * @param {String}	params.folderId			the ID of briefcase folder to search in
 * @param {String}	[params.query]				the query to send (overrides folderId)
 * @param {AjxCallback}	[params.callback]			the callback
 * @param {String}	[params.accountName]		the account name
 * @param {Boolean}	[params.noRender]			if <code>true</code>, do not display results
 */
ZmBriefcaseApp.prototype.search =
function(params) {

	params = params || {};
    var folderId = params.folderId || (appCtxt.isExternalAccount() ? this.getDefaultFolderId() : ZmOrganizer.ID_BRIEFCASE);
	var folder = appCtxt.getById(folderId);

	var searchParams = {
		query:			params.query || folder.createQuery(),
		types:			[ZmItem.BRIEFCASE_ITEM],
		limit:			this.getLimit(),
		searchFor:		ZmId.ITEM_BRIEFCASE,
		callback:		params.callback,
		accountName:	params.accountName,
		noRender:		params.noRender
	};
	var sc = appCtxt.getSearchController();
	sc.searchAllAccounts = false;
	sc.search(searchParams);
};

/**
 * Shows the search results.
 * 
 * @param	{Object}	results	the results
 * @param	{AjxCallback}	callback		the callback
 */
ZmBriefcaseApp.prototype.showSearchResults =
function(results, callback, searchResultsController) {
	var loadCallback = this._handleLoadShowSearchResults.bind(this, results, callback, searchResultsController);
	AjxDispatcher.require(["BriefcaseCore", "Briefcase"], false, loadCallback, null, true);
};

ZmBriefcaseApp.prototype._handleLoadShowSearchResults =
function(results, callback, searchResultsController) {
	var sessionId = searchResultsController ? searchResultsController.getCurrentViewId() : ZmApp.MAIN_SESSION;
	var controller = AjxDispatcher.run("GetBriefcaseController", sessionId, searchResultsController);
	controller.show(results);
	this._setLoadedTime(this.toString(), new Date());
	if (callback) {
		callback.run(controller);
	}
};

ZmBriefcaseApp.prototype.setActive =
function(active) {
};

// return enough for us to get a scroll bar since we are pageless
/**
 * Gets the limit for the search triggered by the application launch or an overview click.
 * 
 * @param	{Boolean}	offset	if <code>true</code> app has offset
 * @return	{int}	the limit
 */
ZmBriefcaseApp.prototype.getLimit =
function(offset) {
	var limit = appCtxt.get(ZmSetting.PAGE_SIZE);
	return offset ? limit : 2 * limit;
};

ZmBriefcaseApp.prototype._newBriefcaseCallback =
function(parent, name, color) {
	appCtxt.getNewBriefcaseDialog().popdown();
	var oc = appCtxt.getOverviewController();
	oc.getTreeController(ZmOrganizer.BRIEFCASE)._doCreate(parent, name, color);
};

ZmBriefcaseApp.prototype.getBriefcaseController =
function(sessionId, searchResultsController) {
	return this.getSessionController({controllerClass:			"ZmBriefcaseController",
									  sessionId:				sessionId || ZmApp.MAIN_SESSION,
									  searchResultsController:	searchResultsController});
};

ZmBriefcaseApp.prototype.createFromAttachment =
function(msgId, partId,name) {
	var loadCallback = new AjxCallback(this, this._handleCreateFromAttachment, [msgId, partId, name]);
	AjxDispatcher.require(["BriefcaseCore","Briefcase"], false, loadCallback);
};

ZmBriefcaseApp.prototype._handleCreateFromAttachment =
function(msgId, partId, name) {
	if (this._deferredFolders.length != 0) {
		this._createDeferredFolders(ZmApp.BRIEFCASE);
	}
    AjxDispatcher.run("GetBriefcaseController").createFromAttachment(msgId, partId, name);
};


//Make sure we load BriefcaseCore before calling _creatDeferredFolders() from child window.
ZmBriefcaseApp.prototype._createDeferredFolders =
function(type) {
	AjxPackage.require("BriefcaseCore");
	ZmApp.prototype._createDeferredFolders.call(this, type);
};



// --- Briefcase External DnD upload initiation

ZmBriefcaseApp.prototype.initExternalDndUpload = function(files, node, isInline, selectionCallback, folderId) {
	var name = "";

	if (!AjxEnv.supportsHTML5File) {
		// IE, FF 3.5 and lower - use the File browser
		if (selectionCallback) {
			selectionCallback.run();
		}
		return;
	}

	if (!files) {
		files = node.files;
	}

	var size = 0;
	if (files) {
		var file;
		var docFiles = [];
		var errors   = {};
		var aCtxt    = ZmAppCtxt.handleWindowOpener();
		var maxSize  = aCtxt.get(ZmSetting.DOCUMENT_SIZE_LIMIT);
		var briefcaseController = AjxDispatcher.run("GetBriefcaseController");

		if (!folderId) {
			if (briefcaseController) {
				folderId = briefcaseController.getFolderId();
			}
			if(!folderId || folderId == ZmOrganizer.ID_TRASH) {
				folderId = ZmOrganizer.ID_BRIEFCASE;
			}
		}

		if(this.chkFolderPermission(folderId)){
			var cFolder = appCtxt.getById(folderId);
			var uploadManager = appCtxt.getZmUploadManager();

			var errors = [];
			for (var i = 0; i < files.length; i++){
				var newError = uploadManager.getErrors(files[i], maxSize);
				if (newError) {
					errors.push(newError);
				}
			}
			if (errors.length > 0) {
				var errorMsg = uploadManager.createUploadErrorMsg(errors, maxSize, "<br>");
				var msgDlg = appCtxt.getMsgDialog();
				msgDlg.setMessage(errorMsg, DwtMessageDialog.WARNING_STYLE);
				msgDlg.popup();
			} else {
				var params = {
					attachment:              false,
					uploadFolder:            cFolder,
					files:                   files,
					notes:                   "",
					allResponses:            null,
					start:                   0,
					curView:                 null,
					preAllCallback:          null,
					initOneUploadCallback:   null,
					progressCallback:        null,
					errorCallback:           null,
					completeOneCallback:     null,
					completeAllCallback:     this.uploadSaveDocs.bind(this),
					completeDocSaveCallback: this._finishUpload.bind(this, null)
				}
				uploadManager.upload(params);
			}
		}
	}
};

ZmBriefcaseApp.prototype.chkFolderPermission = function(folderId){
	var briefcase = appCtxt.getById(folderId);
	if(briefcase.isRemote() && briefcase.isReadOnly()){
		var dialog = appCtxt.getMsgDialog();
		dialog.setMessage(ZmMsg.errorPermissionCreate, DwtMessageDialog.WARNING_STYLE);
		dialog.popup();
		return false;
	}
	return true;
};

// --- Briefcase Upload Completion - SaveDocuments and Conflict resolution ------

/**
 * uploadSaveDocs performs SaveDocument calls, creating a document with an associated uploadId.  If the file
 * already exists, conflict resolution is performed.
 *
 * @param	{object}	params		params to customize the upload flow:
 *      uploadFolder                Folder to save associated document into
 *      files:                      raw File object from the external HTML5 drag and drop
 *      notes:                      Notes associated with each of the files being added
 *      allResponses:               All the server responses.  Contains the uploadId (guid) for a file
 *      errorCallback:              Run upon an error
 *      conflictAction			    If specified, the action used to resolve a file conflict
 *      preResolveConflictCallback: Standard processing (SaveDocument), Run prior to conflict resolution
 *      completeDocSaveCallback:    Standard processing (SaveDocument), Run when all documents have been saved
 *
 */
ZmBriefcaseApp.prototype.uploadSaveDocs = function(allResponses, params, status, guids) {
	if (status != AjxPost.SC_OK) {
		var errorMessage = appCtxt.getAppController().createErrorMessage(ZmItem.BRIEFCASE, status);
		this._popupErrorDialog(errorMessage, params.errorCallback);
	} else {
		var docFiles;
		if (allResponses) {
			// External DnD files
		    docFiles = [];
			var files    = params.files;
			if (allResponses.length === files.length) {
				for (var i = 0; i < files.length; i++){
					var file = files[i];
					var response = allResponses[i];
					var aid = (response && response.aid);
					docFiles.push(
						{name:     file.name,
						 fullname: file.name,
						 notes:    params.notes,
						 version:  file.version,
						 id:	   file.id,
						 guid:     aid,
						 preventDuplicate: file.preventDuplicate});
				}
				params.docFiles = docFiles;
			}
		} else {
			// AjxPost callback, providing the guids separately
			docFiles = params.docFiles;
			if (guids) {
				guids = guids.split(",");
				for (var i = 0; i < docFiles.length; i++) {
					DBG.println("guids[" + i + "]: " + guids[i] + ", files[" + i + "]: " + docFiles[i]);
					docFiles[i].guid = guids[i];
				}
			}
		}
		if (params.uploadFolder) {
			this._uploadSaveDocs2(params);
		} else {
			this._completeUpload(params);
		}
	}
};

ZmBriefcaseApp.prototype._popupErrorDialog = function(message, errorCallback) {
	if (errorCallback) {
		errorCallback.run();
	}
	var dialog = appCtxt.getMsgDialog();
	dialog.setMessage(message, DwtMessageDialog.CRITICAL_STYLE);
	dialog.popup();
};

ZmBriefcaseApp.prototype._uploadSaveDocs2 = function(params) {

	// create document wrappers
	var request = [];
	var foundOne = false;
	var docFiles = params.docFiles;
	for (var i = 0; i < docFiles.length; i++) {
		var file = docFiles[i];
		if (file.done) {
			continue;
		}
		foundOne = true;

		var SaveDocumentRequest = { _jsns: "urn:zimbraMail", requestId: i, doc: {}}
		var doc = SaveDocumentRequest.doc;
		if (file.id) {
			doc.id = file.id;
			doc.ver = file.version;
		} else {
			doc.l = params.uploadFolder.id;
		}
		if (file.notes) {
			doc.desc = file.notes;
		}
		doc.upload = {
			id: file.guid
		}
		request.push(SaveDocumentRequest);
	}

	if (foundOne) {
		var json = {
			BatchRequest: {
				_jsns: "urn:zimbra",
				onerror: "continue",
				SaveDocumentRequest: ( (request.length == 1) ? request[0] : request )
			}
		};
		var callback = this._uploadSaveDocsResponse.bind(this, params);
		var saveDocParams = {
			jsonObj:  json,
			asyncMode:true,
			callback: callback
		};
		var appController = appCtxt.getAppController();
		appController.sendRequest(saveDocParams);
	}
	else {
		// This calls the callback of the client - e.g. ZmHtmlEditor.prototype._imageUploaded since
		// _uploadSaveDocsResponse is not called in this case, we still need the client callback since the
		// user chose the "old" version of the image
		this._completeUpload(params);
	}
};

ZmBriefcaseApp.prototype._uploadSaveDocsResponse = function(params, response) {
	var resp = response && response._data && response._data.BatchResponse;
	var docFiles = params.docFiles;

	// mark successful uploads
	if (resp && resp.SaveDocumentResponse) {
		for (var i = 0; i < resp.SaveDocumentResponse.length; i++) {
			var saveDocResp = resp.SaveDocumentResponse[i];
			docFiles[saveDocResp.requestId].done    = true;
			docFiles[saveDocResp.requestId].name    = saveDocResp.doc[0].name;
			docFiles[saveDocResp.requestId].id      = saveDocResp.doc[0].id;
			docFiles[saveDocResp.requestId].ver     = saveDocResp.doc[0].ver;
			docFiles[saveDocResp.requestId].version = saveDocResp.doc[0].ver;
		}
	}

	// check for conflicts
	var mailboxQuotaExceeded = false;
	var alreadyExists = false;
	var uploadRejected = false;
	var isItemLocked = false;
	var code = 0;
	var conflicts = [];
	if (resp && resp.Fault) {
		var errors = [];
		var uploadRejected = false, rejectedFile = "Unknown", rejectedReason = "Unknown";
		for (var i = 0; i < resp.Fault.length; i++) {
			var fault = resp.Fault[i];
			var error = fault.Detail.Error;
			code = error.Code;
			var attrs = error.a;
			isItemLocked = (code == ZmCsfeException.LOCKED);
			var file = docFiles[fault.requestId];
			if ((code == ZmCsfeException.MAIL_ALREADY_EXISTS) && file.preventDuplicate) {
				alreadyExists = true;
			} else if (code == ZmCsfeException.MAIL_ALREADY_EXISTS ||
				code == ZmCsfeException.MODIFY_CONFLICT) {
				for (var p in attrs) {
					var attr = attrs[p];
					switch (attr.n) {
						case "itemId" : { file.id      = attr._content; break }
						case "id":      { file.id      = attr._content; break; }
						case "ver":     { file.version = attr._content; break; }
						case "name":    { file.name    = attr._content; break; }
					}
				}
				file.version = file.version || 1;
				conflicts.push(file);
			}else {
				DBG.println("Unknown error occurred: " + code);
				if (code == ZmCsfeException.MAIL_QUOTA_EXCEEDED) {
					mailboxQuotaExceeded = true;
				}  else if (code === ZmCsfeException.UPLOAD_REJECTED) {
					uploadRejected = true;
					for (var p in attrs) {
						var attr = attrs[p];
						switch (attr.n) {
							case "reason" : rejectedReason = attr._content; break;
							case "name":    rejectedFile   = attr._content; break;
						}
					}
				}

				errors[fault.requestId] = fault;
			}
		}
	}

	// dismiss dialog/enable the upload button
	if (params.preResolveConflictCallback) {
		params.preResolveConflictCallback.run();
	}

	// TODO: What to do about other errors?
	// TODO: This should handle reporting several errors at once
	if (mailboxQuotaExceeded) {
		this._popupErrorDialog(ZmMsg.errorQuotaExceeded, params.errorCallback);
		return;
	} else 	if (alreadyExists) {
		this._popupErrorDialog(AjxMessageFormat.format(ZmMsg.itemWithFileNameExits, file.name), params.errorCallback);
		return;
	} else if (isItemLocked) {
		this._popupErrorDialog(ZmMsg.errorItemLocked, params.errorCallback);
		return;
	} else if (uploadRejected) {
		var rejectedMsg = AjxMessageFormat.format(ZmMsg.uploadRejectedError, [ rejectedFile, rejectedReason ] );
		this._popupErrorDialog(rejectedMsg, params.errorCallback);
		return;
	}
	else if (code == ZmCsfeException.SVC_PERM_DENIED) {
		this._popupErrorDialog(ZmMsg.errorPermissionDenied, params.errorCallback);
		return;
	}

	// resolve conflicts
	var conflictCount = conflicts.length;

	var action = params.conflictAction || ZmBriefcaseApp.ACTION_KEEP_MINE;
	if (conflictCount > 0 && action == ZmBriefcaseApp.ACTION_ASK) {
		var dialog = appCtxt.getUploadConflictDialog();
		dialog.popup(params.uploadFolder, conflicts, this._uploadSaveDocs2.bind(this, params));
	} else if (conflictCount > 0 && action == ZmBriefcaseApp.ACTION_KEEP_MINE) {
		if (params.conflictAction) {
			this._shieldSaveDocs(params);
		} else {
			this._uploadSaveDocs2(params);
		}
	} else {
		this._completeUpload(params);
	}
};

ZmBriefcaseApp.prototype._shieldSaveDocs = function(params) {
	var dlg = appCtxt.getYesNoMsgDialog();
	dlg.reset();
	dlg.setButtonListener(DwtDialog.YES_BUTTON, new AjxListener(this, this._shieldSaveDocsYesCallback, [dlg, params]));
	dlg.setMessage(ZmMsg.uploadConflictShield, DwtMessageDialog.WARNING_STYLE, ZmMsg.uploadConflict);
	dlg.popup();
};

ZmBriefcaseApp.prototype._shieldSaveDocsYesCallback = function(dlg, params) {
	this._uploadSaveDocs2(params);
	dlg.popdown();
};

ZmBriefcaseApp.prototype._completeUpload = function(params) {
	if (params.completeDocSaveCallback) {
		params.completeDocSaveCallback.run(params.docFiles, params.uploadFolder);
	}
};

ZmBriefcaseApp.prototype._finishUpload = function(finishCallback, docFiles, uploadFolder) {
	var filenames = [];
	for (var i in docFiles) {
		var name = docFiles[i].name;
		filenames.push(name);
	}
	this._handlePostUpload(uploadFolder, filenames, docFiles);

	if (finishCallback) {
		finishCallback(docFiles);
	}
};

ZmBriefcaseApp.prototype._handlePostUpload = function(folder, filenames, files) {
	var msg = ZmMsg.successfullyUploaded;
	if(files.length > 1){
		msg = AjxMessageFormat.format(ZmMsg.successfullyUploadedFiles, files.length);
	}
	appCtxt.setStatusMsg(msg, ZmStatusView.LEVEL_INFO);
	// Remove the previous selection(s)
	var briefcaseController = AjxDispatcher.run("GetBriefcaseController");
	briefcaseController.resetSelection();
};



ZmBriefcaseApp.ACTION_KEEP_MINE = "mine";
ZmBriefcaseApp.ACTION_KEEP_THEIRS = "theirs";
ZmBriefcaseApp.ACTION_ASK = "ask";


}

if (AjxPackage.define("zimbraMail.share.view.ZmFolderChooser")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @class
 * This is a folder choosing widget designed to be displayed as a dropdown hanging off a menu. Other than
 * that, it works mostly like ZmChooseFolderDialog. Instead of a New button, it has a "New Folder" menu item
 * at the bottom. Items are moved when a menu item is clicked, instead of the OK button in the dialog.
 * 
 * The implementation mostly relies on calling ZmChooseFolderDialog and ZmDialog methods, since those were
 * already written. A cleaner implementation would probably include a base widget that this and the dialog
 * would use.
 *
 * @author Eran Yarkon
 *
 * @param {hash}		params			a hash of parameters
 * @param {DwtComposite}      params.parent			the parent widget
 * @param {string}      params.className			the CSS class
 * @param {constant}      params.posStyle			the positioning style (see {@link Dwt})
 *
 * @extends		DwtComposite
 */
ZmFolderChooser = function(params) {
	if (arguments.length == 0) { return; }
	params.className = params.className || "ZmFolderChooser";
	DwtComposite.call(this, params);

	this._overview = {};
	this._opc = appCtxt.getOverviewController();
	this._treeView = {};
	this._folderTreeDivId = this._htmlElId + "_folderTreeDivId";

	this._uuid = Dwt.getNextId();

	AjxDispatcher.require("Extras");	// ZmChooseFolderDialog
	this._changeListener = ZmChooseFolderDialog.prototype._folderTreeChangeListener.bind(this);
	this._treeViewListener = this._treeViewSelectionListener.bind(this);

	var moveMenu = params.parent;
	moveMenu._addItem(this, params.index); //this is what DwtMenuItem does. Allows this item to be in the menu items table - better for layout purposes such as consistent widths
	this._moveOnFolderCreate = true;
	
	if (!params.hideNewButton) {
		//add separator menu item on the move menu (the parent)
		new DwtMenuItem({parent:moveMenu, style:DwtMenuItem.SEPARATOR_STYLE});
	
		// add New button
		var newFolderItem = this._newButton = new DwtMenuItem({parent:moveMenu, id: moveMenu.getHTMLElId() + "|NEWFOLDER"});
		var appName = appCtxt.getCurrentAppName();	
		var defaultApp = ZmApp.MAIL;
		var newTextKey = ZmFolderChooser.NEW_ORG_KEY[appName] || ZmFolderChooser.NEW_ORG_KEY[defaultApp];
		var newImage = ZmFolderChooser.NEW_ORG_ICON[appName] || ZmFolderChooser.NEW_ORG_ICON[defaultApp];
		var newShortcut = ZmFolderChooser.NEW_ORG_SHORTCUT[appName];
		newFolderItem.setText(ZmMsg[newTextKey]);
		newFolderItem.setImage(newImage);
		if (newShortcut) {
			newFolderItem.setShortcut(appCtxt.getShortcutHint(this._keyMap, newShortcut));
		}
		newFolderItem.addSelectionListener(this._showNewDialog.bind(this));
	}

	this._init();
};

ZmFolderChooser.prototype = new DwtComposite;
ZmFolderChooser.prototype.constructor = ZmFolderChooser;

ZmFolderChooser.prototype.isZmFolderChooser = true;
ZmFolderChooser.prototype.toString = function() { return "ZmFolderChooser"; };


// Properties for New button at bottom
ZmFolderChooser.NEW_ORG_KEY = {};
ZmFolderChooser.NEW_ORG_KEY[ZmApp.MAIL]				= "newFolder";
ZmFolderChooser.NEW_ORG_KEY[ZmApp.CONTACTS]			= "newAddrBook";
ZmFolderChooser.NEW_ORG_KEY[ZmApp.CALENDAR]			= "newCalendar";
ZmFolderChooser.NEW_ORG_KEY[ZmApp.TASKS]			= "newTaskFolder";

ZmFolderChooser.NEW_ORG_ICON = {};
ZmFolderChooser.NEW_ORG_ICON[ZmApp.MAIL]			= "NewFolder";
ZmFolderChooser.NEW_ORG_ICON[ZmApp.CONTACTS]		= "NewContactsFolder";
ZmFolderChooser.NEW_ORG_ICON[ZmApp.CALENDAR]		= "NewAppointment";
ZmFolderChooser.NEW_ORG_ICON[ZmApp.TASKS]			= "NewTaskList";

ZmFolderChooser.NEW_ORG_SHORTCUT = {};
ZmFolderChooser.NEW_ORG_SHORTCUT[ZmApp.MAIL]		= ZmKeyMap.NEW_FOLDER;
ZmFolderChooser.NEW_ORG_SHORTCUT[ZmApp.CALENDAR]	= ZmKeyMap.NEW_CALENDAR;

/**
 *
 * see ZmChooseFolderDialog.prototype.popup
 */
ZmFolderChooser.prototype.setupFolderChooser =
function(params, selectionCallback) {

	this._selectionCallback = selectionCallback;
	this._overviewId = params.overviewId;

	ZmChooseFolderDialog.prototype.popup.call(this, params, true);
};

ZmFolderChooser.prototype._getNewButton =
function () {
	return this._newButton;
};

ZmFolderChooser.prototype.updateData =
function(data) {
	this._data = data;
};

ZmFolderChooser.prototype._focus =
function() {
	var overview = this._overview[this._overviewId];
	if (overview) {
		overview.focus();
	}
};

/**
 * this is not really doing the popup, just setting more stuff up, but to reuse the caller (ZmChooseFolderDialog.prototype.popup)
 * from ZmChooseFolderDialog, I had to keep the name.
 *
 * @param params
 */
ZmFolderChooser.prototype._doPopup =
function(params) {
	ZmChooseFolderDialog.prototype._doPopup.call(this, params, true);
};


/**
 * this reuses ZmDialog stuff. With slight necessary changes. Might be fragile if this is changed in ZmDialog
 * in which case we might be better off with copy-paste. but for now it works.
 * 
 * @param params
 * @param forceSingle
 */
ZmFolderChooser.prototype._setOverview =
function(params, forceSingle) {
	params.overviewClass = "menuOverview";
	params.dynamicWidth = true;

	var overview = ZmDialog.prototype._setOverview.call(this, params, forceSingle); //reuse from ZmDialog

	if (!appCtxt.multiAccounts || forceSingle) {
		//this  is needed for some reason
		this._overview[params.overviewId] = overview;
	}

	return overview;
};

/**
 * delegate to ZmDialog. called from ZmDialog.prototype._setOverview (which we delegate to from ZmFolderChooser.prototype._setOverview)
 */
ZmFolderChooser.prototype._renderOverview =
function() {
	ZmDialog.prototype._renderOverview.apply(this, arguments); //reuse code from ZmDialog
};

/**
 * delegate to ZmDialog.
 */
ZmFolderChooser.prototype._setRootSelection =
function() {
	ZmDialog.prototype._setRootSelection.apply(this, arguments); //reuse code from ZmDialog
};


/**
 * delegate to ZmDialog. called from ZmDialog.prototype._setOverview (which we delegate to from ZmFolderChooser.prototype._setOverview)
 */
ZmFolderChooser.prototype._makeOverviewVisible =
function() {
	ZmDialog.prototype._makeOverviewVisible.apply(this, arguments); //reuse code from ZmDialog
};

ZmFolderChooser.prototype._resetTree =
function(treeIds, overview) {
	ZmChooseFolderDialog.prototype._resetTree.call(this, treeIds, overview);
};

ZmFolderChooser.prototype._getOverview =
function() {
	return ZmChooseFolderDialog.prototype._getOverview.call(this)
};

ZmFolderChooser.prototype._treeViewSelectionListener =
function(ev) {
	if (ev.detail != DwtTree.ITEM_SELECTED) {
		return;
	}
	//set in DwtTree.prototype._itemClicked and DwtTree.prototype.setSelection (which is called by DwtTreeItem.prototype.handleKeyAction)
	if (!ev.clicked && !ev.enter) {
		return;
	}

	//I kept this logic from ZmChooseFolderDialog.prototype._treeViewSelectionListener. Not sure what it means exactly
	if (this._getOverview() instanceof ZmAccountOverviewContainer) {
		if (ev.item instanceof DwtHeaderTreeItem) {
			return;
		}

		var oc = this._opc.getOverviewContainer(this._curOverviewId);
		var overview = oc.getOverview(ev.item.getData(ZmTreeView.KEY_ID));
		oc.deselectAll(overview);
	}

	var organizer = ev.item && ev.item.getData(Dwt.KEY_OBJECT);
	if (organizer.id == ZmFolder.ID_LOAD_FOLDERS) {
		return; // user clicked on "Show More Folders", it's not a real selection, it just expanded more folders.
	}
	var value = organizer ? organizer.getName(null, null, true) : ev.item.getText();
	this._lastVal = value.toLowerCase();
	this._doSelection();
};

/**
 * copied mostly from ZmChooseFolderDialog.prototype._okButtonListener  
 * @param tgtFolder
 */
ZmFolderChooser.prototype._doSelection =
function(tgtFolder) {
    tgtFolder = tgtFolder || this._getOverview().getSelected();
    if  (!tgtFolder) {
        tgtFolder = appCtxt.getById(this._selected);
    }
	var folderList = (tgtFolder && (!(tgtFolder instanceof Array)))
		? [tgtFolder] : tgtFolder;

	var msg = (!folderList || (folderList && folderList.length == 0))
		? ZmMsg.noTargetFolder : null;

	//todo - what is that? can you move stuff to multiple targets?  annotation on ZmChooseFolderDialog show it might be for filters on multiple folders. obviously in that case we can't have a drop down. we might have to keep that folder dialog
	
	// check for valid target
	if (!msg && this._data) {
		for (var i = 0; i < folderList.length; i++) {
			var folder = folderList[i];
			if (folder.mayContain && !folder.mayContain(this._data, null, this._acceptFolderMatch)) {
				if (this._data instanceof ZmFolder) {
					msg = ZmMsg.badTargetFolder;
				}
				else {
					var items = AjxUtil.toArray(this._data);
					for (var i = 0; i < items.length; i++) {
						var item = items[i];
						if (!item) {
							continue;
						}
						if (item.isDraft && (folder.nId != ZmFolder.ID_TRASH && folder.nId != ZmFolder.ID_DRAFTS && folder.rid != ZmFolder.ID_DRAFTS)) {
							// can move drafts into Trash or Drafts
							msg = ZmMsg.badTargetFolderForDraftItem;
							break;
						}
						else if ((folder.nId == ZmFolder.ID_DRAFTS || folder.rid == ZmFolder.ID_DRAFTS) && !item.isDraft)	{
							// only drafts can be moved into Drafts
							msg = ZmMsg.badItemForDraftsFolder;
							break;
						}
					}
					if (!msg) {
						msg = ZmMsg.badTargetFolderItems;
					}
				}
				break;
			}
		}
	}

	if (msg) {
		ZmDialog.prototype._showError.call(this, msg);
		return;
	}
	if (this._selectionCallback) {
		this._selectionCallback(tgtFolder);
	}
};

ZmFolderChooser.prototype._resetTreeView =
function(visible) {
	ZmChooseFolderDialog.prototype._resetTreeView.call(this, visible);
};

ZmFolderChooser.prototype.getOverviewId =
function(part) {
	return appCtxt.getOverviewId([this.toString(), part], null);
};

ZmFolderChooser.prototype._loadFolders =
function() {
	ZmChooseFolderDialog.prototype._loadFolders.call(this);
};

ZmFolderChooser.prototype._init =
function() {

	var html = [], idx = 0;

	html[idx++] =	"<table cellspacing='0' cellpadding='0' style='border-collapse:collapse;'>";
	html[idx++] =		"<tr><td><div id='" + this._folderTreeDivId + "'>";
	html[idx++] =		"</div></td></tr>";
	html[idx++] =	"</table>";

	this.getHtmlElement().innerHTML = html.join("");
};

ZmFolderChooser.prototype._showNewDialog =
function() {
	var item = this._getOverview().getSelected(true);
	var newType = (item && item.type) || this._treeIds[0];
	var ftc = this._opc.getTreeController(newType);
	var dialog = ftc._getNewDialog();
	dialog.reset();
	dialog.registerCallback(DwtDialog.OK_BUTTON, ZmChooseFolderDialog.prototype._newCallback, this, [ftc, dialog]);
	this.parent.popdown(); //pop it down so it doenst pop down when user clicks on the "new" dialog, confusing them. this is also consistent with the tag menu "new".
	dialog.popup();
};
}

if (AjxPackage.define("zimbraMail.calendar.model.ZmCalBaseItem")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines a base calendar item.
 *
 */

/**
 * @class
 * This class represents the base calendar item.
 * 
 * @param	{constant}	type	the item type
 * @param	{ZmList}	list		the list
 * @param	{String}	id		the id
 * @param	{String}	folderId	the folder id
 * @extends	ZmItem
 */
ZmCalBaseItem = function(type, list, id, folderId) {
	if (arguments.length == 0) { return; }

	ZmItem.call(this, type, id, list);

	this.id = id || -1;
	this.uid = -1; // iCal uid of appt
	this.folderId = folderId || this._getDefaultFolderId();
	this.fragment = "";
	this.name = "";
	this.allDayEvent = "0";
	this.startDate = null;
	this.endDate = null;
	this.timezone = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
	this.alarm = false;
	this.alarmData = null;
	this.isException = false;
	this.recurring = false;
	this.priority = null;
	this.ptst = null; // participant status
	this.status = ZmCalendarApp.STATUS_CONF;
	this._reminderMinutes = 0;
	this.otherAttendees = false;	
};

ZmCalBaseItem.prototype = new ZmItem;
ZmCalBaseItem.prototype.constructor = ZmCalBaseItem;
/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmCalBaseItem.prototype.toString =
function() {
	return "ZmCalBaseItem";
};


// consts
/**
 * Defines the "person" resource type.
 */
ZmCalBaseItem.PERSON				= "PERSON";
/**
 * Defines the "optional person" resource type.
 */
ZmCalBaseItem.OPTIONAL_PERSON		= "OPT_PERSON";
/**
 * Defines the "group" resource type.
 */
ZmCalBaseItem.GROUP					= "GROUP";
/**
 * Defines the "location" resource type.
 */
ZmCalBaseItem.LOCATION				= "LOCATION";
/**
 * Defines the "equipment" resource type.
 */
ZmCalBaseItem.EQUIPMENT				= "EQUIPMENT";
ZmCalBaseItem.FORWARD				= "FORWARD";

/**
 * Defines the "accept" participant status.
 */
ZmCalBaseItem.PSTATUS_ACCEPT		= "AC";			// vevent, vtodo
/**
 * Defines the "declined" participant status.
 */
ZmCalBaseItem.PSTATUS_DECLINED		= "DE";			// vevent, vtodo
/**
 * Defines the "deferred" participant status.
 */
ZmCalBaseItem.PSTATUS_DEFERRED		= "DF";			// vtodo					[outlook]
/**
 * Defines the "delegated" participant status.
 */
ZmCalBaseItem.PSTATUS_DELEGATED		= "DG";			// vevent, vtodo
/**
 * Defines the "needs action" participant status.
 */
ZmCalBaseItem.PSTATUS_NEEDS_ACTION	= "NE";			// vevent, vtodo
/**
 * Defines the "completed" participant status.
 */
ZmCalBaseItem.PSTATUS_COMPLETED		= "CO";			// vtodo
/**
 * Defines the "tentative" participant status.
 */
ZmCalBaseItem.PSTATUS_TENTATIVE		= "TE";			// vevent, vtodo
/**
 * Defines the "waiting" participant status.
 */
ZmCalBaseItem.PSTATUS_WAITING		= "WA";			// vtodo					[outlook]

ZmCalBaseItem.FBA_TO_PTST = {
	B: ZmCalBaseItem.PSTATUS_ACCEPT,
	F: ZmCalBaseItem.PSTATUS_DECLINED,
	T: ZmCalBaseItem.PSTATUS_TENTATIVE
};

ZmCalBaseItem._pstatusString = {
	NE: ZmMsg._new,
	TE: ZmMsg.tentative,
	AC: ZmMsg.accepted,
	DE: ZmMsg.declined,
	DG: ZmMsg.delegated
};

/**
 * Compares two appointments by start time and duration.
 *
 * @param {ZmCalBaseItem}	a		an appointment
 * @param {ZmCalBaseItem}	b		an appointment
 * @return	{int}	1 if start time "a" is after "b" or duration "a" is shorter than "b"; 1 if start time "b" is after "a" or duration "b" is shorter than "a"; 0 if both are the same 
 */
ZmCalBaseItem.compareByTimeAndDuration =
function(a, b) {
	if (a.getStartTime() > b.getStartTime()) 	return 1;
	if (a.getStartTime() < b.getStartTime()) 	return -1;
	if (a.getDuration() < b.getDuration()) 		return 1;
	if (a.getDuration() > b.getDuration()) 		return -1;
	return 0;
};

/**
 * Creates the item from the DOM.
 * 
 * @private
 */
ZmCalBaseItem.createFromDom =
function(apptNode, args, instNode) {
	var appt = new ZmCalBaseItem(ZmItem.APPT, args.list);
	appt._loadFromDom(apptNode, (instNode || {}));
	return appt;
};

/**
 * Gets the name (the "subject").
 * 
 * @return	{String}	the name
 */
ZmCalBaseItem.prototype.getName 		= function() { return this.name || ""; };			// name (aka Subject) of appt

/**
 * Gets the end time.
 * 
 * @return	{Date}	the end time
 */
ZmCalBaseItem.prototype.getEndTime 		= function() { return this.endDate.getTime(); }; 	// end time in ms

/**
 * Gets the start time.
 * 
 * @return	{Date}	the start time
 */
ZmCalBaseItem.prototype.getStartTime 	= function() { return this.startDate.getTime(); }; 	// start time in ms

/**
 * Gets the alarm instance start time
 *
 * @return	{Date}	the alarmInst time
 */
ZmCalBaseItem.prototype.getAlarmInstStart = function() { return this._alarmInstStart; }; 	// alarm inst time in ms

/**
 * Gets the duration.
 * 
 * @return	{int}	the duration (in milliseconds)
 */
ZmCalBaseItem.prototype.getDuration 	= function() { return this.getEndTime() - this.getStartTime(); } // duration in ms
/**
 * Gets the location.
 * 
 * @return	{String}	the location
 */
ZmCalBaseItem.prototype.getLocation		= function() { return this.location || ""; };
/**
 * Checks if the item is an all day event.
 * 
 * @return	{Boolean}	<code>true</code> if all day event
 */
ZmCalBaseItem.prototype.isAllDayEvent	= function() { return this.allDayEvent == "1"; };

/**
 * Gets the participant status as a string.
 * 
 * @return	{String}	the participant status
 */
ZmCalBaseItem.prototype.getParticipantStatusStr =
function() { 
	return ZmCalBaseItem._pstatusString[this.ptst]; 
};

/**
 * Gets the unique id for this item.
 * 
 * @param	{Boolean}	useStartTime	if <code>true</code>, use the start time
 * @return	{String}	the unique id
 */
ZmCalBaseItem.prototype.getUniqueId =
function(useStartTime) {
	if (useStartTime) {
		if (!this._startTimeUniqId) {
			this._startTimeUniqId = this.id + "_" + this.getStartTime();
		}
		return this._startTimeUniqId;
	} else {
		if (this._uniqId == null) {
			this._uniqId = Dwt.getNextId();
		}
		return (this.id + "_" + this._uniqId);
	}
};

/**
 * Checks if this item is multi-day.
 * 
 * @return	{Boolean}	<code>true</code> if start date and end date are on different days
 * 
 * @see		#getStartTime
 * @see		#getEndTime
 */
ZmCalBaseItem.prototype.isMultiDay =
function() {
	var start = this.startDate;
	var end = this.endDate;

    if(!start && !end) { return false; }

    if(!start) { return false; }

	if (end.getHours() == 0 && end.getMinutes() == 0 && end.getSeconds() == 0) {
		// if end is the beginning of day, then disregard that it
		// technically crossed a day boundary for the purpose of
		// determining if it is a multi-day appt
		end = new Date(end.getTime() - 2 * AjxDateUtil.MSEC_PER_HOUR);
	}

	return (start.getDate() != end.getDate()) ||
		   (start.getMonth() != end.getMonth()) ||
		   (start.getFullYear() != end.getFullYear());
};

/**
 * Gets the duration text.
 * 
 * @param	{Boolean}	emptyAllDay		if <code>true</code>, return empty string if all day event
 * @param	{Boolean}	startOnly		if <code>true</code>, use start date only
 * @param   {Boolean}   getSimpleText   if <code>true</code>, use the modified representation for duration where:
 * 1. For one day all day event we show only "All day" before event name and omit the Date information
 * 2. For multiday all day event we just show  final start/end date and omit time information and other words.
 * 3. For appt that entirely falls in one day we omit day and just show time.
 * 4. For multiday appt we show final start/end date&time
 * @return	{String}	the duration text
 */
ZmCalBaseItem.prototype.getDurationText =
function(emptyAllDay, startOnly, getSimpleText) {
	var isAllDay = this.isAllDayEvent();
	var isMultiDay = this.isMultiDay();
	var pattern;
	
	if (isAllDay) {
		if (emptyAllDay) return "";

		var start = this.startDate;
		var end = new Date(this.endDate.getTime() - (isMultiDay ? 2 * AjxDateUtil.MSEC_PER_HOUR : 0));	

		if (getSimpleText) {
			if (isMultiDay) {
				pattern = ZmMsg.apptTimeAllDayMultiCondensed;
			}
			else {
				return ZmMsg.allDay;
			}
		}
		else {
			pattern = isMultiDay ? ZmMsg.apptTimeAllDayMulti : ZmMsg.apptTimeAllDay;
		}
		return AjxMessageFormat.format(pattern, [start, end]);
	}

	if (startOnly) {
		return ZmCalBaseItem._getTTHour(this.startDate);
	}

	if (getSimpleText) {
		pattern = isMultiDay ? ZmMsg.apptTimeInstanceMultiCondensed : ZmMsg.apptTimeInstanceCondensed;
	}
	else {
		pattern = isMultiDay ? ZmMsg.apptTimeInstanceMulti : ZmMsg.apptTimeInstance;
	}
	
	return AjxMessageFormat.format(pattern, [this.getDateInLocalTimezone(this.startDate), this.getDateInLocalTimezone(this.endDate), ""]);
};

/**
 * Checks if alarm is in range (based on current time).
 * 
 * @return	{Boolean}	<code>true</code> if the alarm is in range
 */
ZmCalBaseItem.prototype.isAlarmInRange =
function() {
	if (!this.alarmData) { return false; }

	var alarmData = this.alarmData[0];
	
	if (!alarmData) { return false; }
	
    this._nextAlarmTime = this.adjustMS(alarmData.nextAlarm, this.tzo);
    this._alarmInstStart = this.adjustMS(alarmData.alarmInstStart, this.tzo);

	var currentTime = (new Date()).getTime();

    return (currentTime >= this._nextAlarmTime); 
};

/**
 * Adjusts milliseconds.
 * 
 * @param	{int}	s		the seconds
 * @param	{int}	tzo		the timezone offset
 * @return	{int}	the resulting milliseconds
 */
ZmCalBaseItem.prototype.adjustMS =
function(s, tzo) {
    var adjustMs = this.isAllDayEvent() ? (tzo + new Date(s).getTimezoneOffset()*60*1000) : 0;
    return parseInt(s, 10) + adjustMs;
};

/**
 * Checks if this is an alarm instance.
 * 
 * @return	{Boolean}	<code>true</code> if this is an alarm instance
 */
ZmCalBaseItem.prototype.isAlarmInstance =
function() {
    var alarmData = this.alarmData ? this.alarmData[0] : null;

    if (!alarmData ||
        !alarmData.alarmInstStart ||
        !this.startDate) {
        return false;
    }
    this._alarmInstStart = this.adjustMS(alarmData.alarmInstStart, this.tzo);
    return (this._alarmInstStart == this.startDate.getTime());
};

/**
 * Checks if this item has alarm data.
 * 
 * @return	{Boolean}	 <code>true</code> if item has alarm data
 */
ZmCalBaseItem.prototype.hasAlarmData =
function() {
	return (this.alarmData !=  null);
};

/**
 * @private
 */
ZmCalBaseItem.prototype._loadFromDom =
function(calItemNode, instNode) {

	this.uid 			= calItemNode.uid;
	this.folderId 		= calItemNode.l || this._getDefaultFolderId();
	this.invId			= calItemNode.invId;
	this.isException 	= instNode.ex; 
	this.id 			= calItemNode.id;
	this.name 			= this._getAttr(calItemNode, instNode, "name");
	this.fragment 		= this._getAttr(calItemNode, instNode, "fr");
	this.status 		= this._getAttr(calItemNode, instNode, "status");
	this.ptst 			= this._getAttr(calItemNode, instNode, "ptst");
	
	this.allDayEvent	= (instNode.allDay || calItemNode.allDay)  ? "1" : "0";
	this.organizer		= calItemNode.or && calItemNode.or.a;
	this.isOrg 			= this._getAttr(calItemNode, instNode, "isOrg");
	this.transparency	= this._getAttr(calItemNode, instNode, "transp");

	if (instNode.allDay == false) {
		this.allDayEvent = "0";
	}

	this.alarm 			= this._getAttr(calItemNode, instNode, "alarm");
	this.alarmData 		= this._getAttr(calItemNode, instNode, "alarmData");
    if (!this.alarmData && this.isException) {
        this.alarmData  = calItemNode.alarmData;
    }
	this.priority 		= parseInt(this._getAttr(calItemNode, instNode, "priority"));

	this.recurring 		= instNode.recur != null ? instNode.recur : calItemNode.recur; // TEST for null since recur can be FALSE
    this.ridZ 			= this.recurring && instNode && instNode.ridZ;

	this.fba = this._getAttr(calItemNode, instNode, "fba");

	var sd = instNode.s !=null ? instNode.s : calItemNode.inst && calItemNode.inst.length > 0 &&  calItemNode.inst[0].s;
	if (sd) {
        var tzo = this.tzo = instNode.tzo != null ? instNode.tzo : calItemNode.tzo;
		var adjustMs = this.isAllDayEvent() ? (tzo + new Date(sd).getTimezoneOffset()*60*1000) : 0;
		var startTime = parseInt(sd,10) + adjustMs;
		this.startDate = new Date(startTime);
		this.uniqStartTime = this.startDate.getTime();
	}

	var dur = this._getAttr(calItemNode, instNode, "dur");
	if (dur) {
		var endTime = startTime + (parseInt(dur));
		this.endDate = new Date(endTime);
	}
	
	this.otherAttendees = this._getAttr(calItemNode, instNode, "otherAtt");
	this.location = this._getAttr(calItemNode, instNode, "loc");
};

/**
 * @private
 */
ZmCalBaseItem.prototype._getDefaultFolderId =
function() {
	return ZmOrganizer.ID_CALENDAR;
};

/**
 * @private
 */
ZmCalBaseItem.prototype._getAttr =
function(calItem, inst, name) {
	return inst[name] != null ? inst[name] : inst.ex ? null : calItem[name];
};

/**
 * @private
 */
ZmCalBaseItem.prototype._addLocationToRequest =
function(inv) {
    inv.loc = this.getLocation();
};

/**
 * @private
 */
ZmCalBaseItem._getTTHour =
function(d) {
	var formatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	return formatter.format(d);
};


ZmCalBaseItem.prototype.getReminderLocation =
function() {
	return (this.alarmData[0].loc || "");
};

/**
 * Gets the reminder name.
 * 
 * @return	{String}	the reminder name or empty string if not set
 */
ZmCalBaseItem.prototype.getReminderName =
function() {
	return (this.alarmData[0].name || "");
};

/**
 * Gets alarm info
 *
 * @return	{Object}    the alarm information
 */
ZmCalBaseItem.prototype.getAlarmData =
function() {
	return this.alarmData;
}

/**
 * Checks if the alarm is old (based on current time).
 * 
 * @return	{Boolean}	<code>true</code> if the alarm is old
 */
ZmCalBaseItem.prototype.isAlarmOld =
function() {
	if (!this.alarmData) { return false; }

	var alarmData = this.alarmData[0];
	this._nextAlarmTime = alarmData.nextAlarm;
	this._alarmInstStart = alarmData.alarmInstStart;

	var currentTime = (new Date()).getTime();

    var diff = (currentTime - this._nextAlarmTime);

    //reminder controller takes 1 minute interval for house keeping schedule
    //if the diff is greater than 2 minutes (safer deadline) mark the alarm as old
    if(diff > 2*60*1000) {
        return true;
    }
    return false;
};

ZmCalBaseItem.prototype.getRestUrl =
function() {
	// return REST URL as seen by server
	if (this.restUrl) {
		return this.restUrl;
	}

	// if server doesn't tell us what URL to use, do our best to generate
	var organizer = appCtxt.getById(this.folderId);
	var url = organizer
		? ([organizer.getRestUrl(), "/?id=", AjxStringUtil.urlComponentEncode(this.id || this.invId)].join(""))
		: null;

	DBG.println(AjxDebug.DBG3, "NO REST URL FROM SERVER. GENERATED URL: " + url);

	return url;
};

ZmCalBaseItem.prototype.getDateInLocalTimezone =
function(date) {
    var apptTZ = this.getTimezone();
    var localTZ = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
    if(apptTZ != localTZ) {
        var offset1 = AjxTimezone.getOffset(AjxTimezone.DEFAULT, date);
        var offset2 = AjxTimezone.getOffset(AjxTimezone.getClientId(apptTZ), date);
        return new Date(date.getTime() + (offset1 - offset2)*60*1000);
    }
    return date;
};

}
if (AjxPackage.define("zimbraMail.calendar.model.ZmCalItem")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */
 
/**
 * @overview
 * This file defines a Zimbra calendar item.
 *
 */

/**
 * @class
 * This class represents a calendar item.
 *
 * @param	{constant}	type		the item type
 * @param	{ZmList}	list		the list
 * @param	{int}	id				the task id
 * @param	{String}	folderId	the folder id
 *
 * @extends ZmCalBaseItem
 */
ZmCalItem = function(type, list, id, folderId) {
	if (arguments.length == 0) { return; }

	ZmCalBaseItem.call(this, type, list, id, folderId);

	this.notesTopPart = null; // ZmMimePart containing children w/ message parts
	this.attachments = null;
	this.viewMode = ZmCalItem.MODE_NEW;
	this._recurrence = new ZmRecurrence(this);
	this._noBusyOverlay = null;
    this._sendNotificationMail = true;
    this.identity = null;
    this.isProposeTimeMode = false;
    this.isForwardMode = false;
	this.alarmActions = new AjxVector();
	this.alarmActions.add(ZmCalItem.ALARM_DISPLAY);
	this._useAbsoluteReminder = false;
    this._ignoreVersion=false; //to ignore revision related attributes(ms & rev) during version conflict
};

ZmCalItem.prototype = new ZmCalBaseItem;
ZmCalItem.prototype.constructor = ZmCalItem;

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmCalItem.prototype.toString =
function() {
	return "ZmCalItem";
};

// Consts

/**
 * Defines the "new" mode.
 */
ZmCalItem.MODE_NEW					    = "NEW"; // Changing those constants from numbers to strings to be easier for debugging. I could not deal with 2,3 etc anymore.
/**
 * Defines the "edit" mode.
 */
ZmCalItem.MODE_EDIT					    = "EDIT";

/**
 * Defines the "copy single instance" mode.
 */
ZmCalItem.MODE_COPY_SINGLE_INSTANCE	    = "COPY_INST";

/**
 * Defines the "edit single instance" mode.
 */
ZmCalItem.MODE_EDIT_SINGLE_INSTANCE	    = "EDIT_INST";
/**
 * Defines the "edit series" mode.
 */
ZmCalItem.MODE_EDIT_SERIES			    = "EDIT_SER";
/**
 * Defines the "delete" mode.
 */
ZmCalItem.MODE_DELETE				    = "DELETE";
/**
 * Defines the "delete instance" mode.
 */
ZmCalItem.MODE_DELETE_INSTANCE		    = "DELETE_INST";
/**
 * Defines the "delete series" mode.
 */
ZmCalItem.MODE_DELETE_SERIES		    = "DELETE_SER";
/**
 * Defines the "new from quick" mode.
 */
ZmCalItem.MODE_NEW_FROM_QUICKADD 	    = "NEW_FROM_QUICK";
/**
 * Defines the "get" mode.
 */
ZmCalItem.MODE_GET					    = "GET";
/**
 * Defines the "forward" mode.
 */
ZmCalItem.MODE_FORWARD				    = "FORWARD";
/**
 * Defines the "forward single instance" mode.
 */
ZmCalItem.MODE_FORWARD_SINGLE_INSTANCE	= "FORWARD_INST";
/**
 * Defines the "forward series" mode.
 */
ZmCalItem.MODE_FORWARD_SERIES			= "FORWARD_SER";
/**
 * Defines the "forward" mode.
 */
ZmCalItem.MODE_FORWARD_INVITE			= "FORWARD_INV";
/**
 * Defines the "propose" mode.
 */
ZmCalItem.MODE_PROPOSE_TIME 			= "PROPOSE_TIME";

/**
 * Defines the "purge" (delete from trash) mode.
 */
ZmCalItem.MODE_PURGE 					= 15; //keeping this and the last one as 15 as I am not sure if it's a bug or intentional that they are the same

/**
 * Defines the "last" mode index constant.
 */
ZmCalItem.MODE_LAST					    = 15;

ZmCalItem.FORWARD_MAPPING = {};
ZmCalItem.FORWARD_MAPPING[ZmCalItem.MODE_FORWARD]                   = ZmCalItem.MODE_EDIT;
ZmCalItem.FORWARD_MAPPING[ZmCalItem.MODE_FORWARD_SINGLE_INSTANCE]   = ZmCalItem.MODE_EDIT_SINGLE_INSTANCE;
ZmCalItem.FORWARD_MAPPING[ZmCalItem.MODE_FORWARD_SERIES]            = ZmCalItem.MODE_EDIT_SERIES;
ZmCalItem.FORWARD_MAPPING[ZmCalItem.MODE_FORWARD_INVITE]            = ZmCalItem.MODE_EDIT;

/**
 * Defines the "low" priority.
 */
ZmCalItem.PRIORITY_LOW				= 9;
ZmCalItem.PRIORITY_LOW_RANGE		= [6,7,8,9];

/**
 * Defines the "normal" priority.
 */
ZmCalItem.PRIORITY_NORMAL			= 5;
ZmCalItem.PRIORITY_NORMAL_RANGE		= [0,5];
/**
 * Defines the "high" priority.
 */
ZmCalItem.PRIORITY_HIGH				= 1;
ZmCalItem.PRIORITY_HIGH_RANGE		= [1,2,3,4];

/**
 * Defines the "chair" role.
 */
ZmCalItem.ROLE_CHAIR				= "CHA";
/**
 * Defines the "required" role.
 */
ZmCalItem.ROLE_REQUIRED				= "REQ";
/**
 * Defines the "optional" role.
 */
ZmCalItem.ROLE_OPTIONAL				= "OPT";
/**
 * Defines the "non-participant" role.
 */
ZmCalItem.ROLE_NON_PARTICIPANT		= "NON";

ZmCalItem.SERVER_WEEK_DAYS			= ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];

ZmCalItem.ATTACHMENT_CHECKBOX_NAME	= "__calAttCbox__";
ZmCalItem.ATT_LINK_IMAGE            = "mainImage";
ZmCalItem.ATT_LINK_MAIN			    = "main";
ZmCalItem.ATT_LINK_DOWNLOAD		    = "download";

/**
 * Defines "minutes "reminder units.
 */
ZmCalItem.REMINDER_UNIT_MINUTES     = "minutes";
/**
 * Defines "hours" reminder units.
 */
ZmCalItem.REMINDER_UNIT_HOURS       = "hours";
/**
 * Defines "days" reminder units.
 */
ZmCalItem.REMINDER_UNIT_DAYS        = "days";
/**
 * Defines "weeks" reminder units.
 */
ZmCalItem.REMINDER_UNIT_WEEKS       = "weeks";
/**
 * Defines "none" reminder.
 */
ZmCalItem.REMINDER_NONE             = "none";

// Alarm actions
ZmCalItem.ALARM_DISPLAY	= "DISPLAY";
ZmCalItem.ALARM_EMAIL	= "EMAIL";
ZmCalItem.ALARM_DEVICE_EMAIL = "DEVICE_EMAIL"; // SMS

// Duration Checks
ZmCalItem.MSEC_LIMIT_PER_WEEK  = AjxDateUtil.MSEC_PER_DAY * 7;
// Because recurrences can be on the first (or 2nd, 3rd...) Day-of-week of a
// month, play it safe and make the limit 5 weeks
ZmCalItem.MSEC_LIMIT_PER_MONTH = AjxDateUtil.MSEC_PER_DAY * 7 * 5;
ZmCalItem.MSEC_LIMIT_PER_YEAR  = AjxDateUtil.MSEC_PER_DAY * 366;


// Getters

/**
 * @private
 */
ZmCalItem.prototype.getCompNum			= function() { return this.compNum || "0"; };

/**
 * Gets the folder.
 * 
 * @return	{Object}	the folder
 */
ZmCalItem.prototype.getFolder			= function() { };						// override if necessary

/**
 * Gets the organizer.
 * 
 * @return	{String}	the organizer
 */
ZmCalItem.prototype.getOrganizer 		= function() { return this.organizer || ""; };

/**
 * Gets the organizer name.
 *
 * @return	{String}	the organizer name
 */
ZmCalItem.prototype.getOrganizerName 	= function() { return this.organizerName; };


/**
 * Gets the sent by.
 * 
 * @return	{String}	the sent by
 */
ZmCalItem.prototype.getSentBy           = function() { return this.sentBy || ""; };

/**
 * Gets the original start date.
 * 
 * @return	{Date}	the original start date
 */
ZmCalItem.prototype.getOrigStartDate 	= function() { return this._origStartDate || this.startDate; };

/**
 * Gets the original start time.
 * 
 * @return	{Date}	the original start time
 */
ZmCalItem.prototype.getOrigStartTime 	= function() { return this.getOrigStartDate().getTime(); };

/**
 * Gets the original end date.
 *
 * @return	{Date}	the original end date
 */
ZmCalItem.prototype.getOrigEndDate 	= function() { return this._origEndDate || this.endDate; };

/**
 * Gets the original end time.
 *
 * @return	{Date}	the original end time
 */
ZmCalItem.prototype.getOrigEndTime 	= function() { return this.getOrigEndDate().getTime(); };

/**
 * Gets the original calendar item.
 *
 * @return	{ZmCalItem}	the original calendar item
 */
ZmCalItem.prototype.getOrig 	        = function() { return this._orig; };

/**
 * Gets the original timezone.
 * 
 * @return	{Date}	the original timezone
 */
ZmCalItem.prototype.getOrigTimezone     = function() { return this._origTimezone || this.timezone; };

/**
 * Gets the recurrence "blurb".
 * 
 * @return	{String}	the recurrence blurb
 * @see		ZmRecurrence
 */
ZmCalItem.prototype.getRecurBlurb		= function() { return this._recurrence.getBlurb(); };

/**
 * Gets the recurrence.
 * 
 * @return	{ZmRecurrence}	the recurrence
 */
ZmCalItem.prototype.getRecurrence		= function() { return this._recurrence; };

/**
 * Gets the recurrence "type".
 * 
 * @return	{String}	the recurrence type
 * @see		ZmRecurrence
 */
ZmCalItem.prototype.getRecurType		= function() { return this._recurrence.repeatType; };

/**
 * Gets the timezone.
 * 
 * @return	{AjxTimezone}	the timezone
 */
ZmCalItem.prototype.getTimezone         = function() { return this.timezone; };

/**
 * Gets the summary.
 * 
 * @param	{Boolean}	isHtml		<code>true</code> to return as html
 * @return	{String}	the summary
 */
ZmCalItem.prototype.getSummary			= function(isHtml) { };					// override if necessary

/**
 * Gets the tool tip.
 * 
 * @param	{ZmController}		controller		the controller
 * @return	{String}	the tool tip
 */
ZmCalItem.prototype.getToolTip			= function(controller) { };				// override if necessary
/**
 * Checks if this item has a custom recurrence.
 * 
 * @return	{Boolean}	<code>true</code> for a custom recurrence
 */
ZmCalItem.prototype.isCustomRecurrence 	= function() { return this._recurrence.repeatCustom == "1" || this._recurrence.repeatEndType != "N"; };
/**
 * Checks if this item is an organizer.
 * 
 * @return	{Boolean}	<code>true</code> for an organizer
 */
ZmCalItem.prototype.isOrganizer 		= function() { return (typeof(this.isOrg) === 'undefined') || (this.isOrg == true); };
/**
 * Checks if this item is recurring.
 * 
 * @return	{Boolean}	<code>true</code> for recurrence
 */
ZmCalItem.prototype.isRecurring 		= function() { return (this.recurring || (this._rawRecurrences != null)); };
/**
 * Checks if this item has attachments.
 * 
 * @return	{Boolean}	<code>true</code> if this item has attachments
 */
ZmCalItem.prototype.hasAttachments 		= function() { return this.getAttachments() != null; };
/**
 * Checks if this item has attendee type.
 * 
 * @return	{Boolean}	always returns <code>false</code>; override if necessary
 */
ZmCalItem.prototype.hasAttendeeForType	= function(type) { return false; };		// override if necessary
/**
 * Checks if this item has attendees.
 * 
 * @return	{Boolean}	always returns <code>false</code>; override if necessary
 */
ZmCalItem.prototype.hasAttendees    	= function() { return false; }; 		// override if necessary
/**
 * Checks if this item has person attendees.
 * 
 * @return	{Boolean}	always returns <code>false</code>; override if necessary
 */
ZmCalItem.prototype.hasPersonAttendees	= function() { return false; };			// override if necessary

// Setters
/**
 * Sets all day event.
 * 
 * @param	{Boolean}	isAllDay	<code>true</code> for an all day event
 */
ZmCalItem.prototype.setAllDayEvent 		= function(isAllDay) 	{ this.allDayEvent = isAllDay ? "1" : "0"; };
/**
 * Sets the name.
 * 
 * @param	{String}	newName			the name
 */
ZmCalItem.prototype.setName 			= function(newName) 	{ this.name = newName; };
/**
 * Sets the organizer.
 * 
 * @param	{String}	organizer			the organizer
 */
ZmCalItem.prototype.setOrganizer 		= function(organizer) 	{ this.organizer = organizer != "" ? organizer : null; };
/**
 * Sets the repeat type.
 * 
 * @param	{constant}	repeatType			the repeat type
 */
ZmCalItem.prototype.setRecurType		= function(repeatType)	{ this._recurrence.repeatType = repeatType; };
/**
 * Sets the item type.
 * 
 * @param	{constant}	newType			the item type
 */
ZmCalItem.prototype.setType 			= function(newType) 	{ this.type = newType; };
/**
 * Sets the original timezone.
 * 
 * @param	{Object}	timezone		the timezone
 */
ZmCalItem.prototype.setOrigTimezone     = function(timezone)    { this._origTimezone = timezone; };

/**
 * Sets the folder id.
 * 
 * @param	{String}	folderId		the folder id
 */
ZmCalItem.prototype.setFolderId =
function(folderId) {
	this.folderId = folderId || ZmOrganizer.ID_CALENDAR;
};

/**
 * Gets the "local" folder id even for remote folders. Otherwise, just use <code>this.folderId</code>.
 * 
 * @return	{ZmFolder|String}		the folder or folder id
 */
ZmCalItem.prototype.getLocalFolderId =
function() {
	var fid = this.folderId;
	if (this.isShared()) {
		var folder = appCtxt.getById(this.folderId);
		if (folder)
			fid = folder.id;
	}
	return fid;
};

/**
 * Sets the end date.
 * 
 * @param	{Date}	endDate		the end date
 * @param	{Boolean}	keepCache	if <code>true</code>, keep the cache; <code>false</code> to reset the cache
 */
ZmCalItem.prototype.setEndDate =
function(endDate, keepCache) {
    if (this._origEndDate == null && this.endDate != null && this.endDate != "") {
        this._origEndDate = new Date(this.endDate.getTime());
    }
	this.endDate = new Date(endDate instanceof Date ? endDate.getTime(): endDate);
	if (!keepCache)
		this._resetCached();
};

/**
 * Sets the start date.
 * 
 * @param	{Date}	startDate		the start date
 * @param	{Boolean}	keepCache	if <code>true</code>, keep the cache; <code>false</code> to reset the cache
 */
ZmCalItem.prototype.setStartDate =
function(startDate, keepCache) {
	if (this._origStartDate == null && this.startDate != null && this.startDate != "") {
		this._origStartDate = new Date(this.startDate.getTime());
	}
	this.startDate = new Date(startDate instanceof Date ? startDate.getTime() : startDate);

	if (!keepCache) {
		this._resetCached();
	}

	// recurrence should reflect start date
	if (this.recurring && this._recurrence) {
		this._recurrence.setRecurrenceStartTime(this.startDate.getTime());
	}
};

/**
 * Sets the timezone.
 * 
 * @param	{AjxTimezone}	timezone	the timezone
 * @param	{Boolean}	keepCache	if <code>true</code>, keep the cache; <code>false</code> to reset the cache
 */
ZmCalItem.prototype.setTimezone =
function(timezone, keepCache) {
	if (this._origTimezone == null) {
		this._origTimezone = timezone;
	}
	this.timezone = timezone;
	if (!keepCache) {
		this._resetCached();
	}
};

/**
 * Sets the end timezone.
 *
 * @param	{AjxTimezone}	timezone	the timezone
 */
ZmCalItem.prototype.setEndTimezone =
function(timezone) {
	if (this._origEndTimezone == null) {
		this._origEndTimezone = timezone;
	}
	this.endTimezone = timezone;
};

/**
 * Sets the view mode, and resets any other fields that should not be set for that view mode.
 * 
 * @param	{constant}	mode		the mode (see <code>ZmCalItem.MODE_</code> constants)
 */
ZmCalItem.prototype.setViewMode =
function(mode) {
	this.viewMode = mode || ZmCalItem.MODE_NEW;

	if (this.viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE)
		this._recurrence.repeatType = "NON";
};

/**
 * Gets the view mode
 */
ZmCalItem.prototype.getViewMode =
function(mode) {
	return this.viewMode;
};

/**
 * Gets the notes part. This method will walk the notesParts array looking for
 * the first part that matches given content type.
 * 
 * @param	{constant}	contentType		the content type (see {@link ZmMimeTable.TEXT_PLAIN})	
 * @return	{String}	the content
 * 
 * @see	ZmMimeTable
 */
ZmCalItem.prototype.getNotesPart =
function(contentType) {
	if (this.notesTopPart) {
		var ct = contentType || ZmMimeTable.TEXT_PLAIN;
		var content = this.notesTopPart.getContentForType(ct);

		// if requested content type not found, try the other
		if (!content) {
			if (ct == ZmMimeTable.TEXT_PLAIN) {
				var div = document.createElement("div");
				content = this.notesTopPart.getContentForType(ZmMimeTable.TEXT_HTML);
				div.innerHTML = content || "";
				var text = AjxStringUtil.convertHtml2Text(div);
				return text.substring(1); // above func prepends \n due to div
			} else if (ct == ZmMimeTable.TEXT_HTML) {
				content = AjxStringUtil.convertToHtml(this.notesTopPart.getContentForType(ZmMimeTable.TEXT_PLAIN));
			}
		}
		return content;
	} else {
		return this.fragment;
	}
};

/**
 * Gets the remote folder owner.
 * 
 * @return {String}	the "owner" of remote/shared item folder this item belongs to
 */
ZmCalItem.prototype.getRemoteFolderOwner =
function() {
	// bug fix #18855 - dont return the folder owner if moving betw. accounts
	var controller = AjxDispatcher.run("GetCalController");
	if (controller.isMovingBetwAccounts(this, this.folderId)) {
		return null;
	}

	var folder = this.getFolder();
	var owner = folder && folder.link && folder.owner;

    var acct = (!owner && appCtxt.multiAccounts && folder.getAccount());
	if (acct) {
		owner = acct.name;
	}
	return owner;
};

/**
 * Checks if the item is read-only.
 * 
 * @return	{Boolean}	<code>true</code> if the item is read-only
 */
ZmCalItem.prototype.isReadOnly =
function() {
	var folder = this.getFolder();

	if (appCtxt.multiAccounts) {
		var orgAcct = appCtxt.accountList.getAccountByEmail(this.organizer);
		var calAcct = appCtxt.accountList.getAccountByEmail(folder.getAccount().getEmail());
		if (orgAcct == calAcct) {
			return false;
		}
	}
   // TODO: Correct this method in order to return fasle for users with manager/admin rights
	return (!this.isOrganizer() || (folder.link && folder.isReadOnly()));
};

/**
 * Checks if the folder containing the item is read-only by the .
 *
 * @return	{Boolean}	<code>true</code> if the folder is read-only
 */
ZmCalItem.prototype.isFolderReadOnly =
function() {
	var folder = this.getFolder();
    return (folder && folder.isReadOnly());
};

/*
*   To check whether version has been ignored
* */
ZmCalItem.prototype.isVersionIgnored=function(){
    return this._ignoreVersion;
}

/*
*   Method to set _ignoreVersion as true when conflict arises and false otherwise.
*   If true, the next soap request wont be sent with revision related attributes like ms&rev.
* */
ZmCalItem.prototype.setIgnoreVersion=function(isIgnorable){
    this._ignoreVersion=isIgnorable;
}

/**
 * Resets the repeat weekly days.
 */
ZmCalItem.prototype.resetRepeatWeeklyDays =
function() {
	if (this.startDate) {
		this._recurrence.repeatWeeklyDays = [ZmCalItem.SERVER_WEEK_DAYS[this.startDate.getDay()]];
	}
};

/**
 * Resets the repeat monthly day months list.
 */
ZmCalItem.prototype.resetRepeatMonthlyDayList =
function() {
	if (this.startDate) {
		this._recurrence.repeatMonthlyDayList = [this.startDate.getDate()];
	}
};

/**
 * Resets the repeat yearly months list.
 */
ZmCalItem.prototype.resetRepeatYearlyMonthsList =
function(mo) {
	this._recurrence.repeatYearlyMonthsList = mo;
};

/**
 * Resets the repeat custom day of week.
 */
ZmCalItem.prototype.resetRepeatCustomDayOfWeek =
function() {
	if (this.startDate) {
		this._recurrence.repeatCustomDayOfWeek = ZmCalItem.SERVER_WEEK_DAYS[this.startDate.getDay()];
	}
};

/**
 * Checks if the item is overlapping.
 * 
 * @param	{ZmCalItem}	other		the other item to check
 * @param	{Boolean}	checkFolder	<code>true</code> to check the folder id
 * @return	{Boolean}	<code>true</code> if the items overlap; <code>false</code> if the items do not overlap or the item folder ids do not match
 */
ZmCalItem.prototype.isOverlapping =
function(other, checkFolder) {
	if (checkFolder && this.folderId != other.folderId) { return false; }

	var tst = this.getStartTime();
	var tet = this.getEndTime();
	var ost = other.getStartTime();
	var oet = other.getEndTime();

	return (tst < oet) && (tet > ost);
};

/**
 * Checks if this item is in range.
 * 
 * @param	{Date}	startTime	the start range
 * @param	{Date}	endTime	the end range
 * @return	{Boolean}	<code>true</code> if the item is in range
 */
ZmCalItem.prototype.isInRange =
function(startTime, endTime) {
	var tst = this.getStartTime();
	var tet = this.getEndTime();
	return (tst < endTime && tet > startTime);
};

/**
 * Checks whether the duration of this item is valid.
 *
 * @return	{Boolean}	<code>true</code> if the item possess valid duration.
 */
ZmCalItem.prototype.isValidDuration =
function(){

    var startTime = this.getStartTime();
    var endTime = this.getEndTime();

    if(this.endTimezone && this.endTimezone!=this.timezone){
      var startOffset = AjxTimezone.getRule(this.timezone).standard.offset;
      var endOffset = AjxTimezone.getRule(this.endTimezone).standard.offset;

      startTime = startTime - (startOffset*60000);
      endTime = endTime - (endOffset*60000);
    }

    return (startTime<=endTime);

}
/**
 * Checks whether the duration of this item is valid with respect to the
 * recurrence period.  For example, if the item repeats daily, its duration
 * should not be longer than a day.
 *
 * This can get very complicated due to custom repeat rules.  So the
 * limitation is just set on the repeat type.  The purpose is to prevent
 * (as has happened) someone creating a repeating appt where they set the
 * duration to be the span the appt is in effect over a year instead of its
 * duration during the day.  For example, repeat daily, start = Jan 1 2014,
 * end = July 1 2014.   See Bug 87993.
 *
 * @return	{Boolean}	<code>true</code> if the item possess valid duration.
 */
ZmCalItem.prototype.isValidDurationRecurrence = function() {
	var valid     = true;
	var recurType = this.getRecurType();
	var duration  = this.getDuration();
	switch (recurType) {
		case ZmRecurrence.DAILY:   valid = duration <= AjxDateUtil.MSEC_PER_DAY;       break;
		case ZmRecurrence.WEEKLY:  valid = duration <= ZmCalItem.MSEC_LIMIT_PER_WEEK;  break;
		case ZmRecurrence.MONTHLY: valid = duration <= ZmCalItem.MSEC_LIMIT_PER_MONTH; break;
		case ZmRecurrence.YEARLY:  valid = duration <= ZmCalItem.MSEC_LIMIT_PER_YEAR;  break;
		default: break;
	}
	return valid;
}

/**
 * @private
 */
ZmCalItem.prototype.parseAlarmData =
function() {
	if (!this.alarmData) { return; }

	for (var i = 0; i < this.alarmData.length; i++) {
		var alarm = this.alarmData[i].alarm;
		if (alarm) {
			for (var j = 0; j < alarm.length; j++) {
				this.parseAlarm(alarm[j]);
			}
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype.parseAlarm =
function(tmp) {
	if (!tmp) { return; }

	var s, m, h, d, w;
	var trigger = tmp.trigger;
	var rel = (trigger && (trigger.length > 0)) ? trigger[0].rel : null;
    s = (rel && (rel.length > 0)) ? rel[0].s : null;
	m = (rel && (rel.length > 0)) ? rel[0].m : null;
	d = (rel && (rel.length > 0)) ? rel[0].d : null;
	h = (rel && (rel.length > 0)) ? rel[0].h : null;
	w = (rel && (rel.length > 0)) ? rel[0].w : null;

    this._reminderMinutes = -1;
	if (tmp.action == ZmCalItem.ALARM_DISPLAY) {
        if (s == 0) { // at time of event
            this._reminderMinutes = 0;
        }
		if (m != null) {
			this._reminderMinutes = m;
            this._origReminderUnits = ZmCalItem.REMINDER_UNIT_MINUTES;
		}
		if (h != null) {
			h = parseInt(h);
			this._reminderMinutes = h * 60;
            this._origReminderUnits = ZmCalItem.REMINDER_UNIT_HOURS;
		}
		if (d != null) {
			d = parseInt(d);
			this._reminderMinutes = d * 24 * 60;
            this._origReminderUnits = ZmCalItem.REMINDER_UNIT_DAYS;
		}
        if (w != null) {
			w = parseInt(w);
			this._reminderMinutes = w * 7 * 24 * 60;
            this._origReminderUnits = ZmCalItem.REMINDER_UNIT_WEEKS;
		}
	}
};

/**
 * Checks if the start date is in range.
 * 
 * @param	{Date}	startTime	the start time of the range
 * @param	{Date}	endTime		the end time of the range
 * @return {Boolean}	<code>true</code> if the start date of this item is within range
 */
ZmCalItem.prototype.isStartInRange =
function(startTime, endTime) {
	var tst = this.getStartTime();
	return (tst < endTime && tst >= startTime);
};

/**
 * Checks if the end date is in range.
 * 
 * @param	{Date}	startTime	the start time of the range
 * @param	{Date}	endTime		the end time of the range
 * @return {Boolean}	<code>true</code> if the end date of this item is within range
 */
ZmCalItem.prototype.isEndInRange =
function(startTime, endTime) {
	var tet = this.getEndTime();
	return (tet <= endTime && tet > startTime);
};

/**
 * Sets the date range.
 * 
 * @param	{Hash}	rangeObject		a hash of <code>startDate</code> and <code>endDate</code>
 * @param	{Object}	instance	not used
 * @param	{Object}	parentValue	not used
 * @param	{Object}	refPath	not used
 */
ZmCalItem.prototype.setDateRange =
function (rangeObject, instance, parentValue, refPath) {
	var s = rangeObject.startDate;
	var e = rangeObject.endDate;
	this.endDate.setTime(rangeObject.endDate.getTime());
	this.startDate.setTime(rangeObject.startDate.getTime());
};

/**
 * Gets the date range.
 * 
 * @param	{Object}	instance	not used
 * @param	{Object}	current		not used
 * @param	{Object}	refPath		not used
 * @return	{Hash}	a hash of <code>startDate</code> and <code>endDate</code>
 */
ZmCalItem.prototype.getDateRange =
function(instance, current, refPath) {
	return { startDate:this.startDate, endDate: this.endDate };
};

/**
 * Sets the attachments.
 * 
 * @param	{String}	ids		a comma delimited string of ids
 */
ZmCalItem.prototype.setAttachments =
function(ids) {
	this.attachments = [];

	if (ids && ids.length > 0) {
		var split = ids.split(',');
		for (var i = 0 ; i < split.length; i++) {
			this.attachments[i] = { id:split[i] };
		}
	}
};

/**
 * Gets the attachments.
 * 
 * @return	{Array}	an array of attachments or <code>null</code> for none
 */
ZmCalItem.prototype.getAttachments =
function() {
	var attachs = this.message ? this.message.attachments : null;
	if (attachs) {
		if (this._validAttachments == null) {
			this._validAttachments = [];
			for (var i = 0; i < attachs.length; ++i) {
				if (this.message.isRealAttachment(attachs[i]) || attachs[i].contentType == ZmMimeTable.TEXT_CAL) {
					this._validAttachments.push(attachs[i]);
				}
			}
		}
		return this._validAttachments.length > 0 ? this._validAttachments : null;
	}
	return null;
};

/**
 * Removes an attachment.
 * 
 * @param	{Object}	part	the attachment part to remove
 */
ZmCalItem.prototype.removeAttachment =
function(part) {
	if (this._validAttachments && this._validAttachments.length > 0) {
		for (var i = 0; i < this._validAttachments.length; i++) {
			if (this._validAttachments[i].part == part) {
				this._validAttachments.splice(i,1);
				break;
			}
		}
	}
};

/**
 * Gets the start hour in short date format.
 * 
 * @return	{String}	the start hour
 */
ZmCalItem.prototype.getShortStartHour =
function() {
	var formatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	return formatter.format(this.startDate);
};

/**
 * Gets the unique start date.
 * 
 * @return	{Date}	the start date
 */
ZmCalItem.prototype.getUniqueStartDate =
function() {
	if (this._uniqueStartDate == null && this.uniqStartTime) {
		this._uniqueStartDate = new Date(this.uniqStartTime);
	}
	return this._uniqueStartDate;
};

/**
 * Gets the unique end date.
 * 
 * @return	{Date}	the end date
 */
ZmCalItem.prototype.getUniqueEndDate =
function() {
	if (this._uniqueEndDate == null && this.uniqStartTime) {
		this._uniqueEndDate = new Date(this.uniqStartTime + this.getDuration());
	}
	return this._uniqueEndDate;
};

/**
 * Gets the details.
 * 
 * @param	{constant}	viewMode	the view mode
 * @param	{AjxCallback}	callback	the callback
 * @param	{AjxCallback}	errorCallback	the callback on error
 * @param	{Boolean}	ignoreOutOfDate		if <code>true</code>, ignore out of date items
 * @param	{Boolean}	noBusyOverlay		if <code>true</code>, no busy overlay
 * @param	{ZmBatchCommand}	batchCmd			set if part of a batch operation
 */
ZmCalItem.prototype.getDetails =
function(viewMode, callback, errorCallback, ignoreOutOfDate, noBusyOverlay, batchCmd) {
	var mode = viewMode || this.viewMode;

	var seriesMode = mode == ZmCalItem.MODE_EDIT_SERIES;
    var fetchSeriesMsg = (seriesMode && this.message && !this.message.seriesMode);
	if (this.message == null || fetchSeriesMsg) {
		var id = seriesMode ? (this.seriesInvId || this.invId || this.id) : this.invId;
		this.message = new ZmMailMsg(id);
		if (this._orig) {
			this._orig.message = this.message;
		}
		var respCallback = new AjxCallback(this, this._handleResponseGetDetails, [mode, this.message, callback]);
		var respErrorCallback = (!ignoreOutOfDate)
			? (new AjxCallback(this, this._handleErrorGetDetails, [mode, callback, errorCallback]))
			: errorCallback;

		var acct = appCtxt.isOffline && this.getFolder().getAccount();
		var params = {
			callback: respCallback,
			errorCallback: respErrorCallback,
			noBusyOverlay: noBusyOverlay,
			ridZ: (seriesMode ? null : this.ridZ),
			batchCmd: batchCmd,
			accountName: (acct && acct.name)
		};
		this.message.load(params);
	} else {
		this.setFromMessage(this.message, mode);
		if (callback) {
			callback.run();
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype.convertToLocalTimezone =
function() {
    var apptTZ = this.getTimezone();
    var localTZ = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
    var sd = this.startDate;
    var ed = this.endDate;
    if(apptTZ != localTZ) {
        var offset1 = AjxTimezone.getOffset(AjxTimezone.DEFAULT, sd);
        var offset2 = AjxTimezone.getOffset(AjxTimezone.getClientId(apptTZ), sd);
        sd.setTime(sd.getTime() + (offset1 - offset2)*60*1000);
        ed.setTime(ed.getTime() + (offset1 - offset2)*60*1000);
        this.setTimezone(localTZ);
        this.setEndTimezone(localTZ);
    }
};


/**
 * @private
 */
ZmCalItem.prototype._handleResponseGetDetails =
function(mode, message, callback, result) {
	// msg content should be text, so no need to pass callback to setFromMessage()
	this.setFromMessage(message, mode);
    message.seriesMode = (mode == ZmCalItem.MODE_EDIT_SERIES);

    //overwrite proposed time
    if(this._orig && this._orig.proposedInvite) {
        var invite = this._orig.proposedInvite;
        var start = invite.getServerStartTime();
        var end = invite.getServerEndTime();
        if (start) this.setStartDate(AjxDateUtil.parseServerDateTime(start, true));
        if (end) this.setEndDate(AjxDateUtil.parseServerDateTime(end, true));

        //set timezone from proposed invite
        var tz = invite.getServerStartTimeTz();
        this.setTimezone(tz || AjxTimezone.getServerId(AjxTimezone.DEFAULT));

        // record whether the start/end dates are in UTC
        this.startsInUTC = start ? start.charAt(start.length-1) == "Z" : null;
        this.endsInUTC = end && start ? end.charAt(start.length-1) == "Z" : null;

        //set all the fields that are not generated in GetAppointmentResponse - accept proposal mode
        this.status = invite.components[0].status;

        //convert proposed invite timezone to local timezone
        this.convertToLocalTimezone();
        this.isAcceptingProposal = true;
    }
	if (callback) callback.run(result);
};

/**
 * @private
 */
ZmCalItem.prototype._handleErrorGetDetails =
function(mode, callback, errorCallback, ex) {
	if (ex.code == "mail.INVITE_OUT_OF_DATE") {
        var jsonObj = {},
            requestName = this._getRequestNameForMode(ZmCalItem.MODE_GET),
            request = jsonObj[requestName] = {
                _jsns : "urn:zimbraMail"
            },
            respCallback = new AjxCallback(this, this._handleErrorGetDetails2, [mode, callback, errorCallback]),
            params;

        request.id = this.id;
		params = {
			jsonObj: jsonObj,
			asyncMode: true,
			callback: respCallback,
			errorCallback: errorCallback
		};
		appCtxt.getAppController().sendRequest(params);
		return true;
	}
	if (ex.code == "account.ACCOUNT_INACTIVE") {
        var msg = ex.msg ? ex.msg.split(':') : null,
            acctEmailId = msg ? msg[1] : '',
            msgDlg = appCtxt.getMsgDialog();
        msgDlg.setMessage(AjxMessageFormat.format(ZmMsg.accountInactiveError, acctEmailId), DwtMessageDialog.CRITICAL_STYLE);
        msgDlg.popup();
		return true;
	}
	if (errorCallback) {
		return errorCallback.run(ex);
	}
	return false;
};

/**
 * @private
 */
ZmCalItem.prototype._handleErrorGetDetails2 =
function(mode, callback, errorCallback, result) {
	// Update invId and force a message reload
	var invite = this._getInviteFromError(result);
	this.invId = [this.id, invite.id].join("-");
	this.message = null;
	var ignoreOutOfDate = true;
	this.getDetails(mode, callback, errorCallback, ignoreOutOfDate);
};

/**
 * Sets the from message.
 * 
 * @param	{String}	message		the message
 * @param	{constant}	viewMode	the view mode
 * 
 * @private
 */
ZmCalItem.prototype.setFromMessage =
function(message, viewMode) {
	if (message == this._currentlyLoaded) { return; }

	if (message.invite) {
		this.isOrg = message.invite.isOrganizer();
		this.organizer = message.invite.getOrganizerEmail();
		this.organizerName = message.invite.getOrganizerName();
		this.sentBy = message.invite.getSentBy();
		this.name = message.invite.getName() || message.subject;
		this.isException = message.invite.isException();
        this.recurring =  message.invite.isRecurring();
        this.location = message.invite.getLocation();
        this.seq = message.invite.getSequenceNo();
        this.allDayEvent = message.invite.isAllDayEvent();
        if(message.invite.id) {
            this.invId = this.id + "-" + message.invite.id;
        }
		this._setTimeFromMessage(message, viewMode);
		this._setExtrasFromMessage(message);
		this._setRecurrence(message);
	}
	this._setNotes(message);
	this.getAttachments();

	this._currentlyLoaded = message;
};

/**
 * Sets the required data from saved response
 *
 * @param	{Object} result create/moify appt response
 */
ZmCalItem.prototype.setFromSavedResponse =
function(result) {
    this.invId = result.invId;
    if(this.message) {
        this.message.rev = result.rev;
        this.message.ms = result.ms;
    }

    if(this.viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE && !this.isException) {
        this.isException = true;
    }
};

/**
 * Sets the from mail message. This method gets called when a mail item
 * is dragged onto the item and we
 * need to load the mail item and parse the right parts to show in {@link ZmCalItemEditView}.
 * 
 * @param	{String}	message		the message
 * @param	{String}	subject		the subject
 * 
 * @private
 */
ZmCalItem.prototype.setFromMailMessage =
function(message, subject) {
	this.name = subject;
	this._setNotes(message);
	// set up message so attachments work
	this.message = message;
	this.invId = message.id;
};

/**
 * Sets the notes (text/plain).
 * 
 * @param	{String}	notes		the notes
 */
ZmCalItem.prototype.setTextNotes =
function(notes) {
	this.notesTopPart = new ZmMimePart();
	this.notesTopPart.setContentType(ZmMimeTable.TEXT_PLAIN);
	this.notesTopPart.setContent(notes);
};

/**
 * @private
 */
ZmCalItem.prototype._setTimeFromMessage =
function(message, viewMode) {
	// For instance of recurring appointment, start date is generated from unique
	// start time sent in appointment summaries. Associated message will contain
	// only the original start time.
	var start = message.invite.getServerStartTime();
	var end = message.invite.getServerEndTime();
	if (viewMode === ZmCalItem.MODE_EDIT_SINGLE_INSTANCE || viewMode === ZmCalItem.MODE_FORWARD_SINGLE_INSTANCE
			|| viewMode === ZmCalItem.MODE_COPY_SINGLE_INSTANCE) {
		var usd = this.getUniqueStartDate();
		if (usd) {
			this.setStartDate(usd);
		}

		var ued = this.getUniqueEndDate();
		if (ued) {
			if (this.isAllDayEvent() && viewMode === ZmCalItem.MODE_COPY_SINGLE_INSTANCE) {
				//special case - copying and all day event. The day it ends is a one too many days. Creating a copy gets confused otherwise and adds that day.
				ued.setDate(ued.getDate() - 1);
			}
			this.setEndDate(ued);
		}
		if (viewMode === ZmCalItem.MODE_COPY_SINGLE_INSTANCE) {
			viewMode = ZmCalItem.MODE_EDIT_SINGLE_INSTANCE; // kinda hacky - the copy mode has run its course. Now treat it like edit mode. Would be less impact.
		}
	}
	else {
		if (start) this.setStartDate(AjxDateUtil.parseServerDateTime(start));
		if (end) this.setEndDate(AjxDateUtil.parseServerDateTime(end));
	}

	// record whether the start/end dates are in UTC
	this.startsInUTC = start ? start.charAt(start.length-1) == "Z" : null;
	this.endsInUTC = end && start ? end.charAt(start.length-1) == "Z" : null;

	// record timezone
    var timezone;
	if (viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE || viewMode == ZmCalItem.MODE_DELETE_INSTANCE || viewMode == ZmCalItem.MODE_FORWARD_SINGLE_INSTANCE) {
        timezone = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
		this.setTimezone(timezone);
		this.setEndTimezone(timezone);
	}
	else {
		var serverId = !this.startsInUTC && message.invite.getServerStartTimeTz();
        timezone = serverId || AjxTimezone.getServerId(AjxTimezone.DEFAULT);
		this.setTimezone(timezone);
        var endServerId = !this.endsInUTC && message.invite.getServerEndTimeTz();
		this.setEndTimezone(endServerId || AjxTimezone.getServerId(AjxTimezone.DEFAULT));
		if(!this.startsInUTC && message.invite.getServerEndTimeTz()) this.setEndTimezone(message.invite.getServerEndTimeTz());
	}

	var tzrule = AjxTimezone.getRule(AjxTimezone.getClientId(this.getTimezone()));
	if (tzrule) {
		if (tzrule.aliasId) {
			tzrule = AjxTimezone.getRule(tzrule.aliasId) || tzrule;
		}
		this.setTimezone(tzrule.serverId);
	}

    tzrule = AjxTimezone.getRule(AjxTimezone.getClientId(this.endTimezone));
    if (tzrule) {
        if (tzrule.aliasId) {
            tzrule = AjxTimezone.getRule(tzrule.aliasId) || tzrule;
        }
        this.setEndTimezone(tzrule.serverId);
    }
};

/**
 * Override to add specific initialization but remember to call
 * the base implementation.
 *
 * @private
 */
ZmCalItem.prototype._setExtrasFromMessage =
function(message) {
    this._setAlarmFromMessage(message);
};

ZmCalItem.prototype._setAlarmFromMessage =
function(message) {
    this._reminderMinutes = -1;
	var alarm = message.invite.getAlarm();
	if (alarm) {
		for (var i = 0; i < alarm.length; i++) {
            var alarmInst = alarm[i];
            if (!alarmInst) continue;

            var action = alarmInst.action;
			if (action == ZmCalItem.ALARM_DISPLAY) {
				this.parseAlarm(alarmInst);
                // NOTE: No need to add a display alarm because it's
                // NOTE: added by default in the constructor.
                continue;
			}

            // NOTE: Both email and device-email/sms reminders appear
            // NOTE: as "EMAIL" alarms but we distinguish between them
            // NOTE: upon loading.
            if (action == ZmCalItem.ALARM_EMAIL) {
                var emails = alarmInst.at;
                if (!emails) continue;
                for (var j = 0; j < emails.length; j++) {
                    var email = emails[j].a;
                    if (email == appCtxt.get(ZmSetting.CAL_DEVICE_EMAIL_REMINDERS_ADDRESS)) {
                        action = ZmCalItem.ALARM_DEVICE_EMAIL;
                    }
                    this.addReminderAction(action);
                }
            }
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype._setRecurrence =
function(message) {
	var recurRules = message.invite.getRecurrenceRules();

	if (recurRules)
		this._recurrence.parse(recurRules);

	if (this._recurrence.repeatWeeklyDays == null)
		this.resetRepeatWeeklyDays();

	if (this._recurrence.repeatMonthlyDayList == null)
		this.resetRepeatMonthlyDayList();
};

/**
 * We are removing starting 2 \n's for the bug 21823
 * XXX - this does not look very efficient
 * 
 * @private
 */
ZmCalItem.prototype._getCleanHtml2Text = 
function(dwtIframe) {
	var textContent;
	var idoc = dwtIframe ? dwtIframe.getDocument() : null;
	var body = idoc ? idoc.body : null;
	if (body) {
		var html = body.innerHTML.replace(/\n/ig, "");
		body.innerHTML = html.replace(/<!--.*-->/ig, "");
		var firstChild = body.firstChild;
		var removeN = (firstChild && firstChild.tagName && firstChild.tagName.toLocaleLowerCase() == "p");
		textContent = AjxStringUtil.convertHtml2Text(body);
		if (removeN) {
			textContent = textContent.replace(/\n\n/i, "");
		}
	}
	return textContent;
};

/**
 * @private
 */
ZmCalItem.prototype._setNotes =
function(message) {

    if(!(message.isZmMailMsg)) { return; }
	this.notesTopPart = new ZmMimePart();

	var htmlContent = message.getBodyContent(ZmMimeTable.TEXT_HTML);
	if (htmlContent) {
		htmlContent = htmlContent.replace(/<title\s*>.*\/title>/ig,"");
		if (!this._includeEditReply) {
			htmlContent = this._trimNotesSummary(htmlContent, true);
		}
	}

	if (htmlContent) {
		// create a temp iframe to create a proper DOM tree
		var params = {parent:appCtxt.getShell(), hidden:true, html:htmlContent};
		var textContent = message.getInviteDescriptionContentValue(ZmMimeTable.TEXT_PLAIN);
		if (!textContent) { //only go through this pain if textContent is somehow not available from getInviteDescriptionContentValue (no idea if this could happen).
			var dwtIframe = new DwtIframe(params);
			textContent = this._getCleanHtml2Text(dwtIframe);
			// bug: 23034 this hidden iframe under shell is adding more space
			// which breaks calendar column view
			var iframe = dwtIframe.getIframe();
			if (iframe && iframe.parentNode) {
				iframe.parentNode.removeChild(iframe);
			}
			delete dwtIframe;
		}

        // create two more mp's for text and html content types
		var textPart = new ZmMimePart();
		textPart.setContentType(ZmMimeTable.TEXT_PLAIN);
		textPart.setContent(textContent);

		var htmlPart = new ZmMimePart();
		htmlPart.setContentType(ZmMimeTable.TEXT_HTML);
		htmlPart.setContent(htmlContent);

		this.notesTopPart.setContentType(ZmMimeTable.MULTI_ALT);
		this.notesTopPart.children.add(textPart);
		this.notesTopPart.children.add(htmlPart);
	} else {
		var textContent = message.getBodyContent(ZmMimeTable.TEXT_PLAIN);
		if (!this._includeEditReply) {
			textContent = this._trimNotesSummary(textContent);
		}
		this.notesTopPart.setContentType(ZmMimeTable.TEXT_PLAIN);
		this.notesTopPart.setContent(textContent);
	}
};

/**
 * Gets the mail notification option.
 * 
 * @return	{Boolean}	<code>true</code> if the mail notification is set; <code>false</code> otherwise
 */
ZmCalItem.prototype.getMailNotificationOption =
function() {
    return this._sendNotificationMail;
};

/**
 * Sets the mail notification option.
 * 
 * @param	{Boolean}	sendNotificationMail	<code>true</code> to set the mail notification
 */
ZmCalItem.prototype.setMailNotificationOption =
function(sendNotificationMail) {
    this._sendNotificationMail = sendNotificationMail;    
};

/**
 * Sets the exception details to request
 *
 * @param	{Element}	comp	comp element of request object
 */
ZmCalItem.prototype.addExceptionDetails =
function(comp) {
    var exceptId = comp.exceptId = {},
        allDay = this._orig ? this._orig.allDayEvent : this.allDayEvent,
        timezone,
        sd;

    if (allDay != "1") {
        sd = AjxDateUtil.getServerDateTime(this.getOrigStartDate(), this.startsInUTC);
        // bug fix #4697 (part 2)
        timezone = this.getOrigTimezone();
        if (!this.startsInUTC && timezone) {
            exceptId.tz = timezone;
        }
        exceptId.d = sd;
    }
    else {
        sd = AjxDateUtil.getServerDate(this.getOrigStartDate());
        exceptId.d = sd;
    }
};

/**
 * Saves the item.
 * 
 * @param {String}	attachmentId 		the id of the already uploaded attachment
 * @param {AjxCallback}		callback 			the callback triggered once request for appointment save is complete
 * @param {AjxCallback}		errorCallback		the callback triggered if error during appointment save request
 * @param {Array}	notifyList 		the optional sublist of attendees to be notified (if different from original list of attendees)
*/
ZmCalItem.prototype.save =
function(attachmentId, callback, errorCallback, notifyList) {
	var needsExceptionId = false,
        jsonObj = {},
        requestName = this._getRequestNameForMode(this.viewMode, this.isException),
        request = jsonObj[requestName] = {
            _jsns : "urn:zimbraMail"
        },
        accountName,
        invAndMsg,
        comp;

	if (this.viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE &&
		!this.isException)
	{
		this._addInviteAndCompNum(request);
		needsExceptionId = true;
	}
	else if (this.viewMode == ZmCalItem.MODE_EDIT ||
			 this.viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE || 
			 this.viewMode == ZmCalItem.MODE_EDIT_SERIES)
	{
		this._addInviteAndCompNum(request);
		needsExceptionId = this.isException;
	}

	accountName = this.getRemoteFolderOwner();
	invAndMsg = this._setRequestAttributes(request, attachmentId, notifyList, accountName);

	comp = invAndMsg.inv.comp[0];
	if (needsExceptionId) {
        this.addExceptionDetails(comp);
	} else {
		// set recurrence rules for appointment (but not for exceptions!)
		this._recurrence.setJson(comp);
	}

	//set alarm data
	this._setAlarmData(comp);

	this._sendRequest(null, accountName, callback, errorCallback, jsonObj, requestName);
};

ZmCalItem.prototype._setAlarmData =
function(comp) {

	var useAbs = this._useAbsoluteReminder,
        time = useAbs ? this._reminderAbs : this._reminderMinutes;

    if (time == null || time === -1) {
        return;
    }

    for (var i = 0, len = this.alarmActions.size(); i < len; i++) {
		var email = null;
		var action = this.alarmActions.get(i);
		if (action == ZmCalItem.ALARM_EMAIL) {
			email = appCtxt.get(ZmSetting.CAL_EMAIL_REMINDERS_ADDRESS);
			if (!email) {
                continue;
            }
		}
        if (action == ZmCalItem.ALARM_DEVICE_EMAIL) {
            email = appCtxt.get(ZmSetting.CAL_DEVICE_EMAIL_REMINDERS_ADDRESS);
            if (!email) {
                continue;
            }
            // NOTE: treat device email alarm as a standard email alarm
            action = ZmCalItem.ALARM_EMAIL;
        }
		var alarms = comp.alarm = comp.alarm || [];
		var alarm = {action: action};
		alarms.push(alarm);
		var trigger = alarm.trigger = {};
		this._setReminderUnits(trigger, time);
		this._addXPropsToAlarm(alarm);
		if (email) {
			alarm.at = {a: email};
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype._setReminderUnits =
function(trigger, time) {
	time = time || 0;
	var useAbs = this._useAbsoluteReminder,
        rel = trigger[useAbs ? "abs" : "rel"] = {};
	if (useAbs) {
		rel.d = time;
	}
	else {
		rel.m = time;
		//default option is to remind before appt start
		rel.related = "START";
		rel.neg = "1";
	}
};

/**
 * @private
 */
ZmCalItem.prototype._addXPropsToAlarm =
function(alarmNode) {
	if (!this.alarmData) {
        return;
    }
	var alarmData = (this.alarmData && this.alarmData.length > 0)? this.alarmData[0] : null,
	    alarm = alarmData ? alarmData.alarm : null,
	    alarmInst = (alarm && alarm.length > 0) ? alarm[0] : null;

    this._setAlarmXProps(alarmInst, alarmNode);
};

/**
 * @private
 */
ZmCalItem.prototype._setAlarmXProps =
function(alarmInst, alarmNode)  {
    var xprops = (alarmInst && alarmInst.xprop) ? alarmInst.xprop : null,
        i,
        x,
        xprop;

    if (!xprops) {
        return;
    }
    // bug 28924: preserve x props
    xprops = (xprops instanceof Array) ? xprops : [xprops];

    for (i = 0; i < xprops.length; i++) {
        xprop = xprops[i];
        if (xprop && xprop.name) {
            x = alarmNode.xprop = {};
            x.name = xprop.name;
            if (xprop.value != null) {
                x.value = xprop.value;
            }
            this._addXParamToRequest(x, xprop.xparam);
        }
    }
};

/**
 * Sets reminder minutes.
 * 
 * @param	{int}	minutes		the minutes
 */
ZmCalItem.prototype.setReminderMinutes =
function(minutes) {
	this._reminderMinutes = minutes;
};

/**
 * Sets the reminder units
 * 
 * @param	{int}	reminderValue		the reminder value
 * @param	{int}	reminderUnits		the reminder units
 */
ZmCalItem.prototype.setReminderUnits =
function(reminderValue, reminderUnits, sendEmail) {
    if (!reminderValue) {
        this._reminderMinutes = 0;
        return;
    }
    reminderValue = parseInt(reminderValue + "");
	this._reminderMinutes = ZmCalendarApp.convertReminderUnits(reminderValue, reminderUnits);
	this._reminderSendEmail = sendEmail;
};

/**
 * Adds the given action to this appt's reminders. A type of action can only be added once.
 *
 * @param {constant}	action		alarm action
 */
ZmCalItem.prototype.addReminderAction =
function(action) {
	this.alarmActions.add(action, null, true);
};

/**
 * Removes the given action from this appt's reminders.
 *
 * @param {constant}	action		alarm action
 */
ZmCalItem.prototype.removeReminderAction =
function(action) {
	this.alarmActions.remove(action);
};

/**
 * Deletes/cancels appointment/invite
 *
 * @param {int}	mode		designated what kind of delete op is this?
 * @param {ZmMailMsg}		msg				the message to be sent in lieu of delete
 * @param {AjxCallback}		callback			the callback to trigger after delete
 * @param {AjxCallback}		errorCallback	the error callback to trigger
 * @param {ZmBatchCommand}	batchCmd		set if part of a batch operation
 */
ZmCalItem.prototype.cancel =
function(mode, msg, callback, errorCallback, batchCmd) {
	this.setViewMode(mode);
	if (msg) {
		// REVISIT: We explicitly set the bodyParts of the message b/c
		// ZmComposeView#getMsg only sets topPart on new message that's returned.
		// And ZmCalItem#_setNotes calls ZmMailMsg#getBodyPart.
		var bodyParts = [];
		var childParts = (msg._topPart.contentType == ZmMimeTable.MULTI_ALT)
			? msg._topPart.children.getArray()
			: [msg._topPart];
		for (var i = 0; i < childParts.length; i++) {
			bodyParts.push(childParts[i]);
		}
		msg.setBodyParts(bodyParts);
		this._setNotes(msg);
		this._doCancel(mode, callback, msg, batchCmd);
	} else {
		// To get the attendees for this appointment, we have to get the message.
		var respCallback = new AjxCallback(this, this._doCancel, [mode, callback, null, batchCmd]);
		var cancelErrorCallback = new AjxCallback(this, this._handleCancelError, [mode, callback, errorCallback]);
		if (this._blobInfoMissing && mode != ZmCalItem.MODE_DELETE_SERIES) {
			this.showBlobMissingDlg();		
		} else {
			this.getDetails(null, respCallback, cancelErrorCallback);
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype.showBlobMissingDlg =
function() {
	var msgDialog = appCtxt.getMsgDialog();
	msgDialog.setMessage(ZmMsg.apptBlobMissing, DwtMessageDialog.INFO_STYLE);
	msgDialog.popup();
};

/**
 * @private
 */
ZmCalItem.prototype._handleCancelError = 
function(mode, callback, errorCallback, ex) {

	if (ex.code == "mail.NO_SUCH_BLOB") {
 		//bug: 19033, cannot delete instance of appt with missing blob info
 		if (this.isRecurring() && mode != ZmCalItem.MODE_DELETE_SERIES) {
			this._blobInfoMissing = true;
			this.showBlobMissingDlg();
			return true;
 		} else {
	 		this._doCancel(mode, callback, this.message);
 		}
 		return true;
 	}
	
	if (errorCallback) {
		return errorCallback.run(ex);
	}

	return false;
};

/**
 * @private
 */
ZmCalItem.prototype.setCancelFutureInstances =
function(cancelFutureInstances) {
    this._cancelFutureInstances = cancelFutureInstances;    
};

ZmCalItem.prototype._sendCancelMsg =
function(callback){
    this.save(null, callback);
};

/**
 * @private
 */
ZmCalItem.prototype._doCancel =
function(mode, callback, msg, batchCmd, result) {
    var folderId = this.getFolder().nId,
        jsonObj = {},
        requestName,
        request,
        action,
        accountName = this.getRemoteFolderOwner(),
        recurrence,
        untilDate,
        inst,
        allDay,
        format,
        clientId,
        m,
        e,
        i,
        j,
        type,
        vector,
        count,
        addr,
        subject,
        mailFromAddress,
        isOrganizer;

    if (folderId == ZmOrganizer.ID_TRASH) {
		mode = ZmCalItem.MODE_PURGE;
        requestName = this._getRequestNameForMode(mode);
        request = jsonObj[requestName] = {
            _jsns : "urn:zimbraMail"
        };
        action = request.action = {};
		action.op = "delete";
		action.id = this.id;
		if (batchCmd) {
			batchCmd.addRequestParams(jsonObj, callback);
		} else {
			this._sendRequest(null, accountName, callback, null, jsonObj, requestName);
		}
	}
    else {
	    if (mode == ZmCalItem.MODE_DELETE_SERIES && this._cancelFutureInstances && this.getOrigStartDate().getTime() != this.getStartTime()) {
	
	        recurrence = this._recurrence;
	        untilDate = new Date(this.getOrigStartDate().getTime());
	        untilDate.setTime(untilDate.getTime() - AjxDateUtil.MSEC_PER_DAY);
	        recurrence.repeatEndDate = untilDate;
	        recurrence.repeatEndType = "D";
	
	        this.viewMode = ZmCalItem.MODE_EDIT_SERIES;
	        this._sendCancelMsg(callback);
	        return;
	    }
		
		if (mode == ZmCalItem.MODE_DELETE ||
			mode == ZmCalItem.MODE_DELETE_SERIES ||
			mode == ZmCalItem.MODE_DELETE_INSTANCE)
		{
            requestName = this._getRequestNameForMode(mode);
            request = jsonObj[requestName] = {
                _jsns : "urn:zimbraMail"
            };

			this._addInviteAndCompNum(request);

			// Exceptions should be treated as instances (bug 15817)
			if (mode == ZmCalItem.MODE_DELETE_INSTANCE || this.isException) {
                request.s = this.getOrigStartTime();
				inst = request.inst = {};
				allDay = this.isAllDayEvent();
				format = allDay ? AjxDateUtil.getServerDate : AjxDateUtil.getServerDateTime;
				inst.d = format(this.getOrigStartDate());
				if (!allDay && this.timezone) {
					inst.tz = this.timezone;

					clientId = AjxTimezone.getClientId(this.timezone);
					ZmTimezone.set(request, clientId, null, true);
				}
			}
            m = request.m = {};
            e = m.e = [];
            isOrganizer = this.isOrganizer();
            if (isOrganizer) {
                if (!this.inviteNeverSent) {
                    // NOTE: We only use the explicit list of addresses if sending via
                    //       a message compose.
                    if (msg) {
                        for (i = 0; i < ZmMailMsg.ADDRS.length; i++) {
                            type = ZmMailMsg.ADDRS[i];

                            // if on-behalf-of, dont set the from address and
                            // don't set the reset-from (only valid when receiving a message)
                            if ((accountName && type == AjxEmailAddress.FROM) ||
                                (type == AjxEmailAddress.RESENT_FROM)) {
                                continue;
                            }

                            vector = msg.getAddresses(type);
                            count = vector.size();
                            for (j = 0; j < count; j++) {
                                addr = vector.get(j);
                                e.push({
                                    a: addr.getAddress(),
                                    t: AjxEmailAddress.toSoapType[type]
                                });
                            }
                        }

                        // set from address to on-behalf-of if applicable
                        if (accountName) {
                            e.push({
                                a: accountName,
                                t: AjxEmailAddress.toSoapType[AjxEmailAddress.FROM]
                            });
                        }
                    }
                    else {
                        this._addAttendeesToRequest(null, m, null, accountName);
                    }
                }
                mailFromAddress = this.getMailFromAddress();
                if (mailFromAddress) {
                    e.push({
                        a : mailFromAddress,
                        t : AjxEmailAddress.toSoapType[AjxEmailAddress.FROM]
                    });
                }
            }
	        subject = (msg && msg.subject) ? msg.subject : ([ZmMsg.cancelled, ": ", this.name].join(""));
            m.su = subject;
			this._addNotesToRequest(m, true);

			if (batchCmd) {
				batchCmd.addRequestParams(jsonObj, callback);
			}
            else {
				this._sendRequest(null, accountName, callback, null, jsonObj, requestName);
			}
		}
        else {
			if (callback) callback.run();
		}
	}
};

/**
 * Gets the mail from address.
 * 
 * @return	{String}	the address
 */
ZmCalItem.prototype.getMailFromAddress =
function() {
    var mailFromAddress = appCtxt.get(ZmSetting.MAIL_FROM_ADDRESS);
    if(mailFromAddress) {
        return (mailFromAddress instanceof Array) ? mailFromAddress[0] : mailFromAddress;
    }
};

// Returns canned text for meeting invites.
// - Instances of recurring meetings should send out information that looks very
//   much like a simple appointment.
/**
 * Gets the summary as text.
 * 
 * @return	{String}	the summary
 */
ZmCalItem.prototype.getTextSummary =
function() {
	return this.getSummary(false);
};

/**
 * Gets the summary as HTML.
 * 
 * @return	{String}	the summary
 */
ZmCalItem.prototype.getHtmlSummary =
function() {
	return this.getSummary(true);
};



// Private / Protected methods

/**
 * @private
 */
ZmCalItem.prototype._getTextSummaryTime =
function(isEdit, fieldstr, extDate, start, end, hasTime) {
	var showingTimezone = appCtxt.get(ZmSetting.CAL_SHOW_TIMEZONE);

	var buf = [];
	var i = 0;

	if (extDate) {
		buf[i++] = AjxDateUtil.longComputeDateStr(extDate);
		buf[i++] = ", ";
	}
	if (this.isAllDayEvent()) {
		buf[i++] = ZmMsg.allDay;
	} else {
		var formatter = AjxDateFormat.getTimeInstance();
		if (start)
			buf[i++] = formatter.format(start);
		if (start && end)
			buf[i++] = " - ";
		if (end)
			buf[i++] = formatter.format(end);

		if (showingTimezone) {
			buf[i++] = " ";
			buf[i++] = AjxTimezone.getLongName(AjxTimezone.getClientId(this.timezone));
		}
	}
	// NOTE: This relies on the fact that setModel creates a clone of the
	//		 appointment object and that the original object is saved in
	//		 the clone as the _orig property.
	if (isEdit && ((this._orig && this._orig.isAllDayEvent() != this.isAllDayEvent()) || hasTime)) {
		buf[i++] = " ";
		buf[i++] = ZmMsg.apptModifiedStamp;
	}
	buf[i++] = "\n";

	return buf.join("");
};

/**
 * Uses indexOf() rather than a regex since IE didn't split on the regex correctly.
 * 
 * @private
 */
ZmCalItem.prototype._trimNotesSummary =
function(notes, isHtml) {
	if (notes) {
		var idx = notes.indexOf(ZmItem.NOTES_SEPARATOR);
		if (idx != -1) {
			notes = notes.substr(idx + ZmItem.NOTES_SEPARATOR.length);
            if (isHtml) {
                // If HTML content is generated from text content \n are replaced with br
                // Remove the leading <br> added
                notes = notes.replace(/^<br><br>/i, "");
				notes = notes.replace(/^<\/div><br>/i, "");
				// Removes </body></html> if that is all that is left.  Reduces the html to "" in that case,
				// so that later checks don't detect HTML notes.
				notes = notes.replace(/^<\/body><\/html>/i, "");
			}
            else {
                notes = notes.replace(/^\n\n/i, "");
            }
		}
	}
	return AjxStringUtil.trim(notes);
};

/**
 * @private
 */
ZmCalItem.prototype._resetCached =
function() {
	delete this._startTimeUniqId; this._startTimeUniqId = null;
	delete this._validAttachments; this._validAttachments = null;
	delete this.tooltip; this.tooltip = null;
};

/**
 * @private
 */
ZmCalItem.prototype._getTTDay =
function(d) {
	return DwtCalendar.getDayFormatter().format(d);
};

/**
 * @private
 */
ZmCalItem.prototype._addInviteAndCompNum =
function(request) {
    var id;
    if(this.message && !this.isVersionIgnored()){
        request.ms = this.message.ms;
        request.rev = this.message.rev;

    }
	if (this.viewMode == ZmCalItem.MODE_EDIT_SERIES || this.viewMode == ZmCalItem.MODE_DELETE_SERIES) {
		if (this.recurring && this.seriesInvId != null) {
            request.id = this.seriesInvId;
            request.comp = this.getCompNum();
		}
	} else {
		if (this.invId != null && this.invId != -1) {
			id =  this.invId;

			// bug: 41530 - for offline, make sure id is fully qualified if moving across accounts
			if (appCtxt.multiAccounts &&
				this._orig &&
				this._orig.getFolder().getAccount() != this.getFolder().getAccount())
			{
				id = ZmOrganizer.getSystemId(this.invId, this._orig.getFolder().getAccount(), true);
			}

            request.id = id;
            request.comp = this.getCompNum();
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype._getDefaultBlurb =
function(cancel, isHtml) {
	var buf = [];
	var i = 0;
	var singleInstance = this.viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE ||
						 this.viewMode == ZmCalItem.MODE_DELETE_INSTANCE;

	if (isHtml) buf[i++] = "<h3>";

    if(this.isProposeTimeMode) {
        buf[i++] =  ZmMsg.subjectNewTime;
    }else if (cancel) {
		buf[i++] = singleInstance ? ZmMsg.apptInstanceCanceled : ZmMsg.apptCanceled;
	} else if(!this.isForwardMode || this.isOrganizer()){
		if (!this.inviteNeverSent && ( this.viewMode == ZmCalItem.MODE_EDIT ||
			this.viewMode == ZmCalItem.MODE_EDIT_SINGLE_INSTANCE ||
			this.viewMode == ZmCalItem.MODE_EDIT_SERIES ) )
		{
			buf[i++] = singleInstance ? ZmMsg.apptInstanceModified : ZmMsg.apptModified;
		}
		else
		{
			buf[i++] = ZmMsg.apptNew;
		}
	}else {
        buf[i++] =  ZmMsg.apptForwarded;
    }

	if (isHtml) buf[i++] = "</h3>";

	buf[i++] = "\n\n";
	buf[i++] = this.getSummary(isHtml);

	return buf.join("");
};

// Server request calls

/**
 * @private
 */
ZmCalItem.prototype._getRequestNameForMode =
function(mode, isException) {
	// override
};

/**
 * @private
 */
ZmCalItem.prototype._getInviteFromError =
function(result) {
	// override
};

/**
 * @private
 */
ZmCalItem.prototype._setRequestAttributes =
function(request, attachmentId, notifyList, accountName) {

	var m = request.m = {},
	    calendar = this.getFolder(),
        acct = calendar.getAccount(),
        isOnBehalfOf = accountName && acct && acct.name != accountName,
        mailFromAddress,
        identityUser,
        displayName,
        validAttLen,
        attachNode,
        organizer,
        isPrimary,
        identityC,
        identity,
        isRemote,
        addrObj,
        orgName,
        comps,
        comp,
        user,
        addr,
        inv,
        org,
        mid,
        me,
        e,
        i;
	//m.setAttribute("l", (isOnBehalfOf ? this.getFolder().rid : this.folderId));
    m.l = (isOnBehalfOf ? this.getFolder().rid : this.folderId);
    inv = m.inv = {};
    e = m.e = [];
	if (this.uid != null && this.uid != -1 && !this.isSharedCopy) {
        inv.uid = this.uid;
	}

    comps = inv.comp = [];
    comp = comps[0] = {};
    comp.at = [];
	// attendees
	this._addAttendeesToRequest(comp, m, notifyList, accountName);

    identity = this.identity;
    isPrimary = identity == null || identity.isDefault;
    isRemote = calendar.isRemote();

    //FROM Address
	mailFromAddress = this.getMailFromAddress();
	if (this.isOrganizer() && !accountName && (mailFromAddress || isRemote || !isPrimary)) {
        if(mailFromAddress){
            addr = mailFromAddress;
        }else{
            if(isRemote){
                addr = this.organizer;
            }else if(identity){
                addr = identity.sendFromAddress;
                displayName = identity.sendFromDisplay;
            }
        }
        addrObj = {
            a : addr,
            t : AjxEmailAddress.toSoapType[AjxEmailAddress.FROM]
        };
        if(!displayName && addr == appCtxt.get(ZmSetting.USERNAME)){
             displayName = appCtxt.get(ZmSetting.DISPLAY_NAME);
        }
        if(displayName){
            addrObj.p = displayName;
        }
        e.push(addrObj);
        if (identity && identity.isFromDataSource && !isRemote) {
            this._addIdentityFrom(identity, e, m);
        }
	}

    //SENDER Address
    if (isRemote) {
        if (!identity) {
            identityC = appCtxt.getIdentityCollection();
            identity = identityC && identityC.defaultIdentity;
        }
        if (identity) {
            addr = identity.sendFromAddress;
            displayName = identity.sendFromDisplay;
        }
        else {
            addr = appCtxt.get(ZmSetting.USERNAME);
            displayName = appCtxt.get(ZmSetting.DISPLAY_NAME);
        }
        addrObj = {
            a : addr,
            t : AjxEmailAddress.toSoapType[AjxEmailAddress.SENDER]
        };
        if (displayName) {
            addrObj.p = displayName;
        }
        e.push(addrObj);
    }

	this._addExtrasToRequest(request, comp);
	this._addDateTimeToRequest(request, comp);
	this._addXPropsToRequest(comp);
	
	// subject/location
    m.su = this.name;
    comp.name = this.name;
	this._addLocationToRequest(comp);

	// notes
	this._addNotesToRequest(m);

	// set organizer - but not for local account
	if (!(appCtxt.isOffline && acct.isMain)) {
		me = (appCtxt.multiAccounts) ? acct.getEmail() : appCtxt.get(ZmSetting.USERNAME);
        if (!identity) {
            identityC = appCtxt.getIdentityCollection(acct);
            identity = identityC && identityC.defaultIdentity;
        }        
        if (identity) { //If !Identity then consider the default identity
            identityUser = identity.sendFromAddress;
            displayName = identity.sendFromDisplay;
        }
		user = mailFromAddress || identityUser || me;
		organizer = this.organizer || user;
        org = comp.or = {};
        org.a = organizer;
		if (isRemote) {
			org.sentBy = user;  // if on-behalf of, set sentBy
		}
        orgName = (organizer == identityUser) ? displayName : (ZmApptViewHelper.getAddressEmail(organizer)).getName();
		if (orgName) {
            org.d = orgName;
        }
	}

	// handle attachments
	this.flagLocal(ZmItem.FLAG_ATTACH, false);
	this.getAttachments(); // bug 22874: make sure to populate _validAttachments
	if (attachmentId != null ||
		(this._validAttachments != null && this._validAttachments.length))
	{
        attachNode = request.m.attach = {};
		if (attachmentId){
            attachNode.aid = attachmentId;
			this.flagLocal(ZmItem.FLAG_ATTACH, true);
		}

		if (this._validAttachments) {
			validAttLen = this._validAttachments.length;
            attachNode.mp = [];
			for (i = 0; i < validAttLen; i++) {

				mid = (this.invId || this.message.id);
				if ((mid.indexOf(":") < 0) && calendar.isRemote()) {
					mid = (appCtxt.getActiveAccount().id + ":" + mid);
				}
                attachNode.mp.push({
                    mid : mid,
                    part : this._validAttachments[i].part
                });
			}
			if (validAttLen > 0) {
				this.flagLocal(ZmItem.FLAG_ATTACH, true);
			}
		}
	}

	return {'inv': inv, 'm': m };
};

ZmCalItem.prototype._addIdentityFrom =
function(identity, e, m) {
    var dataSource = appCtxt.getDataSourceCollection().getById(identity.id),
        provider,
        doNotAddSender,
        addrObj,
        displayName;

    if (dataSource) {
        provider = ZmDataSource.getProviderForAccount(dataSource);
        doNotAddSender = provider && provider._nosender;
        // main account is "sender"
        if (!doNotAddSender) {
            e.push({
                t : AjxEmailAddress.toSoapType[AjxEmailAddress.SENDER],
                p : appCtxt.get(ZmSetting.DISPLAY_NAME) || ""
            });
        }
        // mail is "from" external account
        addrObj = {
            t : AjxEmailAddress.toSoapType[AjxEmailAddress.SENDER],
            a : dataSource.getEmail()
        };
        if (appCtxt.get(ZmSetting.DEFAULT_DISPLAY_NAME)) {
            displayName = dataSource.identity && dataSource.identity.sendFromDisplay;
            displayName = displayName || dataSource.userName || dataSource.getName();
            if(displayName) {
                addrObj.p = displayName;
            }
        }
        e.push(addrObj);
    }
};

/**
 * @private
 */
ZmCalItem.prototype._addExtrasToRequest =
function(request, comp) {
	if (this.priority) {
		comp.priority = this.priority;
	}
    comp.status = this.status;
};

/**
 * @private
 */
ZmCalItem.prototype._addXPropsToRequest =
function(comp) {
	var message = this.message ? this.message : null,
	    invite = (message && message.invite) ? message.invite : null,
        xprops = invite ? invite.getXProp() : null,
        xprop,
        x,
        i;
	if (!xprops) { return; }
    comp.xprop = [];
	// bug 16024: preserve x props
	xprops = (xprops instanceof Array) ? xprops : [xprops];

	for (i = 0; i < xprops.length; i++) {
		xprop = xprops[i],
        x = {};
		if (xprop && xprop.name) {
            x.name = xprop.name;
			if (xprop.value != null) {
                x.value = xprop.value;
			}
			this._addXParamToRequest(x, xprop.xparam);
            comp.xprop.push(x);
		}		
	}
};

/**
 * @private
 */
ZmCalItem.prototype._addXParamToRequest =
function(xprop, xparams) {
	if (!xparams) {
        return;
    }

	xparams = (xparams instanceof Array) ? xparams : [xparams];
    var xparam = xprop.xparam = [],
        xObj = {},
        j,
        x;

	for (j = 0; j < xparams.length; j++) {
		x = xparams[j];
        xObj = {};
		if (x && x.name) {
            xObj.name = x.name;
			if (x.value != null) {
                xObj.value = x.value;
			}
            xparam.push(xObj);
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype._addDateTimeToRequest =
function(request, comp) {
	// always(?) set all day
    comp.allDay = this.allDayEvent + "";
	// timezone
	var tz,
        clientId,
        s,
        sd,
        e,
        ed;
	if (this.timezone) {
		clientId = AjxTimezone.getClientId(this.timezone);
		ZmTimezone.set(request, clientId, null, true);
		tz = this.timezone;
	}

	// start date
	if (this.startDate) {
        s = comp.s = {};
		if (!this.isAllDayEvent()) {
			sd = AjxDateUtil.getServerDateTime(this.startDate, this.startsInUTC);

			// set timezone if not utc date/time
			if (!this.startsInUTC && tz && tz.length) {
                s.tz = tz;
            }
            s.d = sd;
		}
        else {
            s.d = AjxDateUtil.getServerDate(this.startDate);
		}
	}


    if(this.endTimezone) {
        tz = this.endTimezone;
    }

	// end date
	if (this.endDate) {
        e = comp.e = {};
		if (!this.isAllDayEvent()) {
			ed = AjxDateUtil.getServerDateTime(this.endDate, this.endsInUTC);

			// set timezone if not utc date/time
			if (!this.endsInUTC && tz && tz.length) {
				e.tz = tz;
            }
            e.d = ed;

		} else {
			e.d = AjxDateUtil.getServerDate(this.endDate);
		}
	}
};

/**
 * @private
 */
ZmCalItem.prototype._addAttendeesToRequest =
function(inv, m, notifyList, accountName) {
	// if this appt is on-behalf-of, set the from address to that person
    if (this.isOrganizer() && accountName) {
        m.e.push({
            a : accountName,
            t : AjxEmailAddress.toSoapType[AjxEmailAddress.FROM]
        });
    }
};

/**
 * @private
 */
ZmCalItem.prototype._addNotesToRequest =
function(m, cancel) {

	var hasAttendees = this.hasAttendees(),
        tprefix = hasAttendees ? this._getDefaultBlurb(cancel) : "",
        hprefix = hasAttendees ? this._getDefaultBlurb(cancel, true) : "",
        mp = m.mp = {"mp" : []},
        numSubParts,
        part,
        pct,
        content,
        ntp,
        tcontent,
        hcontent,
        html,
        i;

    mp.ct = ZmMimeTable.MULTI_ALT;
	numSubParts = this.notesTopPart ? this.notesTopPart.children.size() : 0;
	if (numSubParts > 0) {
		for (i = 0; i < numSubParts; i++) {
			part = this.notesTopPart.children.get(i);
            pct = part.getContentType();

			if (pct == ZmMimeTable.TEXT_HTML) {
                var htmlContent = part.getContent();
                htmlContent = AjxStringUtil.defangHtmlContent(htmlContent);
                content = "<html><body id='htmlmode'>" + (this._includeEditReply ? htmlContent : AjxBuffer.concat(hprefix, htmlContent)) + "</body></html>";
			} else {
				content = this._includeEditReply ? part.getContent() : AjxBuffer.concat(tprefix, part.getContent());
			}
            mp.mp.push({
                ct : pct,
                content : content
            });
		}
	} else {
        ntp = this.notesTopPart;
		tcontent = ntp ? ntp.getContent() : "";
        pct = ntp ? ntp.getContentType() : ZmMimeTable.TEXT_PLAIN;
        mp.mp.push({
            ct : pct
        });
        if (pct == ZmMimeTable.TEXT_HTML) {
            //bug fix #9592 - html encode the text before setting it as the "HTML" part
            hcontent = AjxStringUtil.nl2br(AjxStringUtil.htmlEncode(tcontent));
            html = "<html><body>" + (this._includeEditReply ? hcontent : AjxBuffer.concat(hprefix, hcontent)) + "</body></html>";
            mp.mp[0].content = html;
        }
        else {
            mp.mp[0].content = (this._includeEditReply ? tcontent : AjxBuffer.concat(tprefix, tcontent));
        }
	}
};


/**
 * Gets a string representation of the invite content.
 * 
 * @param       {Boolean}		isHtml	if <code>true</code>, get HTML content
 * @return		{String}		a string representation of the invite
 */
ZmCalItem.prototype.getInviteDescription =
function(isHtml) {
	var hasAttendees = this.hasAttendees();
	var tprefix = hasAttendees ? this.getSummary(false) : "";
	var hprefix = hasAttendees ? this.getSummary(true) : "";

    var notes = this.getNotesPart(isHtml ? ZmMimeTable.TEXT_HTML : ZmMimeTable.TEXT_PLAIN);
    return AjxBuffer.concat(isHtml ? hprefix : tprefix, notes)    
};

/**
 * @private
 */
ZmCalItem.prototype.setIncludeEditReply =
function(includeEditReply) {
	this._includeEditReply = includeEditReply;
};

/**
 * @private
 */
ZmCalItem.prototype._sendRequest =
function(soapDoc, accountName, callback, errorCallback, jsonObj, requestName) {
	var responseName = soapDoc ? soapDoc.getMethod().nodeName.replace("Request", "Response") : requestName.replace("Request", "Response");
	var respCallback = new AjxCallback(this, this._handleResponseSend, [responseName, callback]);
    if (!jsonObj) {
	    appCtxt.getAppController().sendRequest({soapDoc:soapDoc, asyncMode:true, accountName:accountName, callback:respCallback, errorCallback:errorCallback});
    }
    else {
        appCtxt.getAppController().sendRequest({jsonObj:jsonObj, asyncMode:true, accountName:accountName, callback:respCallback, errorCallback:errorCallback});
    }
};

/**
 * @private
 */
ZmCalItem.prototype._loadFromDom =
function(calItemNode, instNode) {
	ZmCalBaseItem.prototype._loadFromDom.call(this, calItemNode, instNode);

	this.isOrg 			= this._getAttr(calItemNode, instNode, "isOrg");
	var org				= calItemNode.or;
	this.organizer		= org && org.a;
	this.sentBy			= org && org.sentBy;
	this.invId 			= this._getAttr(calItemNode, instNode, "invId");
	this.compNum 		= this._getAttr(calItemNode, instNode, "compNum") || "0";
	this.parseAlarmData(this.alarmData);
	this.seriesInvId	= this.recurring ? calItemNode.invId : null;
	this.ridZ 			= instNode && instNode.ridZ;

	if (calItemNode.tn) {
		this._parseTagNames(calItemNode.tn);
	}
	if (calItemNode.f) {
		this._parseFlags(calItemNode.f);
	}
};

// Callbacks

/**
 * @private
 */
ZmCalItem.prototype._handleResponseSend =
function(respName, callback, result) {
	var resp = result.getResponse();

	// branch for different responses
	var response = resp[respName];
	if (response.uid != null) {
		this.uid = response.uid;
	}

    var msgNode;
    //echo=1 sends back echo response node, process it
    if(response.echo){
        msgNode = response.echo;
        if(msgNode.length > 0){
            msgNode = msgNode[0];
        }
    }
    msgNode = msgNode ? msgNode.m : response.m;
	if (msgNode != null) {
        if(msgNode.length > 0){
            msgNode = msgNode[0];
        }
		var oldInvId = this.invId;
		this.invId = msgNode.id;
		if (AjxUtil.isSpecified(oldInvId) && oldInvId != this.invId){
			this.message = null;
        }else if(msgNode){
            this.message = new ZmMailMsg(msgNode.id);
            this.message._loadFromDom(msgNode);
            delete this._validAttachments;
            this._validAttachments = null;
            this.getAttachments();
        }
	}

	this._messageNode = null;

	if (callback) {
		callback.run(response);
	}
};

ZmCalItem.prototype.processErrorSave =
function(ex) {
	// TODO: generalize error message for calItem instead of just Appt
    var status = {
        continueSave: false,
        errorMessage: ""
    };
	if (ex.code == ZmCsfeException.MAIL_SEND_ABORTED_ADDRESS_FAILURE) {
		var invalid = ex.getData(ZmCsfeException.MAIL_SEND_ADDRESS_FAILURE_INVALID);
		var invalidMsg = (invalid && invalid.length)
			? AjxMessageFormat.format(ZmMsg.apptSendErrorInvalidAddresses, AjxStringUtil.htmlEncode(invalid.join(", "))) : null;
		status.errorMessage = ZmMsg.apptSendErrorAbort + "<br/>" + invalidMsg;
	} else if (ex.code == ZmCsfeException.MAIL_SEND_PARTIAL_ADDRESS_FAILURE) {
		var invalid = ex.getData(ZmCsfeException.MAIL_SEND_ADDRESS_FAILURE_INVALID);
		status.errorMessage = (invalid && invalid.length)
			? AjxMessageFormat.format(ZmMsg.apptSendErrorPartial, AjxStringUtil.htmlEncode(invalid.join(", ")))
			: ZmMsg.apptSendErrorAbort;
	} else if(ex.code == ZmCsfeException.MAIL_MESSAGE_TOO_BIG) {
        status.errorMessage = (this.type == ZmItem.TASK) ? ZmMsg.taskSaveErrorToobig : ZmMsg.apptSaveErrorToobig;
    } else if (ex.code == ZmCsfeException.MAIL_INVITE_OUT_OF_DATE) {
        if(!this.isVersionIgnored()){
            this.setIgnoreVersion(true);
            status.continueSave = true;
        }
        else{
            status.errorMessage = ZmMsg.inviteOutOfDate;
            this.setIgnoreVersion(false);
        }
    } else if (ex.code == ZmCsfeException.MAIL_NO_SUCH_CALITEM) {
        status.errorMessage = ex.getErrorMsg([ex.getData("itemId")]);
    } else if (ex.code == ZmCsfeException.MAIL_QUOTA_EXCEEDED) {
    		if(this.type == ZmItem.APPT){
                status.errorMessage=ZmMsg.errorQuotaExceededAppt;
            } else if(this.type == ZmItem.TASK){
                status.errorMessage=ZmMsg.errorQuotaExceededTask;
            }
    }
	else if (ex.code === ZmCsfeException.MUST_BE_ORGANIZER) {
		status.errorMessage = ZmMsg.mustBeOrganizer;
	}

    return status;
};

ZmCalItem.prototype.setProposedTimeCallback =
function(callback) {
    this._proposedTimeCallback = callback;
};

ZmCalItem.prototype.handlePostSaveCallbacks =
function() {
    if(this._proposedTimeCallback) this._proposedTimeCallback.run(this);
    this.setIgnoreVersion(false);
};

// Static methods

ZmCalItem.isPriorityHigh = function(priority) {
	return AjxUtil.arrayContains(ZmCalItem.PRIORITY_HIGH_RANGE, priority);
};
ZmCalItem.isPriorityLow = function(priority) {
	return AjxUtil.arrayContains(ZmCalItem.PRIORITY_LOW_RANGE, priority);
};
ZmCalItem.isPriorityNormal = function(priority) {
	return AjxUtil.arrayContains(ZmCalItem.PRIORITY_NORMAL_RANGE, priority);
};

/**
 * Gets the priority label.
 * 
 * @param	{int}	priority		the priority (see <code>ZmCalItem.PRIORITY_</code> constants)
 * @return	{String}	the priority label
 * 
 */
ZmCalItem.getLabelForPriority =
function(priority) {
	if (ZmCalItem.isPriorityLow(priority)) {
		return ZmMsg.low;
	}
	if (ZmCalItem.isPriorityNormal(priority)) {
		return ZmMsg.normal;
	}
	if (ZmCalItem.isPriorityHigh(priority)) {
		return ZmMsg.high;
	}
	return "";
};

/**
 * Gets the priority image.
 * 
 * @param	{ZmTask}	task	the task
 * @param	{int}	id		the id
 * @return	{String}	the priority image
 */
ZmCalItem.getImageForPriority =
function(task, id) {
	if (ZmCalItem.isPriorityLow(task.priority)) {
			return id
				? AjxImg.getImageHtml("PriorityLow_list", null, ["id='", id, "'"].join(""))
				: AjxImg.getImageHtml("PriorityLow_list");
	} else if (ZmCalItem.isPriorityHigh(task.priority)) {
			return id
				? AjxImg.getImageHtml("PriorityHigh_list", null, ["id='", id, "'"].join(""))
				: AjxImg.getImageHtml("PriorityHigh_list");
	}
	return "";
};

/**
 * Gets the status label.
 * 
 * @param	{int}	status		the status (see <code>ZmCalendarApp.STATUS_</code> constants)
 * @return	{String}	the status label
 * 
 * @see	ZmCalendarApp
 */
ZmCalItem.getLabelForStatus =
function(status) {
	switch (status) {
		case ZmCalendarApp.STATUS_CANC: return ZmMsg.cancelled;
		case ZmCalendarApp.STATUS_COMP: return ZmMsg.completed;
		case ZmCalendarApp.STATUS_DEFR: return ZmMsg.deferred;
		case ZmCalendarApp.STATUS_INPR: return ZmMsg.inProgress;
		case ZmCalendarApp.STATUS_NEED: return ZmMsg.notStarted;
		case ZmCalendarApp.STATUS_WAIT: return ZmMsg.waitingOn;
	}
	return "";
};

/**
 * Gets the participation status label.
 * 
 * @param	{int}	status		the status (see <code>ZmCalBaseItem.PSTATUS_</code> constants)
 * @return	{String}	the status label
 * 
 * @see	ZmCalBaseItem
 */
ZmCalItem.getLabelForParticipationStatus =
function(status) {
	switch (status) {
		case ZmCalBaseItem.PSTATUS_ACCEPT:		return ZmMsg.ptstAccept;
		case ZmCalBaseItem.PSTATUS_DECLINED:	return ZmMsg.ptstDeclined;
		case ZmCalBaseItem.PSTATUS_DEFERRED:	return ZmMsg.ptstDeferred;
		case ZmCalBaseItem.PSTATUS_DELEGATED:	return ZmMsg.ptstDelegated;
		case ZmCalBaseItem.PSTATUS_NEEDS_ACTION:return ZmMsg.ptstNeedsAction;
		case ZmCalBaseItem.PSTATUS_COMPLETED:	return ZmMsg.completed;
		case ZmCalBaseItem.PSTATUS_TENTATIVE:	return ZmMsg.ptstTentative;
		case ZmCalBaseItem.PSTATUS_WAITING:		return ZmMsg.ptstWaiting;
	}
	return "";
};

/**
 * Gets the participation status icon.
 * 
 * @param	{int}	status		the status (see <code>ZmCalBaseItem.PSTATUS_</code> constants)
 * @return	{String}	the status icon or an empty string if status not set
 * 
 * @see	ZmCalBaseItem
 */
ZmCalItem.getParticipationStatusIcon =
function(status) {
	switch (status) {
		case ZmCalBaseItem.PSTATUS_ACCEPT:		return "Check";
		case ZmCalBaseItem.PSTATUS_DECLINED:	return "Cancel";
		case ZmCalBaseItem.PSTATUS_DEFERRED:	return "QuestionMark";
		case ZmCalBaseItem.PSTATUS_DELEGATED:	return "Plus";
		case ZmCalBaseItem.PSTATUS_NEEDS_ACTION:return "NeedsAction";
		case ZmCalBaseItem.PSTATUS_COMPLETED:	return "Completed";
		case ZmCalBaseItem.PSTATUS_TENTATIVE:	return "QuestionMark";
		case ZmCalBaseItem.PSTATUS_WAITING:		return "Minus";
	}
	return "";
};

/**
 * @private
 */
ZmCalItem._getTTDay =
function(d, format) {
	format = format || AjxDateFormat.SHORT;
	var formatter = AjxDateFormat.getDateInstance();
	return formatter.format(d);
};
}
if (AjxPackage.define("zimbraMail.calendar.model.ZmMiniCalCache")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmMiniCalCache = function(calViewController) {
	this._calViewController = calViewController;
	this.clearCache();
};

ZmMiniCalCache.prototype.toString =
function() {
	return "ZmMiniCalCache";
};

ZmMiniCalCache.prototype.clearCache =
function() {
	this._miniCalData = {};
};

ZmMiniCalCache.prototype.updateCache =
function(params, data) {
	var key = this._getCacheKey(params);
	this._miniCalData[key] = data;	
};

ZmMiniCalCache.prototype._getCacheKey =
function(params) {
	var sortedFolderIds = [];
	sortedFolderIds = sortedFolderIds.concat(params.folderIds);
	sortedFolderIds.sort();
	return (params.start + ":" + params.end + ":" + sortedFolderIds.join(":"));
};

ZmMiniCalCache.prototype._getMiniCalData =
function(params) {
	var cacheKey = this._getCacheKey(params);
	var cachedData = this._miniCalData[cacheKey];
	if (cachedData) {
		this.highlightMiniCal(cachedData);
		if (params.callback) {
			params.callback.run(cachedData);
			return;
		}
		return cachedData;
	}	

	var jsonObj = {GetMiniCalRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.GetMiniCalRequest;

	this._setSoapParams(request, params);

	appCtxt.getAppController().sendRequest({
		jsonObj: jsonObj,
		asyncMode: true,
        offlineCache: true,
		callback: (new AjxCallback(this, this._getMiniCalResponse, [params])),
		errorCallback: (new AjxCallback(this, this._handleMiniCalResponseError, [params])),
        offlineCallback: this._getMiniCalOfflineResponse.bind(this, params),
		noBusyOverlay: params.noBusyOverlay,
		accountName: (appCtxt.multiAccounts ? appCtxt.accountList.mainAccount.name : null)
	});
};

ZmMiniCalCache.prototype.getCacheData =
function(params) {
	var cacheKey = this._getCacheKey(params);
	var cachedData = this._miniCalData[cacheKey];
	if (cachedData) {
		return cachedData;
	}
};

ZmMiniCalCache.prototype._handleMiniCalResponseError =
function(params, result) {
	var code = result ? result.code : null;
	if (code == ZmCsfeException.ACCT_NO_SUCH_ACCOUNT ||
		code == ZmCsfeException.MAIL_NO_SUCH_MOUNTPOINT)
	{
		var data = (result && result.data) ? result.data : null;
		var id = (data && data.itemId && (data.itemId.length>0)) ? data.itemId[0] : null;
		if (id && appCtxt.getById(id) && this._faultHandler) {
			var folder = appCtxt.getById(id);
			folder.noSuchFolder = true;
			this._faultHandler.run(folder);
			return true;
		}
	}

	//continue with callback operation
	if(params.callback) {
		params.callback.run([]);
	}

	return true;
};

ZmMiniCalCache.prototype._setSoapParams = 
function(request, params) {
	request.s = params.start;
	request.e = params.end;
    request.tz = params.tz;

	var folderNode = null;
	if (params.folderIds && params.folderIds.length) {
		request.folder = [];
		for (var i = 0; i < params.folderIds.length; i++) {
			request.folder.push({id:params.folderIds[i]});
		}
	}
    if(params.tz){
        request.tz = [];
        var timezone = AjxTimezone.getRule(params.tz);
        request.tz.push({id:params.tz,stdoff: timezone ? timezone.standard.offset : 0});
    }

};

ZmMiniCalCache.prototype.setFaultHandler =
function(faultHandler) {
	this._faultHandler = faultHandler;
};

ZmMiniCalCache.prototype._getMiniCalResponse =
function(params, result) {
	var data = [];
	if (!result) { return data; }

	var callback = params.callback;
	var resp = result && result._data && result._data;
	var miniCalResponse = resp.GetMiniCalResponse;

	if (miniCalResponse && miniCalResponse.date) {
		var dates = miniCalResponse.date;
		if (dates) {
			for (var i = 0; i < dates.length; i++) {
				if (dates[i]._content) {
					data.push(dates[i]._content);
				}
			}
		}	
		this.highlightMiniCal(data);
	} else {
		// always reset hiliting if empty response returned
		this.highlightMiniCal([]);
	}

    var errors = (miniCalResponse && miniCalResponse.error);
    this.handleError(errors);

	this.updateCache(params, data);

	if (params.callback) {
		params.callback.run(data);
		return;
	}

	return data;
};

ZmMiniCalCache.prototype._getMiniCalOfflineResponse =
function(params) {

    var calMgr = appCtxt.getCalManager();
    var calViewController = calMgr && calMgr.getCalViewController();
    if (calViewController) {
        var apptCache = calViewController.getApptCache();
        if (apptCache) {
            var folderIds = calViewController.getMainAccountCheckedCalendarIds();
            var searchParams = { folderIds: folderIds,
                                 start: params.start,
                                 end: params.end
                               };
            var apptList = apptCache.setSearchParams(searchParams);
            if (apptList) {
                apptCache.processOfflineMiniCal(params, apptList);
            } else {
                apptCache.offlineSearchAppts(searchParams, params, null);
            }
        }
    }
}

ZmMiniCalCache.prototype.processBatchResponse =
function(miniCalResponse, data) {
	if (!miniCalResponse) { return; }

	for (var i = 0; i < miniCalResponse.length; i++) {
		var dates = (miniCalResponse[i] && miniCalResponse[i].date);
		if (dates) {
			for (var j = 0; j < dates.length; j++) {
				if (dates[j]._content) {
					data.push(dates[j]._content);
				}
			}
		}

        var errors = (miniCalResponse[i] && miniCalResponse[i].error);
        this.handleError(errors);
	}
};

ZmMiniCalCache.prototype.handleError =
function(errors) {
    if (errors && errors.length) {
        for (var i = 0; i < errors.length; i++) {
            if (errors[i].code == ZmCsfeException.MAIL_NO_SUCH_FOLDER || errors[i].code == ZmCsfeException.MAIL_NO_SUCH_MOUNTPOINT || errors[i].code == ZmCsfeException.ACCT_NO_SUCH_ACCOUNT || errors[i].code == ZmCsfeException.SVC_PERM_DENIED) {
                var id = errors[i].id;
                if (id && appCtxt.getById(id)) {
                    var folder = appCtxt.getById(id);
                    folder.noSuchFolder = true;
                }
            }
        }
    }
};

ZmMiniCalCache.prototype.highlightMiniCal =
function(dateArr) {
	var highlight = {};
	for (var i = 0; i < dateArr.length; i++) {
		if (dateArr[i]) {
			highlight[dateArr[i]] = AjxDateFormat.parse("yyyyMMdd", dateArr[i]);
		}
	}
	if (this._calViewController && this._calViewController._miniCalendar) {
		this._calViewController._miniCalendar.setHilite(highlight, true, true);
	}
};
}
if (AjxPackage.define("zimbraMail.calendar.model.ZmCalMgr")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmCalMgr = function(container) {
	this._container = container;
	this.clearCache();
	
	this._listeners = {};
	this._folderNames = {};

	this._listeners[ZmOperation.NEW_APPT] = new AjxListener(this, this._newApptAction);
	this._listeners[ZmOperation.NEW_ALLDAY_APPT] = new AjxListener(this, this._newAllDayApptAction);
	this._listeners[ZmOperation.SEARCH_MAIL] = new AjxListener(this, this._searchMailAction);
};

ZmCalMgr.prototype.toString =
function() {
	return "ZmCalMgr";
};

ZmCalMgr.prototype.clearCache =
function() {
	this._miniCalData = {};
};

ZmCalMgr.prototype._createMiniCalendar =
function(date) {
	date = date ? date : new Date();

	var firstDayOfWeek = appCtxt.get(ZmSetting.CAL_FIRST_DAY_OF_WEEK) || 0;

    //todo: need to use server setting to decide the weekno standard
    var serverId = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
    var useISO8601WeekNo = (serverId && serverId.indexOf("Europe")==0 && serverId != "Europe/London");

	this._miniCalendar = new DwtCalendar({parent: this._container, posStyle:DwtControl.ABSOLUTE_STYLE,
										  firstDayOfWeek: firstDayOfWeek, showWeekNumber: appCtxt.get(ZmSetting.CAL_SHOW_CALENDAR_WEEK), useISO8601WeekNo: useISO8601WeekNo});
	this._miniCalendar.setDate(date);
	this._miniCalendar.setScrollStyle(Dwt.CLIP);
	this._miniCalendar.addSelectionListener(new AjxListener(this, this._miniCalSelectionListener));
	this._miniCalendar.addActionListener(new AjxListener(this, this._miniCalActionListener));
	this._miniCalendar.addDateRangeListener(new AjxListener(this, this._miniCalDateRangeListener));
	this._miniCalendar.setMouseOverDayCallback(new AjxCallback(this, this._miniCalMouseOverDayCallback));
	this._miniCalendar.setMouseOutDayCallback(new AjxCallback(this, this._miniCalMouseOutDayCallback));

	var list = [];
	if (appCtxt.get(ZmSetting.MAIL_ENABLED)) {
		list.push("ZmMailMsg");
		list.push("ZmConv");
	}
	if (appCtxt.get(ZmSetting.CONTACTS_ENABLED)) {
		list.push("ZmContact");
	}
	this._miniCalDropTarget = new DwtDropTarget(list);
	this._miniCalDropTarget.addDropListener(new AjxListener(this, this._miniCalDropTargetListener));
	this._miniCalendar.setDropTarget(this._miniCalDropTarget);

	var workingWeek = [];
	for (var i = 0; i < 7; i++) {
		var d = (i + firstDayOfWeek) % 7;
		workingWeek[i] = (d > 0 && d < 6);
	}
	this._miniCalendar.setWorkingWeek(workingWeek);

	// add mini-calendar to skin
	var components = {};
	components[ZmAppViewMgr.C_TREE_FOOTER] = this._miniCalendar;
	appCtxt.getAppViewMgr().setViewComponents(ZmAppViewMgr.GLOBAL, components, true);
	
	var app = appCtxt.getApp(ZmApp.CALENDAR);
	var show = app._active || appCtxt.get(ZmSetting.CAL_ALWAYS_SHOW_MINI_CAL);
	this._miniCalendar.setSkipNotifyOnPage(show && !app._active);
	if (!app._active) {
		this._miniCalendar.setSelectionMode(DwtCalendar.DAY);
	}

    this._dayRollTimer = null;
};



ZmCalMgr.prototype.startDayRollTimer =
function(){
  if(!this._dayRollTimer){
    var curTime = new Date();
    var rollTime = new Date();
    rollTime.setHours(23,59,59,999);
    var interval = rollTime.getTime() - curTime.getTime();
    var dayRollAction = new AjxTimedAction(this,this._rollDay);
    AjxTimedAction.scheduleAction(dayRollAction,interval);
  }
}


ZmCalMgr.prototype._rollDay =
function(){
    this._dayRollTimer = null;
    this._miniCalendar.setDate(new Date(),true);
    this.startDayRollTimer();
}

ZmCalMgr.prototype._miniCalDropTargetListener =
function(ev) {
	var calController = this.getCalViewController();
	calController._miniCalDropTargetListener(ev);
};

ZmCalMgr.prototype.getMiniCalendar = 
function() {
	if (!this._miniCalendar) {
		this._createMiniCalendar();
	}
	
	return this._miniCalendar;
};

ZmCalMgr.prototype._refreshCallback =
function(list) {
	this.getReminderController()._refreshCallback(list);
};

ZmCalMgr.prototype.getReminderController =
function() {
	if (!this._reminderController) {
		this._reminderController = new ZmReminderController(this, "appt");
	}
	return this._reminderController;
};

ZmCalMgr.prototype._miniCalSelectionListener =
function(ev) {
	if (ev.item instanceof DwtCalendar) {
		var calController = this.getCalViewController();
		calController._handleLoadMiniCalSelection(ev);
	}
};

ZmCalMgr.prototype._miniCalActionListener =
function(ev) {
    if (appCtxt.isExternalAccount()) { return; }
	var mm = this._getMiniCalActionMenu();
	mm.__detail = ev.detail;
	mm.popup(0, ev.docX, ev.docY);
};

ZmCalMgr.prototype._getMiniCalActionMenu =
function() {
	if (this._minicalMenu == null) {

		this.postInitListeners();

		var list = [ZmOperation.NEW_APPT, ZmOperation.NEW_ALLDAY_APPT, ZmOperation.SEP, ZmOperation.SEARCH_MAIL];
		//Zimlet hack
		var zimletOps = ZmZimlet.actionMenus ? ZmZimlet.actionMenus["ZmCalViewController"] : null;
		if (zimletOps && zimletOps.length) {
			for (var i = 0; i < zimletOps.length; i++) {
				var op = zimletOps[i];
				ZmOperation.defineOperation(null, op);
				list.push(op.id);
			}
		}
		var params = {parent: appCtxt.getShell(), menuItems:list};
		this._minicalMenu = new ZmActionMenu(params);
		list = this._minicalMenu.opList;
		var cnt = list.length;
		for(var ix=0; ix < cnt; ix++) {
			if(this._listeners[list[ix]]) {
				this._minicalMenu.addSelectionListener(list[ix], this._listeners[list[ix]]);
			}
		}
	}
	return this._minicalMenu;
};

// Zimlet hack
ZmCalMgr.prototype.postInitListeners =
function () {
	if (ZmZimlet.listeners && ZmZimlet.listeners["ZmCalViewController"]) {
		for (var ix in ZmZimlet.listeners["ZmCalViewController"]) {
			if (ZmZimlet.listeners["ZmCalViewController"][ix] instanceof AjxListener) {
				this._listeners[ix] = ZmZimlet.listeners["ZmCalViewController"][ix];
			} else {
				this._listeners[ix] = new AjxListener(this, this._proxyListeners, [ZmZimlet.listeners["ZmCalViewController"][ix]]);
			}
		}
	}
};

// Few zimlets might expect listeners from calendar view controller object
ZmCalMgr.prototype._proxyListeners =
function(zimletListener, event) {
	var calController = this.getCalViewController();
	return (new AjxListener(calController, zimletListener)).handleEvent(event);
};

ZmCalMgr.prototype.isMiniCalCreated =
function() {
	return (this._miniCalendar != null);
};

ZmCalMgr.prototype._miniCalDateRangeListener =
function(ev) { 
	var viewId = appCtxt.getCurrentViewId();
	if (viewId == ZmId.VIEW_CAL) {
		var calController = this.getCalViewController();
		calController._scheduleMaintenance(ZmCalViewController.MAINT_MINICAL);
	} else {
		this.highlightMiniCal();
	}
};

ZmCalMgr.prototype._miniCalMouseOverDayCallback =
function(control, day) {
	this._currentMouseOverDay = day;
	var action = new AjxTimedAction(this, this._getDayToolTipOnDelay, [control, day]);
	AjxTimedAction.scheduleAction(action, 1000);
};

ZmCalMgr.prototype.getCalViewController = 
function() {
	var calController = AjxDispatcher.run("GetCalController");
	calController._miniCalendar = this._miniCalendar;
	calController._minicalMenu = this._minicalMenu;
	calController._miniCalDropTarget = this._miniCalDropTarget;
	return calController;
};

ZmCalMgr.prototype._miniCalMouseOutDayCallback =
function(control) {
	this._currentMouseOverDay = null;
};

ZmCalMgr.prototype._getDayToolTipOnDelay =
function(control, day) {
	if (!this._currentMouseOverDay) { return; }
	if ((this._currentMouseOverDay.getDate() == day.getDate()) &&
		(this._currentMouseOverDay.getMonth() == day.getMonth()))
	{
		this._currentMouseOverDay = null;
        var mouseEv = DwtShell.mouseEvent;
        if(mouseEv && mouseEv.docX > 0 && mouseEv.docY > 0) {
            var callback = new AjxCallback(this, this.showTooltip, [control, mouseEv.docX, mouseEv.docY]);
            this.getCalViewController().getDayToolTipText(day, false, callback, true);
        }
	}
};

ZmCalMgr.prototype.showTooltip =
function(control, x, y, tooltipContent) {
    control.setToolTipContent(tooltipContent);
    if(x > 0 && y > 0) {
        var shell = DwtShell.getShell(window);
        var tooltip = shell.getToolTip();
        tooltip.setContent(tooltipContent);
        tooltip.popup(x, y);
        control.__tooltipClosed = false;
    }
};

ZmCalMgr.prototype.getApptSummaries =
function(params) {
	var apptVec = this.setSearchParams(params);

	if (apptVec != null && (apptVec instanceof AjxVector)) {
		return apptVec;
	}

	// this array will hold a list of appts as we collect them from the server
	this._rawAppts = [];

	if (params.callback) {
		this._search(params);
	} else {
		return this._search(params);
	}
};

ZmCalMgr.prototype.setSearchParams =
function(params) {
	if (!(params.folderIds instanceof Array)) {
		params.folderIds = [params.folderIds];
	} else if (params.folderIds.length == 0) {
		var newVec = new AjxVector();
		if (params.callback) {
			params.callback.run(newVec);
		}
		return newVec;
	}

	var folderIdMapper = {};
	var query = "";
	for (var i=0; i < params.folderIds.length; i++) {
		var fid = params.folderIds[i];
		var systemFolderId = appCtxt.getActiveAccount().isMain
			? fid : ZmOrganizer.getSystemId(fid);

		// map remote folder ids into local ones while processing search since
		// server wont do it for us (see bug 7083)
		var folder = appCtxt.getById(systemFolderId);
		var rid = folder ? folder.getRemoteId() : systemFolderId;
		folderIdMapper[rid] = systemFolderId;

		if (query.length) {
			query += " OR ";
		}
		var idText = AjxUtil.isNumeric(fid) ? fid : ['"', fid, '"'].join("");
		query += "inid:" + idText;
		
	}
	params.queryHint = query;
    params.needToFetch = params.folderIds;
	params.folderIdMapper = folderIdMapper;
	params.offset = 0;
};

ZmCalMgr.prototype._search =
function(params) {
	var jsonObj = {SearchRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.SearchRequest;

	this._setSoapParams(request, params);

    var calController = this.getCalViewController();
    var apptCache     = calController.getApptCache();

    var accountName = appCtxt.multiAccounts ? appCtxt.accountList.mainAccount.name : null;
	if (params.callback) {
		appCtxt.getAppController().sendRequest({
			jsonObj: jsonObj,
			asyncMode: true,
			callback: (new AjxCallback(this, this._getApptSummariesResponse, [params])),
            offlineCallback: apptCache.offlineSearchAppts(null, null, params),
			noBusyOverlay: params.noBusyOverlay,
			accountName: accountName
		});
	} else {
		var response = appCtxt.getAppController().sendRequest({jsonObj: jsonObj, accountName: accountName});
		var result = new ZmCsfeResult(response, false);
		return this._getApptSummariesResponse(params, result);
	}
};

ZmCalMgr.prototype._setSoapParams =
function(request, params) {	
	request.sortBy = "none";
	request.limit = "500";
	request.calExpandInstStart = params.start;
	request.calExpandInstEnd = params.end;
	request.types = ZmSearch.TYPE[ZmItem.APPT];
	request.offset = params.offset;

	var query = params.query;
	if (params.queryHint) {
		query = (query != null)
			? (query + " (" + params.queryHint + ")")
			: params.queryHint;
	}
	request.query = {_content:query};
};


ZmCalMgr.prototype._getApptSummariesResponse =
function(params, result) {
	// TODO: mark both as needing refresh?
	if (!result) { return; }

	var callback = params.callback;
	var resp;
	try {
		resp = result.getResponse();
	} catch (ex) {
		if (callback) {
			callback.run(new AjxVector());
		}
		return;
	}

	var searchResp = resp.SearchResponse;
	var newList = this.processSearchResponse(searchResp, params);
	if (newList == null) { return; }

	if (callback) {
		callback.run(newList, params.query);
	} else {
		return newList;
	}
};

ZmCalMgr.prototype.processSearchResponse = 
function(searchResp, params) {
	if(!searchResp) { return; }

	if (searchResp && searchResp.appt && searchResp.appt.length) {
		this._rawAppts = this._rawAppts != null 
			? this._rawAppts.concat(searchResp.appt)
			: searchResp.appt;

		// if "more" flag set, keep requesting more appts
		if (searchResp.more) {
			var lastAppt = searchResp.appt[searchResp.appt.length-1];
			if (lastAppt) {
				params.offset += 500;
				this._search(params);
				return;
			}
		}
	}

	var newList = new AjxVector();
	if (this._rawAppts && this._rawAppts.length) {
		this._list = new ZmList(ZmItem.APPT);
		for (var i = 0; i < this._rawAppts.length; i++) {
			DBG.println(AjxDebug.DBG2, "appt[j]:" + this._rawAppts[i].name);
			var apptNode = this._rawAppts[i];
			var instances = apptNode ? apptNode.inst : null;
			if (instances) {
				var args = {list:this._list};
				for (var j = 0; j < instances.length; j++) {
					var appt = ZmCalBaseItem.createFromDom(apptNode, args, instances[j]);
					DBG.println(AjxDebug.DBG2, "lite appt :" + appt);
					if (appt) newList.add(appt);
				}
			}
		}

	}
	return newList;
};

ZmCalMgr.prototype.getCalendarName =
function(folderId) {
	var app = appCtxt.getApp(ZmApp.CALENDAR);
	return app.getCalendarName(folderId);
};

// Mini calendar action menu listeners, calview controller is loaded and than
// event handling listener functions are called
ZmCalMgr.prototype._newApptAction =
function(ev) {
	var calController = this.getCalViewController();
	calController._newApptAction(ev);
};

ZmCalMgr.prototype._newAllDayApptAction =
function(ev) {
	var calController = this.getCalViewController();
	calController._newAllDayApptAction(ev);
};

ZmCalMgr.prototype._searchMailAction =
function(ev) {
	var calController = this.getCalViewController();
	calController._searchMailAction(ev);
};

ZmCalMgr.prototype.getCheckedCalendarFolderIds =
function(localOnly) {
	var app = appCtxt.getApp(ZmApp.CALENDAR);
	return app.getCheckedCalendarFolderIds(localOnly);
};

ZmCalMgr.prototype.getReminderCalendarFolderIds =
function() {
	var app = appCtxt.getApp(ZmApp.CALENDAR);
	return app.getReminderCalendarFolderIds();
};

ZmCalMgr.prototype._handleError =
function(ex) {
	if (ex.code == 'mail.INVITE_OUT_OF_DATE' ||	ex.code == 'mail.NO_SUCH_APPT') {
		var msgDialog = appCtxt.getMsgDialog();
		msgDialog.setMessage(ZmMsg.apptOutOfDate, DwtMessageDialog.INFO_STYLE);
		msgDialog.popup();
		return true;
	}
	return false;
};

ZmCalMgr.prototype.highlightMiniCal =
function() {
	this.getMiniCalCache()._getMiniCalData(this.getMiniCalendarParams());
};

ZmCalMgr.prototype.getMiniCalendarParams =
function() {
	var dr = this.getMiniCalendar().getDateRange();
	return {
		start: dr.start.getTime(),
		end: dr.end.getTime(),
		fanoutAllDay: true,
		noBusyOverlay: true,
		folderIds: this.getCheckedCalendarFolderIds(),
        tz: AjxTimezone.DEFAULT
	};
};

ZmCalMgr.prototype.getMiniCalCache =
function() {
	if (!this._miniCalCache) {
		this._miniCalCache = new ZmMiniCalCache(this);
	}
	return this._miniCalCache;
};

ZmCalMgr.prototype.getQuickReminderSearchTimeRange =
function() {
	var endOfDay = new Date();
	endOfDay.setHours(23,59,59,999);

	var end = new Date(endOfDay.getTime());

	var start = endOfDay;
	start.setHours(0,0,0, 0);

	return { start: start.getTime(), end: end.getTime() };
};

ZmCalMgr.prototype.showQuickReminder =
function() {
    var params = this.getQuickReminderParams();
    this.getApptSummaries(params);
};

ZmCalMgr.prototype.getQuickReminderParams =
function() {

	var timeRange = this.getQuickReminderSearchTimeRange();
	return {
		start: timeRange.start,
		end: timeRange.end,
		fanoutAllDay: false,
		folderIds: this.getCheckedCalendarFolderIds(true),
		callback: (new AjxCallback(this, this._quickReminderCallback)),
		includeReminders: true
	};
};

ZmCalMgr.prototype._quickReminderCallback =
function(list) {
    var newList = new AjxVector();
    this._cacheMap = {};
    var size = list.size();

    var currentTime  = (new Date()).getTime();

    for (var i = 0; i < size; i++) {
        var appt = list.get(i);
        var id = appt.id;
        if (!this._cacheMap[id]) {
            this._cacheMap[id] = appt;
            if(appt.isAllDayEvent()) continue;
            var diff = appt.getStartTime() - currentTime;
            var isUpcomingEvent = (diff >= 0 && diff <= AjxDateUtil.MSEC_PER_HOUR)
            if((currentTime >= appt.getStartTime() && currentTime <= appt.getEndTime()) || isUpcomingEvent) {
                appt.isUpcomingEvent = isUpcomingEvent;
                newList.add(appt);
            }
        }
    }

    var qDlg = this.getQuickReminderDialog();
    qDlg.initialize(newList);
    qDlg.popup();
};


/**
 * Gets the quick reminder dialog.
 *
 * @return	{ZmQuickReminderDialog}	the dialog
 */
ZmCalMgr.prototype.getQuickReminderDialog =
function() {
	if (this._reminderDialog == null) {
		this._reminderDialog = new ZmQuickReminderDialog(appCtxt.getShell(), this, this._calController);
	}
	return this._reminderDialog;
};
}
if (AjxPackage.define("zimbraMail.calendar.model.ZmRecurrence")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a recurrence object.
 * @class
 * This class represents a recurrence pattern.
 * 
 * @param	{ZmCalItem}	calItem		the calendar item
 * 
 */
ZmRecurrence = function(calItem) {
	this._startDate 			= (calItem && calItem.startDate) ? calItem.startDate : (new Date());

	// initialize all params (listed alphabetically)
	this.repeatCustom			= "0";  										// 1|0
	this.repeatCustomCount		= 1; 											// ival
	this.repeatCustomDayOfWeek	= "SU"; 										// (DAY|WEEKDAY|WEEKEND) | (SU|MO|TU|WE|TH|FR|SA)
	this.repeatBySetPos	= "1";
	this.repeatCustomMonthDay	= this._startDate.getDate();
	this.repeatCustomType		= "S"; 											// (S)pecific, (O)rdinal
	this.repeatEnd				= null;
	this.repeatEndCount			= 1; 											// maps to "count" (when there is no end date specified)
	this.repeatEndDate			= null; 										// maps to "until"
	this.repeatEndType			= "N";
	this.repeatMonthlyDayList	= null; 										// list of numbers representing days (usually, just one day)
	this.repeatType				= ZmRecurrence.NONE;							// maps to "freq"
	this.repeatWeekday			= false; 										// set to true if freq = "DAI" and custom repeats every weekday
	this.repeatWeeklyDays		= [];	 										// SU|MO|TU|WE|TH|FR|SA
	this.repeatYearlyMonthsList	= 1; 											// list of numbers representing months (usually, just one month)

    this._cancelRecurIds        = {};                                           //list of recurIds to be excluded
};

ZmRecurrence.prototype.toString =
function() {
	return "ZmRecurrence";
};

/**
 * Defines the "none" recurrence.
 */
ZmRecurrence.NONE		= "NON";
/**
 * Defines the "daily" recurrence.
 */
ZmRecurrence.DAILY		= "DAI";
/**
 * Defines the "weekly" recurrence.
 */
ZmRecurrence.WEEKLY		= "WEE";
/**
 * Defines the "monthly" recurrence.
 */
ZmRecurrence.MONTHLY	= "MON";
/**
 * Defines the "yearly" recurrence.
 */
ZmRecurrence.YEARLY		= "YEA";

/**
 * Defines the "day" week day selection.
 */
ZmRecurrence.RECURRENCE_DAY = -1;
/**
 * Defines the "weekend" week day selection.
 */
ZmRecurrence.RECURRENCE_WEEKEND = -2;
/**
 * Defines the "weekday" week day selection.
 */
ZmRecurrence.RECURRENCE_WEEKDAY = -3

ZmRecurrence.prototype.setJson =
function(inv) {
	if (this.repeatType == ZmRecurrence.NONE) {
        return;
    }

	var recur = inv.recur = {},
        add = recur.add = {},
        rule = add.rule = {},
        interval = rule.interval = {},
        until,
        bwd,
        bmd,
        c,
        i,
        day,
        wkDay,
        bysetpos,
        bm;

	rule.freq = this.repeatType;
	interval.ival = this.repeatCustomCount;

	if (this.repeatEndDate != null && this.repeatEndType == "D") {
		until = rule.until = {};
		until.d = AjxDateUtil.getServerDate(this.repeatEndDate);
	}
    else if (this.repeatEndType == "A"){
		c = rule.count = {};
		c.num = this.repeatEndCount;
	}

	if (this.repeatCustom != "1") {
        this.setExcludes(recur);
		return;
    }

	if (this.repeatType == ZmRecurrence.DAILY) {
        if (this.repeatWeekday) {
			// TODO: for now, handle "every weekday" as M-F
			//       eventually, needs to be localized work week days
			bwd = rule.byday = {};
            wkDay = bwd.wkday = [];
			for (i = 0; i < ZmCalItem.SERVER_WEEK_DAYS.length; i++) {
				day = ZmCalItem.SERVER_WEEK_DAYS[i];
				if (day == "SA" || day == "SU") {
					continue;
                }
				wkDay.push({
                    day : day
                });
			}
		}
	}
    else if (this.repeatType == ZmRecurrence.WEEKLY) {
        bwd = rule.byday = {};
        wkDay = bwd.wkday = [];
		for (i = 0; i < this.repeatWeeklyDays.length; ++i) {
            wkDay.push({
                day : this.repeatWeeklyDays[i]
            });
		}
	}
	else if (this.repeatType == ZmRecurrence.MONTHLY) {
		if (this.repeatCustomType == "S") {
			bmd = rule.bymonthday = {};
			bmd.modaylist = this.repeatMonthlyDayList.join(",");
		}
        else {
			bwd = rule.byday = {};
            bwd.wkday = [];
            if (this.repeatCustomDays) {
                for (i=0; i < this.repeatCustomDays.length; i++) {
                    wkDay = {};
                    wkDay.day = this.repeatCustomDays[i];
                    if (this.repeatCustomOrdinal) {
                        wkDay.ordwk = this.repeatCustomOrdinal;
                    }
                    bwd.wkday.push(wkDay);
                }
            }

            if (this.repeatCustomOrdinal == null) {
                bysetpos = rule.bysetpos = {};
                bysetpos.poslist = this.repeatBySetPos;
            }
        }
    }
	else if (this.repeatType == ZmRecurrence.YEARLY) {
		bm = rule.bymonth = {};
		bm.molist = this.repeatYearlyMonthsList;
		if (this.repeatCustomType == "O") {
			bwd = rule.byday = {};
            bwd.wkday = [];
            if(this.repeatCustomDays) {
                for(i=0; i < this.repeatCustomDays.length; i++) {
                    wkDay = {};
                    wkDay.day = this.repeatCustomDays[i];
                    if (this.repeatCustomOrdinal) {
                        wkDay.ordwk = this.repeatCustomOrdinal;
                    }
                    bwd.wkday.push(wkDay);
                }
            }

            if(this.repeatCustomOrdinal == null) {
                bysetpos = rule.bysetpos = {};
                bysetpos.poslist = this.repeatBySetPos;
            }

        } else {
			bmd = rule.bymonthday = {};
			bmd.modaylist = this.repeatCustomMonthDay;
		}

	}

    this.setExcludes(recur);
};

ZmRecurrence.prototype.setExcludes =
function(recur) {
    if (!this._cancelRecurIds) {
        return;
    }

    var exclude,
        dates,
        i,
        ridZ,
        dtval,
        s;

    for (i in this._cancelRecurIds) {

        if (!this._cancelRecurIds[i]) {
            continue;
        }

        if (!exclude && !dates) {
            exclude = recur.exclude = {};
            dates = exclude.dates = {};
            // Fix for bug: 77998, 84054. Object was missing child element dtval as per soap doc.
            dates.dtval = [];
        }

        ridZ = i;
        dtval = {};
        s = dtval.s = {};
        s.d = ridZ;
        // dtval should hold list of timestamps for conflicting appointments.
        dates.dtval.push(dtval);
    }
};

/**
 * Gets the recurrence blurb.
 * 
 * @return	{String}	the blurb text
 */
ZmRecurrence.prototype.getBlurb =
function() {
	if (this.repeatType == ZmRecurrence.NONE)
		return "";

	var every = [];
	switch (this.repeatType) {
		case ZmRecurrence.DAILY: {
			if (this.repeatCustom == "1" && this.repeatWeekday) {
				every.push(ZmMsg.recurDailyEveryWeekday);
			} else if (this.repeatCustomCount == 1) {
				every.push(ZmMsg.recurDailyEveryDay);
			} else {
				var formatter = new AjxMessageFormat(ZmMsg.recurDailyEveryNumDays);
				every.push(formatter.format(this.repeatCustomCount));
			}
			break;
		}
		case ZmRecurrence.WEEKLY: {
			if (this.repeatCustomCount == 1 && this.repeatWeeklyDays.length == 1) {
				var dayofweek = AjxUtil.indexOf(ZmCalItem.SERVER_WEEK_DAYS, this.repeatWeeklyDays[0]);
				var date = new Date();
				date.setDate(date.getDate() - date.getDay() + dayofweek);

				var formatter = new AjxMessageFormat(ZmMsg.recurWeeklyEveryWeekday);
				every.push(formatter.format(date));
			} else {
				var weekdays = [];
				for (var i = 0; i < this.repeatWeeklyDays.length; i++) {
					var dayofweek = AjxUtil.indexOf(ZmCalItem.SERVER_WEEK_DAYS, this.repeatWeeklyDays[i]);
					var date = new Date();
					date.setDate(date.getDate() - date.getDay() + dayofweek);
					weekdays.push(date);
				}

				var formatter = new AjxMessageFormat(ZmMsg.recurWeeklyEveryNumWeeksDate);
				every.push(formatter.format([ this.repeatCustomCount, weekdays, "" ]));
			}
			break;
		}
		case ZmRecurrence.MONTHLY: {
			if (this.repeatCustomType == "S") {
				var count = Number(this.repeatCustomCount);
				var date = Number(this.repeatMonthlyDayList[0]);

				var formatter = new AjxMessageFormat(ZmMsg.recurMonthlyEveryNumMonthsDate);
				every.push(formatter.format([ date, count ]));
			} else {
				var ordinal = Number(this.repeatCustomOrdinal);
                var bysetpos = Number(this.repeatBySetPos);                                
                var dayofweek = AjxUtil.indexOf(ZmCalItem.SERVER_WEEK_DAYS, this.repeatCustomDayOfWeek);
				var day = new Date();
				day.setDate(day.getDate() - day.getDay() + dayofweek);
                var count = Number(this.repeatCustomCount);

                var days = this.repeatCustomDays.join(",");
                var workWeekDays = ZmCalItem.SERVER_WEEK_DAYS.slice(1,6).join(","); 
                var weekEndDays = [ZmCalItem.SERVER_WEEK_DAYS[AjxDateUtil.SUNDAY], ZmCalItem.SERVER_WEEK_DAYS[AjxDateUtil.SATURDAY]].join(",");

                //if both values are present and unequal give preference to repeatBySetPos
                if (this.repeatCustomOrdinal != null &&
                    this.repeatBySetPos != null &&
                    this.repeatCustomOrdinal != this.repeatBySetPos) {
                    this.repeatCustomOrdinal = this.repeatBySetPos;
                }

                if((ZmCalItem.SERVER_WEEK_DAYS.join(",") == days) || (workWeekDays == days) || (weekEndDays == days)) {
                    var formatter = new AjxMessageFormat(ZmMsg.recurMonthlyEveryNumMonthsWeekDays);
                    var dayType = -1;
                    if(workWeekDays == days) {
                        dayType = 1;
                    }else if(weekEndDays == days) {
                        dayType = 0;
                    }
                    every.push(formatter.format([ bysetpos || ordinal, dayType, count ]));
                }else {
                    var day = new Date();
                    day.setDate(day.getDate() - day.getDay() + dayofweek);
                    var formatter = new AjxMessageFormat(ZmMsg.recurMonthlyEveryNumMonthsNumDay);
                    every.push(formatter.format([ bysetpos || ordinal, day, count ]));
                }
			}
			break;
		}
		case ZmRecurrence.YEARLY: {
			if (this.repeatCustomType == "S") {
				var month = new Date();
				month.setMonth(Number(this.repeatYearlyMonthsList) - 1);
				var day = Number(this.repeatCustomMonthDay);

				var formatter = new AjxMessageFormat(ZmMsg.recurYearlyEveryDate);
				every.push(formatter.format([ month, day ]));
			} else {
				var ordinal = Number(this.repeatCustomOrdinal);
                var bysetpos = Number(this.repeatBySetPos);                
                var dayofweek = AjxUtil.indexOf(ZmCalItem.SERVER_WEEK_DAYS, this.repeatCustomDayOfWeek);
                var month = new Date();
                month.setMonth(Number(this.repeatYearlyMonthsList)-1);

                var days = this.repeatCustomDays.join(",");
                var workWeekDays = ZmCalItem.SERVER_WEEK_DAYS.slice(1,6).join(",");
                var weekEndDays = [ZmCalItem.SERVER_WEEK_DAYS[AjxDateUtil.SUNDAY], ZmCalItem.SERVER_WEEK_DAYS[AjxDateUtil.SATURDAY]].join(",");

                if((ZmCalItem.SERVER_WEEK_DAYS.join(",") == days) || (workWeekDays == days) || (weekEndDays == days)) {
                    var formatter = new AjxMessageFormat(ZmMsg.recurYearlyEveryMonthWeekDays);
                    var dayType = -1;
                    if(workWeekDays == days) {
                        dayType = 1;
                    }else if(weekEndDays == days) {
                        dayType = 0;
                    }
                    every.push(formatter.format([ bysetpos || ordinal, dayType, month ]));
                }else {

                    var day = new Date();
                    day.setDate(day.getDate() - day.getDay() + dayofweek);
                    var formatter = new AjxMessageFormat(ZmMsg.recurYearlyEveryMonthNumDay);
                    every.push(formatter.format([ bysetpos || ordinal, day, month ]));
                }
            }
			break;
		}
	}

	// start
	var start = [];
	var formatter = new AjxMessageFormat(ZmMsg.recurStart);
	start.push(formatter.format(this._startDate));

	// end
	var end = [];
	switch (this.repeatEndType) {
		case "N": {
			end.push(ZmMsg.recurEndNone);
			break;
		}
		case "A": {
			formatter = new AjxMessageFormat(ZmMsg.recurEndNumber);
			end.push(formatter.format(this.repeatEndCount));
			break;
		}
		case "D": {
			formatter = new AjxMessageFormat(ZmMsg.recurEndByDate);
			end.push(formatter.format(this.repeatEndDate));
			break;
		}
	}

	// join all three together
	if (every.length > 0) {
		every.push(".  ");
	}
	if (end.length > 0) {
		end.push(".  ");
	}
	formatter = new AjxMessageFormat(ZmMsg.recurBlurb);
	return formatter.format([ every.join(""), end.join(""), start.join("") ]);
};

ZmRecurrence.prototype.parse =
function(recurRules) {
	// bug 16513: This array never gets cleaned.
	// TODO: Maybe this needs a flag so it doesn't reparse?
	this.repeatWeeklyDays = [];

	for (var k = 0; k < recurRules.length ; ++k) {
		var adds = recurRules[k].add;
		if (!adds) continue;

		this.repeatYearlyMonthsList = this._startDate.getMonth() + 1;
		for (var i = 0; i < adds.length; ++i) {
			var rules = adds[i].rule;
			if (!rules) continue;

			for (var j = 0; j < rules.length; ++j) {
				var rule = rules[j];
				if (rule.freq) {
					this.repeatType = rule.freq.substring(0,3);
					if (rule.interval && rule.interval[0].ival) {
						this.repeatCustomCount = parseInt(rule.interval[0].ival);
						this.repeatCustom = "1";
					}
				}
				if (rule.bymonth) {
					this.repeatYearlyMonthsList = rule.bymonth[0].molist;
					this.repeatCustom = "1";
				}
				if (rule.bymonthday) {
					if (this.repeatType == ZmRecurrence.YEARLY) {
						this.repeatCustomMonthDay = rule.bymonthday[0].modaylist;
						this.repeatCustomType = "S";
					} else if (this.repeatType == ZmRecurrence.MONTHLY){
						this.repeatMonthlyDayList = rule.bymonthday[0].modaylist.split(",");
					}
					this.repeatCustom = "1";
				}
				if (rule.byday && rule.byday[0] && rule.byday[0].wkday) {
					this.repeatCustom = "1";
					var wkday = rule.byday[0].wkday;
					if (this.repeatType == ZmRecurrence.WEEKLY || (this.repeatType == ZmRecurrence.DAILY && wkday.length == 5)) {
						this.repeatWeekday = this.repeatType == ZmRecurrence.DAILY;
						for (var x = 0; x < wkday.length; ++x) {
							this.repeatWeeklyDays.push(wkday[x].day);
						}
					} else {
						this.repeatCustomDayOfWeek = wkday[0].day;
                        var days = [];
                        for(var i = 0; i < wkday.length; i++) {
                            days.push(wkday[i].day);
                        }
                        this.repeatCustomDays = days;                        
                        this.repeatCustomOrdinal = wkday[0].ordwk;
                        this.repeatBySetPos  = (rule.bysetpos && (rule.bysetpos.length > 0)) ? rule.bysetpos[0].poslist : null;
                        //ical sends only ordwk in recurrence rule, we follow outlook behavior in setting repeatbysetpos instead of ordwk
                        if(this.repeatBySetPos == null && this.repeatCustomOrdinal) {
                            this.repeatBySetPos  = this.repeatCustomOrdinal; 
                        }
                        this.repeatCustomType = "O";
					}
				}
				if (rule.until) {
					this.repeatEndType = "D";
					this.repeatEndDate = AjxDateUtil.parseServerDateTime(rule.until[0].d);
				} else if (rule.count) {
					this.repeatEndType = "A";
					this.repeatEndCount = rule.count[0].num;
				}
			}
		}
	}
};

ZmRecurrence.prototype.setRecurrenceStartTime =
function(startTime) {
	
	this._startDate.setTime(startTime);
    this.repeatCustomMonthDay	= this._startDate.getDate();    
	
	if (this.repeatType == ZmRecurrence.NONE) return;

	//if (this.repeatCustom != "0")
		//return;

 	if (this.repeatType == ZmRecurrence.WEEKLY) {
		this.repeatWeeklyDays = [ZmCalItem.SERVER_WEEK_DAYS[this._startDate.getDay()]];
	} else if (this.repeatType == ZmRecurrence.MONTHLY) {
		this.repeatMonthlyDayList = [this._startDate.getDate()];
    } else if (this.repeatType == ZmRecurrence.YEARLY) {
		this.repeatYearlyMonthsList = this._startDate.getMonth() + 1;	
	}
};

ZmRecurrence.prototype.setRecurrenceRules =
function(recurRules, startDate) {

    if (recurRules)
        this.parse(recurRules);    

    if(!startDate) return;

    if (this.repeatWeeklyDays == null) {
        this.repeatWeeklyDays = [ZmCalItem.SERVER_WEEK_DAYS[startDate.getDay()]];
    }
    if (this.repeatMonthlyDayList == null) {
        this.repeatMonthlyDayList = [startDate.getDate()];
    }

};

ZmRecurrence.prototype.addCancelRecurId =
function(ridZ) {
    this._cancelRecurIds[ridZ] = true;        
};

ZmRecurrence.prototype.resetCancelRecurIds =
function(   ) {
    this._cancelRecurIds = {};
};

ZmRecurrence.prototype.isInstanceCanceled =
function(ridZ) {
    return this._cancelRecurIds[ridZ];
};

ZmRecurrence.prototype.removeCancelRecurId =
function(ridZ) {
    this._cancelRecurIds[ridZ] = null;
};

ZmRecurrence.prototype.parseExcludeInfo =
function(recurInfo) {

    if (!recurInfo) { return; }

    for(var i=0; i < recurInfo.length; i++) {
        var excludeInfo = (recurInfo[i] && recurInfo[i].exclude) ? recurInfo[i].exclude : null;
        if(!excludeInfo) continue;
        for(var j=0; j < excludeInfo.length; j++) {
            var datesInfo = excludeInfo[j].dates;
            if(datesInfo) this._parseExcludeDates(datesInfo);
        }
    }

};

ZmRecurrence.prototype._parseExcludeDates =
function(datesInfo) {
    for(var j=0; j < datesInfo.length; j++) {

        var dtval = datesInfo[j].dtval;
        if(!dtval) continue;

        for(var k=0; k < dtval.length; k++) {
            var dinfo = dtval[k];
            var excludeDate = (dinfo && dinfo.s) ? dinfo.s[0].d : null;
            if(excludeDate) this.addCancelRecurId(excludeDate);
        }
    }
};

}

if (AjxPackage.define("zimbraMail.mail.model.ZmDataSource")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a data source.
 * @class
 * This class represents a data source.
 * 
 * @param	{constant}	type	the account type (see <code>ZmAccount.TYPE_</code> constants)
 * @param	{String}	id		the id
 * 
 * @extends		ZmAccount
 */
ZmDataSource = function(type, id) {
	if (arguments.length == 0) { return; }
	ZmAccount.call(this, type, id);
	this.reset();
};

ZmDataSource.prototype = new ZmAccount;
ZmDataSource.prototype.constructor = ZmDataSource;

ZmDataSource.prototype.toString =
function() {
	return "ZmDataSource";
};

//
// Constants
//
/**
 * Defines the "cleartext" connection type.
 */
ZmDataSource.CONNECT_CLEAR = "cleartext";
/**
 * Defines the "ssl" connection type.
 */
ZmDataSource.CONNECT_SSL = "ssl";
ZmDataSource.CONNECT_DEFAULT = ZmDataSource.CONNECT_CLEAR;

ZmDataSource.POLL_NEVER = "0";

// soap attribute to property maps

ZmDataSource.DATASOURCE_ATTRS = {
	// SOAP attr:		JS property
	"id":				"id",
	"name":				"name",
	"isEnabled":		"enabled",
	"emailAddress":		"email",
	"host":				"mailServer",
	"port":				"port",
	"username":			"userName",
	"password":			"password",
	"l":				"folderId",
	"connectionType":	"connectionType",
	"pollingInterval":	"pollingInterval",
    "smtpEnabled":      "smtpEnabled",
	"leaveOnServer":	"leaveOnServer" // POP only
};

ZmDataSource.IDENTITY_ATTRS = {
	// SOAP attr:					JS property
	"fromDisplay":					"sendFromDisplay",
	"useAddressForForwardReply":	"setReplyTo",
	"replyToAddress":				"setReplyToAddress",
	"replyToDisplay":				"setReplyToDisplay",
	"defaultSignature":				"signature",
	"forwardReplySignature":		"replySignature"
};

//
// Data
//

ZmDataSource.prototype.ELEMENT_NAME = "dsrc";

// data source settings

ZmDataSource.prototype.enabled = true;

// basic settings

ZmDataSource.prototype.mailServer = "";
ZmDataSource.prototype.userName = "";
ZmDataSource.prototype.password = "";
ZmDataSource.prototype.folderId = ZmOrganizer.ID_INBOX;

// advanced settings

ZmDataSource.prototype.leaveOnServer = true;
ZmDataSource.prototype.connectionType = ZmDataSource.CONNECT_DEFAULT;

//
// Public methods
//

/** NOTE: Email is same as the identity's from address. */
ZmDataSource.prototype.setEmail =
function(email) {
	this.email = email;
};

ZmDataSource.prototype.getEmail =
function() {
	var email = this.email != null ? this.email : this.identity.getField(ZmIdentity.SEND_FROM_ADDRESS); // bug: 23042
	if (!email) { // bug: 38175
		var provider = ZmDataSource.getProviderForAccount(this);
		var host = (provider && provider._host) || this.mailServer;
		email = "";
        if (this.userName) {
            if (this.userName.match(/@/)) email = this.userName; // bug: 48186
            else if (host) email = [ this.userName, host].join("@");
        }
	}
	return email;
};

ZmDataSource.prototype.setFolderId =
function(folderId) {
	// TODO: Is there a better way to do this?
	//       I basically need to have the folder selector on the options
	//       page have a value of -1 but allow other code to see that and
	//       fill in the correct folder id. But I don't want it to
	//       overwrite that value once set.
	if (folderId == -1 && this.folderId != ZmOrganizer.ID_INBOX) { return; }
	this.folderId = folderId;
};

ZmDataSource.prototype.getFolderId =
function() {
	return this.folderId;
};

ZmDataSource.prototype.getIdentity =
function() {
	return this.identity;
};

// operations

ZmDataSource.prototype.create =
function(callback, errorCallback, batchCommand) {
	var soapDoc = AjxSoapDoc.create("CreateDataSourceRequest", "urn:zimbraMail");
	var dsrc = soapDoc.set(this.ELEMENT_NAME);
	for (var aname in ZmDataSource.DATASOURCE_ATTRS) {
		var pname = ZmDataSource.DATASOURCE_ATTRS[aname];
		var pvalue = pname == "folderId"
			? ZmOrganizer.normalizeId(this[pname])
			: this[pname];
		if (pname == "id" || (!pvalue && pname != "enabled" && pname != "leaveOnServer")) continue;

		dsrc.setAttribute(aname, String(pvalue));
	}
	var identity = this.getIdentity();
	for (var aname in ZmDataSource.IDENTITY_ATTRS) {
		var pname = ZmDataSource.IDENTITY_ATTRS[aname];
		var pvalue = identity[pname];
		if (!pvalue) continue;

		dsrc.setAttribute(aname, String(pvalue));
	}

	var respCallback = new AjxCallback(this, this._handleCreateResponse, [callback]);
	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, respCallback, errorCallback);
		batchCommand.setSensitive(Boolean(this.password));
		return;
	}

	var params = {
		soapDoc: soapDoc,
		sensitive: Boolean(this.password),
		asyncMode: Boolean(callback),
		callback: respCallback,
		errorCallback: errorCallback
	};
	return appCtxt.getAppController().sendRequest(params);
};

ZmDataSource.prototype.save = function(callback, errorCallback, batchCommand, isIdentity) {

	var soapDoc = AjxSoapDoc.create("ModifyDataSourceRequest", "urn:zimbraMail");
	var dsrc = soapDoc.set(this.ELEMENT_NAME);
	// NOTE: If this object is a proxy, we guarantee that the
	//       the id attribute is *always* set.
	dsrc.setAttribute("id", this.id);
    if (!isIdentity) {
        for (var aname in ZmDataSource.DATASOURCE_ATTRS) {
            var pname = ZmDataSource.DATASOURCE_ATTRS[aname];
            if (!this.hasOwnProperty(pname)) {
                continue;
            }
            var avalue = this[pname];
            if (pname === "folderId") {
                avalue = ZmOrganizer.normalizeId(avalue);
            }
            // server sends us pollingInterval in ms, expects it back in seconds (!)
            // since it is not a user-visible value, it's safer to not send it back at all
            else if (pname === "pollingInterval") {
                continue;
            }
            dsrc.setAttribute(aname, String(avalue));
        }
    }
	var identity = this.getIdentity();
	for (var aname in ZmDataSource.IDENTITY_ATTRS) {
		var pname = ZmDataSource.IDENTITY_ATTRS[aname];
		if (!identity.hasOwnProperty(pname)) continue;

		var avalue = identity[pname];
		dsrc.setAttribute(aname, String(avalue));
	}

	var respCallback = new AjxCallback(this, this._handleSaveResponse, [callback]);
	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, respCallback, errorCallback);
		batchCommand.setSensitive(Boolean(this.password));
		return;
	}

	var params = {
		soapDoc: soapDoc,
		sensitive: Boolean(this.password),
		asyncMode: Boolean(callback),
		callback: respCallback,
		errorCallback: errorCallback
	};
	return appCtxt.getAppController().sendRequest(params);
};

ZmDataSource.prototype.doDelete =
function(callback, errorCallback, batchCommand) {
	var soapDoc = AjxSoapDoc.create("DeleteDataSourceRequest", "urn:zimbraMail");
	var dsrc = soapDoc.set(this.ELEMENT_NAME);
	dsrc.setAttribute("id", this.id);

	var respCallback = new AjxCallback(this, this._handleDeleteResponse, [callback]);
	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, respCallback, errorCallback);
		return;
	}

	var params = {
		soapDoc: soapDoc,
		asyncMode: Boolean(callback),
		callback: respCallback,
		errorCallback: errorCallback
	};
	return appCtxt.getAppController().sendRequest(params);
};

/**
 * Tests the data source connection.
 * 
 * @param	{AjxCallback}		callback		the callback
 * @param	{AjxCallback}		errorCallback		the error callback
 * @param	{ZmBatchCommand}		batchCommand		the batch command
 * @param	{Boolean}	noBusyOverlay		if <code>true</code>, do not show busy overlay
 * @return	{Object}	the response
 */
ZmDataSource.prototype.testConnection =
function(callback, errorCallback, batchCommand, noBusyOverlay) {
	var soapDoc = AjxSoapDoc.create("TestDataSourceRequest", "urn:zimbraMail");
	var dsrc = soapDoc.set(this.ELEMENT_NAME);

	var attrs = ["host", "port", "username", "password", "connectionType", "leaveOnServer"];
	for (var i = 0; i < attrs.length; i++) {
		var aname = attrs[i];
		var pname = ZmDataSource.DATASOURCE_ATTRS[aname];
		dsrc.setAttribute(aname, this[pname]);
	}

	if (batchCommand) {
		batchCommand.addNewRequestParams(soapDoc, callback, errorCallback);
		batchCommand.setSensitive(true);
		return;
	}

	var params = {
		soapDoc: soapDoc,
		sensitive: true,
		asyncMode: Boolean(callback),
		noBusyOverlay: noBusyOverlay,
		callback: callback,
		errorCallback: errorCallback
	};
	return appCtxt.getAppController().sendRequest(params);
};

/**
 * Gets the port.
 * 
 * @return	{int}	port
 */
ZmDataSource.prototype.getPort =
function() {
	return this.port || this.getDefaultPort();
};

ZmDataSource.prototype.isStatusOk = function() {
	return this.enabled && !this.failingSince;
};

ZmDataSource.prototype.setFromJson =
function(obj) {
	// errors
	if (obj.failingSince) {
		this.failingSince = obj.failingSince;
		this.lastError = (obj.lastError && obj.lastError[0]._content) || ZmMsg.unknownError;
	}
	else {
		delete this.failingSince;
		delete this.lastError;
	}
	// data source fields
	for (var aname in ZmDataSource.DATASOURCE_ATTRS) {
		var avalue = obj[aname];
		if (avalue == null) continue;
		if (aname == "isEnabled" || aname == "leaveOnServer") {
			avalue = avalue == "1" || String(avalue).toLowerCase() == "true";
		}
        // server sends us pollingInterval in ms, expects it back in seconds (!)
        else if (aname === "pollingInterval") {
            avalue = avalue / 1000;
        }
		var pname = ZmDataSource.DATASOURCE_ATTRS[aname];
		this[pname] = avalue;
	}

	// pseudo-identity fields
	var identity = this.getIdentity();
	for (var aname in ZmDataSource.IDENTITY_ATTRS) {
		var avalue = obj[aname];
		if (avalue == null) continue;
		if (aname == "useAddressForForwardReply") {
			avalue = avalue == "1" || String(avalue).toLowerCase() == "true";
		}

		var pname = ZmDataSource.IDENTITY_ATTRS[aname];
		identity[pname] = avalue;
	}
	this._setupIdentity();
};

ZmDataSource.prototype.reset = function() {
	// reset data source properties
	// NOTE: These have default values on the prototype object
	delete this.mailServer;
	delete this.userName;
	delete this.password;
	delete this.folderId;
	delete this.leaveOnServer;
	delete this.connectionType;
	delete this.pollingInterval;
	// other
	this.email = "";
	this.port = this.getDefaultPort();

	// reset identity
	var identity = this.identity = new ZmIdentity();
	identity.id = this.id;
	identity.isFromDataSource = true;
	
	// saving the identity itself won't work; need to save the data source
	var self = this;
	identity.save = function(callback, errorCallback, batchCommand) {
		ZmDataSource.prototype.save.call(self, callback, errorCallback, batchCommand, true);
	};
};

ZmDataSource.prototype.getProvider = function() {
	return ZmDataSource.getProviderForAccount(this);
};

//
// Public functions
//

// data source providers - provides default values

/**
 * Adds a data source provider. The registered providers are objects that
 * specify default values for data sources. This can be used to show the
 * user a list of known email providers (e.g. Yahoo! Mail) to pre-fill the
 * account information.
 *
 * @param {Hash}	provider  a hash of provider information
 * @param	{String}	provider.id		a unique identifier for this provider
 * @param	{String}	provider.name	the name of this provider to display to the user
 * @param	{String}	[provider.type]		the type (see <code>ZmAccount.TYPE_</code> constants)
 * @param	{String}	[provider.connectionType]	the connection type (see <code>ZmDataSource.CONNECT_</code> constants)
 * @param	{String}	[provider.host]	the server
 * @param	{String}	[provider.pollingInterval]		the polling interval
 * @param	{Boolean}	[provider.leaveOnServer]	if <code>true</code>, leave message on server (POP only)
 */
ZmDataSource.addProvider = function(provider) {
	var providers = ZmDataSource.getProviders();
	providers[provider.id] = provider;
	// normalize values -- defensive programming
	if (provider.type) {
		provider.type = provider.type.toLowerCase() == "pop" ? ZmAccount.TYPE_POP : ZmAccount.TYPE_IMAP;
	}
	else {
		provider.type = ZmAccount.TYPE_POP;
	}
	if (provider.connectionType) {
		var isSsl = provider.connectionType.toLowerCase() == "ssl";
		provider.connectionType =  isSsl ? ZmDataSource.CONNECT_SSL : ZmDataSource.CONNECT_CLEAR;
	}
	else {
		provider.connectionType = ZmDataSource.CONNECT_CLEAR;
	}
	if (!provider.port) {
		var isPop = provider.type == ZmAccount.TYPE_POP;
		if (isSsl) {
			provider.port = isPop ? ZmPopAccount.PORT_SSL : ZmImapAccount.PORT_SSL;
		}
		else {
			provider.port = isPop ? ZmPopAccount.PORT_CLEAR : ZmImapAccount.PORT_CLEAR;
		}
	}
};

/**
 * Gets the providers.
 * 
 * @return	{Array}		an array of providers
 */
ZmDataSource.getProviders =
function() {
	if (!ZmDataSource._providers) {
		ZmDataSource._providers = {};
	}
	return ZmDataSource._providers;
};

/**
 * Gets the provider.
 * 
 * @param	{ZmAccount}	account		the account
 * @return	{Hash}		the provider or <code>null</code> for none
 */
ZmDataSource.getProviderForAccount =
function(account) {
	return ZmDataSource.getProviderForHost(account.mailServer);
};

/**
 * Gets the provider.
 * 
 * @param	{String}	host		the host
 * @return	{Hash}		the provider or <code>null</code> for none
 */
ZmDataSource.getProviderForHost =
function(host) {
	var providers = ZmDataSource.getProviders();
	for (var id in providers) {
		hasProviders = true;
		var provider = providers[id];
		if (provider.host == host) {
			return provider;
		}
	}
	return null;
};

/**
 * Removes all providers.
 */
ZmDataSource.removeAllProviders = function() {
	delete ZmDataSource._providers;
};

//
// Protected methods
//


ZmDataSource.prototype._setupIdentity =
function() {
	this.identity.useWhenSentTo = true;
	this.identity.whenSentToAddresses = [ this.getEmail() ];
	this.identity.name = this.name;
};

ZmDataSource.prototype._loadFromDom =
function(data) {
	this.setFromJson(data);
};

ZmDataSource.prototype._handleCreateResponse =
function(callback, result) {
	var resp = result._data.CreateDataSourceResponse;
	this.id = resp[this.ELEMENT_NAME][0].id;
	this.identity.id = this.id;
	this._setupIdentity();
	delete this._new;
	delete this._dirty;

	appCtxt.getDataSourceCollection().add(this);

	var apps = [ZmApp.MAIL, ZmApp.PORTAL];
	for (var i=0; i<apps.length; i++) {
		var app = appCtxt.getApp(apps[i]);
		if (app) {
			var overviewId = app.getOverviewId();
			var treeView = appCtxt.getOverviewController().getTreeView(overviewId, ZmOrganizer.FOLDER);
			var fid = appCtxt.getActiveAccount().isMain ? this.folderId : ZmOrganizer.getSystemId(this.folderId);
			var treeItem = treeView ? treeView.getTreeItemById(fid) : null;
			if (treeItem) {
				// reset the icon in the tree view if POP account since the first time it
				// was created, we didnt know it was a data source
				if (this.type == ZmAccount.TYPE_POP && this.folderId != ZmFolder.ID_INBOX) {
					treeItem.setImage("POPAccount");
				}
				else if (this.type == ZmAccount.TYPE_IMAP) {
					// change imap folder to a tree header since folder is first created
					// without knowing its a datasource
					treeItem.dispose();
					var rootId = ZmOrganizer.getSystemId(ZmOrganizer.ID_ROOT);
					var parentNode = treeView.getTreeItemById(rootId);
					var organizer = appCtxt.getById(this.folderId);
					treeView._addNew(parentNode, organizer);
				}
			}
		}
	}

	if (callback) {
		callback.run();
	}
};

ZmDataSource.prototype._handleSaveResponse =
function(callback, result) {
	delete this._dirty;

	var collection = appCtxt.getDataSourceCollection();
	// NOTE: By removing and adding it again, we make this proxy the
	//       base datasource object in the collection.
	collection.remove(this);
	collection.add(this);

	if (callback) {
		callback.run();
	}
};

ZmDataSource.prototype._handleDeleteResponse =
function(callback, result) {
	appCtxt.getDataSourceCollection().remove(this);

	var overviewId = appCtxt.getApp(ZmApp.MAIL).getOverviewId();
	var treeView = appCtxt.getOverviewController().getTreeView(overviewId, ZmOrganizer.FOLDER);
	var fid = appCtxt.getActiveAccount().isMain ? this.folderId : ZmOrganizer.getSystemId(this.folderId);
	if(this.folderId == ZmAccountsPage.DOWNLOAD_TO_FOLDER && this._object_ && this._object_.folderId) {
		fid = this._object_.folderId;
	}	
	var treeItem = treeView ? treeView.getTreeItemById(fid) : null;
	if (treeItem) {
		if (this.type == ZmAccount.TYPE_POP && this.folderId != ZmFolder.ID_INBOX) {
			// reset icon since POP folder is no longer hooked up to a datasource
			treeItem.setImage("Folder");
		} else if (this.type == ZmAccount.TYPE_IMAP) {
			// reset the icon in the tree view if POP account since the first time it
			// was created, we didnt know it was a data source
			treeItem.dispose();
			var parentNode = treeView.getTreeItemById(ZmOrganizer.ID_ROOT);
			var organizer = appCtxt.getById(fid);
			if (organizer) {
				treeView._addNew(parentNode, organizer);
			}
		}
	}

	if (callback) {
		callback.run();
	}
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmDataSourceCollection")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates the data source collection.
 * @class
 * This class represents a data source collection.
 * 
 * @extends		ZmModel
 */
ZmDataSourceCollection = function() {
    ZmModel.call(this, ZmEvent.S_DATA_SOURCE);
	this._initialized = false;
	this._itemMap = {};
    this._pop3Map = {};
	this._imapMap = {};
};
ZmDataSourceCollection.prototype = new ZmModel;
ZmDataSourceCollection.prototype.constructor = ZmDataSourceCollection;

//
// Public methods
//

ZmDataSourceCollection.prototype.toString =
function() {
	return "ZmDataSourceCollection";
};

ZmDataSourceCollection.prototype.getItems = function() {
	return AjxUtil.values(this._itemMap);
};

ZmDataSourceCollection.prototype.getItemsFor = function(folderId) {
    var accounts = [];
    for (var id in this._itemMap) {
        var account = this._itemMap[id];
        if (account.folderId == folderId && account.enabled) {
            accounts.push(account);
        }
    }
    return accounts;
};

/**
 * Gets the POP accounts.
 * 
 * @return	{Array}	an array of {@link ZmPopAccount} objects
 */
ZmDataSourceCollection.prototype.getPopAccounts = function() {
    return AjxUtil.values(this._pop3Map);
};

/**
 * Gets the IMAP accounts.
 * 
 * @return	{Array}	an array of {@link ZmImapAccount} objects
 */
ZmDataSourceCollection.prototype.getImapAccounts = function() {
    return AjxUtil.values(this._imapMap);
};

/**
 * Gets the POP accounts.
 * 
 * @param	{String}	folderId		the folder id
 * @return	{Array}	an array of {@link ZmPopAccount} objects
 */
ZmDataSourceCollection.prototype.getPopAccountsFor = function(folderId) {
    var accounts = [];
    for (var id in this._pop3Map) {
        var account = this._pop3Map[id];
        if (account.folderId == folderId && account.enabled) {
            accounts.push(account);
        }
    }
    return accounts;
};

/**
 * Gets the IMAP accounts.
 * 
 * @param	{String}	folderId		the folder id
 * @return	{Array}	an array of {@link ZmImapAccount} objects
 */
ZmDataSourceCollection.prototype.getImapAccountsFor = function(folderId) {
    var accounts = [];
    for (var id in this._imapMap) {
        var account = this._imapMap[id];
        if (account.folderId == folderId && account.enabled) {
            accounts.push(account);
        }
    }
    return accounts;
};

ZmDataSourceCollection.prototype.importMailFor = function(folderId) {
	this.importMail(this.getItemsFor(folderId));
};

ZmDataSourceCollection.prototype.importPopMailFor = function(folderId) {
	this.importMail(this.getPopAccountsFor(folderId));
};

ZmDataSourceCollection.prototype.importImapMailFor = function(folderId) {
	this.importMail(this.getImapAccountsFor(folderId));
};

ZmDataSourceCollection.prototype.importMail = function(accounts) {
    if (accounts && accounts.length > 0) {
        var sourceMap = {};
        var soapDoc = AjxSoapDoc.create("ImportDataRequest", "urn:zimbraMail");
        for (var i = 0; i < accounts.length; i++) {
            var account = accounts[i];
            sourceMap[account.id] = account;

            var dsrc = soapDoc.set(account.ELEMENT_NAME);
            dsrc.setAttribute("id", account.id);
        }

	    // send import request
        var params = {
            soapDoc: soapDoc,
            asyncMode: true,
	        noBusyOverlay: true,
            callback: null,
            errorCallback: null
        };
        appCtxt.getAppController().sendRequest(params);

	    // kick off check status request because import request
	    // doesn't return for (potentially) a looong time
	    var delayMs = 2000;
	    var action = new AjxTimedAction(this, this.checkStatus, [sourceMap, delayMs]);
	    AjxTimedAction.scheduleAction(action, delayMs);
    }
};

ZmDataSourceCollection.prototype.getById = function(id) {
	return this._itemMap[id];
};

/**
 * Gets a list of data sources associated with the given folder ID.
 *
 * @param {String}	folderId		[String]	the folderId
 * @param {constant}	type			the type of data source (see <code>ZmAccount.TYPE_</code> constants)
 * @return	{Array}	an array of items
 * 
 * @see	ZmAccount
 */
ZmDataSourceCollection.prototype.getByFolderId = function(folderId, type) {
	var list = [];
	for (var id in this._itemMap) {
		var item = this._itemMap[id];
		if (item.folderId == folderId) {
			if (!type || (type && type == item.type))
				list.push(item);
		}
	}
	return list;
};

ZmDataSourceCollection.prototype.add = function(item) {
	this._itemMap[item.id] = item;
	if (item.type == ZmAccount.TYPE_POP) {
		this._pop3Map[item.id] = item;
	}
	else if (item.type == ZmAccount.TYPE_IMAP) {
		this._imapMap[item.id] = item;
	}
	appCtxt.getIdentityCollection().add(item.getIdentity());
	this._notify(ZmEvent.E_CREATE, {item:item});
};

ZmDataSourceCollection.prototype.modify = function(item) {
	appCtxt.getIdentityCollection().notifyModify(item.getIdentity(), true);
    this._notify(ZmEvent.E_MODIFY, {item:item});
};

ZmDataSourceCollection.prototype.remove = function(item) {
    delete this._itemMap[item.id];
	delete this._pop3Map[item.id];
	delete this._imapMap[item.id];
	appCtxt.getIdentityCollection().remove(item.getIdentity());
    this._notify(ZmEvent.E_DELETE, {item:item});
};

ZmDataSourceCollection.prototype.initialize = function(dataSources) {
	if (!dataSources || this._initialized) { return; }

	var errors = [];

	if (appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED)) {
		var popAccounts = dataSources.pop3 || [];
		for (var i = 0; i < popAccounts.length; i++) {
			var object = popAccounts[i];
			var dataSource = new ZmPopAccount(object.id);
			dataSource.setFromJson(object);
			this.add(dataSource);
			if (!dataSource.isStatusOk()) {
				errors.push(dataSource);
			}
		}
	}

	if (appCtxt.get(ZmSetting.IMAP_ACCOUNTS_ENABLED)) {
		var imapAccounts = dataSources.imap || [];
		for (var i = 0; i < imapAccounts.length; i++) {
			var object = imapAccounts[i];
			var dataSource = new ZmImapAccount(object.id);
			dataSource.setFromJson(object);
			this.add(dataSource);
			if (!dataSource.isStatusOk()) {
				errors.push(dataSource);
			}
		}
	}

	this._initialized = true;

	var count = errors.length;
	if (count > 0) {
		// build error message
		var array = [
			AjxMessageFormat.format(ZmMsg.dataSourceFailureDescription, [count])
		];
		for (var i = 0; i < count; i++) {
			var dataSource = errors[i];
			var timestamp = Number(dataSource.failingSince);
			var lastError = dataSource.lastError;
			if (isNaN(timestamp)) {
				var pattern = ZmMsg.dataSourceFailureItem_noDate;
				var params = [AjxStringUtil.htmlEncode(dataSource.getName()), AjxStringUtil.htmlEncode(lastError)];
			} else {
				var pattern = ZmMsg.dataSourceFailureItem;
				var params = [AjxStringUtil.htmlEncode(dataSource.getName()), new Date(timestamp * 1000), AjxStringUtil.htmlEncode(lastError)];
			}
			array.push(AjxMessageFormat.format(pattern, params));
		}
		array.push(ZmMsg.dataSourceFailureInstructions);
		var message = array.join("");

		// show error message
		var shell = DwtShell.getShell(window);
		var dialog = new DwtMessageDialog({parent:shell,buttons:[DwtDialog.OK_BUTTON,DwtDialog.CANCEL_BUTTON]});
		dialog.setMessage(message, DwtMessageDialog.CRITICAL_STYLE, ZmMsg.dataSourceFailureTitle);
		dialog.setButtonListener(DwtDialog.OK_BUTTON, new AjxListener(this, this.__handleErrorDialogOk, [dialog]));
		dialog.popup();
	}
};

ZmDataSourceCollection.prototype.__handleErrorDialogOk = function(dialog) {
	dialog.popdown();

	var callback = new AjxCallback(this, this.__gotoPrefSection, ["ACCOUNTS"]);
	appCtxt.getAppController().activateApp(ZmApp.PREFERENCES, true, callback);
};

ZmDataSourceCollection.prototype.__gotoPrefSection = function(prefSectionId) {
	var controller = appCtxt.getApp(ZmApp.PREFERENCES).getPrefController();
	controller.getPrefsView().selectSection(prefSectionId);
};

/**
 * Periocially check status of the import
 * @param {Object} sourceMap map of accounts
 * @param {int} delayMs delay time between checks
 */
ZmDataSourceCollection.prototype.checkStatus =
function(sourceMap, delayMs) {
	// Slowly back off import status checks but no more than 15 secs.
	if (delayMs && delayMs < 15000) {
		delayMs += 2000;
	}

    var soapDoc = AjxSoapDoc.create("GetImportStatusRequest", "urn:zimbraMail");
    var callback = new AjxCallback(this, this._checkStatusResponse, [sourceMap, delayMs]);
    var params = {
        soapDoc: soapDoc,
        asyncMode: true,
        callback: callback,
        errorCallback: null
    };

    var appController = appCtxt.getAppController();
    var action = new AjxTimedAction(appController, appController.sendRequest, [params]);
    AjxTimedAction.scheduleAction(action, delayMs || 2000);
};

//
// Protected methods
//

ZmDataSourceCollection.prototype._checkStatusResponse =
function(sourceMap, delayMs, result) {
	var dataSources = [];

	// gather sources from the response
	var popSources = result._data.GetImportStatusResponse.pop3;
	if (popSources) {
		for (var i in popSources) {
			dataSources.push(popSources[i]);
		}
	}
	var imapSources = result._data.GetImportStatusResponse.imap;
	if (imapSources) {
		for (var i in imapSources) {
			dataSources.push(imapSources[i]);
		}
	}
	var genericSources = result._data.GetImportStatusResponse.dsrc;
	if (genericSources) {
		for (var i in genericSources) {
			dataSources.push(genericSources[i]);
		}
	}

	// is there anything to do?
	if (dataSources.length == 0) return;

	// report status
	for (var i = 0; i < dataSources.length; i++) {
		var dsrc = dataSources[i];
		// NOTE: Only report the ones we were asked to; forget others
		if (!dsrc.isRunning && sourceMap[dsrc.id]) {
			var source = sourceMap[dsrc.id];
			if (sourceMap[dsrc.id]) {
				delete sourceMap[dsrc.id];
				if (dsrc.success) {
					var message = AjxMessageFormat.format(ZmMsg.dataSourceLoadSuccess, AjxStringUtil.htmlEncode(source.name));
					appCtxt.setStatusMsg(message);
				}
				else {
					var message = AjxMessageFormat.format(ZmMsg.dataSourceLoadFailure, AjxStringUtil.htmlEncode(source.name));
					appCtxt.setStatusMsg(message, ZmStatusView.LEVEL_CRITICAL);
					var dialog = appCtxt.getErrorDialog();
					dialog.setMessage(message, dsrc.error, DwtMessageDialog.CRITICAL_STYLE);
					dialog.popup();
				}
			}
		}
	}

	// continue checking status
	if (AjxUtil.keys(sourceMap).length > 0) {
		this.checkStatus(sourceMap, delayMs);
	}
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmPopAccount")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an POP account.
 * @class
 * This class represents an POP account.
 * 
 * @param	{String}	id		the id
 * 
 * @extends		ZmDataSource
 */ZmPopAccount = function(id) {
	ZmDataSource.call(this, ZmAccount.TYPE_POP, id);
};

ZmPopAccount.prototype = new ZmDataSource;
ZmPopAccount.prototype.constructor = ZmPopAccount;

// Constants
/**
 * Defines the "cleartext" port.
 * 
 * @type	int
 */
ZmPopAccount.PORT_CLEAR 	= 110;
/**
 * Defines the "ssl" port.
 * 
 * @type	int
 */
ZmPopAccount.PORT_SSL 		= 995;
ZmPopAccount.PORT_DEFAULT	= ZmPopAccount.PORT_CLEAR;


// advanced settings
ZmPopAccount.prototype.ELEMENT_NAME = "pop3";
ZmPopAccount.prototype.port = ZmPopAccount.PORT_DEFAULT;


// Public methods

ZmPopAccount.prototype.toString =
function() {
	return "ZmPopAccount";
};

/**
 * Gets the default port.
 * 
 * @return	{int}		the port
 */
ZmPopAccount.prototype.getDefaultPort =
function() {
	return (this.connectionType == ZmDataSource.CONNECT_SSL)
		? ZmPopAccount.PORT_SSL : ZmPopAccount.PORT_DEFAULT;
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmImapAccount")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2009, 2010, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an IMAP account.
 * @class
 * This class represents an IMAP account.
 * 
 * @param	{String}	id		the id
 * 
 * @extends		ZmDataSource
 */
ZmImapAccount = function(id) {
	ZmDataSource.call(this, ZmAccount.TYPE_IMAP, id);
};

ZmImapAccount.prototype = new ZmDataSource;
ZmImapAccount.prototype.constructor = ZmImapAccount;


// Constants
/**
 * Defines the "cleartext" port.
 * 
 * @type	int
 */
ZmImapAccount.PORT_CLEAR	= 143;
/**
 * Defines the "ssl" port.
 * 
 * @type	int
 */
ZmImapAccount.PORT_SSL		= 993;
ZmImapAccount.PORT_DEFAULT	= ZmImapAccount.PORT_CLEAR;


// advanced settings
ZmImapAccount.prototype.ELEMENT_NAME = "imap";
ZmImapAccount.prototype.port = ZmImapAccount.PORT_DEFAULT;


// Public methods

ZmImapAccount.prototype.toString =
function() {
	return "ZmImapAccount";
};

/**
 * Gets the default port.
 * 
 * @return	{int}		the port
 */
ZmImapAccount.prototype.getDefaultPort =
function() {
	return (this.connectionType == ZmDataSource.CONNECT_SSL)
		? ZmImapAccount.PORT_SSL : ZmImapAccount.PORT_DEFAULT;
};

/**
 * Comparison function for *IMAP* folders. Since IMAP folderId's are *not* well-
 * known, we have to compare their names instead of their ID's.
 * 
 * @param	{ZmFolder}	folderA
 * @param	{ZmFolder}	folderB
 * @return	{int}	0 if the folders are the same; 1 if "a" is before "b"; -1 if "b" is before "a"
 */
ZmImapAccount.sortCompare =
function(folderA, folderB) {
	var check = ZmOrganizer.checkSortArgs(folderA, folderB);
	if (check != null) { return check; }

	var aId = ZmFolder.getIdForName(folderA.name);
	var bId = ZmFolder.getIdForName(folderB.name);

	if (ZmFolder.SORT_ORDER[aId] && ZmFolder.SORT_ORDER[bId]) {
		return (ZmFolder.SORT_ORDER[aId] - ZmFolder.SORT_ORDER[bId]);
	}
	if (!ZmFolder.SORT_ORDER[aId] && ZmFolder.SORT_ORDER[bId]) { return 1; }
	if (ZmFolder.SORT_ORDER[aId] && !ZmFolder.SORT_ORDER[bId]) { return -1; }
	if (folderA.name.toLowerCase() > folderB.name.toLowerCase()) { return 1; }
	if (folderA.name.toLowerCase() < folderB.name.toLowerCase()) { return -1; }
	return 0;
};

}
if (AjxPackage.define("zimbraMail.mail.model.ZmIdentity")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an identity.
 * @class
 * This class represents an identity.
 * 
 * @param	{String}	name		the identity name
 * 
 */
ZmIdentity = function(name) {

	this.reset();
	this.name = name;
	this.id = "";
};

ZmIdentity.prototype.toString =
function() {
	return "ZmIdentity";
};


// Constants

ZmIdentity.COMPOSE_SAME				= "same";
ZmIdentity.COMPOSE_TEXT 			= "text";
ZmIdentity.COMPOSE_HTML 			= "html";
ZmIdentity.DEFAULT_NAME 			= "DEFAULT";


ZmIdentity.FIELDS	= {};
ZmIdentity._SOAP	= {};

ZmIdentity.SIG_ID_NONE = "11111111-1111-1111-1111-111111111111";

// Static inititialization

ZmIdentity.addField =
function(id, params) {

	ZmIdentity[id] = id;
	ZmIdentity.FIELDS[id] = params;
	ZmIdentity._SOAP[params.soap] = params;
};

// Identity fields. The "name" parameter is used to set a property on this object.

ZmIdentity.addField("NAME",						{ name: "name", soap: "zimbraPrefIdentityName", type: ZmSetting.D_STRING });
ZmIdentity.addField("SEND_FROM_DISPLAY",		{ name: "sendFromDisplay", soap: "zimbraPrefFromDisplay", type: ZmSetting.D_STRING });
ZmIdentity.addField("SEND_FROM_ADDRESS",		{ name: "sendFromAddress", soap: "zimbraPrefFromAddress", type: ZmSetting.D_STRING });
ZmIdentity.addField("SEND_FROM_ADDRESS_TYPE",	{ name: "sendFromAddressType", soap: "zimbraPrefFromAddressType", type: ZmSetting.D_STRING });
ZmIdentity.addField("SET_REPLY_TO",				{ name: "setReplyTo", soap: "zimbraPrefReplyToEnabled", type: ZmSetting.D_BOOLEAN });
ZmIdentity.addField("SET_REPLY_TO_DISPLAY",		{ name: "setReplyToDisplay", soap: "zimbraPrefReplyToDisplay", type: ZmSetting.D_STRING });
ZmIdentity.addField("SET_REPLY_TO_ADDRESS",		{ name: "setReplyToAddress", soap: "zimbraPrefReplyToAddress", type: ZmSetting.D_STRING });
ZmIdentity.addField("SIGNATURE",				{ name: "signature", soap: "zimbraPrefDefaultSignatureId", type: ZmSetting.D_STRING });
ZmIdentity.addField("REPLY_SIGNATURE",			{ name: "replySignature", soap: "zimbraPrefForwardReplySignatureId", type: ZmSetting.D_STRING });

// Used only for Persona
ZmIdentity.addField("USE_WHEN_SENT_TO",			{ name: "useWhenSentTo", soap: "zimbraPrefWhenSentToEnabled", type: ZmSetting.D_BOOLEAN });
ZmIdentity.addField("WHEN_SENT_TO_ADDRESSES",	{ name: "whenSentToAddresses", soap: "zimbraPrefWhenSentToAddresses", type: ZmSetting.D_LIST });
ZmIdentity.addField("USE_WHEN_IN_FOLDER",		{ name: "useWhenInFolder", soap: "zimbraPrefWhenInFoldersEnabled", type: ZmSetting.D_BOOLEAN });
ZmIdentity.addField("WHEN_IN_FOLDERIDS",		{ name: "whenInFolderIds", soap: "zimbraPrefWhenInFolderIds", type: ZmSetting.D_LIST });


// Public methods

/**
 * Gets the field.
 * 
 * @param	{constant}	fieldId		the id
 * @return	{Object}	the value
 */
ZmIdentity.prototype.getField =
function(fieldId) {
	return this[ZmIdentity.FIELDS[fieldId].name];
};

/**
 * Sets the field.
 * 
 * @param	{constant}	fieldId		the id
 * @param	{Object}	value		the value
 */
ZmIdentity.prototype.setField =
function(fieldId, value) {
	this[ZmIdentity.FIELDS[fieldId].name] = value;
};

/**
 * Creates the identity.
 * 
 * @param	{AjxCallback}		callback		the callback
 * @param	{AjxCallback}		errorCallback		the error callback
 * @param	{ZmBatchCommand}		batchCmd		the batch command
 */
ZmIdentity.prototype.create =
function(callback, errorCallback, batchCmd) {
	return this._doRequest("Create", this._handleCreateResponse, callback, errorCallback, batchCmd);
};

/**
 * Saves the identity.
 * 
 * @param	{AjxCallback}		callback		the callback
 * @param	{AjxCallback}		errorCallback		the error callback
 * @param	{ZmBatchCommand}		batchCmd		the batch command
 */
ZmIdentity.prototype.save =
function(callback, errorCallback, batchCmd) {
	return this._doRequest("Modify", this._handleSaveResponse, callback, errorCallback, batchCmd);
};

/**
 * Deletes the identity.
 * 
 * @param	{AjxCallback}		callback		the callback
 * @param	{AjxCallback}		errorCallback		the error callback
 * @param	{ZmBatchCommand}		batchCmd		the batch command
 */
ZmIdentity.prototype.doDelete =
function(callback, errorCallback, batchCmd) {
	return this._doRequest("Delete", this._handleDeleteResponse, callback, errorCallback, batchCmd);
};

/**
 * Clears this identity's fields.
 */
ZmIdentity.prototype.reset =
function() {
	for (var field in ZmIdentity.FIELDS) {
		var props = ZmIdentity.FIELDS[field];
		switch (props.type) {
			case ZmSetting.D_STRING:	this[props.name] = "";		break;
			case ZmSetting.D_BOOLEAN:	this[props.name] = false;	break;
			case ZmSetting.D_LIST:		this[props.name] = [];		break;
		}
	}
};

// Protected methods

ZmIdentity.prototype._doRequest =
function(requestType, respFunction, callback, errorCallback, batchCmd) {

	var soapDoc = AjxSoapDoc.create(requestType + "IdentityRequest", "urn:zimbraAccount");
	var identityNode = soapDoc.set("identity");

	var name = this.isDefault ? ZmIdentity.DEFAULT_NAME : this.name;
	if (requestType != "Create" && this.id !== "") {
		identityNode.setAttribute("id", this.id);
	}
	else {
		identityNode.setAttribute("name", this.name);
	}
	if (requestType != "Delete") {
		for (var i in ZmIdentity.FIELDS) {
			var field = ZmIdentity.FIELDS[i];
			if (this.hasOwnProperty(field.name)) {
				var value = this.getField(i);
				if (field.type == ZmSetting.D_LIST) {
					for (var j = 0, count = value.length; j < count; j++) {
						if (value[j]) {
							var propertyNode = soapDoc.set("a", value[j], identityNode);
							propertyNode.setAttribute("name", field.soap);
						}
					}
				} else {
					if (field.type == ZmSetting.D_BOOLEAN) {
						value = value ? "TRUE" : "FALSE";
					}
					var isSignature = (i == ZmIdentity.SIGNATURE || i == ZmIdentity.REPLY_SIGNATURE);
					var isDisplayName = (i == ZmIdentity.SEND_FROM_DISPLAY || i == ZmIdentity.SET_REPLY_TO_DISPLAY);
					var isEmailAddress = (i == ZmIdentity.SET_REPLY_TO_ADDRESS);
					if (value || isSignature || isDisplayName || isEmailAddress) {
						var propertyNode = soapDoc.set("a", value, identityNode);
						propertyNode.setAttribute("name", field.soap);
					}
				}
			}
		}
	}

	var respCallback = new AjxCallback(this, respFunction, [callback]);
	if (batchCmd) {
		batchCmd.addNewRequestParams(soapDoc, respCallback, errorCallback);
		return;
	}

	var params = {
		soapDoc: soapDoc,
		asyncMode: Boolean(callback),
		callback: respCallback,
		errorCallback: errorCallback
	};

	return appCtxt.getAppController().sendRequest(params);
};

ZmIdentity.prototype._loadFromDom =
function(data) {

	this.id = data.id;

    var props = data._attrs;
	if (props) {
		for (var i in props) {
			var field = ZmIdentity._SOAP[i];
			if (field) {
				var value = props[i];
				if (field.type == ZmSetting.D_BOOLEAN) {
					this[field.name] = (value.toString().toUpperCase() == "TRUE");
				}
				else if (field.type == ZmSetting.D_LIST) {
					this[field.name] = AjxUtil.isArray(value) ? value : [value];
				}
				else {
					this[field.name] = value;
				}
			}
		}
	}

    if (data.name) {
		if (data.name == ZmIdentity.DEFAULT_NAME) {
			this.isDefault = true;
        }
	}
};

ZmIdentity.prototype._handleCreateResponse =
function(callback, result, response) {

	this.id = response.identity[0].id;
	delete this._new;
	delete this._dirty;

	var collection = appCtxt.getIdentityCollection();
	collection.add(this);
	collection._notify(ZmEvent.E_CREATE, { item: this } );

	if (callback) {
		callback.run(this, result);
	}
};

ZmIdentity.prototype._handleSaveResponse =
function(callback, result, response) {

	delete this._dirty;

	var collection = appCtxt.getIdentityCollection();
	collection.remove(this);
	collection.add(this);
	collection._notify(ZmEvent.E_MODIFY, { item: this } );

	if (callback) {
		callback.run(this, result);
	}
};

ZmIdentity.prototype._handleDeleteResponse =
function(callback, result, response) {

	var collection = appCtxt.getIdentityCollection();
	collection.remove(this);
	collection._notify(ZmEvent.E_DELETE, { item: this } );

	if (callback) {
		callback.run(this, result);
	}
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmIdentityCollection")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2007, 2008, 2009, 2010, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2007, 2008, 2009, 2010, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates the identity collection.
 * @class
 * This class represents the identity collection
 * 
 * @extends		ZmModel
 */
ZmIdentityCollection = function() {
	ZmModel.call(this, ZmEvent.S_IDENTITY);
	this.defaultIdentity = null;
	this._initialized = false;
	this._idToIdentity = {};
	this._addressToIdentity = {};
	this._folderToIdentity = {};
	this._size = 0;
};

ZmIdentityCollection.prototype = new ZmModel;
ZmIdentityCollection.prototype.constructor = ZmIdentityCollection;

ZmIdentityCollection.prototype.toString =
function() {
	return "ZmIdentityCollection";
};

//
// Public methods
//

/**
 * Gets the count of identities.
 * 
 * @return	{int}		the size
 */
ZmIdentityCollection.prototype.getSize =
function() {
	// bug: 30009
	return this.getIdentities().length;
};

/**
 * Gets the identities.
 * 
 * @param	{Object}	sort		(not used)
 * @return	{Array}		an array of {ZmIdentity} objects
 */
ZmIdentityCollection.prototype.getIdentities =
function(sort) {
	var identity, i = 0, result = [], isOffline = appCtxt.isOffline;
	for (var id in this._idToIdentity) {
		identity = this._idToIdentity[id];
		// bug: 30009
		if (isOffline && identity.isFromDataSource) continue;
		result[i++] = identity;
	}
	if (sort) {
		result.sort(ZmIdentityCollection._comparator);
	}
	return result;
};

/**
 * Gets the identity by id.
 * 
 * @param	{String}	id	the identity id
 * @return	{ZmIdentity}	the identity
 */
ZmIdentityCollection.prototype.getById =
function(id) {
	return this._idToIdentity[id];
};

/**
 * Gets the identity by name.
 * 
 * @param	{String}	name		the identity name
 * @return	{ZmIdentity}	the identity
 */
ZmIdentityCollection.prototype.getByName =
function(name) {
	name = name.toLowerCase();
	for (var id in this._idToIdentity) {
		var identity = this._idToIdentity[id];
		if (identity.name.toLowerCase() == name) {
			return identity;
		}
	}
	return null;
};

/**
 * Adds the identity to the collection.
 * 
 * @param	{ZmIdentity}	identity		the identity
 */
ZmIdentityCollection.prototype.add =
function(identity) {
	if (!this._idToIdentity[identity.id]) {
		this._idToIdentity[identity.id] = identity;
		if (identity.isDefault) {
			this.defaultIdentity = identity;
		}

		this._addToMaps(identity);
		this._size++;
	}
};

/**
 * Removes the identity from the collection.
 * 
 * @param	{ZmIdentity}	identity		the identity
 */
ZmIdentityCollection.prototype.remove =
function(identity) {
	if (this._idToIdentity[identity.id]) {
		this._removeFromMaps(identity);
		delete this._idToIdentity[identity.id];
		this._size--;
	}
};
/**
 * try to find the persona to use from the rules defined in the accounts settings. Recurse to parent so to apply rules to sub-folders too.
 * @param folderId
 * @returns {*}
 */
ZmIdentityCollection.prototype.selectIdentityFromFolder =
function(folderId) {
	if (!folderId) {
		return this.defaultIdentity;
	}
	var folder = appCtxt.getById(folderId);
	var parent = folder.parent;
	return this._folderToIdentity[folder.getRemoteId()] || this.selectIdentityFromFolder(parent && parent.id);
};

ZmIdentityCollection.prototype.selectIdentity =
function(mailMsg, type) {
	if (!appCtxt.get(ZmSetting.IDENTITIES_ENABLED) || !mailMsg) {
		return this.defaultIdentity;
	}

	// Check if the a identity's address was in the given type field.
	if (type) {
		return this._selectIdentityFromAddresses(mailMsg, type);
	}

	// Check if the a identity's address was in the to field.
	var identity = this._selectIdentityFromAddresses(mailMsg, AjxEmailAddress.TO);
	if (identity) { return identity; }

	// Check if the a identity's address was in the cc field.
	identity = this._selectIdentityFromAddresses(mailMsg, AjxEmailAddress.CC);
	if (identity) { return identity; }

    //Check if a identity's address was in the attendees list
    if(mailMsg.isInvite()) {
        identity = this._selectIdentityFromAttendees(mailMsg);
        if (identity) { return identity; }
    }

	// Check if a identity's folder is the same as where the message lives.
	return this.selectIdentityFromFolder(mailMsg.folderId);
};

ZmIdentityCollection.prototype.initialize =
function(data) {
	// This can be called unnecessarily after auth token expires.
	if (this._initialized || this.getSize() || !data) { return; }

	var identities = data.identity;
	for (var i = 0, count = identities ? identities.length : 0; i < count; i++) {
		var identity = new ZmIdentity('');
		identity._loadFromDom(identities[i]);
		this.add(identity);
	}
	this._initialized = true;
};

//
// Protected methods
//

ZmIdentityCollection.prototype._addToMaps =
function(identity) {
	if (identity.useWhenSentTo) {
		var addresses = identity.whenSentToAddresses;
		for (var i = 0, count = addresses.length; i < count; i++) {
			var address = addresses[i].toLowerCase();
			// External emails are added after other identities, potentially overwriting a persona which should have
			// precedence.  Use the external identity only if the email address has not been assigned an identity.
			if (!this._addressToIdentity[address] || !identity.isFromDataSource) {
				this._addressToIdentity[address] = identity;
			}
		}
	}

	if (identity.useWhenInFolder) {
		var folders = identity.whenInFolderIds;
		for (var i = 0, count = folders.length; i < count; i++) {
			var folder = appCtxt.getById(folders[i]);
			if (folder) {
				var fid = folder.getRemoteId();
				this._folderToIdentity[fid] = identity;
			}
		}
	}
};

ZmIdentityCollection.prototype._removeFromMaps =
function(identity) {
	for (var i = 0, count = identity.whenSentToAddresses.length; i < count; i++) {
		var address = identity.whenSentToAddresses[i];
		delete this._addressToIdentity[address];
	}

	for (var i = 0, count = identity.whenInFolderIds.length; i < count; i++) {
		var folder = appCtxt.getById(identity.whenInFolderIds[i]);
		if (folder) {
			var fid = folder.getRemoteId();
			delete this._folderToIdentity[fid];
		}
	}
};

ZmIdentityCollection._comparator =
function(a, b) {
	if (a.isDefault) {
		return -1;
	} else if (b.isDefault) {
		return 1;
	} else {
		return a.name == b.name ? 0 : a.name < b.name ? -1 : 1;
	}
};

ZmIdentityCollection.prototype.getSortIndex =
function(identity) {

	var identities = this.getIdentities(true);
	if (!(identities && identities.length)) { return 0; }

	if (this.getById(identity.id)) {
		// already have the identity, find its current position
		for (var i = 0; i < identities.length; i++) {
			if (identities[i].id == identity.id) {
				return i;
			}
		}
	} else {
		// hasn't been added yet, find where it should go
		for (var i = 0; i < identities.length; i++) {
			var test = ZmIdentityCollection._comparator(identity, identities[i]);
			if (test == -1) {
				return i;
			}
		}
	}
	return identities.length - 1;
};

ZmIdentityCollection.prototype._selectIdentityFromAddresses =
function(mailMsg, type) {
	var identity;
	var addresses = mailMsg.getAddresses(type).getArray();
	for (var i = 0, count = addresses.length; i < count; i++) {
		var address = addresses[i].getAddress();
		if (address) {
			identity = this._addressToIdentity[address.toLowerCase()];
			if(identity) {
				return identity;
			}
		}
	}
	return null;
};

/**
 * Gets the identity based on attendees list
 *
 * @param	{ZmMailMsg}	    mail msg which is an invitation, passing non-invite mail msg will return null
 * @return	{ZmIdentity}	the identity
 */
ZmIdentityCollection.prototype._selectIdentityFromAttendees =
function(mailMsg) {

    if(!mailMsg.isInvite()) return null;

	var identity;
    var attendees = mailMsg.invite.getAttendees();

    if(!attendees) return null;
    
	for (var i = 0, count = attendees.length; i < count; i++) {
		var address = attendees[i].url;
		if (address) {
			identity = this._addressToIdentity[address.toLowerCase()];
			if(identity) {
				return identity;
			}
		}
	}
    
	return null;
};

ZmIdentityCollection.prototype.getIdentityBySendAddress =
function(address) {
    for(var id in this._idToIdentity){
        var identity = this._idToIdentity[id];
        if(identity.sendFromAddress == address){
            return identity;
        }
    }
    return null;
};
}
if (AjxPackage.define("zimbraMail.prefs.model.ZmPersona")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2006, 2007, 2008, 2009, 2010, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a personna.
 * @class
 * This class represents a personna.
 * 
 * @param	{ZmIdentity}		identity		the identity
 * @param	{Object}		list		the list
 * @extends		ZmAccount
 */
ZmPersona = function(identity, list) {
	if (arguments.length == 0) { return; }
	
	ZmAccount.call(this, ZmAccount.TYPE_PERSONA, identity.id, null, list);

	identity.sendFromDisplay = identity.sendFromDisplay || appCtxt.get(ZmSetting.DISPLAY_NAME);
	identity.sendFromAddress = identity.sendFromAddress || appCtxt.get(ZmSetting.USERNAME);
    identity.sendFromAddressType = identity.sendFromAddressType || ZmSetting.SEND_AS;
	this.identity = identity;
};
ZmPersona.prototype = new ZmAccount;
ZmPersona.prototype.constructor = ZmPersona;

ZmPersona.prototype.toString =
function() {
	return "ZmPersona";
};


//
// Public methods
//

ZmPersona.prototype.setName =
function(name) {
	this.getIdentity().name = AjxStringUtil.htmlEncode(name);
};

ZmPersona.prototype.getName =
function() {
	return AjxStringUtil.htmlDecode(this.getIdentity().name);
};

ZmPersona.prototype.setEmail =
function(email) {
	this.getIdentity().sendFromAddress = email;
};

ZmPersona.prototype.getEmail =
function() {
	return this.getIdentity().sendFromAddress;
};

ZmPersona.prototype.getIdentity =
function() {
	return this.identity;
};

ZmPersona.prototype.create =
function(callback, errorCallback, batchCmd) {
	return this.getIdentity().create(callback, errorCallback, batchCmd);
};

ZmPersona.prototype.save =
function(callback, errorCallback, batchCmd) {
	return this.getIdentity().save(callback, errorCallback, batchCmd);
};

ZmPersona.prototype.doDelete = 
function(callback, errorCallback, batchCmd) {
	return this.getIdentity().doDelete(callback, errorCallback, batchCmd);
};
}

if (AjxPackage.define("zimbraMail.mail.model.ZmMailItem")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a mail item.
 * @constructor
 * @class
 * This class represents a mail item, which may be a conversation or a mail
 * message.
 *
 * @param {constant}	type		the type of object (conv or msg)
 * @param {int}	id		the unique ID
 * @param {ZmMailList}	list		the list that contains this mail item
 * @param {Boolean}	noCache		if <code>true</code>, do not cache this item
 * 
 * @extends		ZmItem
 */
ZmMailItem = function(type, id, list, noCache) {

	if (arguments.length == 0) { return; }
	ZmItem.call(this, type, id, list, noCache);

	this._loaded = false;
	this._initializeParticipants();
};

ZmMailItem.prototype = new ZmItem;
ZmMailItem.prototype.constructor = ZmMailItem;

ZmMailItem.sortBy = ZmSearch.DATE_DESC;
ZmMailItem.sortCompare =
function(itemA, itemB) {
	var sortBy = ZmMailItem.sortBy;
	if (!sortBy || (sortBy != ZmSearch.DATE_DESC && sortBy != ZmSearch.DATE_ASC)) { return 0; }

	var itemDateA = parseInt(itemA.date);
	var itemDateB = parseInt(itemB.date);
	if (sortBy == ZmSearch.DATE_DESC) {
		return (itemDateA > itemDateB) ? -1 : (itemDateA < itemDateB) ? 1 : 0;
	}
	if (sortBy == ZmSearch.DATE_ASC) {
		return (itemDateA > itemDateB) ? 1 : (itemDateA < itemDateB) ? -1 : 0;
	}
};

ZmMailItem.prototype.toString =
function() {
	return "ZmMailItem";
};

/**
 * Gets the read/unread icon.
 *
 * @return	{String}	the icon
 */
ZmMailItem.prototype.getReadIcon =
function() {
	return this.isUnread ? "MsgUnread" : "MsgRead";
};

/**
 * Gets the mute/unmute icon.
 *
 * @return	{String}	the icon
 */
ZmMailItem.prototype.getMuteIcon =
function() {
	return "";
};


ZmMailItem.prototype.getColor =
function() {
	if (!this.tags || this.tags.length !== 1) {
		return null;
	}
	var tagList = appCtxt.getAccountTagList(this);

	var tag = tagList.getByNameOrRemote(this.tags[0]);

	return tag.getColor();
};

/**
 * Clears this item.
 * 
 */
ZmMailItem.prototype.clear = function() {

    // only clear data if no more views are using this item
    if (this.refCount <= 1) {
        this._clearParticipants();
        this._loaded = false;
    }

    ZmItem.prototype.clear.call(this);
};

ZmMailItem.prototype.getFolderId =
function() {
	return this.folderId;
};

ZmMailItem.prototype.notifyModify =
function(obj, batchMode) {
	var fields = {};
	if (obj.e && obj.e.length) {
		this._clearParticipants();
		this._initializeParticipants();
		for (var i = 0; i < obj.e.length; i++) {
			this._parseParticipantNode(obj.e[i]);
		}
		fields[ZmItem.F_FROM] = true;
		this._notify(ZmEvent.E_MODIFY, {fields:fields});
	}

	return ZmItem.prototype.notifyModify.apply(this, arguments);
};

ZmMailItem.prototype._initializeParticipants =
function() {
	this.participants = new AjxVector();
	this.participantsElided = false;
};

ZmMailItem.prototype._clearParticipants =
function() {
	if (this.participants) {
		this.participants.removeAll();
		this.participants = null;
		this.participantsElided = false;
	}
};

ZmMailItem.prototype._getFlags =
function() {
	var list = ZmItem.prototype._getFlags.call(this);
	list.push(ZmItem.FLAG_UNREAD, ZmItem.FLAG_MUTE, ZmItem.FLAG_REPLIED, ZmItem.FLAG_FORWARDED, ZmItem.FLAG_READ_RECEIPT_SENT, ZmItem.FLAG_PRIORITY);
	return list;
};

ZmMailItem.prototype._markReadLocal =
function(on) {
	this.isUnread = !on;
	this._notify(ZmEvent.E_FLAGS, {flags:[ZmItem.FLAG_UNREAD]});
};

ZmMailItem.prototype._parseParticipantNode =
function(node) {
	var type = AjxEmailAddress.fromSoapType[node.t];
	if (type == AjxEmailAddress.READ_RECEIPT) {
		this.readReceiptRequested = true;
	} else {
		// if we can find the person in contacts, use the name from there
		var contactList = AjxDispatcher.run("GetContacts"),
			contact = contactList && contactList.getContactByEmail(node.a),
			fullName = contact && contact.getFullNameForDisplay(false);

		var addr = new AjxEmailAddress(node.a, type, fullName || node.p, node.d, node.isGroup, node.isGroup && node.exp);
		var ac = window.parentAppCtxt || window.appCtxt;
		ac.setIsExpandableDL(node.a, addr.canExpand);
		this.participants.add(addr);
	}
};

/**
 * Gets the email addresses of the participants.
 * 
 * @return	{Array}	an array of email addresses
 */
ZmMailItem.prototype.getEmails =
function() {
	return this.participants.map("address");
};

/**
 * Checks if this item is in Junk or Trash and the user is not including
 * those in search results.
 * 
 * @return	{Boolean}	<code>true</code> if this item is in the Junk or Trash folder
 */
ZmMailItem.prototype.ignoreJunkTrash =
function() {
	return Boolean((this.folderId == ZmFolder.ID_SPAM && !appCtxt.get(ZmSetting.SEARCH_INCLUDES_SPAM)) ||
				   (this.folderId == ZmFolder.ID_TRASH && !appCtxt.get(ZmSetting.SEARCH_INCLUDES_TRASH)));
};

ZmMailItem.prototype.setAutoSendTime =
function(autoSendTime) {
	var wasScheduled = this.isScheduled;
	var isDate = AjxUtil.isDate(autoSendTime);
	this.flagLocal(ZmItem.FLAG_ISSCHEDULED, isDate);
	var autoSendTime = isDate ? autoSendTime : null;
	if (autoSendTime != this.autoSendTime) {
		this.autoSendTime = autoSendTime;
		this._notify(ZmEvent.E_MODIFY);
	}
	if (wasScheduled != this.isScheduled) {
		this._notify(ZmEvent.E_FLAGS, {flags: ZmItem.FLAG_ISSCHEDULED});
	}
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmMailMsg")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the mail message.
 */

/**
 * @constructor
 * @class
 * Creates a new (empty) mail message.
 *
 * @param {int}			id			the unique ID
 * @param {Array}		list		the list that contains this message
 * @param {Boolean}		noCache		if true, do not cache this message
 * 
 * @extends	ZmMailItem
 */
ZmMailMsg = function(id, list, noCache) {

	ZmMailItem.call(this, ZmItem.MSG, id, list, noCache);

	this.inHitList = false;
	this._attHitList = [];
	this._inviteDescBody = {};
	this._addrs = {};

	// info about MIME parts
	this.attachments = [];
	this._bodyParts = [];
	this._contentType = {};
	
	for (var i = 0; i < ZmMailMsg.ADDRS.length; i++) {
		var type = ZmMailMsg.ADDRS[i];
		this._addrs[type] = new AjxVector();
	}
	this.identity = null;
};

ZmMailMsg.prototype = new ZmMailItem;
ZmMailMsg.prototype.constructor = ZmMailMsg;

ZmMailMsg.prototype.isZmMailMsg = true;
ZmMailMsg.prototype.toString = function() {	return "ZmMailMsg"; };

ZmMailMsg.DL_SUB_VERSION = "0.1";

ZmMailMsg.ADDRS = [AjxEmailAddress.FROM, AjxEmailAddress.TO, AjxEmailAddress.CC,
				   AjxEmailAddress.BCC, AjxEmailAddress.REPLY_TO, AjxEmailAddress.SENDER,
                   AjxEmailAddress.RESENT_FROM];

ZmMailMsg.COMPOSE_ADDRS = [AjxEmailAddress.TO, AjxEmailAddress.CC, AjxEmailAddress.BCC];

ZmMailMsg.HDR_FROM		= AjxEmailAddress.FROM;
ZmMailMsg.HDR_TO		= AjxEmailAddress.TO;
ZmMailMsg.HDR_CC		= AjxEmailAddress.CC;
ZmMailMsg.HDR_BCC		= AjxEmailAddress.BCC;
ZmMailMsg.HDR_REPLY_TO	= AjxEmailAddress.REPLY_TO;
ZmMailMsg.HDR_SENDER	= AjxEmailAddress.SENDER;
ZmMailMsg.HDR_DATE		= "DATE";
ZmMailMsg.HDR_SUBJECT	= "SUBJECT";
ZmMailMsg.HDR_LISTID    = "List-ID";
ZmMailMsg.HDR_XZIMBRADL = "X-Zimbra-DL";
ZmMailMsg.HDR_INREPLYTO = "IN-REPLY-TO";

ZmMailMsg.HDR_KEY = {};
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_FROM]		= ZmMsg.from;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_TO]			= ZmMsg.to;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_CC]			= ZmMsg.cc;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_BCC]		= ZmMsg.bcc;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_REPLY_TO]	= ZmMsg.replyTo;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_SENDER]		= ZmMsg.sender;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_DATE]		= ZmMsg.sentAt;
ZmMailMsg.HDR_KEY[ZmMailMsg.HDR_SUBJECT]	= ZmMsg.subject;

// Ordered list - first matching status wins
ZmMailMsg.STATUS_LIST = ["isScheduled", "isDraft", "isReplied", "isForwarded", "isSent", "isUnread"];

ZmMailMsg.STATUS_ICON = {};
ZmMailMsg.STATUS_ICON["isDraft"]		= "MsgStatusDraft";
ZmMailMsg.STATUS_ICON["isReplied"]		= "MsgStatusReply";
ZmMailMsg.STATUS_ICON["isForwarded"]	= "MsgStatusForward";
ZmMailMsg.STATUS_ICON["isSent"]			= "MsgStatusSent";
ZmMailMsg.STATUS_ICON["isUnread"]		= "MsgStatusUnread";
ZmMailMsg.STATUS_ICON["isScheduled"]	= "SendLater";

ZmMailMsg.PSTATUS_ACCEPT		= "AC";
ZmMailMsg.PSTATUS_DECLINED		= "DE";
ZmMailMsg.PSTATUS_TENTATIVE		= "TE";

ZmMailMsg.STATUS_ICON[ZmMailMsg.PSTATUS_ACCEPT]		= "CalInviteAccepted";
ZmMailMsg.STATUS_ICON[ZmMailMsg.PSTATUS_DECLINED]	= "CalInviteDeclined";
ZmMailMsg.STATUS_ICON[ZmMailMsg.PSTATUS_TENTATIVE]	= "CalInviteTentative";

// tooltips for invite status icons
ZmMailMsg.TOOLTIP = {};
ZmMailMsg.TOOLTIP["Appointment"]		= ZmMsg.appointment;
ZmMailMsg.TOOLTIP["CalInviteAccepted"]	= ZmMsg.ptstAccept;
ZmMailMsg.TOOLTIP["CalInviteDeclined"]	= ZmMsg.ptstDeclined;
ZmMailMsg.TOOLTIP["CalInviteTentative"]	= ZmMsg.ptstTentative;

// We just hard-code "Re:" or "Fwd:", but other clients may use localized versions
ZmMailMsg.SUBJ_PREFIX_RE = new RegExp("^\\s*(Re|Fw|Fwd|" + ZmMsg.re + "|" + ZmMsg.fwd + "|" + ZmMsg.fw + "):" + "\\s*", "i");

ZmMailMsg.URL_RE = /((telnet:)|((https?|ftp|gopher|news|file):\/\/)|(www\.[\w\.\_\-]+))[^\s\xA0\(\)\<\>\[\]\{\}\'\"]*/i;

ZmMailMsg.CONTENT_PART_ID = "ci";
ZmMailMsg.CONTENT_PART_LOCATION = "cl";

// Additional headers to request.  Also used by ZmConv and ZmSearch
ZmMailMsg.requestHeaders = {listId: ZmMailMsg.HDR_LISTID, xZimbraDL: ZmMailMsg.HDR_XZIMBRADL,replyTo:ZmMailMsg.HDR_INREPLYTO};

/**
 * Fetches a message from the server.
 *
 * @param {Hash}			params					a hash of parameters
 * @param {ZmZimbraMail}	params.sender			the provides access to sendRequest()
 * @param {int}				params.msgId			the ID of the msg to be fetched.
 * @param {int}				params.partId 			the msg part ID (if retrieving attachment part, i.e. rfc/822)
 * @param {int}				params.ridZ   			the RECURRENCE-ID in Z (UTC) timezone
 * @param {Boolean}			params.getHtml			if <code>true</code>, try to fetch html from the server
 * @param {Boolean}			params.markRead			if <code>true</code>, mark msg read
 * @param {AjxCallback}		params.callback			the async callback
 * @param {AjxCallback}		params.errorCallback	the async error callback
 * @param {Boolean}			params.noBusyOverlay	if <code>true</code>, do not put up busy overlay during request
 * @param {Boolean}			params.noTruncate		if <code>true</code>, do not truncate message body
 * @param {ZmBatchCommand}	params.batchCmd			if set, request gets added to this batch command
 * @param {String}			params.accountName		the name of the account to send request on behalf of
 * @param {boolean}			params.needExp			if not <code>false</code>, have server check if addresses are DLs
 */
ZmMailMsg.fetchMsg =
function(params) {
	var jsonObj = {GetMsgRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.GetMsgRequest;
	var m = request.m = {};
	m.id = params.msgId;
	if (params.partId) {
		m.part = params.partId;
	}
	if (params.markRead) {
		m.read = 1;
	}
	if (params.getHtml) {
		m.html = 1;
	}
	if (params.needExp !== false) {
		m.needExp = 1;
	}

	if (params.ridZ) {
		m.ridZ = params.ridZ;
	}

	ZmMailMsg.addRequestHeaders(m);

	if (!params.noTruncate) {
		m.max = appCtxt.get(ZmSetting.MAX_MESSAGE_SIZE) || ZmMailApp.DEFAULT_MAX_MESSAGE_SIZE;
	}

	if (params.batchCmd) {
		params.batchCmd.addRequestParams(jsonObj, params.callback);
	} else {
		var newParams = {
			jsonObj:		jsonObj,
			asyncMode:		true,
            offlineCache:   true,
			callback:		ZmMailMsg._handleResponseFetchMsg.bind(null, params.callback),
			errorCallback:	params.errorCallback,
			noBusyOverlay:	params.noBusyOverlay,
			accountName:	params.accountName
		};
        newParams.offlineCallback = ZmMailMsg._handleOfflineResponseFetchMsg.bind(null, m.id, newParams.callback);
		params.sender.sendRequest(newParams);
	}
};

ZmMailMsg._handleResponseFetchMsg =
function(callback, result) {
	if (callback) {
		callback.run(result);
	}
};

ZmMailMsg._handleOfflineResponseFetchMsg =
function(msgId, callback) {
    var getItemCallback = ZmMailMsg._handleOfflineResponseFetchMsgCallback.bind(null, callback);
    ZmOfflineDB.getItem(msgId, ZmApp.MAIL, getItemCallback);
};

ZmMailMsg._handleOfflineResponseFetchMsgCallback =
function(callback, result) {
    var response = {
        GetMsgResponse : {
            m : result
        }
    };
    if (callback) {
        callback(new ZmCsfeResult(response));
    }
};

ZmMailMsg.stripSubjectPrefixes =
function(subj) {
	var regex = ZmMailMsg.SUBJ_PREFIX_RE;
	while (regex.test(subj)) {
		subj = subj.replace(regex, "");
	}
	return subj;
};

// Public methods

/**
 * Gets a vector of addresses of the given type.
 *
 * @param {constant}	type			an email address type
 * @param {Hash}		used			an array of addresses that have been used. If not <code>null</code>,
 *										then this method will omit those addresses from the
 * 										returned vector and will populate used with the additional new addresses
 * @param {Boolean}		addAsContact	if <code>true</code>, emails should be converted to {@link ZmContact} objects
 * @param {boolean}		dontUpdateUsed	if true, do not update the hash of used addresses
 * 
 * @return	{AjxVector}	a vector of email addresses
 */
ZmMailMsg.prototype.getAddresses =
function(type, used, addAsContact, dontUpdateUsed) {
	if (!used) {
		return this._addrs[type];
	} else {
		var a = this._addrs[type].getArray();
		var addrs = [];
		for (var i = 0; i < a.length; i++) {
			var addr = a[i];
			var email = addr.getAddress();
			if (!email) { continue; }
			email = email.toLowerCase();
			if (!used[email]) {
				var contact = addr;
				if (addAsContact) {
					var cl = AjxDispatcher.run("GetContacts");
					contact = cl.getContactByEmail(email);
					if (contact == null) {
						contact = new ZmContact(null);
						contact.initFromEmail(addr);
					}
				}
				addrs.push(contact);
			}
			if (!dontUpdateUsed) {
				used[email] = true;
			}
		}
		return AjxVector.fromArray(addrs);
	}
};

/**
 * Gets a Reply-To address if there is one, otherwise the From address
 * unless this message was sent by the user, in which case, it is the To
 * field (but only in the case of Reply All). A list is returned, since
 * theoretically From and Reply To can have multiple addresses.
 * 
 * @return	{AjxVector}	an array of {@link AjxEmailAddress} objects
 */
ZmMailMsg.prototype.getReplyAddresses =
function(mode, aliases, isDefaultIdentity) {

	if (!this.isSent) { //ignore reply_to for sent messages.
		// reply-to has precedence over everything else
		var addrVec = this._addrs[AjxEmailAddress.REPLY_TO];
	}
	if (!addrVec && this.isInvite() && this.needsRsvp()) {
		var invEmail = this.invite.getOrganizerEmail(0);
		if (invEmail) {
			return AjxVector.fromArray([new AjxEmailAddress(invEmail)]);
		}
	}

	if (!(addrVec && addrVec.size())) {
		if (mode == ZmOperation.REPLY_CANCEL || (this.isSent && mode == ZmOperation.REPLY_ALL)) {
			addrVec = this.isInvite() ? this._getAttendees() : this.getAddresses(AjxEmailAddress.TO, aliases, false, true);
		} else {
			addrVec = this.getAddresses(AjxEmailAddress.FROM, aliases, false, true);
			if (addrVec.size() == 0) {
				addrVec = this.getAddresses(AjxEmailAddress.TO, aliases, false, true);
			}
		}
	}
	return addrVec;
};

ZmMailMsg.prototype._getAttendees =
function() {
	var attendees = this.invite.components[0].at;
	var emails = new AjxVector();
	for (var i = 0; i < (attendees ? attendees.length : 0); i++) {
		var at = attendees[i];
		emails.add(new AjxEmailAddress(at.a, null, null, at.d));
	}

	return emails;
};

/**
 * Gets the first address in the vector of addresses of the given type.
 * 
 * @param	{constant}		type		the type
 * @return	{String}	the address
 */
ZmMailMsg.prototype.getAddress =
function(type) {
	return this._addrs[type].get(0);
};

/**
 * Gets the fragment. If maxLen is given, will truncate fragment to maxLen and add ellipsis.
 * 
 * @param	{int}	maxLen		the maximum length
 * @return	{String}	the fragment
 */
ZmMailMsg.prototype.getFragment =
function(maxLen) {
	var frag = this.fragment;

	if (maxLen && frag && frag.length) {
		frag = frag.substring(0, maxLen);
		if (this.fragment.length > maxLen)
			frag += "...";
	}
	return frag;
};

/**
 * Checks if the message is read only.
 * 
 * @return	{Boolean}	<code>true</code> if read only
 */
ZmMailMsg.prototype.isReadOnly =
function() {
	if (this._isReadOnly == null) {
		var folder = appCtxt.getById(this.folderId);
		this._isReadOnly = (folder ? folder.isReadOnly() : false);
	}
	return this._isReadOnly;
};

/**
 * Gets the header string.
 * 
 * @param	{constant}	hdr			the header (see <code>ZmMailMsg.HDR_</code> constants)
 * @param	{boolean}	htmlMode	if true, format as HTML
 * @return	{String}	the value
 */
ZmMailMsg.prototype.getHeaderStr =
function(hdr, htmlMode) {

	var key, value;
	if (hdr == ZmMailMsg.HDR_DATE) {
		if (this.sentDate) {
			var formatter = AjxDateFormat.getDateTimeInstance(AjxDateFormat.FULL, AjxDateFormat.MEDIUM);
			value = formatter.format(new Date(this.sentDate));
		}
	} else if (hdr == ZmMailMsg.HDR_SUBJECT) {
		value = this.subject;
	} else {
		var addrs = this.getAddresses(hdr);
		value = addrs.toString(", ", true);
	}

	var key = ZmMailMsg.HDR_KEY[hdr] + ": ";
	if (!value) { return; }
	if (htmlMode) {
		key = "<b>" + key + "</b>";
		value = AjxStringUtil.convertToHtml(value);
	}

	return key + value;
};

/**
 * Checks if this message has html parts.
 * 
 * @return	{Boolean}	<code>true</code> if this message has HTML
 */
ZmMailMsg.prototype.isHtmlMail =
function() {
    if (this.isInvite()) {
		return this.invite.isHtmlInvite();
    }
    else {
        return this.getBodyPart(ZmMimeTable.TEXT_HTML) != null;
    }
};

// Setters

/**
 * Sets the vector of addresses of the given type to the given vector of addresses
 *
 * @param {constant}		type	the address type
 * @param {AjxVector}		addrs	a vector of {@link AjxEmailAddress}	objects
 */
ZmMailMsg.prototype.setAddresses =
function(type, addrs) {
	this._onChange("address", type, addrs);
	this._addrs[type] = addrs;
};

/**
 * Sets the vector of addresses of the given type to the address given.
 *
 * @param {constant}	type	the address type
 * @param {AjxEmailAddress}	addr	an address
 */
ZmMailMsg.prototype.setAddress =
function(type, addr) {
	this._onChange("address", type, addr);
	this._addrs[type].removeAll();
	this._addrs[type] = new AjxVector();
	this._addrs[type].add(addr);
};

/**
 * Clears out all the address vectors.
 * 
 */
ZmMailMsg.prototype.clearAddresses =
function() {
	for (var i = 0; i < ZmMailMsg.ADDRS.length; i++) {
		var type = ZmMailMsg.ADDRS[i];
		this._addrs[type].removeAll();
	}
};

/**
 * Adds the given vector of addresses to the vector of addresses of the given type
 *
 * @param {constant}	type	the address type
 * @param {AjxVector}	addrs	a vector of {@link AjxEmailAddress} objects
 */
ZmMailMsg.prototype.addAddresses =
function(type, addrs) {
	var size = addrs.size();
	for (var i = 0; i < size; i++) {
		this._addrs[type].add(addrs.get(i));
	}
};

/**
 * Adds the given address to the vector of addresses of the given type
 *
 * @param {AjxEmailAddress}	addr	an address
 */
ZmMailMsg.prototype.addAddress =
function(addr, type) {
	type = type || addr.type || AjxEmailAddress.TO;
	this._addrs[type].add(addr);
};

/**
 * Sets the subject
 *
 * @param	{String}	subject		the subject
 */
ZmMailMsg.prototype.setSubject =
function(subject) {
	this._onChange("subject", subject);
	this.subject = subject;
};

/**
 * Sets the message's top part to the given MIME part
 *
 * @param {String}	part	a MIME part
 */
ZmMailMsg.prototype.setTopPart =
function(part) {
	this._onChange("topPart", part);
	this._topPart = part;
};

/**
 * Sets the body parts.
 *  
 * @param	{array}	parts		an array of ZmMimePart
 * 
 */
ZmMailMsg.prototype.setBodyParts =
function(parts) {
	this._onChange("bodyParts", parts);
	this._bodyParts = parts;
    this._loaded = this._bodyParts.length > 0 || this.attachments.length > 0;
};

/**
* Sets the ID of any attachments which have already been uploaded.
*
* @param {String}	id		an attachment ID
*/
ZmMailMsg.prototype.addAttachmentId =
function(id) {
	if (this.attId) {
		id = this.attId + "," + id;
	}
	this._onChange("attachmentId", id);
	this.attId = id;
};

/**
 * Adds an inline attachment.
 * 
 * @param	{String}	cid		the content id
 * @param	{String}	aid		the attachment id
 * @param	{String}	part		the part
 * @param	{Boolean}	ismsg		if true, aid is a message id
 */
ZmMailMsg.prototype.addInlineAttachmentId =
function (cid, aid, part, ismsg) {
	if (!this._inlineAtts) {
		this._inlineAtts = [];
	}
	this._onChange("inlineAttachments",aid);
	if (ismsg && aid && part) {
		this._inlineAtts.push({"cid":cid, "mid":aid, "part": part});
	} else if (aid) {
		this._inlineAtts.push({"cid":cid, "aid":aid});
	} else if (part) {
		this._inlineAtts.push({"cid":cid, "part":part});
	}
};

ZmMailMsg.prototype._resetAllInlineAttachments =
function(){
    this._inlineAtts = [];
    for (var i = 0; i < this.attachments.length; i++) {
       this.attachments[i].foundInMsgBody = false;
    }
}

/**
 * Adds an inline document attachment.
 * 
 * @param	{String}	cid		the content id
 * @param	{String}	docId		the document id
 * @param	{String}	docpath		the document path
 * @param	{String}	part		the part
 */
ZmMailMsg.prototype.addInlineDocAttachment =
function (cid, docId, docpath, part) {
	if (!this._inlineDocAtts) {
		this._inlineDocAtts = [];
	}
	this._onChange("inlineDocAttachments", docId, docpath, part);
	if (docId) {
		this._inlineDocAtts.push({"cid":cid,"docid":docId});
	} else if (docpath) {
		this._inlineDocAtts.push({"cid":cid,"docpath":docpath});
	}else if (part) {
		this._inlineDocAtts.push({"cid":cid,"part":part});
	}
};

ZmMailMsg.prototype.setInlineAttachments =
function(inlineAtts){
	if (inlineAtts) {
		this._inlineAtts = inlineAtts;
	}
};

/**
 * Gets the inline attachments.
 * 
 * @return	{Array}	an array of attachments
 */
ZmMailMsg.prototype.getInlineAttachments =
function() {
	return this._inlineAtts || [];
};


/**
 * Gets the inline document attachments.
 * 
 * @return	{Array}	an array of attachments
 */
ZmMailMsg.prototype.getInlineDocAttachments =
function() {
	return this._inlineDocAtts || [];
};

/**
 * Finds the attachment in this message for the given CID.
 * 
 * @param	{String}	cid		the content id
 * @return	{Object}	the attachment or <code>null</code> if not found
 */
ZmMailMsg.prototype.findInlineAtt =
function(cid) {
	if (!(this.attachments && this.attachments.length)) { return null; }

	for (var i = 0; i < this.attachments.length; i++) {
		if (this.attachments[i].contentId == cid) {
			return this.attachments[i];
		}
	}
	return null;
};

/**
 * Sets the IDs of messages to attach (as a forward)
 *
 * @param {Array}	ids	a list of mail message IDs
 */
ZmMailMsg.prototype.setMessageAttachmentId =
function(ids) {
	this._onChange("messageAttachmentId", ids);
	this._msgAttIds = ids;
};

/**
 * Sets the IDs of docs to attach 
 *
 * @param {Array}	ids	a list of document IDs
 */
ZmMailMsg.prototype.setDocumentAttachments =
function(docs) {
	this._onChange("documentAttachmentId", docs);
	this._docAtts = docs;
};

ZmMailMsg.prototype.addDocumentAttachment =
function(doc) {
	if(!this._docAtts) {
		this._docAtts = [];
	}
	this._docAtts.push(doc);
};

/**
* Sets the list of attachment (message part) IDs to be forwarded
*
* @param {Array}	ids		a list of attachment IDs
*/
ZmMailMsg.prototype.setForwardAttIds =
function(ids) {
	this._onChange("forwardAttIds", ids);
	this._forAttIds = ids;
};

/**
* Sets the list of attachments details(message id and message part) to be forwarded
*
* @param {Array}	objs		a list of attachments details {id, part}
*/
ZmMailMsg.prototype.setForwardAttObjs =
function(objs) {
	this._forAttObjs = objs;
};

/**
* Sets the ID of the contacts that are to be attached as vCards
*
* @param {Array}	ids		a list of contact IDs
*/
ZmMailMsg.prototype.setContactAttIds =
function(ids) {
	ids = AjxUtil.toArray(ids);
	this._onChange("contactAttIds", ids);
	this._contactAttIds = ids;
};

// Actions

/**
 * Fills in the message from the given message node. Whatever attributes and child nodes
 * are available will be used. The message node is not always fully populated, since it
 * may have been created as part of getting a conversation.
 *
 * @param	{Object}	node		a message node
 * @param	{Hash}		args		a hash of arguments
 * @param	{Boolean}	noCache		if true, do not cache this message
 * @return	{ZmMailMsg}				the message
 */
ZmMailMsg.createFromDom =
function(node, args, noCache) {
	var msg = new ZmMailMsg(node.id, args.list, noCache);
	msg._loadFromDom(node);
	return msg;
};

/**
 * Gets the full message object from the back end based on the current message ID, and
 * fills in the message.
 *
 * @param {Hash}			params					a hash of parameters:
 * @param {Boolean}			params.getHtml			if <code>true</code>, try to fetch html from the server
 * @param {Boolean}			params.markRead			if <code>true</code>, mark msg read
 * @param {Boolean}			params.forceLoad		if <code>true</code>, get msg from server
 * @param {AjxCallback}		params.callback			the async callback
 * @param {AjxCallback}		params.errorCallback	the async error callback
 * @param {Boolean}			params.noBusyOverlay	if <code>true</code>, do not put up busy overlay during request
 * @param {Boolean}			params.noTruncate		if <code>true</code>, do not set max limit on size of msg body
 * @param {ZmBatchCommand}	params.batchCmd			if set, request gets added to this batch command
 * @param {String}			params.accountName		the name of the account to send request on behalf of
 * @param {boolean}			params.needExp			if not <code>false</code>, have server check if addresses are DLs
 */
ZmMailMsg.prototype.load =
function(params) {
	if (this._loading && !params.forceLoad) {
		//the only way to not get partial results is to try in some timeout.
		//this method will be called again, eventually, the message will be finished loading, and the callback would be called safely.
		this._loadingWaitCount = (this._loadingWaitCount || 0) + 1;
		if (this._loadingWaitCount > 20) {
			//give up after 20 timeouts (about 10 seconds) - maybe request got lost. send another request below.
			this._loadingWaitCount = 0;
			this._loading = false;
		}
		else {
			setTimeout(this.load.bind(this, params), 500);
			return;
		}
	}
	// If we are already loaded, then don't bother loading
	if (!this._loaded || params.forceLoad) {
		this._loading = true;
		var respCallback = this._handleResponseLoad.bind(this, params, params.callback);
		params.getHtml = params.getHtml || this.isDraft || appCtxt.get(ZmSetting.VIEW_AS_HTML);
		params.sender = appCtxt.getAppController();
		params.msgId = this.id;
		params.partId = this.partId;
		params.callback = respCallback;
		var errorCallback = this._handleResponseLoadFail.bind(this, params, params.errorCallback);
		params.errorCallback = errorCallback;
		ZmMailMsg.fetchMsg(params);
	} else {
		if (params.callback) {
			params.callback.run(new ZmCsfeResult()); // return exceptionless result
		}
	}
};

ZmMailMsg.prototype._handleResponseLoad =
function(params, callback, result) {
	var response = result.getResponse().GetMsgResponse;

	this.clearAddresses();

	// clear all participants (since it'll get re-parsed w/ diff. ID's)
	if (this.participants) {
		this.participants.removeAll();
	}

	this._loadFromDom(response.m[0]);
	if (!this.isReadOnly() && params.markRead) {
        this.markRead();
	} else {
        // Setup the _evt.item field and list._evt.item in order to insure proper notifications.
        this._setupNotify();
    }
	this.findAttsFoundInMsgBody();

	this._loading = false;
	
	// return result so callers can check for exceptions if they want
	if (this._loadCallback) {
		// overriding callback (see ZmMsgController::show)
		this._loadCallback.run(result);
		this._loadCallback = null;
	} else if (callback) {
		callback.run(result);
	}
};

ZmMailMsg.prototype.markRead = function() {
	if (!this.isReadOnly()) {
		//For offline mode keep isUnread property as true so that additional MsgActionRequest gets fired.
		//MsgActionRequest also gets stored in outbox queue and it also sends notify header for reducing the folder unread count.
		this._markReadLocal(!appCtxt.isWebClientOffline());
	}
};

ZmMailMsg.prototype._handleResponseLoadFail =
function(params, callback, result) {
    this._loading = false;
	if (callback) {
		return callback.run(result);
	}
};

ZmMailMsg.prototype._handleIndexedDBResponse =
function(params, requestParams, result) {

    var obj = result[0],
        msgNode,
        data = {},
        methodName = requestParams.methodName;

    if (obj) {
        msgNode = obj[obj.methodName]["m"];
        if (msgNode) {
            msgNode.su = msgNode.su._content;
            msgNode.fr = msgNode.mp[0].content._content;
            msgNode.mp[0].content = msgNode.fr;
            if (msgNode.fr) {
                msgNode.mp[0].body = true;
            }
            data[methodName.replace("Request", "Response")] = { "m" : [msgNode] };
            var csfeResult = new ZmCsfeResult(data);
            this._handleResponseLoad(params, params.callback, csfeResult);
        }
    }
};

ZmMailMsg.prototype.isLoaded =
function() {
	return this._loaded;
};

/**
 * Returns the list of body parts.
 * 
 * @param	{string}	contentType		preferred MIME type of alternative parts (optional)
 */
ZmMailMsg.prototype.getBodyParts =
function(contentType) {

	if (contentType) {
		this._lastContentType = contentType;
	}

	// no multi/alt, so we have a plain list
	if (!this.hasContentType(ZmMimeTable.MULTI_ALT)) {
		return this._bodyParts;
	}
	
	// grab the preferred type out of multi/alt parts
	contentType = contentType || this._lastContentType;
	var parts = [];
	for (var i = 0; i < this._bodyParts.length; i++) {
		var part = this._bodyParts[i];
		if (part.isZmMimePart) {
			parts.push(part);
		}
		else if (part) {
			// part is a hash of alternative parts by content type
			var altPart = contentType && part[contentType];
			parts.push(altPart || AjxUtil.values(part)[0]);
		}
	}
		
	return parts;
};

/**
 * Returns true if this msg has loaded a part with the given content type.
 * 
 * @param	{string}		contentType		MIME type
 */
ZmMailMsg.prototype.hasContentType =
function(contentType) {
	return this._contentType[contentType];
};

/**
 * Returns true is the msg has more than one body part. The server marks parts that
 * it considers to be body parts.
 * 
 * @return {boolean}
 */
ZmMailMsg.prototype.hasMultipleBodyParts =
function() {
	var parts = this.getBodyParts();
	return (parts && parts.length > 1);
};

/**
 * Returns the first body part, of the given type if provided. May invoke a
 * server call if it needs to fetch an alternative part.
 * 
 * @param	{string}		contentType		MIME type
 * @param	{callback}		callback		callback
 * 
 * @return	{ZmMimePart}					MIME part
 */
ZmMailMsg.prototype.getBodyPart =
function(contentType, callback) {

	if (contentType) {
		this._lastContentType = contentType;
	}

	function getPart(ct) {
		var bodyParts = this.getBodyParts(ct);
		for (var i = 0; i < bodyParts.length; i++) {
			var part = bodyParts[i];
			// should be a ZmMimePart, but check just in case
			part = part.isZmMimePart ? part : part[ct];
			if (!ct || (part.contentType === ct)) {
				return part;
			}
		}
	}
	var bodyPart = getPart.call(this, contentType);
	
	if (this.isInvite()) {
		if (!bodyPart) {
			if (contentType === ZmMimeTable.TEXT_HTML) {
				//text/html not available so look for text/plain
				bodyPart = getPart.call(this,ZmMimeTable.TEXT_PLAIN);
			} else if (contentType === ZmMimeTable.TEXT_PLAIN) {
				//text/plain not available so look for text/html
				bodyPart = getPart.call(this,ZmMimeTable.TEXT_HTML);
			}
		}
		// bug: 46071, handle missing body part/content
		if (!bodyPart || (bodyPart && !bodyPart.getContent())) {
			bodyPart = this.getInviteDescriptionContent(contentType);
		}
	}

	if (callback) {
		if (bodyPart) {
			callback.run(bodyPart);
		}
		// see if we should try to fetch an alternative part
		else if (this.hasContentType(ZmMimeTable.MULTI_ALT) &&
				((contentType == ZmMimeTable.TEXT_PLAIN && this.hasContentType(ZmMimeTable.TEXT_PLAIN)) ||
				 (contentType == ZmMimeTable.TEXT_HTML && this.hasContentType(ZmMimeTable.TEXT_HTML)))) {

			ZmMailMsg.fetchMsg({
				sender:		appCtxt.getAppController(),
				msgId:		this.id,
				getHtml:	(contentType == ZmMimeTable.TEXT_HTML),
				callback:	this._handleResponseFetchAlternativePart.bind(this, contentType, callback)
			});
		}
		else {
			callback.run();
		}
	}

	return bodyPart;
};

/**
  * Fetches the requested alternative part and adds it to our MIME structure, and body parts.
  * 
  * @param {string}		contentType		MIME type of part to fetch
  * @param {callback}	callback
  */
ZmMailMsg.prototype.fetchAlternativePart =
function(contentType, callback) {
	
	var respCallback = this._handleResponseFetchAlternativePart.bind(this, contentType, callback);
	ZmMailMsg.fetchMsg({
		sender:		appCtxt.getAppController(),
		msgId:		this.id,
		getHtml:	(contentType == ZmMimeTable.TEXT_HTML),
		callback:	respCallback
	});
};

ZmMailMsg.prototype._handleResponseFetchAlternativePart =
function(contentType, callback, result) {

	// look for first multi/alt with child of type we want, add it; assumes at most one multi/alt per msg
	var response = result.getResponse().GetMsgResponse;
	var altPart = this._topPart && this._topPart.addAlternativePart(response.m[0].mp[0], contentType, 0);
	if (altPart) {
		var found = false;
		for (var i = 0; i < this._bodyParts.length; i++) {
			var bp = this._bodyParts[i];
			// a hash rather than a ZmMimePart indicates multi/alt
			if (!bp.isZmMimePart) {
				bp[altPart.contentType] = altPart;
			}
		}
	}
		
	if (callback) {
		callback.run();
	}
};

/**
 * Gets the content of the first body part of the given content type (if provided).
 * If HTML is requested, may return content set via setHtmlContent().
 * 
 * @param	{string}	contentType		MIME type
 * @param	{boolean}	useOriginal		if true, do not grab the copy w/ the images defanged (HTML only)
 * 
 * @return	{string}					the content
 */
ZmMailMsg.prototype.getBodyContent =
function(contentType, useOriginal) {

	if (contentType) {
		this._lastContentType = contentType;
	}

	if (contentType == ZmMimeTable.TEXT_HTML && !useOriginal && this._htmlBody) {
		return this._htmlBody;
	}

	var bodyPart = this._loaded && this.getBodyPart(contentType);
	return bodyPart ? bodyPart.getContent() : "";
};

/**
 * Extracts and returns the text content out of a text/calendar part.
 * 
 * @param	{ZmMimePart}	bodyPart	a text/calendar MIME part
 * @return	{string}					text content
 */
ZmMailMsg.getTextFromCalendarPart =
function(bodyPart) {

	// NOTE: IE doesn't match multi-line regex, even when explicitly
	// specifying the "m" attribute.
	var bpContent = bodyPart ? bodyPart.getContent() : "";
	var lines = bpContent.split(/\r\n/);
	var desc = [];
	var content = "";
	for (var i = 0; i < lines.length; i++) {
		var line = lines[i];
		if (line.match(/^DESCRIPTION:/)) {
			desc.push(line.substr(12));
			for (var j = i + 1; j < lines.length; j++) {
				line = lines[j];
				if (line.match(/^\s+/)) {
					desc.push(line.replace(/^\s+/, " "));
					continue;
				}
				break;
			}
			break;
		}
        else if (line.match(/^COMMENT:/)) {
            //DESCRIPTION is sent as COMMENT in Lotus notes.
            desc.push(line.substr(8));
            for (var j = i + 1; j < lines.length; j++) {
                line = lines[j];
                if (line.match(/^\s+/)) {
                    desc.push(line.replace(/^\s+/, " "));
                    continue;
                }
                break;
            }
            break;
        }
	}
	if (desc.length > 0) {
		content = desc.join("");
		content = content.replace(/\\t/g, "\t");
		content = content.replace(/\\n/g, "\n");
		content = content.replace(/\\(.)/g, "$1");
	}
	return content;
};

/**
 * Returns a text/plain or text-like (not HTML or calendar) body part
 * 
 * @return {ZmMimePart}		MIME part
 */
ZmMailMsg.prototype.getTextBodyPart =
function() {
	var bodyPart = this.getBodyPart(ZmMimeTable.TEXT_PLAIN) || this.getBodyPart();
	return (bodyPart && bodyPart.isBody && ZmMimeTable.isTextType(bodyPart.contentType)) ? bodyPart : null;
};

/**
 * Returns true if this message has an inline image
 * 
 * @return {boolean}
 */
ZmMailMsg.prototype.hasInlineImage =
function() {
	for (var i = 0; i < this._bodyParts.length; i++) {
		var bp = this._bodyParts[i];
		if (bp.isZmMimePart && bp.contentDisposition == "inline" && bp.fileName && ZmMimeTable.isRenderableImage(bp.contentType)) {
			return true;
		}
	}
	return false;
};

/**
 * Sets the html content, overriding that of any HTML body part.
 * 
 * @param	{string}	content		the HTML content
 */
ZmMailMsg.prototype.setHtmlContent =
function(content) {
	this._onChange("htmlContent", content);
	this._htmlBody = content;
};

/**
 * Sets the invite description.
 * 
 * @param {String}	contentType	the content type ("text/plain" or "text/html")
 * @param	{String}	content		the content
 */
ZmMailMsg.prototype.setInviteDescriptionContent =
function(contentType, content) {
	this._inviteDescBody[contentType] = content;
};

/**
 * Gets the invite description content value.
 *
 * @param {String}	contentType	the content type ("text/plain" or "text/html")
 * @return	{String}	the content value
 */
ZmMailMsg.prototype.getInviteDescriptionContentValue =
function(contentType) {
    return this._inviteDescBody[contentType];
}
/**
 * Gets the invite description content.
 * 
 * @param {String}	contentType	the content type ("text/plain" or "text/html")
 * @return	{String}	the content
 */
ZmMailMsg.prototype.getInviteDescriptionContent =
function(contentType) {

	if (!contentType) {
		contentType = ZmMimeTable.TEXT_HTML;
	}

	var desc = this._inviteDescBody[contentType];

	if (!desc) {
		var htmlContent =  this._inviteDescBody[ZmMimeTable.TEXT_HTML];
		var textContent =  this._inviteDescBody[ZmMimeTable.TEXT_PLAIN];

		if (!htmlContent && textContent) {
			htmlContent = AjxStringUtil.convertToHtml(textContent);
		}

		if (!textContent && htmlContent) {
			textContent = AjxStringUtil.convertHtml2Text(htmlContent);
		}

		desc = (contentType == ZmMimeTable.TEXT_HTML) ? htmlContent : textContent;
	}

	var idx = desc ? desc.indexOf(ZmItem.NOTES_SEPARATOR) : -1;

	if (idx == -1 && this.isInvite()) {
		var inviteSummary = this.invite.getSummary((contentType == ZmMimeTable.TEXT_HTML));
		desc = desc ? (inviteSummary + desc) : null;
	}

	if (desc != null) {
		var part = new ZmMimePart();
		part.contentType = part.ct = contentType;
		part.size = part.s = desc.length;
		part.node = {content: desc};
		return part;
	}
};

ZmMailMsg.prototype.sendInviteReply =
function(edited, componentId, callback, errorCallback, instanceDate, accountName, ignoreNotify) {
	this._origMsg = this._origMsg || this;
	if (componentId == 0){ // editing reply, custom message
		this._origMsg._customMsg = true;
	}
	this._sendInviteReply(edited, componentId || 0, callback, errorCallback, instanceDate, accountName, ignoreNotify);
};

ZmMailMsg.prototype._sendInviteReply =
function(edited, componentId, callback, errorCallback, instanceDate, accountName, ignoreNotify) {
	var jsonObj = {SendInviteReplyRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.SendInviteReplyRequest;

	request.id = this._origMsg.id;
	request.compNum = componentId;

	var verb = "ACCEPT";
	var needsRsvp = true;
	var newPtst;

	var toastMessage; //message to display after action is done.
	
	switch (this.inviteMode) {
		case ZmOperation.REPLY_ACCEPT_IGNORE:				//falls-through on purpose
			needsRsvp = false;
		case ZmOperation.REPLY_ACCEPT_NOTIFY:               //falls-through on purpose
		case ZmOperation.REPLY_ACCEPT:
			verb = "ACCEPT";
			newPtst = ZmCalBaseItem.PSTATUS_ACCEPT;
			toastMessage = ZmMsg.inviteAccepted;
			break;
		case ZmOperation.REPLY_DECLINE_IGNORE:				//falls-through on purpose
			needsRsvp = false;
		case ZmOperation.REPLY_DECLINE_NOTIFY:              //falls-through on purpose
		case ZmOperation.REPLY_DECLINE:
			verb = "DECLINE";
			newPtst = ZmCalBaseItem.PSTATUS_DECLINED;
			toastMessage = ZmMsg.inviteDeclined;
			break;
		case ZmOperation.REPLY_TENTATIVE_IGNORE:            //falls-through on purpose
			needsRsvp = false;
		case ZmOperation.REPLY_TENTATIVE_NOTIFY:            //falls-through on purpose
		case ZmOperation.REPLY_TENTATIVE:
			verb = "TENTATIVE";
			newPtst = ZmCalBaseItem.PSTATUS_TENTATIVE;
			toastMessage = ZmMsg.inviteAcceptedTentatively;
			break;
	}
	request.verb = verb;

	var inv = this._origMsg.invite;
	//update the ptst to new one (we currently don't use the rest of the info in "replies" so it's ok to remove it for now)
	//note - this updated value is used later in _handleResponseSendInviteReply, and also in the list view when
	// re-displaying the message (not reloaded from server)
	if (newPtst) {
		inv.replies = [{
			reply: [{
				ptst: newPtst
			}]
		}];
		if (appCtxt.isWebClientOffline()) {
			// Update the offline entry and appt too.  Depending upon whether this is invoked from mail or appointments,
			// msgId will either be a single id, or the composite msg-appt id
			var msgId = inv.getMessageId();
			var invId = msgId;
			if (msgId.indexOf("-") >= 0) {
				// Composite id
				msgId = msgId.split("-")[1];
			} else {
				invId = [inv.getAppointmentId(), msgId].join("-");
			}
			var inviteUpdateCallback = this.applyPtstOffline.bind(this, msgId, newPtst);
			appCtxt.updateOfflineAppt(invId, "ptst", newPtst, null, inviteUpdateCallback);
		}
	}
	if (this.getAddress(AjxEmailAddress.TO) == null && !inv.isOrganizer()) {
		var to = inv.getOrganizerEmail() || inv.getSentBy();
		if (to == null) {
			var ac = window.parentAppCtxt || window.appCtxt;
			var mainAcct = ac.accountList.mainAccount.getEmail();
			var from = this._origMsg.getAddresses(AjxEmailAddress.FROM).get(0);
			//bug: 33639 when organizer component is missing from invitation
			if (from && from.address != mainAcct) {
				to = from.address;
			}
		}
		if (to) {
			this.setAddress(AjxEmailAddress.TO, (new AjxEmailAddress(to)));
		}
	}

    if(!this.identity) {
		var ac = window.parentAppCtxt || window.appCtxt;
		var account = (ac.multiAccounts && ac.getActiveAccount().isMain)
			? ac.accountList.defaultAccount : null;
		var identityCollection = ac.getIdentityCollection(account);
		this.identity = identityCollection ? identityCollection.selectIdentity(this._origMsg) : null;
	}

	if (this.identity) {
		request.idnt = this.identity.id;
	}

	if (ignoreNotify) { //bug 53974
		needsRsvp = false;
	}
	this._sendInviteReplyContinue(jsonObj, needsRsvp ? "TRUE" : "FALSE", edited, callback, errorCallback, instanceDate, accountName, toastMessage);
};

ZmMailMsg.prototype.applyPtstOffline = function(msgId, newPtst) {
	var applyPtstOfflineCallback = this._applyPtstOffline.bind(this, newPtst);
	ZmOfflineDB.getItem(msgId, ZmApp.MAIL, applyPtstOfflineCallback);
};
ZmMailMsg.prototype._applyPtstOffline = function(newPtst, result) {
	if (result && result[0] && result[0].inv && result[0].inv[0]) {
		var inv = result[0].inv[0];
		if (!inv.replies) {
			// See _sendInviteReply - patch the invite status
			inv.replies = [{
				reply: [{
					ptst: newPtst
				}]
			}];
		} else {
			inv.replies[0].reply[0].ptst = newPtst;
		}
		// Finally, Alter the offline folder - upon accepting an invite, it moves to the Trash folder
		result[0].l = ZmFolder.ID_TRASH;
		ZmOfflineDB.setItem(result, ZmApp.MAIL);

		// With the Ptst of an invite altered offline, move the message to trash locally
		var originalMsg = this._origMsg;
		originalMsg.moveLocal(ZmFolder.ID_TRASH);
		if (originalMsg.list) {
			originalMsg.list.moveLocal([originalMsg], ZmFolder.ID_TRASH);
		}
		var details = {oldFolderId:originalMsg.folderId};
		originalMsg._notify(ZmEvent.E_MOVE, details);

	}
}

ZmMailMsg.prototype._sendInviteReplyContinue =
function(jsonObj, updateOrganizer, edited, callback, errorCallback, instanceDate, accountName, toastMessage) {

	var request = jsonObj.SendInviteReplyRequest;
	request.updateOrganizer = updateOrganizer;

	if (instanceDate) {
		var serverDateTime = AjxDateUtil.getServerDateTime(instanceDate);
		var timeZone = AjxTimezone.getServerId(AjxTimezone.DEFAULT);
		var clientId = AjxTimezone.getClientId(timeZone);
		ZmTimezone.set(request, clientId, null, true);
		request.exceptId = {d:serverDateTime, tz:timeZone};
	}

	if (edited) {
		this._createMessageNode(request, null, accountName);
	}

	var respCallback = new AjxCallback(this, this._handleResponseSendInviteReply, [callback, toastMessage]);
    this._sendMessage({ jsonObj:jsonObj,
								isInvite:true,
								isDraft:false,
								callback:respCallback,
								errorCallback:errorCallback,
								accountName:accountName
                       });
};

ZmMailMsg.prototype._handleResponseSendInviteReply =
function(callback, toastMessage, result) {
	var resp = result.getResponse();

	var id = resp.id ? resp.id.split("-")[0] : null;
	var statusOK = (id || resp.status == "OK");

	if (statusOK) {
		this._notifySendListeners();
		this._origMsg.folderId = ZmFolder.ID_TRASH;
	}

	// allow or disallow move logic:
	var allowMove;
	if ((this.acceptFolderId != ZmOrganizer.ID_CALENDAR) ||
		(appCtxt.multiAccounts &&
			!this.getAccount().isMain &&
			this.acceptFolderId == ZmOrganizer.ID_CALENDAR))
	{
		allowMove = true;
	}

	if (this.acceptFolderId && allowMove && resp.apptId != null) {
		this.moveApptItem(resp.apptId, this.acceptFolderId);
	}

    if (window.parentController) {
		window.close();
	}

	if (toastMessage) {
		//note - currently this is not called from child window, but just in case it will in the future.
		var ctxt = window.parentAppCtxt || window.appCtxt; //show on parent window if this is a child window, since we close this child window on accept/decline/etc
		ctxt.setStatusMsg(toastMessage);
	}

	if (callback) {
		callback.run(result, this._origMsg.getPtst()); // the ptst was updated in _sendInviteReply
	}
};

/**
 * returns this user's reply to this invite.
 */
ZmMailMsg.prototype.getPtst =
function() {
	return this.invite && this.invite.replies && this.invite.replies[0].reply[0].ptst;
};

ZmMailMsg.APPT_TRASH_FOLDER = 3;

ZmMailMsg.prototype.isInviteCanceled =
function() {
	var invite = this.invite;
	if (!invite) {
		return false;
	}
	return invite.components[0].ciFolder == ZmMailMsg.APPT_TRASH_FOLDER;
};

ZmMailMsg.prototype.moveApptItem =
function(itemId, nfolder) {
	var callback = new AjxCallback(this, this._handleMoveApptResponse, [nfolder]);
	var errorCallback = new AjxCallback(this, this._handleMoveApptError, [nfolder]);
	var ac = window.parentAppCtxt || window.appCtxt;
	var accountName = ac.multiAccounts && ac.accountList.mainAccount.name;
	ZmItem.move(itemId, nfolder, callback, errorCallback, accountName);
};

ZmMailMsg.prototype._handleMoveApptResponse =
function(nfolder, resp) {
	this._lastApptFolder = nfolder;
	// TODO: Display some sort of confirmation?
};

ZmMailMsg.prototype._handleMoveApptError =
function(nfolder, resp) {
	var params = {
		msg:	ZmMsg.errorMoveAppt,
		level:	ZmStatusView.LEVEL_CRITICAL
	};
	appCtxt.setStatusMsg(params);
	return true;
};

/**
 * Sends the message.
 *
 * @param {Boolean}	isDraft				if <code>true</code>, this a draft
 * @param {AjxCallback}	callback			the callback to trigger after send
 * @param {AjxCallback}	errorCallback	the error callback to trigger
 * @param {String}	accountName			the account to send on behalf of
 * @param {Boolean}	noSave				if set, a copy will *not* be saved to sent regardless of account/identity settings
 * @param {Boolean}	requestReadReceipt	if set, a read receipt is sent to *all* recipients
 * @param {ZmBatchCommand} batchCmd		if set, request gets added to this batch command
 * @param {Date} sendTime				if set, tell server that this message should be sent at the specified time
 * @param {Boolean} isAutoSave          if <code>true</code>, this an auto-save draft
 */
ZmMailMsg.prototype.send =
function(isDraft, callback, errorCallback, accountName, noSave, requestReadReceipt, batchCmd, sendTime, isAutoSave) {

	var aName = accountName;
	if (!aName) {
		// only set the account name if this *isnt* the main/parent account
		var acct = appCtxt.getActiveAccount();
		if (acct && !acct.isMain) {
			aName = acct.name;
		}
	}
	// if we have an invite reply, we have to send a different message
	if (this.isInviteReply && !isDraft) {
		// TODO: support for batchCmd here as well
		return this.sendInviteReply(true, 0, callback, errorCallback, this._instanceDate, aName, false);
	} else {
		var jsonObj, request;
		if (isDraft) {
			jsonObj = {SaveDraftRequest:{_jsns:"urn:zimbraMail"}};
			request = jsonObj.SaveDraftRequest;
		} else {
			jsonObj = {SendMsgRequest:{_jsns:"urn:zimbraMail"}};
			request = jsonObj.SendMsgRequest;
			if (this.sendUID) {
				request.suid = this.sendUID;
			}
		}
		if (noSave) {
			request.noSave = 1;
		}
		this._createMessageNode(request, isDraft, aName, requestReadReceipt, sendTime);
		appCtxt.notifyZimlets("addExtraMsgParts", [request, isDraft]);
		var params = {
			jsonObj: jsonObj,
			isInvite: false,
			isDraft: isDraft,
			isAutoSave: isAutoSave,
			accountName: aName,
			callback: (new AjxCallback(this, this._handleResponseSend, [isDraft, callback])),
			errorCallback: errorCallback,
			batchCmd: batchCmd,
            skipOfflineCheck: true
		};
        this._sendMessage(params);
    }
};

ZmMailMsg.prototype._handleResponseSend =
function(isDraft, callback, result) {
	var resp = result.getResponse().m[0];

	// notify listeners of successful send message
	if (!isDraft) {
		if (resp.id || !appCtxt.get(ZmSetting.SAVE_TO_SENT)) {
			this._notifySendListeners();
		}
	} else {
		this._loadFromDom(resp);
		if (resp.autoSendTime) {
			this._notifySendListeners();
		}
	}

	if (callback) {
		callback.run(result);
	}
};

ZmMailMsg.prototype._createMessageNode =
function(request, isDraft, accountName, requestReadReceipt, sendTime) {

	var msgNode = request.m = {};
	var ac = window.parentAppCtxt || window.appCtxt;
	var activeAccount = ac.accountList.activeAccount;
	var mainAccount = ac.accountList.mainAccount;

	//When fwding an email in Parent's(main) account(main == active), but we are sending on-behalf-of child(active != accountName)
	var doQualifyIds = !ac.isOffline && accountName && mainAccount.name !== accountName;

	// if origId is given, means we're saving a draft or sending a msg that was
	// originally a reply/forward
	if (this.origId) {
         // always Qualify ID when forwarding mail using a child account
        if (appCtxt.isOffline) {
            var origAccount = this._origMsg && this._origMsg.getAccount();
            doQualifyIds = ac.multiAccounts  && origAccount.id == mainAccount.id;
        }
		var id = this.origId;
		if(doQualifyIds) {
			id = ZmOrganizer.getSystemId(this.origId, mainAccount, true);
		}
		msgNode.origid = id;
	}
	// if id is given, means we are re-saving a draft
	var oboDraftMsgId = null; // On Behalf of Draft MsgId
	if ((isDraft || this.isDraft) && this.id) {
		// bug fix #26508 - check whether previously saved draft was moved to Trash
		var msg = ac.getById(this.id);
		var folder = msg ? ac.getById(msg.folderId) : null;
		if (!folder || (folder && !folder.isInTrash())) {
			if (!ac.isOffline && !isDraft && this._origMsg && this._origMsg.isDraft) {
				var defaultAcct = ac.accountList.defaultAccount || ac.accountList.mainAccount;
				var from = this._origMsg.getAddresses(AjxEmailAddress.FROM).get(0);
				// this means we're sending a draft msg obo
				if (from && from.address != defaultAcct.getEmail()) {
					oboDraftMsgId = (this.id.indexOf(":") == -1)
						? ([defaultAcct.id, ":", this.id].join("")) : this.id;
					msgNode.id = oboDraftMsgId;
				} else {
					msgNode.id = this.nId;
				}
			} else {
				msgNode.id = this.nId;
			}

			if (!isDraft) { // not saveDraftRequest 
				var did = this.nId || this.id; // set draft id
				if (doQualifyIds) {
					did = ZmOrganizer.getSystemId(did, mainAccount, true);
				}
				msgNode.did = did;
			}
		}
	}

	if (this.isForwarded) {
		msgNode.rt = "w";
	} else if (this.isReplied) {
		msgNode.rt = "r";
	}
	if (this.identity) {
		msgNode.idnt = this.identity.id;
	}

	if (this.isHighPriority) {
		msgNode.f = ZmItem.FLAG_HIGH_PRIORITY;
	} else if (this.isLowPriority) {
		msgNode.f = ZmItem.FLAG_LOW_PRIORITY;
	}

	if (this.isPriority) {
	    msgNode.f = ZmItem.FLAG_PRIORITY;			
	}

    if (this.isOfflineCreated) {
        msgNode.f = msgNode.f || "";
        if (msgNode.f.indexOf(ZmItem.FLAG_OFFLINE_CREATED) === -1) {
            msgNode.f = msgNode.f + ZmItem.FLAG_OFFLINE_CREATED;
        }
    }
	
	var addrNodes = msgNode.e = [];
	for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
		var type = ZmMailMsg.COMPOSE_ADDRS[i];
		this._addAddressNodes(addrNodes, type, isDraft);
	}
	this._addFrom(addrNodes, msgNode, isDraft, accountName);
	this._addReplyTo(addrNodes);
	if (requestReadReceipt) {
		this._addReadReceipt(addrNodes, accountName);
	}
	if (addrNodes.length) {
		msgNode.e = addrNodes;
	}
	
	//Let Zimlets set custom mime headers. They need to push header-name and header-value like below:
	//customMimeHeaders.push({name:"header1", _content:"headerValue"})
	var customMimeHeaders = [];
	appCtxt.notifyZimlets("addCustomMimeHeaders", [customMimeHeaders]);
	if((customMimeHeaders instanceof Array) && customMimeHeaders.length > 0) {
		 msgNode.header = customMimeHeaders;
	}
	msgNode.su = {_content:this.subject};

	var topNode = {ct:this._topPart.getContentType()};
	msgNode.mp = [topNode];

	// if the top part has sub parts, add them as children
	var numSubParts = this._topPart.children ? this._topPart.children.size() : 0;
	if (numSubParts > 0) {
		var partNodes = topNode.mp = [];
		for (var i = 0; i < numSubParts; i++) {
			var part = this._topPart.children.get(i);
			var content = part.getContent();
			var numSubSubParts = part.children ? part.children.size() : 0;
			if (content == null && numSubSubParts == 0) { continue; }

			var partNode = {ct:part.getContentType()};

			if (numSubSubParts > 0) {
				// If each part again has subparts, add them as children
				var subPartNodes = partNode.mp = [];
				for (var j = 0; j < numSubSubParts; j++) {
					var subPart = part.children.get(j);
					subPartNodes.push({ct:subPart.getContentType(), content:{_content:subPart.getContent()}});
				}
				// Handle Related SubPart , a specific condition
				if (part.getContentType() == ZmMimeTable.MULTI_RELATED) {
					// Handle Inline Attachments
					var inlineAtts = this.getInlineAttachments() || [];
					if (inlineAtts.length) {
						for (j = 0; j < inlineAtts.length; j++) {
							var inlineAttNode = {ci:inlineAtts[j].cid};
							var attachNode = inlineAttNode.attach = {};
							if (inlineAtts[j].aid) {
								attachNode.aid = inlineAtts[j].aid;
							} else {
								var id = inlineAtts[j].mid
									|| (isDraft || this.isDraft)
									? (oboDraftMsgId || this.id || this.origId)
									: (this.origId || this.id);

								if (!id && this._origMsg) {
									id = this._origMsg.id;
								}
								if (id && doQualifyIds) {
									id = ZmOrganizer.getSystemId(id, mainAccount, true);
								}
								if(id) {
									attachNode.mp = [{mid:id, part:inlineAtts[j].part}];
								}
							}
							subPartNodes.push(inlineAttNode);
						}
					}
					// Handle Inline Attachments
					var inlineDocAtts = this.getInlineDocAttachments() || [];
					if (inlineDocAtts.length) {
						for (j = 0; j < inlineDocAtts.length; j++) {
							var inlineDocAttNode = {ci:inlineDocAtts[j].cid};
							var attachNode = inlineDocAttNode.attach = {};
							if (inlineDocAtts[j].docpath) {
								attachNode.doc = [{path: inlineDocAtts[j].docpath, optional:1 }];
							} else if (inlineDocAtts[j].docid) {
								attachNode.doc = [{id: inlineDocAtts[j].docid}];
							} 
							subPartNodes.push(inlineDocAttNode);
						}
					}
				}
			} else {
				partNode.content = {_content:content};
			}
			partNodes.push(partNode);
		}
	} else {
		topNode.content = {_content:this._topPart.getContent()};
	}

	if (this.irtMessageId) {
		msgNode.irt = {_content:this.irtMessageId};
	}

	if (this.attId ||
		(this._msgAttIds && this._msgAttIds.length) ||
		(this._docAtts && this._docAtts.length) ||
		(this._forAttIds && this._forAttIds.length) ||
		(this._contactAttIds && this._contactAttIds.length))
	{
		var attachNode = msgNode.attach = {};
		if (this.attId) {
			attachNode.aid = this.attId;
		}

		// attach mail msgs
		if (this._msgAttIds && this._msgAttIds.length) {
			var msgs = attachNode.m = [];
			for (var i = 0; i < this._msgAttIds.length; i++) {
				msgs.push({id:this._msgAttIds[i]});
			}
		}


		// attach docs
		if (this._docAtts) {
			var docs = attachNode.doc = [];
			for (var i = 0; i < this._docAtts.length; i++) {
                var d = this._docAtts[i];
                // qualify doc id
                var docId = (d.id.indexOf(":") == -1)
                        ? ([mainAccount.id, d.id].join(":")) : d.id;
                var props = {id: docId};
                if(d.ver) props.ver = d.ver;
				docs.push(props);
			}
		}

		// attach msg attachments
		if (this._forAttObjs && this._forAttObjs.length) {
			var parts = attachNode.mp = this._forAttObjs;
			if (doQualifyIds) {
				for (var i = 0; i < parts.length; i++) {
					var part = parts[i];
					part.mid = ZmOrganizer.getSystemId(part.mid, mainAccount, true);
				}
			}
		}

		if (this._contactAttIds && this._contactAttIds.length) {
			attachNode.cn = [];
			for (var i = 0; i < this._contactAttIds.length; i++) {
				attachNode.cn.push({id:this._contactAttIds[i]});
			}
		}
	}

	if (sendTime && sendTime.date) {
		var date = sendTime.date; // See ZmTimeDialog.prototype.getValue
		var timezone = sendTime.timezone || AjxTimezone.DEFAULT;
		var offset = AjxTimezone.getOffset(timezone, date);
		var utcEpochTime = date.getTime() - ((date.getTimezoneOffset() + offset) * 60 * 1000);
		// date.getTime() is the selected timestamp in local machine time (NOT UTC)
		// date.getTimezoneOffset() is negative minutes to UTC from local time (+ for West, - for East)
		// offset is minutes to UTC from selected time (- for West, + for East)
		msgNode.autoSendTime = utcEpochTime;
	}
};

/**
 * Sends this message to its recipients.
 *
 * @param params				[hash]			hash of params:
 *        jsonObj				[object]		JSON object
 *        isInvite				[boolean]		true if this message is an invite
 *        isDraft				[boolean]		true if this message is a draft
 *        callback				[AjxCallback]	async callback
 *        errorCallback			[AjxCallback]	async error callback
 *        batchCmd				[ZmBatchCommand]	if set, request gets added to this batch command
 *
 * @private
 */
ZmMailMsg.prototype._sendMessage =
function(params) {
	var respCallback = new AjxCallback(this, this._handleResponseSendMessage, [params]),
        offlineCallback = this._handleOfflineResponseSendMessage.bind(this, params);
    /* bug fix 63798 removing sync request and making it async
	// bug fix #4325 - its safer to make sync request when dealing w/ new window
	if (window.parentController) {
		var newParams = {
			jsonObj: params.jsonObj,
			accountName: params.accountName,
			errorCallback: params.errorCallback
		};
		var resp = appCtxt.getAppController().sendRequest(newParams);
		if (!resp) { return; } // bug fix #9154
		if (params.toastMessage) {
			parentAppCtxt.setStatusMsg(params.toastMessage); //show on parent window since this is a child window, since we close this child window on accept/decline/etc
		}

		if (resp.SendInviteReplyResponse) {
			return resp.SendInviteReplyResponse;
		} else if (resp.SaveDraftResponse) {
			resp = resp.SaveDraftResponse;
			this._loadFromDom(resp.m[0]);
			return resp;
		} else if (resp.SendMsgResponse) {
			return resp.SendMsgResponse;
		}
	} else if (params.batchCmd) {*/
    if  (params.batchCmd) {
		params.batchCmd.addNewRequestParams(params.jsonObj, respCallback, params.errorCallback);
	} else {
		appCtxt.getAppController().sendRequest({jsonObj:params.jsonObj,
												asyncMode:true,
												noBusyOverlay:params.isDraft && params.isAutoSave,
												callback:respCallback,
												errorCallback:params.errorCallback,
                                                offlineCallback:offlineCallback,
												accountName:params.accountName,
                                                timeout: ( ( params.isDraft && this.attId ) ? 0 : null )
                                                });
	}
};

ZmMailMsg.prototype._handleResponseSendMessage =
function(params, result) {
	var response = result.getResponse();
	if (params.isInvite) {
		result.set(response.SendInviteReplyResponse);
	} else if (params.isDraft) {
		result.set(response.SaveDraftResponse);
	} else {
		result.set(response.SendMsgResponse);
	}
	if (params.callback) {
		params.callback.run(result);
	}
};

ZmMailMsg.prototype._handleOfflineResponseSendMessage =
function(params) {

    var jsonObj = $.extend(true, {}, params.jsonObj),//Always clone the object
        methodName = Object.keys(jsonObj)[0],
        msgNode = jsonObj[methodName].m,
        msgNodeAttach = msgNode.attach,
        origMsg = this._origMsg,
        currentTime = new Date().getTime(),
        callback,
        aid = [];
	var folderId = this.getFolderId();

    jsonObj.methodName = methodName;
    msgNode.d = currentTime; //for displaying date and time in the outbox/Drafts folder

    if (msgNodeAttach && msgNodeAttach.aid) {
        var msgNodeAttachIds = msgNodeAttach.aid.split(",");
        for (var i = 0; i < msgNodeAttachIds.length; i++) {
            var msgNodeAttachId = msgNodeAttachIds[i];
            if (msgNodeAttachId) {
                aid.push(msgNodeAttachId);
                msgNodeAttach[msgNodeAttachId] = appCtxt.getById(msgNodeAttachId);
                appCtxt.cacheRemove(msgNodeAttachId);
            }
        }
    }

    if (origMsg && origMsg.hasAttach) {//Always append origMsg attachments for offline handling
        var origMsgAttachments = origMsg.attachments;
        if (msgNodeAttach) {
            delete msgNodeAttach.mp;//Have to rewrite the code for including original attachments
        } else {
            msgNodeAttach = msgNode.attach = {};
        }
        for (var j = 0; j < origMsgAttachments.length; j++) {
            var node = origMsgAttachments[j].node;
            if (node && node.isOfflineUploaded) {
                aid.push(node.aid);
                msgNodeAttach[node.aid] = node;
            }
        }
    }

	if (msgNodeAttach) {
		if (aid.length > 0) {
			msgNodeAttach.aid = aid.join();
		}
		//If msgNodeAttach is an empty object then delete it
		if (Object.keys(msgNodeAttach).length === 0) {
			delete msgNode.attach;
		}
	}

    // Checking for inline Attachment
    if (this.getInlineAttachments().length > 0 || (origMsg && origMsg.getInlineAttachments().length > 0)) {
        msgNode.isInlineAttachment = true;
    }

    callback = this._handleOfflineResponseSendMessageCallback.bind(this, params, jsonObj);

	//For outbox item, message id will be always undefined.
	if (folderId == ZmFolder.ID_OUTBOX) {
		msgNode.id = origMsg && origMsg.id;
	}
    if (msgNode.id) { //Existing drafts created online or offline
        jsonObj.id = msgNode.id;
        var value = {
            update : true,
            methodName : methodName,
            id : msgNode.id,
            value : jsonObj
        };
        ZmOfflineDB.setItemInRequestQueue(value, callback);
    }
    else {
        jsonObj.id = msgNode.id = currentTime.toString(); //Id should be string
        msgNode.f = (msgNode.f || "").replace(ZmItem.FLAG_OFFLINE_CREATED, "").concat(ZmItem.FLAG_OFFLINE_CREATED);
        ZmOfflineDB.setItemInRequestQueue(jsonObj, callback);
    }
};

ZmMailMsg.prototype._handleOfflineResponseSendMessageCallback =
function(params, jsonObj) {

	var m = ZmOffline.generateMsgResponse(jsonObj);
    var data = {},
        header = this._generateOfflineHeader(params, jsonObj, m),
        notify = header.context.notify[0],
        result;
	if (!params.isInvite) {
		// If existing invite message - do not overwrite it.  The online code does not reload
		// the invite msg, it just patches it in-memory.  When the cal item ptst is patched in the db, it will
		// make a call to patch the invite too.
		ZmOfflineDB.setItem(m, ZmApp.MAIL);
	}

    data[jsonObj.methodName.replace("Request", "Response")] = notify.modified;
    result = new ZmCsfeResult(data, false, header);
    this._handleResponseSendMessage(params, result);
    appCtxt.getRequestMgr()._notifyHandler(notify);

    if (!params.isDraft && !params.isInvite) {
        var key = {
            methodName : "SaveDraftRequest",
            id : jsonObj[jsonObj.methodName].m.id
        };
        ZmOfflineDB.deleteItemInRequestQueue(key);//Delete any drafts for this message id
    }
};

ZmMailMsg.prototype._generateOfflineHeader =
function(params, jsonObj, m) {

    var folderArray = [],
        header = {
            context : {
                notify : [{
                    created : {
                        m : m
                    },
                    modified : {
                        folder : folderArray,
                        m : m
                    }
                }]
            }
        };

	if (!params.isInvite) {
		var folderId = this.getFolderId();
		if (params.isDraft || params.isAutoSave) {
			//For new auto save or draft folderId will not be equal to ZmFolder.ID_DRAFTS
			if (folderId != ZmFolder.ID_DRAFTS) {
				folderArray.push({
					id : ZmFolder.ID_DRAFTS,
					n : appCtxt.getById(ZmFolder.ID_DRAFTS).numTotal + 1
				});
			}
		}
		else {
			if (folderId != ZmFolder.ID_OUTBOX) {
				folderArray.push({
					id : ZmFolder.ID_OUTBOX,
					n : appCtxt.getById(ZmFolder.ID_OUTBOX).numTotal + 1
				});
			}
			if (folderId == ZmFolder.ID_DRAFTS) {
				folderArray.push({
					id : ZmFolder.ID_DRAFTS,
					n : appCtxt.getById(ZmFolder.ID_DRAFTS).numTotal - 1
				});
			}
		}
	}
    return header;
};

ZmMailMsg.prototype._notifySendListeners =
function() {
	var flag, msg;
	if (this.isForwarded) {
		flag = ZmItem.FLAG_FORWARDED;
		msg = this._origMsg;
	} else if (this.isReplied) {
		flag = ZmItem.FLAG_REPLIED;
		msg = this._origMsg;
	}

	if (flag && msg) {
		msg[ZmItem.FLAG_PROP[flag]] = true;
		if (msg.list) {
			msg.list._notify(ZmEvent.E_FLAGS, {items: [msg.list], flags: [flag]});
		}
	}
};

/**
 * from a child window - since we clone the message, the cloned message needs to listen to changes on the original (parent window) message.
 * @param ev
 */
ZmMailMsg.prototype.detachedChangeListener =
function(ev) {
	var parentWindowMsg = ev.item;
	//for now I only need it for keeping up with the isUnread and isFlagged status of the detached message. Keep it simple.
	this.isUnread = parentWindowMsg.isUnread;
	this.isFlagged = parentWindowMsg.isFlagged;
};



ZmMailMsg.prototype.isRealAttachment =
function(attachment) {
	var type = attachment.contentType;

	// bug fix #6374 - ignore if attachment is body unless content type is message/rfc822
	if (ZmMimeTable.isIgnored(type)) {
		return false;
	}

	// bug fix #8751 - dont ignore text/calendar type if msg is not an invite
	if (type == ZmMimeTable.TEXT_CAL && appCtxt.get(ZmSetting.CALENDAR_ENABLED) && this.isInvite()) {
		return false;
	}

	return true;
};

// this is a helper method to get an attachment url for multipart/related content
ZmMailMsg.prototype.getContentPartAttachUrl =
function(contentPartType, contentPart) {
	if (contentPartType != ZmMailMsg.CONTENT_PART_ID &&
		 				contentPartType != ZmMailMsg.CONTENT_PART_LOCATION) {
		return null;
	}
	var url = this._getContentPartAttachUrlFromCollection(this.attachments, contentPartType, contentPart);
	if (url) {
		return url;
	}
	return this._getContentPartAttachUrlFromCollection(this._bodyParts, contentPartType, contentPart);
};

ZmMailMsg.prototype._getContentPartAttachUrlFromCollection =
function(collection, contentPartType, contentPart) {
	if (!collection) {
		return null;
	}
	for (var i = 0; i < collection.length; i++) {
		var attach = collection[i];
		if (attach[contentPartType] == contentPart) {
            return this.getUrlForPart(attach);
		}
	}
	return null;
};


ZmMailMsg.prototype.findAttsFoundInMsgBody =
function() {
	if (this.findAttsFoundInMsgBodyDone) { return; }

	var content = "", cid;
	var bodyParts = this.getBodyParts();
	for (var i = 0; i < bodyParts.length; i++) {
		var bodyPart = bodyParts[i];
		if (bodyPart.contentType == ZmMimeTable.TEXT_HTML) {
			content = bodyPart.getContent();
			var msgRef = this;
			content.replace(/src=([\x27\x22])cid:([^\x27\x22]+)\1/ig, function(s, q, cid) {
				var attach = msgRef.findInlineAtt("<" + AjxStringUtil.urlComponentDecode(cid)  + ">");
				if (attach) {
					attach.foundInMsgBody = true;
				}
			});
		}
	}
	this.findAttsFoundInMsgBodyDone = true;
};

ZmMailMsg.prototype.hasInlineImagesInMsgBody =
function() {
	var body = this.getBodyContent(ZmMimeTable.TEXT_HTML);
	return (body && body.search(/src=([\x27\x22])cid:([^\x27\x22]+)\1/ig) != -1);
};

/**
 * Returns the number of attachments in this msg.
 * 
 * @param {boolean}		includeInlineAtts
 */
ZmMailMsg.prototype.getAttachmentCount =
function(includeInlineAtts) {
	var attachments = includeInlineAtts ? [].concat(this.attachments, this._getInlineAttachments()) : this.attachments;
	return attachments ? attachments.length : 0;
};

ZmMailMsg.prototype._getInlineAttachments =
function() {
	var atts = [];
	var parts = this.getBodyParts();
	if (parts && parts.length > 1) {
		var part;
		for (var k = 0; k < parts.length; k++) {
			part = parts[k];
			if (part.fileName && part.contentDisposition == "inline") {
				atts.push(part);
			}
		}
	}
	return atts;
};

/**
 * Returns an array of objects containing meta info about attachments
 */
ZmMailMsg.prototype.getAttachmentInfo =
function(findHits, includeInlineImages, includeInlineAtts) {

	this._attInfo = [];

	var attachments = (includeInlineAtts || includeInlineImages) ? [].concat(this.attachments, this._getInlineAttachments()) : this.attachments;
	if (attachments && attachments.length > 0) {
		this.findAttsFoundInMsgBody();

		for (var i = 0; i < attachments.length; i++) {
			var attach = attachments[i];

			if (!this.isRealAttachment(attach) ||
					(attach.contentType.match(/^image/) && attach.contentId && attach.foundInMsgBody && !includeInlineImages) ||
					(attach.contentDisposition == "inline" && attach.fileName && ZmMimeTable.isRenderable(attach.contentType, true) && !includeInlineAtts)) {
				continue;
			}

			var props = {};
			props.links = {};	// flags that indicate whether to include a certain type of link

			// set a viable label for this attachment
			props.label = attach.name || attach.fileName || (ZmMsg.unknown + " <" + attach.contentType + ">");

			// use content location instead of built href flag
			var useCL = false;
			// set size info if any
			props.sizeInBytes = attach.s || 0;
			if (attach.size != null && attach.size >= 0) {
				var numFormatter = AjxNumberFormat.getInstance();  
				if (attach.size < 1024) {
					props.size = numFormatter.format(attach.size) + " " + ZmMsg.b;
				}
				else if (attach.size < (1024 * 1024)) {
					props.size = numFormatter.format(Math.round((attach.size / 1024) * 10) / 10) + " " + ZmMsg.kb;
				}
				else {
					props.size = numFormatter.format(Math.round((attach.size / (1024 * 1024)) * 10) / 10) + " " + ZmMsg.mb;
				}
			}

			if (attach.part) {
				useCL = attach.contentLocation && (attach.relativeCl || ZmMailMsg.URL_RE.test(attach.contentLocation));
			} else {
				useCL = attach.contentLocation && true;
			}

			// see if rfc822 is an invite
			if (attach.contentType == ZmMimeTable.MSG_RFC822) {
				props.rfc822Part = attach.part;
				var calPart = (attach.children.size() == 1) && attach.children.get(0);
				if (appCtxt.get(ZmSetting.CALENDAR_ENABLED) && calPart && (calPart.contentType == ZmMimeTable.TEXT_CAL)) {
					props.links.importICS = true;
					props.rfc822CalPart = calPart.part;
				}
			} else {
				// set the anchor html for the link to this attachment on the server
				var url = useCL ? attach.contentLocation : this.getUrlForPart(attach);

				// bug fix #6500 - append filename w/in so "Save As" wont append .html at the end
				if (!useCL) {
					var insertIdx = url.indexOf("?auth=co&");
					var fn = AjxStringUtil.urlComponentEncode(attach.fileName);
					fn = fn.replace(/\x27/g, "%27");
					url = url.substring(0,insertIdx) + fn + url.substring(insertIdx);
				}
				if (!useCL) {
					props.links.download = true;
				}

				var folder = appCtxt.getById(this.folderId);
				if ((attach.name || attach.fileName) && appCtxt.get(ZmSetting.BRIEFCASE_ENABLED)) {
					if (!useCL) {
						props.links.briefcase = true;
					}
				}

				var isICSAttachment = (attach.fileName && attach.fileName.match(/\./) && attach.fileName.replace(/^.*\./, "").toLowerCase() == "ics");

				if (appCtxt.get(ZmSetting.CALENDAR_ENABLED) && ((attach.contentType == ZmMimeTable.TEXT_CAL) || isICSAttachment)) {
					props.links.importICS = true;
				}

				if (!useCL) {
					// check for vcard *first* since we dont care to view it in HTML
					if (ZmMimeTable.isVcard(attach.contentType)) {
						props.links.vcard = true;
					}
					else if (ZmMimeTable.hasHtmlVersion(attach.contentType) && appCtxt.get(ZmSetting.VIEW_ATTACHMENT_AS_HTML)) {
						props.links.html = true;
					}
					else {
						// set the objectify flag
						var contentType = attach.contentType;
						props.objectify = contentType && contentType.match(/^image/) && !contentType.match(/tif/); //see bug 82807 - Tiffs are not really supported by browsers, so don't objectify.
					}
				} else {
					props.url = url;
				}

				if (attach.part) {
					// bug: 233 - remove attachment
					props.links.remove = true;
				}
			}

			// set the link icon
			var mimeInfo = ZmMimeTable.getInfo(attach.contentType);
			props.linkIcon = mimeInfo ? mimeInfo.image : "GenericDoc";
			props.ct = attach.contentType;

			// set other meta info
			props.isHit = findHits && this._isAttInHitList(attach);
			// S/MIME: recognize client-side generated attachments,
			// and stash the cache key for the applet in the part, as
			// it's the only data which we retain later on
			if (attach.part) {
				props.part = attach.part;
			} else {
				props.generated = true;
				props.part = attach.cachekey;
			}
			if (!useCL) {
                if (attach.node && attach.node.isOfflineUploaded) { //for offline upload attachments
                    props.url = attach.node.data;
                } else {
                    props.url = this.getUrlForPart(attach);
    			}
			}
			if (attach.contentId || (includeInlineImages && attach.contentDisposition == "inline")) {  // bug: 28741
				props.ci = true;
			}
            props.mid = this.id;
			props.foundInMsgBody = attach.foundInMsgBody;

			// and finally, add to attLink array
			this._attInfo.push(props);
		}
	}

	return this._attInfo;
};
ZmMailMsg.prototype.getAttachmentLinks = ZmMailMsg.prototype.getAttachmentInfo;

ZmMailMsg.prototype.removeAttachments =
function(partIds, callback) {
	var jsonObj = {RemoveAttachmentsRequest: {_jsns:"urn:zimbraMail"}};
	var request = jsonObj.RemoveAttachmentsRequest;
	request.m = {
		id:		this.id,
		part:	partIds.join(",")
	};

	var params = {
		jsonObj:		jsonObj,
		asyncMode:		true,
		callback:		callback,
		noBusyOverlay:	true
	};
	return appCtxt.getAppController().sendRequest(params);
};


// Private methods

/**
 * Processes a message node, getting attributes and child nodes to fill in the message.
 * This method may be called on an existing msg, since only metadata is returned when a
 * conv is expanded via SearchConvRequest. That is why we check values before setting
 * them, and why we don't clear out all the msg properties here first.
 */
ZmMailMsg.prototype._loadFromDom =
function(msgNode) {
	// this method could potentially be called twice (SearchConvResponse and
	// GetMsgResponse) so always check param before setting!
	if (msgNode.id)		{ this.id = msgNode.id; }
	if (msgNode.part)	{ this.partId = msgNode.part; }
	if (msgNode.cid) 	{ this.cid = msgNode.cid; }
	if (msgNode.s) 		{ this.size = msgNode.s; }
	if (msgNode.d) 		{ this.date = msgNode.d; }
	if (msgNode.sd) 	{ this.sentDate = msgNode.sd; }
	if (msgNode.l) 		{ this.folderId = msgNode.l; }
	if (msgNode.tn)		{ this._parseTagNames(msgNode.tn); }
	if (msgNode.cm) 	{ this.inHitList = msgNode.cm; }
	if (msgNode.su) 	{ this.subject = msgNode.su; }
	if (msgNode.fr) 	{ this.fragment = msgNode.fr; }
	if (msgNode.rt) 	{ this.rt = msgNode.rt; }
	if (msgNode.origid) { this.origId = msgNode.origid; }
	if (msgNode.hp) 	{ this._attHitList = msgNode.hp; }
	if (msgNode.mid)	{ this.messageId = msgNode.mid; }
	if (msgNode.irt)	{ this.irtMessageId = msgNode.irt; }
	if (msgNode._attrs) { this.attrs = msgNode._attrs; }
	if (msgNode.sf) 	{ this.sf = msgNode.sf; }
	if (msgNode.cif) 	{ this.cif = msgNode.cif; }
	if (msgNode.md) 	{ this.md = msgNode.md; }
	if (msgNode.ms) 	{ this.ms = msgNode.ms; }
	if (msgNode.rev) 	{ this.rev = msgNode.rev; }

    if (msgNode.idnt)	{
        var identityColl = appCtxt.getIdentityCollection();
        this.identity = identityColl && identityColl.getById(msgNode.idnt);
    }

    //Copying msg. header's
	if (msgNode.header) {
		this.headers = {};
		for (var i = 0; i < msgNode.header.length; i++) {
			this.headers[msgNode.header[i].n] = msgNode.header[i]._content;
		}
	}

	//Grab the metadata, keyed off the section name
	if (msgNode.meta) {
		this.meta = {};
		for (var i = 0; i < msgNode.meta.length; i++) {
			var section = msgNode.meta[i].section;
			this.meta[section] = {};
			this.meta[section]._attrs = {};
			for (a in msgNode.meta[i]._attrs) {
				this.meta[section]._attrs[a] = msgNode.meta[i]._attrs[a];
			}
		}
	}

	// set the "normalized" Id if this message belongs to a shared folder
	var idx = this.id.indexOf(":");
	this.nId = (idx != -1) ? (this.id.substr(idx + 1)) : this.id;

	if (msgNode._convCreateNode) {
		this._convCreateNode = msgNode._convCreateNode;
	}

	if (msgNode.cid && msgNode.l) {
		var conv = appCtxt.getById(msgNode.cid);
		if (conv) {
			// update conv's folder list
			if (conv.folders) {
				conv.folders[msgNode.l] = true;
			}
			var folders = AjxUtil.keys(conv.folders);
			AjxDebug.println(AjxDebug.NOTIFY, "update conv folder list: conv spans " + folders.length + " folder(s): " + folders.join(" "));
			// update msg list if none exists since we know this conv has at least one msg
			if (!conv.msgIds) {
				conv.msgIds = [this.id];
			}
            
            if(conv.isMute) {
                this.isMute = true;
            }
		}
	}

	// always call parseFlags even if server didn't return any
	this._parseFlags(msgNode.f);

	if (msgNode.mp) {
		// clear all attachments and body data
		this.attachments = [];
		this._bodyParts = [];
		this._contentType = {};
		this.findAttsFoundInMsgBodyDone = false;
		var ctxt = {
			attachments:	this.attachments,
			bodyParts:		this._bodyParts,
			contentTypes:	this._contentType
		};
		this._topPart = ZmMimePart.createFromDom(msgNode.mp[0], ctxt);
		this._loaded = this._bodyParts.length > 0 || this.attachments.length > 0;
		this._cleanupCIds();
	}

	if (msgNode.shr) {
		// TODO: Make server output better msgNode.shr property...
		var shareXmlDoc = AjxXmlDoc.createFromXml(msgNode.shr[0].content);
		try {
			AjxDispatcher.require("Share");
			this.share = ZmShare.createFromDom(shareXmlDoc.getDoc());
			this.share._msgId = msgNode.id;
		} catch (ex) {
			// not a version we support, ignore
		}
	}
	if (msgNode.dlSubs) {
		var dlSubsXmlDoc = AjxXmlDoc.createFromXml(msgNode.dlSubs[0].content);
		try {
			this.subscribeReq = ZmMailMsg.createDlSubFromDom(dlSubsXmlDoc.getDoc());
			this.subscribeReq._msgId = msgNode.id;
		}
		catch (ex) {
			// not a version we support, or missing element, ignore  - Not sure I like this approach but copying Share - Eran
			DBG.println(AjxDebug.DBG1, "createDlSubFromDom failed, content is:" + msgNode.dlSubs[0].content + " ex:" + ex);
		}
	}

	if (msgNode.e && this.participants && this.participants.size() == 0) {
		for (var i = 0; i < msgNode.e.length; i++) {
			this._parseParticipantNode(msgNode.e[i]);
		}
		this.clearAddresses();
		var parts = this.participants.getArray();
		for (var j = 0; j < parts.length; j++ ) {
			this.addAddress(parts[j]);
		}
	}

	if (msgNode.autoSendTime) {
		var timestamp = parseInt(msgNode.autoSendTime) || null;
		if (timestamp) {
			this.setAutoSendTime(new Date(timestamp));
		}
	}

	if (msgNode.inv) {
		try {
			this.invite = ZmInvite.createFromDom(msgNode.inv);
            if (this.invite.isEmpty()) return;
			this.invite.setMessageId(this.id);
			// bug fix #18613
			var desc = this.invite.getComponentDescription();
			var descHtml = this.invite.getComponentDescriptionHtml();
			if (descHtml) {
				this.setHtmlContent(descHtml);
				this.setInviteDescriptionContent(ZmMimeTable.TEXT_HTML, descHtml);
			}

			if (desc) {
				this.setInviteDescriptionContent(ZmMimeTable.TEXT_PLAIN, desc);
			}

			if (!appCtxt.get(ZmSetting.CALENDAR_ENABLED) && this.invite.type == "appt") {
				this.flagLocal(ZmItem.FLAG_ATTACH, true);
			}

		} catch (ex) {
			// do nothing - this means we're trying to load an ZmInvite in new
			// window, which we dont currently load (re: support).
		}
	}
};

ZmMailMsg.createDlSubFromDom =
function(doc) {
	// NOTE: This code initializes DL subscription info from the Zimbra dlSub format, v0.1
	var sub = {};

	var node = doc.documentElement;
	sub.version = node.getAttribute("version");
	sub.subscribe = node.getAttribute("action") == "subscribe";
	if (sub.version != ZmMailMsg.DL_SUB_VERSION) {
		throw "Zimbra dl sub version must be " + ZmMailMsg.DL_SUB_VERSION;
	}

	for (var child = node.firstChild; child != null; child = child.nextSibling) {
		if (child.nodeName != "dl" && child.nodeName != "user") {
			continue;
		}
		sub[child.nodeName] = {
			id: child.getAttribute("id"),
			email: child.getAttribute("email"),
			name: child.getAttribute("name")
		};
	}
	if (!sub.dl) {
		throw "missing dl element";
	}
	if (!sub.user) {
		throw "missing user element";
	}

	return sub;
};

ZmMailMsg.prototype.hasNoViewableContent =
function() {
	if (this.isRfc822) {
		//this means this message is not the top level one - but rather an attached message.
		return false; //till I can find a working heuristic that is not the fragment - size does not work as it includes probably stuff like subject and email addresses, and it's always bigger than 0.
	}
	var hasInviteContent = this.invite && !this.invite.isEmpty();
	//the general case - use the fragment, so that cases where the text is all white space are taken care of as "no content".
	return !this.fragment && !hasInviteContent && !this.hasInlineImagesInMsgBody() && !this.hasInlineImage()
};

ZmMailMsg.prototype._cleanupCIds =
function(atts) {
	atts = atts || this.attachments;
	if (!atts || atts.length == 0) { return; }

	for (var i = 0; i < atts.length; i++) {
		var att = atts[i];
		if (att.contentId && !/^<.+>$/.test(att.contentId)) {
			att.contentId = '<' + att.contentId + '>';
		}
	}
};

ZmMailMsg.prototype.mute =
function () {
	this.isMute = true;
};

ZmMailMsg.prototype.unmute =
function () {
	this.isMute = false;
};

ZmMailMsg.prototype.isInvite =
function () {
	return (this.invite != null);
};

ZmMailMsg.prototype.forwardAsInvite =
function () {
	if(!this.invite) {
		return false;
	}
	return this.invite.getInviteMethod() == "REQUEST";
};

ZmMailMsg.prototype.needsRsvp =
function () {
	if (!this.isInvite() || this.invite.isOrganizer()) { return false; }

	var needsRsvp = false;
	var accEmail = appCtxt.getActiveAccount().getEmail();
	if (this.isInvite()) {
		var at = this.invite.getAttendees();
		for (var i in at) {
			if (at[i].url == accEmail) {
				return at[i].rsvp;
			}
			if (at[i].rsvp) {
				needsRsvp = true;
			}
		}
		at = this.invite.getResources();
		for (var i in at) {
			if (at[i].url == accEmail) {
				return at[i].rsvp;
			}
			if (at[i].rsvp) {
				needsRsvp = true;
			}
		}
	}

	return needsRsvp;
};

// Adds child address nodes for the given address type.
ZmMailMsg.prototype._addAddressNodes =
function(addrNodes, type, isDraft) {

	var addrs = this._addrs[type];
	var num = addrs.size();
	var contactsApp;
	if (num) {
		if (appCtxt.isOffline) {
            contactsApp = appCtxt.getApp(ZmApp.CONTACTS)
        } else {
		    contactsApp = appCtxt.get(ZmSetting.CONTACTS_ENABLED) && appCtxt.getApp(ZmApp.CONTACTS);
        }
        if (contactsApp && !contactsApp.isContactListLoaded()) {
            contactsApp = null;
        }
		for (var i = 0; i < num; i++) {
			var addr = addrs.get(i);
			addr = addr.isAjxEmailAddress ? addr : AjxEmailAddress.parse(addr);
			if (addr) {
				var email = addr.getAddress();
				var name = addr.getName();
				var addrNode = {t:AjxEmailAddress.toSoapType[type], a:email};
				if (name) {
					addrNode.p = name;
				}
				addrNodes.push(addrNode);
			}
		}
	}
};

ZmMailMsg.prototype._addFrom =
function(addrNodes, parentNode, isDraft, accountName) {
	var ac = window.parentAppCtxt || window.appCtxt;

	// only use account name if we either dont have any identities to choose
	// from or the one we have is the default anyway
	var identity = this.identity;
	var isPrimary = identity == null || identity.isDefault;
	if (this.delegatedSenderAddr && !this.delegatedSenderAddrIsDL) {
		isPrimary = false;
	}

	// If repying to an invite which was addressed to user's alias then accept
	// reply should appear from the alias
	if (this._origMsg && this._origMsg.isInvite() &&
		this.isReplied &&
		(!this._origMsg._customMsg || !identity)) // is default reply or has no identities.
	{
		var origTos =  this._origMsg._getAttendees();
		var size = origTos && origTos.size() > 0 ? origTos.size() : 0;
		var aliazesString = "," + appCtxt.get(ZmSetting.MAIL_ALIASES).join(",") + ",";
		for (var i = 0; i < size; i++) {
			var origTo = origTos.get(i).address;
			if (origTo && aliazesString.indexOf("," + origTo + ",") >= 0) {
				var addrNode = {t:"f", a:origTo};
				addrNodes.push(addrNode);
				return; // We have already added appropriate alias as a "from". return from here.
			}
		}
	}

	//TODO: OPTIMIZE CODE by aggregating the common code.
	if (!appCtxt.isOffline && accountName && isPrimary) {
		var mainAcct = ac.accountList.mainAccount.getEmail();
		var onBehalfOf = false;

		var folder = appCtxt.getById(this.folderId);
		if ((!folder || folder.isRemote()) && (!this._origMsg || !this._origMsg.sendAsMe)) {
			accountName = (folder && folder.getOwner()) || accountName;
			onBehalfOf  = (accountName != mainAcct);
		}

		if (this._origMsg && this._origMsg.isDraft && !this._origMsg.sendAsMe) {
			var from = this._origMsg.getAddresses(AjxEmailAddress.FROM).get(0);
			// this means we're sending a draft msg obo so reset account name
			if (from && from.address.toLowerCase() != mainAcct.toLowerCase()) {
				accountName = from.address;
				onBehalfOf = true;
			}
		}

		// bug #44857 - replies/forwards should save sent message into respective account
		if (!onBehalfOf && appCtxt.isFamilyMbox && this._origMsg && folder) {
			onBehalfOf = (folder.getOwner() != mainAcct);
		}

		var addr, displayName;
		if (this.fromSelectValue) {
			addr = this.fromSelectValue.addr.address;
			displayName = this.fromSelectValue.addr.name;
		} else if (this._origMsg && this._origMsg.isInvite() && appCtxt.multiAccounts) {
			identity = this._origMsg.getAccount().getIdentity();
			addr = identity ? identity.sendFromAddress : this._origMsg.getAccount().name;
			displayName = identity && identity.sendFromDisplay;
		} else {
			if (onBehalfOf) {
				addr = accountName;
			} else {
				addr = identity ? identity.sendFromAddress : (this.delegatedSenderAddr || accountName);
                onBehalfOf = this.isOnBehalfOf;
				displayName = identity && identity.sendFromDisplay;
			}
		}

		var node = {t:"f", a:addr};
		if (displayName) {
			node.p = displayName;
		}
		addrNodes.push(node);
		if (onBehalfOf || !(ac.multiAccounts || isDraft)) {
			// the main account is *always* the sender
			addrNodes.push({t:"s", a:mainAcct});
		}
	} else{

		var mainAcct = ac.accountList.mainAccount.getEmail();
		var onBehalfOf = false;

		var folder = appCtxt.getById(this.folderId);
		if (folder && folder.isRemote() && !this._origMsg.sendAsMe) {
			accountName = folder.getOwner();
			onBehalfOf  = (accountName != mainAcct);
		}

		if (this._origMsg && this._origMsg.isDraft && !this._origMsg.sendAsMe) {
			var from = this._origMsg.getAddresses(AjxEmailAddress.FROM).get(0);
			// this means we're sending a draft msg obo so reset account name
			if (from && from.address.toLowerCase() != mainAcct.toLowerCase() && !appCtxt.isMyAddress(from.address.toLowerCase())) {
				accountName = from.address;
				onBehalfOf = true;
			}
		}

		var addr, displayName;
		if (onBehalfOf) {
			addr = accountName;
		} else if (identity) {
            if (identity.sendFromAddressType == ZmSetting.SEND_ON_BEHALF_OF){
                addr = identity.sendFromAddress.replace(ZmMsg.onBehalfOfMidLabel + " ", "");
                onBehalfOf = true;
            } else {
			    addr = identity.sendFromAddress || mainAcct;
            }
            displayName = identity.sendFromDisplay;

		} else {
           addr = this.delegatedSenderAddr || mainAcct;
           onBehalfOf = this.isOnBehalfOf;
        }

		var addrNode = {t:"f", a:addr};
		if( displayName) {
			addrNode.p = displayName;
		}
		addrNodes.push(addrNode);

		if (onBehalfOf) {
			addrNodes.push({t:"s", a:mainAcct});
		}

		if (identity && identity.isFromDataSource) {
			var dataSource = ac.getDataSourceCollection().getById(identity.id);
			if (dataSource) {
				// mail is "from" external account
				addrNode.t = "f";
				addrNode.a = dataSource.getEmail();
				if (ac.get(ZmSetting.DEFAULT_DISPLAY_NAME)) {
					var dispName = dataSource.identity && dataSource.identity.sendFromDisplay;
					addrNode.p = dispName || dataSource.userName || dataSource.getName();
				}
			}
		}
	}
};

ZmMailMsg.prototype._addReplyTo =
function(addrNodes) {
	if (this.identity) {
		if (this.identity.setReplyTo && this.identity.setReplyToAddress) {
			var addrNode = {t:"r", a:this.identity.setReplyToAddress};
			if (this.identity.setReplyToDisplay) {
				addrNode.p = this.identity.setReplyToDisplay;
			}
			addrNodes.push(addrNode);
		}
	}
};

ZmMailMsg.prototype._addReadReceipt =
function(addrNodes, accountName) {
	var addrNode = {t:"n"};
	if (this.identity) {
		addrNode.a = this.identity.readReceiptAddr || this.identity.sendFromAddress;
		addrNode.p = this.identity.sendFromDisplay;
	} else {
		addrNode.a = accountName || appCtxt.getActiveAccount().getEmail();
	}
	addrNodes.push(addrNode);
};

ZmMailMsg.prototype._isAttInHitList =
function(attach) {
	for (var i = 0; i < this._attHitList.length; i++) {
		if (attach.part == this._attHitList[i].part) { return true; }
	}

	return false;
};

ZmMailMsg.prototype._onChange =
function(what, a, b, c) {
	if (this.onChange) {
		this.onChange.run(what, a, b, c);
	}
};

/**
 * Gets the status icon.
 * 
 * @return	{String}	the icon
 */
ZmMailMsg.prototype.getStatusIcon =
function() {

	if (this.isInvite() && appCtxt.get(ZmSetting.CALENDAR_ENABLED)) {
		var method = this.invite.getInviteMethod();
		var status;
		if (method == ZmCalendarApp.METHOD_REPLY) {
			var attendees = this.invite.getAttendees();
			status = attendees && attendees[0] && attendees[0].ptst;
		} else if (method == ZmCalendarApp.METHOD_CANCEL) {
			status = ZmMailMsg.PSTATUS_DECLINED;
		}
		return ZmMailMsg.STATUS_ICON[status] || "Appointment";
	}

	for (var i = 0; i < ZmMailMsg.STATUS_LIST.length; i++) {
		var status = ZmMailMsg.STATUS_LIST[i];
		if (this[status]) {
			return ZmMailMsg.STATUS_ICON[status];
		}
	}

	return "MsgStatusRead";
};

/**
 * Gets the status tool tip.
 * 
 * @return	{String}	the tool tip
 */
ZmMailMsg.prototype.getStatusTooltip =
function() {
	// keep in sync with ZmConv.prototype.getStatusTooltip
	var status = [];
	if (this.isInvite()) {
		var icon = this.getStatusIcon();
		status.push(ZmMailMsg.TOOLTIP[icon]);
	}
	if (this.isScheduled)	{ status.push(ZmMsg.scheduled); }
	if (this.isUnread)		{ status.push(ZmMsg.unread); }
	if (this.isReplied)		{ status.push(ZmMsg.replied); }
	if (this.isForwarded)	{ status.push(ZmMsg.forwarded); }
	if (this.isDraft) {
		status.push(ZmMsg.draft);
	}
	else if (this.isSent) {
		status.push(ZmMsg.sentAt); //sentAt is for some reason "sent", which is what we need.
	}
	if (status.length == 0) {
		status = [ZmMsg.read];
	}

	return status.join(", ");
};

ZmMailMsg.prototype.notifyModify =
function(obj, batchMode) {
	if (obj.cid != null) {
		this.cid = obj.cid;
	}

	return ZmMailItem.prototype.notifyModify.apply(this, arguments);
};

ZmMailMsg.prototype.isResourceInvite =
function() {
	if (!this.cif || !this.invite) { return false; }

	var resources = this.invite.getResources();
	for (var i in resources) {
		if (resources[i] && resources[i].url == this.cif) {
			return true;
		}
	}
	return false;
};

ZmMailMsg.prototype.setAutoSendTime =
function(autoSendTime) {
    this._setAutoSendTime(autoSendTime);
};

ZmMailMsg.prototype._setAutoSendTime =
function(autoSendTime) {
	ZmMailItem.prototype.setAutoSendTime.call(this, autoSendTime);
	var conv = this.cid && appCtxt.getById(this.cid);
	if (Dwt.instanceOf(conv, "ZmConv")) {
		conv.setAutoSendTime(autoSendTime);
	}
};

/**
 * Sends a read receipt.
 * 
 * @param {closure}	callback	response callback
 */
ZmMailMsg.prototype.sendReadReceipt =
function(callback) {

	var jsonObj = {SendDeliveryReportRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.SendDeliveryReportRequest;
	request.mid = this.id;
	var ac = window.parentAppCtxt || window.appCtxt;
	ac.getRequestMgr().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:callback});
};


// Execute the mail redirect server side call
ZmMailMsg.prototype.redirect =
function(addrs, callback) {

	var jsonObj = {BounceMsgRequest:{_jsns:"urn:zimbraMail"}};
	var request = jsonObj.BounceMsgRequest;
	request.m = {id:this.id};
	var e = request.m.e = [];
	for (var iType = 0; iType < ZmMailMsg.COMPOSE_ADDRS.length; iType++) {
		if (addrs[ZmMailMsg.COMPOSE_ADDRS[iType]]) {
			var all =  addrs[ZmMailMsg.COMPOSE_ADDRS[iType]].all;
			for (var i = 0, len = all.size(); i < len; i++) {
				var addr = all.get(i);
				var rType = AjxEmailAddress.toSoapType[addr.type];
				e.push({t:rType, a:addr.address});
			}
		}
	}

    // No Success callback, nothing of interest returned
    var acct = appCtxt.multiAccounts && appCtxt.accountList.mainAccount;
    appCtxt.getAppController().sendRequest({
        jsonObj:       jsonObj,
        asyncMode:     true,
        accountName:   acct,
        callback:      callback
    });
};

ZmMailMsg.prototype.doDelete =
function() {
	var params = {jsonObj:{MsgActionRequest:{_jsns:"urn:zimbraMail",action:{id:this.id, op:"delete"}}}, asyncMode:true};

	// Bug 84549: The params object is a property of the child window, because it
	// was constructed using this window's Object constructor. But when the child
	// window closes immediately after the request is sent, the object would be 
	// garbage-collected by the browser (or otherwise become invalid).
	// Therefore, we need to pass an object that is native to the parent window
	if (appCtxt.isChildWindow && (AjxEnv.isIE || AjxEnv.isModernIE)) {
		var cp = function(from){
			var to = window.opener.Object();
			for (var key in from) {
				var value = from[key];
				to[key] = (AjxUtil.isObject(value)) ? cp(value) : value;
			}
			return to;
		};
		params = cp(params);
	}

	var ac = window.parentAppCtxt || window.appCtxt;
	ac.getRequestMgr().sendRequest(params);
};

/**
 * If message is sent on behalf of returns sender address otherwise returns from address
 * @return {String} email address
 */
ZmMailMsg.prototype.getMsgSender = 
function() {
	var from = this.getAddress(AjxEmailAddress.FROM);
	var sender = this.getAddress(AjxEmailAddress.SENDER);
	if (sender && sender.address != (from && from.address)) {
		return sender.address;
	}
	return from && from.address;
};

/**
 * Return list header id if it exists, otherwise returns null
 * @return {String} list id
 */
ZmMailMsg.prototype.getListIdHeader = 
function() {
	var id = null;
	if (this.attrs && this.attrs[ZmMailMsg.HDR_LISTID]) {
		//extract <ID> from header
		var listId = this.attrs[ZmMailMsg.HDR_LISTID];
		id = listId.match(/<(.*)>/);
		if (AjxUtil.isArray(id)) {
			id = id[id.length-1]; //make it the last match
		}
	}
	return id;
};

/**
 * Return the zimbra DL header if it exists, otherwise return null
 * @return {AjxEmailAddress} AjxEmailAddress object if header exists
**/
ZmMailMsg.prototype.getXZimbraDLHeader = 
function() {
	if (this.attrs && this.attrs[ZmMailMsg.HDR_XZIMBRADL]) {
		return AjxEmailAddress.parseEmailString(this.attrs[ZmMailMsg.HDR_XZIMBRADL]);
	}
	return null;
};

/**
 * Return mime header id if it exists, otherwise returns null
 * @return {String} mime header value
 */
ZmMailMsg.prototype.getMimeHeader =
function(name) {
	var value = null;
	if (this.attrs && this.attrs[name]) {
		value = this.attrs[name];
	}
	return value;
};

/**
 * Adds optional headers to the given request.
 * 
 * @param {object|AjxSoapDoc}	req		SOAP document or JSON parent object (probably a <m> msg object)
 */
ZmMailMsg.addRequestHeaders =
function(req) {
	
	if (!req) { return; }
	if (req.isAjxSoapDoc) {
		for (var hdr in ZmMailMsg.requestHeaders) {
			var headerNode = req.set('header', null, null);
			headerNode.setAttribute('n', ZmMailMsg.requestHeaders[hdr]);
		}
	}
	else {
		var hdrs = ZmMailMsg.requestHeaders;
		if (hdrs) {
			req.header = req.header || [];
			for (var hdr in hdrs) {
				req.header.push({n:hdrs[hdr]});
			}
		}
	}
};

/**
 * Returns a URL that can be used to fetch the given part of this message.
 *
 * @param   {ZmMimePart}    bodyPart        MIME part to fetch
 *
 * @returns {string}    URL to fetch the part
 */
ZmMailMsg.prototype.getUrlForPart = function(bodyPart) {

    return appCtxt.get(ZmSetting.CSFE_MSG_FETCHER_URI) + "&loc=" + AjxEnv.DEFAULT_LOCALE + "&id=" + this.id + "&part=" + bodyPart.part;
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmMimePart")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a mime part.
 * @class
 * This class represents a mime part. Note that the content of the node is
 * not copied into this object, for performance reasons. It is typically
 * available via the 'bodyParts' list that is populated during node parsing.
 * 
 * @extends		ZmModel
 */
ZmMimePart = function(parent) {
	
	ZmModel.call(this, ZmEvent.S_ATT);
	
	this.parent = parent;
	this.children = new AjxVector();
};

ZmMimePart.prototype = new ZmModel;
ZmMimePart.prototype.constructor = ZmMimePart;

ZmMimePart.prototype.isZmMimePart = true;
ZmMimePart.prototype.toString = function() { return "ZmMimePart"; };

/**
 * Returns a ZmMimePart constructed from the given JSON object. If a context
 * hash is provided with 'attachments' and 'bodyParts' arrays, and a hash
 * 'contentTypes', those will be populated as the node is recursively parsed.
 * 
 * @param	{object}		node	JSON representation of MIME part
 * @param	{hash}			ctxt	optional context
 * @return	{ZmMimePart}			a MIME part
 */
ZmMimePart.createFromDom =
function(node, ctxt, parent) {
	var mimePart = new ZmMimePart(parent);
	mimePart._loadFromDom(node, ctxt);
	return mimePart;
};

/**
 * Returns this part's content.
 * 
 * @return	{string}	content		the content
 */
ZmMimePart.prototype.getContent = 
function() {
	return this.content || (this.node && this.node.content) || "";
};

/**
 * Returns content of the given type, in or below this part.
 * 
 * @param	{string}	contentType		the content type
 * @return	{string}					the content
 * 
 */
ZmMimePart.prototype.getContentForType = 
function(contentType) {

	if (this.contentType == contentType) {
		return this.getContent();
	}
	else {
		var children = this.children.getArray();
		if (children.length) {
			for (var i = 0; i < children.length; i++) {
				var content = children[i].getContentForType(contentType);
				if (content) {
					return content;
				}
			}
		}
	}
	return "";
};

/**
 * Sets the content, overriding the original content.
 * 
 * @param	{string}	content		the content
 */
ZmMimePart.prototype.setContent = 
function(content) {
	this.content = content;
};

/**
 * Returns the content disposition.
 * 
 * @return	{string}	the content disposition
 */
ZmMimePart.prototype.getContentDisposition =
function() {
	return this.contentDisposition;
};

/**
 * Returns the content type.
 * 
 * @return	{string}	the content type
 */
ZmMimePart.prototype.getContentType =
function() {
	return this.contentType;
};

/**
 * Sets the content type, , overriding the original content type.
 * 
 * @param	{string}	contentType		the content type
 */
ZmMimePart.prototype.setContentType =
function(contentType) {
	this.contentType = contentType;
};

/**
 * Sets the 'is body' flag, overriding the original part's value.
 * 
 * @param	{boolean}	isBody		if true, this part is the body
 */
ZmMimePart.prototype.setIsBody = 
function(isBody) {
	this.isBody = isBody;
};

/**
 * Returns the filename.
 * 
 * @return	{string}	the filename
 */
ZmMimePart.prototype.getFilename =
function() {
	return this.fileName;
};

/**
 * Returns true if this part should not be considered to be an attachment.
 * 
 * @return	{boolean}
 */
ZmMimePart.prototype.isIgnoredPart =
function() {
	// bug fix #5889 - if parent node was multipart/appledouble,
	// ignore all application/applefile attachments - YUCK
	if (this.parent && this.parent.contentType == ZmMimeTable.MULTI_APPLE_DBL &&
		this.contentType == ZmMimeTable.APP_APPLE_DOUBLE)
	{
		return true;
	}

	// bug fix #7271 - dont show renderable body parts as attachments anymore
	if (this.isBody && this.getContent() && 
		(this.contentType == ZmMimeTable.TEXT_HTML || this.contentType == ZmMimeTable.TEXT_PLAIN))
	{
		return true;
	}

	if (this.contentType == ZmMimeTable.MULTI_DIGEST) {
		return true;
	}

	return false;
};

ZmMimePart.prototype._loadFromDom =
function(node, ctxt) {
	
	this._loadProps(node);
	
	if (node.content) {
		this._loaded = true;
	}
	
	if (ctxt.contentTypes) {
		ctxt.contentTypes[node.ct] = true;
	}

	var isAtt = false;
	if (this.contentDisposition == "attachment" || 
		this.contentType == ZmMimeTable.MSG_RFC822 || this.contentType == ZmMimeTable.TEXT_CAL ||            
		this.fileName || this.contentId || this.contentLocation) {

		if (!this.isIgnoredPart()) {
			if (ctxt.attachments) {
				ctxt.attachments.push(this);
			}
			isAtt = true;
		}
	}

	if (this.isBody) {
		var hasContent = AjxUtil.isSpecified(node.content);
		if ((ZmMimeTable.isRenderableImage(this.contentType) || hasContent)) {
			if (ctxt.bodyParts) {
				if (this.contentType == ZmMimeTable.MULTI_ALT) {
					ctxt.bodyParts.push({});
				}
				else if (ZmMimePart._isPartOfMultipartAlternative(this)) {
					var altPart = {};
					altPart[this.contentType] = this;
					ctxt.bodyParts.push(altPart);
				}
				else {
					ctxt.bodyParts.push(this);
				}
			}
			if (isAtt && ctxt.attachments) {
				//To avoid duplication, Remove attachment that was just added as bodypart.
				ctxt.attachments.pop();
			}
		} else if (!isAtt && this.size != 0 && !this.isIgnoredPart()){
			if (ctxt.attachments) {
				ctxt.attachments.push(this);
			}
		}
	}

	// bug fix #4616 - dont add attachments part of a rfc822 msg part
	if (node.mp && this.contentType != ZmMimeTable.MSG_RFC822) {
		for (var i = 0; i < node.mp.length; i++) {
			this.children.add(ZmMimePart.createFromDom(node.mp[i], ctxt, this));
		}
	}
};

ZmMimePart.prototype._loadProps =
function(node) {

	this.node				= node;
	
	// the middle column is for backward compatibility
	this.contentType		= this.ct			= node.ct;
	this.format									= node.format;	// optional arg for text/plain
	this.name									= node.name;
	this.part									= node.part;
	this.cachekey								= node.cachekey;
	this.size				= this.s			= node.s;
	this.contentDisposition	= this.cd			= node.cd;
	var ci = node.ci;
	//in some cases the content ID is not wrapped by angle brackets (mistake by the mail application), so make sure we wrap it if not
	this.contentId			= this.ci			= ci && ci.indexOf("<") !== 0 ? "<" + ci + ">" : ci;
	this.contentLocation	= this.cl			= node.cl;
	this.fileName			= this.filename		= node.filename;
	this.isTruncated		= this.truncated	= !!(node.truncated);
	this.isBody				= this.body			= !!(node.body);
};

/**
 * @param {object}		parentNode
 * @return {true/false}	true if one of the parent in the hierarchy is multipart/alternative otherwise false.
*/
ZmMimePart._isPartOfMultipartAlternative =
function(part){
    if (!part) { return false; }
    if (part.contentType == ZmMimeTable.MULTI_ALT) { return true; }
    return ZmMimePart._isPartOfMultipartAlternative(part.parent);
};

/**
 * Checks within the given node tree for content within a multipart/alternative part that
 * we don't have, and then creates and adds a MIME part for it. Assumes that there will be
 * at most one multipart/alternative.
 * 
 * @param {object}		node			
 * @param {string}		contentType
 * @param {int}			index
 * 
 * @return {ZmMimePart}		the MIME part that was created and added
 */
ZmMimePart.prototype.addAlternativePart =
function(node, contentType, index) {

	// replace this part if we got new content
	if (node.ct == contentType && ZmMimePart._isPartOfMultipartAlternative(this.parent) && node.body &&  !this.getContent()) {
		var mimePart = new ZmMimePart(this);
		mimePart._loadProps(node);
		this.parent.children.replace(index, mimePart);
		return mimePart;
	}
	if (node.mp && node.mp.length) {
		for (var i = 0; i < node.mp.length; i++) {
			var mimePart = this.children.get(i);
			var altPart = mimePart && mimePart.addAlternativePart(node.mp[i], contentType, i);
			if (altPart) {
				return altPart;
			}
		}
	}
};
}
if (AjxPackage.define("zimbraMail.mail.model.ZmMailList")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an empty list of mail items.
 * @constructor
 * @class
 * This class represents a list of mail items (conversations, messages, or
 * attachments). We retain a handle to the search that generated the list for
 * two reasons: so that we can redo the search if necessary, and so that we
 * can get the folder ID if this list represents folder contents.
 *
 * @author Conrad Damon
 * 
 * @param type		type of mail item (see ZmItem for constants)
 * @param search	the search that generated this list
 */
ZmMailList = function(type, search) {

	ZmList.call(this, type, search);

	this.convId = null; // for msg list within a conv

	// mail list can be changed via folder or tag action (eg "Mark All Read")
	var folderTree = appCtxt.getFolderTree();
	if (folderTree) {
		this._folderChangeListener = new AjxListener(this, this._folderTreeChangeListener);
		folderTree.addChangeListener(this._folderChangeListener);
	}
};

ZmMailList.prototype = new ZmList;
ZmMailList.prototype.constructor = ZmMailList;

ZmMailList.prototype.isZmMailList = true;
ZmMailList.prototype.toString = function() { return "ZmMailList"; };

ZmMailList._SPECIAL_FOLDERS = [ZmFolder.ID_DRAFTS, ZmFolder.ID_TRASH, ZmFolder.ID_SPAM, ZmFolder.ID_SENT];
ZmMailList._SPECIAL_FOLDERS_HASH = AjxUtil.arrayAsHash(ZmMailList._SPECIAL_FOLDERS);


/**
 * Override so that we can specify "tcon" attribute for conv move - we don't want
 * to move messages in certain system folders as a side effect. Also, we need to
 * update the UI based on the response if we're moving convs, since the 
 * notifications only tell us about moved messages. This method should be called
 * only in response to explicit action by the user, in which case we want to
 * remove the conv row(s) from the list view (even if the conv still matches the
 * search).
 *
 * @param {Hash}	params		a hash of parameters
 *        items			[array]			a list of items to move
 *        folder		[ZmFolder]		destination folder
 *        attrs			[hash]			additional attrs for SOAP command
 *        callback		[AjxCallback]*	callback to run after each sub-request
 *        finalCallback	[closure]*		callback to run after all items have been processed
 *        count			[int]*			starting count for number of items processed
 *        fromFolderId  [String]*       optional folder to represent when calculating tcon. If unspecified, use current search folder nId
 *        
 * @private
 */
ZmMailList.prototype.moveItems =
function(params) {

	if (this.type != ZmItem.CONV) {
		return ZmList.prototype.moveItems.apply(this, arguments);
	}

	params = Dwt.getParams(arguments, ["items", "folder", "attrs", "callback", "finalCallback", "noUndo", "actionTextKey", "fromFolderId"]);
	params.items = AjxUtil.toArray(params.items);

	var params1 = AjxUtil.hashCopy(params);
	delete params1.fromFolderId;

	params1.attrs = {};
	var tcon = this._getTcon(params.items, params.fromFolderId);
	if (tcon) {
		params1.attrs.tcon = tcon;
	}
	params1.attrs.l = params.folder.id;
	params1.action = (params.folder.id == ZmFolder.ID_TRASH) ? "trash" : "move";
    if (params1.folder.id == ZmFolder.ID_TRASH) {
        params1.actionTextKey = params.actionTextKey || "actionTrash";
    } else {
        params1.actionTextKey = params.actionTextKey || "actionMove";
        params1.actionArg = params1.folder.getName(false, false, true);
    }
	params1.callback = new AjxCallback(this, this._handleResponseMoveItems, [params]);

	if (appCtxt.multiAccounts) {
		// Reset accountName for multi-account to be the respective account if we're
		// moving a draft out of Trash.
		// OR,
		// check if we're moving to or from a shared folder, in which case, always send
		// request on-behalf-of the account the item originally belongs to.
        var folderId = params.items[0].getFolderId && params.items[0].getFolderId();

        // on bulk delete, when the second chunk loads try to get folderId from the item id.
        if (!folderId) {
            var itemId = params.items[0] && params.items[0].id;
            folderId = itemId && appCtxt.getById(itemId) && appCtxt.getById(itemId).folderId;
        }
        var fromFolder = folderId && appCtxt.getById(folderId);
		if ((params.items[0].isDraft && params.folder.id == ZmFolder.ID_DRAFTS) ||
			(params.folder.isRemote()) || (fromFolder && fromFolder.isRemote()))
		{
			params1.accountName = params.items[0].getAccount().name;
		}
	}

	if (this._handleDeleteFromSharedFolder(params, params1)) {
		return;
	}

	params1.safeMove = true; //Move only items currently seen by the client
	this._itemAction(params1);
};

/**
 * Marks items as "spam" or "not spam". If they're marked as "not spam", a target folder
 * may be provided.
 * @param {Hash}	params		a hash of parameters
 *        items			[array]			a list of items
 *        markAsSpam	[boolean]		if true, mark as "spam"
 *        folder		[ZmFolder]		destination folder
 *        childWin		[window]*		the child window this action is happening in
 *        closeChildWin	[boolean]*		is the child window closed at the end of the action?
 *        callback		[AjxCallback]*	callback to run after each sub-request
 *        finalCallback	[closure]*		callback to run after all items have been processed
 *        count			[int]*			starting count for number of items processed
 * @private
 */
ZmMailList.prototype.spamItems = 
function(params) {

	var items = params.items = AjxUtil.toArray(params.items);

	if (appCtxt.multiAccounts) {
		var accounts = this._filterItemsByAccount(items);
		this._spamAccountItems(accounts, params);
	} else {
		this._spamItems(params);
	}
};

ZmMailList.prototype._spamAccountItems =
function(accounts, params) {
	var items;
	for (var i in accounts) {
		items = accounts[i];
		break;
	}

	if (items) {
		delete accounts[i];

		params.accountName = appCtxt.accountList.getAccount(i).name;
		params.items = items;
		params.callback = new AjxCallback(this, this._spamAccountItems, [accounts, params]);

		this._spamItems(params);
	}
};

ZmMailList.prototype._spamItems =
function(params) {
	params = Dwt.getParams(arguments, ["items", "markAsSpam", "folder", "childWin"]);

	var params1 = AjxUtil.hashCopy(params);

	params1.action = params.markAsSpam ? "spam" : "!spam";
	params1.attrs = {};
	if (this.type === ZmItem.CONV) {
		var tcon = this._getTcon(params.items);
		//the reason not to set "" as tcon is from bug 58727. (though I think it should have been a server fix).
		if (tcon) {
			params1.attrs.tcon = tcon;
		}
	}
	if (params.folder) {
		params1.attrs.l = params.folder.id;
	}
	params1.actionTextKey = params.markAsSpam ? 'actionMarkAsJunk' : 'actionMarkAsNotJunk';

	params1.callback = new AjxCallback(this, this._handleResponseSpamItems, params);
	this._itemAction(params1);
};

ZmMailList.prototype._handleResponseSpamItems =
function(params, result) {

	var movedItems = result.getResponse();
	var summary;
	if (movedItems && movedItems.length) {
		var folderId = params.markAsSpam ? ZmFolder.ID_SPAM : (params.folder ? params.folder.id : ZmFolder.ID_INBOX);
		this.moveLocal(movedItems, folderId);
		var convs = {};
		for (var i = 0; i < movedItems.length; i++) {
			var item = movedItems[i];
			if (item.cid) {
				var conv = appCtxt.getById(item.cid);
				if (conv) {
					if (!convs[conv.id])
						convs[conv.id] = {conv:conv,msgs:[]};
					convs[conv.id].msgs.push(item);
				}
			}
			var details = {oldFolderId:item.folderId, fields:{}};
			details.fields[ZmItem.F_FRAGMENT] = true;
			item.moveLocal(folderId);
		}

		for (var id in convs) {
			if (convs.hasOwnProperty(id)) {
				var conv = convs[id].conv;
				var msgs = convs[id].msgs;
				conv.updateFragment(msgs);
			}
		}
		//ZmModel.notifyEach(movedItems, ZmEvent.E_MOVE);
		
		var item = movedItems[0];
		var list = item.list;
		if (list) {
			list._evt.batchMode = true;
			list._evt.item = item;	// placeholder
			list._evt.items = movedItems;
			list._notify(ZmEvent.E_MOVE, details);
		}
		if (params.actionText) {
			summary = ZmList.getActionSummary(params);
		}

		if (params.childWin) {
			params.childWin.close();
		}
	}
	params.actionSummary = summary;
	if (params.callback) {
		params.callback.run(result);
	}
};

/**
 * Override so that delete of a conv in Trash doesn't hard-delete its msgs in
 * other folders. If we're in conv mode in Trash, we add a constraint of "t",
 * meaning that the action is only applied to items (msgs) in the Trash.
 *
 * @param {Hash}		params		a hash of parameters
 * @param  {Array}     params.items			list of items to delete
 * @param {Boolean}      params.hardDelete	whether to force physical removal of items
 * @param {Object}      params.attrs			additional attrs for SOAP command
 * @param {window}       params.childWin		the child window this action is happening in
 * @param	{Boolean}	params.confirmDelete		the user confirmed hard delete
 *
 * @private
 */
ZmMailList.prototype.deleteItems =
function(params) {

	params = Dwt.getParams(arguments, ["items", "hardDelete", "attrs", "childWin"]);

	if (this.type == ZmItem.CONV) {
		var searchFolder = this.search ? appCtxt.getById(this.search.folderId) : null;
		if (searchFolder && searchFolder.isHardDelete()) {

			if (!params.confirmDelete) {
				params.confirmDelete = true;
				var callback = ZmMailList.prototype.deleteItems.bind(this, params);
				this._popupDeleteWarningDialog(callback, false, params.items.length);
				return;
			}

			var instantOn = appCtxt.getAppController().getInstantNotify();
			if (instantOn) {
				// bug fix #32005 - disable instant notify for ops that might take awhile
				appCtxt.getAppController().setInstantNotify(false);
				params.errorCallback = new AjxCallback(this, this._handleErrorDeleteItems);
			}

			params.attrs = params.attrs || {};
			params.attrs.tcon = ZmFolder.TCON_CODE[searchFolder.nId];
			params.action = "delete";
            params.actionTextKey = 'actionDelete';
			params.callback = new AjxCallback(this, this._handleResponseDeleteItems, instantOn);
			return this._itemAction(params);
		}
	}
	ZmList.prototype.deleteItems.call(this, params);
};

ZmMailList.prototype._handleResponseDeleteItems =
function(instantOn, result) {
	var deletedItems = result.getResponse();
	if (deletedItems && deletedItems.length) {
		this.deleteLocal(deletedItems);
		for (var i = 0; i < deletedItems.length; i++) {
			deletedItems[i].deleteLocal();
		}
		// note: this happens before we process real notifications
		ZmModel.notifyEach(deletedItems, ZmEvent.E_DELETE);
	}

	if (instantOn) {
		appCtxt.getAppController().setInstantNotify(true);
	}
};

ZmMailList.prototype._handleErrorDeleteItems =
function() {
	appCtxt.getAppController().setInstantNotify(true);
};

/**
 * Only make the request for items whose state will be changed.
 *
 * @param {Hash}		params		a hash of parameters
 *
 *        items			[array]				a list of items to mark read/unread
 *        value			[boolean]			if true, mark items read
 *        callback		[AjxCallback]*		callback to run after each sub-request
 *        finalCallback	[closure]*			callback to run after all items have been processed
 *        count			[int]*				starting count for number of items processed
 *        
 * @private
 */
ZmMailList.prototype.markRead =
function(params) {

	var items = AjxUtil.toArray(params.items);

	var items1;
	if (items[0] && items[0] instanceof ZmItem) {
		items1 = [];
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			if ((item.type == ZmItem.CONV && item.hasFlag(ZmItem.FLAG_UNREAD, params.value)) || (item.isUnread == params.value)) {
				items1.push(item);
			}
		}
	} else {
		items1 = items;
	}

	if (items1.length) {
		params.items = items1;
		params.op = "read";
		if (items1.length > 1) {
        	params.actionTextKey = params.value ? 'actionMarkRead' : 'actionMarkUnread';
		}
		this.flagItems(params);
	}
    else if(params.forceCallback) {
        if (params.callback) {
			params.callback.run(new ZmCsfeResult([]));
		}
		if (params.finalCallback) {
			params.finalCallback(params);
		}
		return;
    }
};

/**
 * Only make the request for items whose state will be changed.
 *
 * @param {Hash}		params		a hash of parameters
 *
 *        items			[array]				a list of items to mark read/unread
 *        value			[boolean]			if true, mark items read
 *        callback		[AjxCallback]*		callback to run after each sub-request
 *        finalCallback	[closure]*			callback to run after all items have been processed
 *        count			[int]*				starting count for number of items processed
 *
 * @private
 */
ZmMailList.prototype.markMute =
function(params) {

	var items = AjxUtil.toArray(params.items);

	var items1;
	if (items[0] && items[0] instanceof ZmItem) {
		items1 = [];
		for (var i = 0; i < items.length; i++) {
			var item = items[i];
			if (params.value != item.isMute) {
				items1.push(item);
			}
		}
	} else {
		items1 = items;
	}

	if (items1.length) {
		params.items = items1;
		params.op = "mute";
        params.actionTextKey = params.value ? 'actionMarkMute' : 'actionMarkUnmute';
		this.flagItems(params);
	}
    else if(params.forceCallback) {
        if (params.callback) {
			params.callback.run(new ZmCsfeResult([]));
		}
		if (params.finalCallback) {
			params.finalCallback(params);
		}
		return;
    }
};

// set "force" flag to true on actual hard deletes, so that msgs
// in a conv list are removed
ZmMailList.prototype.deleteLocal =
function(items) {
	for (var i = 0; i < items.length; i++) {
		this.remove(items[i], true);
	}
};

// When a conv or msg is moved to Trash, it is marked read by the server.
ZmMailList.prototype.moveLocal =
function(items, folderId) {
	ZmList.prototype.moveLocal.call(this, items, folderId);
	if (folderId != ZmFolder.ID_TRASH) { return; }

	var flaggedItems = [];
	for (var i = 0; i < items.length; i++) {
		if (items[i].isUnread) {
			items[i].flagLocal(ZmItem.FLAG_UNREAD, false);
			flaggedItems.push(items[i]);
		}
	}
	ZmModel.notifyEach(flaggedItems, ZmEvent.E_FLAGS, {flags:[ZmItem.FLAG_UNREAD]});
};

ZmMailList.prototype.notifyCreate = 
function(convs, msgs) {

	var createdItems = [];
	var newConvs = [];
	var newMsgs = [];
	var flaggedItems = [];
	var modifiedItems = [];
	var newConvId = {};
	var fields = {};
	var sortBy = this.search ? this.search.sortBy : null;
	var sortIndex = {};
	if (this.type == ZmItem.CONV) {
		// handle new convs first so we can set their fragments later from new msgs
		for (var id in convs) {
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: handling conv create " + id);
			if (this.getById(id)) {
				AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: conv already exists " + id);
				continue;
			}
			newConvId[id] = convs[id];
			var conv = convs[id];
			var convMatches =  this.search && this.search.matches(conv) && !conv.ignoreJunkTrash();
			if (convMatches) {
				if (!appCtxt.multiAccounts ||
					(appCtxt.multiAccounts && (this.search.isMultiAccount() || conv.getAccount() == appCtxt.getActiveAccount()))) 
				{
					// a new msg for this conv matches current search
					conv.list = this;
					newConvs.push(conv);
					AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: conv added " + id);
				}
				else {
					AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: conv failed account checks " + id);
				}
			}
			else {
				// debug info for bug 47589
				var query = this.search ? this.search.query : "";
				var ignore = conv.ignoreJunkTrash();
				AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: conv does not match search '" + query + "' or was ignored (" + ignore + "); match function:");
				if (!conv) {
					AjxDebug.println(AjxDebug.NOTIFY, "conv is null!");
				}
				else {
					var folders = AjxUtil.keys(conv.folders) || "";
					AjxDebug.println(AjxDebug.NOTIFY, "conv folders: " + folders.join(" "));
				}
			}
		}

		// a new msg can hand us a new conv, and update a conv's info
		for (var id in msgs) {
			var msg = msgs[id];
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: CLV handling msg create " + id);
			var cid = msg.cid;
			var msgMatches =  this.search && this.search.matches(msg) && !msg.ignoreJunkTrash();
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: CLV msg matches: " + msgMatches);
			var isActiveAccount = (!appCtxt.multiAccounts || (appCtxt.multiAccounts && msg.getAccount() == appCtxt.getActiveAccount()));
			var conv = newConvId[cid] || this.getById(cid);
			var updateConv = false;
			if (msgMatches && isActiveAccount) {
				if (!conv) {
					// msg will have _convCreateNode if it is 2nd msg and caused promotion of virtual conv;
					// the conv node will have proper count and subject
					var args = {list:this};
					if (msg._convCreateNode) {
						if (msg._convCreateNode._newId) {
							msg._convCreateNode.id = msg._convCreateNode._newId;
						}
						//sometimes the conv is already in the app cache. Make sure not to re-create it and with the wrong msgs. This is slight improvement of bug 87861.
						conv = appCtxt.getById(cid);
						if (!conv) {
							conv = ZmConv.createFromDom(msg._convCreateNode, args);
						}
					}
					else {
						conv = appCtxt.getById(cid) || ZmConv.createFromMsg(msg, args);
					}
					newConvId[cid] = conv;
					conv.folders[msg.folderId] = true;
					newConvs.push(conv);
				}
				conv.list = this;
			}
			// make sure conv's msg list is up to date
			if (conv && !(conv.msgs && conv.msgs.getById(id))) {
				if (!conv.msgs) {
					conv.msgs = new ZmMailList(ZmItem.MSG);
					conv.msgs.addChangeListener(conv._listChangeListener);
				}
				msg.list = conv.msgs;
				if (!msg.isSent && msg.isUnread) {
					conv.isUnread = true;
					flaggedItems.push(conv);
				}
				// if the new msg matches current search, update conv date, fragment, and sort order
				if (msgMatches) {
					msg.inHitList = true;
				}
				if (msgMatches || ((msgMatches === null) && !msg.isSent)) {
					if (conv.fragment != msg.fragment) {
						conv.fragment = msg.fragment;
						fields[ZmItem.F_FRAGMENT] = true;
					}
					if (conv.date != msg.date) {
						conv.date = msg.date;
						// recalculate conv's sort position since we changed its date
						fields[ZmItem.F_DATE] = true;
					}
					if (conv.numMsgs === 1) {
						//there is only one message in this conv so set the size of conv to msg size
						conv.size = msg.size;
					}
					else {
						//So it shows the message count, and not the size (see ZmConvListView.prototype._getCellContents)
						//this size is no longer relevant (was set in the above if previously, see bug 87416)
						conv.size = null;
					}
					if (msg._convCreateNode) {
						//in case of single msg virtual conv promoted to a real conv - update the size
						// (in other cases of size it's updated elsewhere - see ZmConv.prototype.notifyModify, the server sends the update notification for the conv size)
						fields[ZmItem.F_SIZE] = true;
					}
					// conv gained a msg, may need to be moved to top/bottom
					if (!newConvId[conv.id] && this._vector.contains(conv)) {
						fields[ZmItem.F_INDEX] = true;
					}
					modifiedItems.push(conv);
				}
				AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: conv list accepted msg " + id);
				newMsgs.push(msg);
			}
		}
	} else if (this.type == ZmItem.MSG) {
		// add new msg to list
		for (var id in msgs) {
			var msg = msgs[id];
			var msgMatches =  this.search && this.search.matches(msg) && !msg.ignoreJunkTrash();
			AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: handling msg create " + id);
			if (this.getById(id)) {
				if (msgMatches) {
					var query = this.search ? this.search.query : "";
					var ignore = msg.ignoreJunkTrash();
					AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: msg does not match search '" + query + "' or was ignored (" + ignore + ")");
					msg.list = this; // Even though we have the msg in the list, it sometimes has its list wrong.
				}
				continue;
			}
			if (this.convId) { // MLV within CV
				if (msg.cid == this.convId && !this.getById(msg.id)) {
					msg.list = this;
					AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: msg list (CV) accepted msg " + id);
					newMsgs.push(msg);
				}
			} else { // MLV (traditional)
				if (msgMatches) {
					msg.list = this;
					AjxDebug.println(AjxDebug.NOTIFY, "ZmMailList: msg list (TV) accepted msg " + id);
					newMsgs.push(msg);
				}
			}
		}
	}

	// sort item list in reverse so they show up in correct order when processed (oldest appears first)
	if (newConvs.length > 1) {
		ZmMailItem.sortBy = sortBy;
		newConvs.sort(ZmMailItem.sortCompare);
		newConvs.reverse();
	}

	this._sortAndNotify(newConvs, sortBy, ZmEvent.E_CREATE);
	this._sortAndNotify(newMsgs, sortBy, ZmEvent.E_CREATE);
	ZmModel.notifyEach(flaggedItems, ZmEvent.E_FLAGS, {flags:[ZmItem.FLAG_UNREAD]});
	this._sortAndNotify(modifiedItems, sortBy, ZmEvent.E_MODIFY, {fields:fields});
	this._sortAndNotify(newMsgs, sortBy, ZmEvent.E_MODIFY, {fields:fields});
};

/**
* Convenience method for adding messages to a conv on the fly. The specific use case for
* this is when a virtual conv becomes real. We basically add the new message(s) to the
* old (virtual) conv's message list.
*
* @param msgs		hash of messages to add
*/
ZmMailList.prototype.addMsgs =
function(msgs) {
	var addedMsgs = [];
	for (var id in msgs) {
		var msg = msgs[id];
		if (msg.cid == this.convId) {
			this.add(msg, 0);
			msg.list = this;
			addedMsgs.push(msg);
		}
	}
	ZmModel.notifyEach(addedMsgs, ZmEvent.E_CREATE);
};


ZmMailList.prototype.removeAllItems = 
function() {
	this._vector = new AjxVector();
	this._idHash = {};
};


ZmMailList.prototype.remove = 
function(item, force) {
	// Don't really remove an item if this is a list of msgs of a conv b/c a
	// msg is always going to be part of a conv unless it's a hard delete!
	if (!this.convId || force) {
		ZmList.prototype.remove.call(this, item);
	}
};

ZmMailList.prototype.clear =
function() {
	// remove listeners for this list from folder tree and tag list
	if (this._folderChangeListener) {
		var folderTree = appCtxt.getFolderTree();
		if (folderTree) {
			folderTree.removeChangeListener(this._folderChangeListener);
		}
	}
	if (this._tagChangeListener) {
		var tagTree = appCtxt.getTagTree();
		if (tagTree) {
			tagTree.removeChangeListener(this._tagChangeListener);
		}
	}

	ZmList.prototype.clear.call(this);
};

/**
 * Gets the first msg in the list that's not in one of the given folders (if any).
 * 
 * @param {int}	offset	the starting point within list
 * @param {int}	limit		the ending point within list
 * @param {foldersToOmit}	A hash of folders to omit
 * @return	{ZmMailMsg}		the message
 */
ZmMailList.prototype.getFirstHit =
function(offset, limit, foldersToOmit) {

	if (this.type !== ZmItem.MSG) {
		return null;
	}

	var msg = null;	
	offset = offset || 0;
	limit = limit || appCtxt.get(ZmSetting.CONVERSATION_PAGE_SIZE);
	var numMsgs = this.size();

	if (numMsgs > 0 && offset >= 0 && offset < numMsgs) {
		var end = (offset + limit > numMsgs) ? numMsgs : offset + limit;
		var list = this.getArray();
		for (var i = offset; i < end; i++) {
			if (!(foldersToOmit && list[i].folderId && foldersToOmit[list[i].folderId])) {
				msg = list[i];
				break;
			}
		}
		if (!msg) {
			msg = list[0];	// no qualifying messages, use first msg
		}
	}
	
	return msg;
};

/**
 * Returns the insertion point for the given item into this list. If we're not sorting by
 * date, returns 0 (the item will be inserted at the top of the list).
 *
 * @param item		[ZmMailItem]	a mail item
 * @param sortBy	[constant]		sort order
 */
ZmMailList.prototype._getSortIndex =
function(item, sortBy) {
	if (!sortBy || (sortBy != ZmSearch.DATE_DESC && sortBy != ZmSearch.DATE_ASC)) {
		return 0;
	}
	
	var itemDate = parseInt(item.date);
	var a = this.getArray();
	// server always orders conv's msg list as DATE_DESC
	if (this.convId && sortBy == ZmSearch.DATE_ASC) {
		//create a temp array with reverse index and date
		var temp = [];
		for(var j = a.length - 1;j >=0;j--) {
			temp.push({date:a[j].date});
		}
		a = temp;
	}
	for (var i = 0; i < a.length; i++) {
		var date = parseInt(a[i].date);
		if ((sortBy == ZmSearch.DATE_DESC && (itemDate >= date)) ||
			(sortBy == ZmSearch.DATE_ASC && (itemDate <= date))) {
			return i;
		}
	}
	return i;
};

ZmMailList.prototype._sortAndNotify =
function(items, sortBy, event, details) {

	if (!(items && items.length)) { return; }

	var itemType = items[0] && items[0].type;
	if ((this.type == ZmItem.MSG) && (itemType == ZmItem.CONV)) { return; }

	details = details || {};
	var doSort = ((event == ZmEvent.E_CREATE) || (details.fields && details.fields[ZmItem.F_DATE]));
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		if (doSort) {
			var doAdd = (itemType == this.type);
			var listSortIndex = 0, viewSortIndex = 0;
			if (this.type == ZmItem.CONV && itemType == ZmItem.MSG) {
				//Bug 87861 - we still want to add the message to the conv even if the conv is not in this view. So look for it in appCtxt cache too. (case in point - it's in "sent" folder)
				var conv = this.getById(item.cid) || appCtxt.getById(item.cid);
				if (conv) {
					// server always orders msgs within a conv by DATE_DESC, so maintain that
					listSortIndex = conv.msgs._getSortIndex(item, ZmSearch.DATE_DESC);
					viewSortIndex = conv.msgs._getSortIndex(item, appCtxt.get(ZmSetting.CONVERSATION_ORDER));
					if (event == ZmEvent.E_CREATE) {
						conv.addMsg(item, listSortIndex);
					}
				}
			} else {
				viewSortIndex = listSortIndex = this._getSortIndex(item, sortBy);
			}
			if (event != ZmEvent.E_CREATE) {
				// if date changed, re-insert item into correct slot
				if (listSortIndex != this.indexOf(item)) {
					this.remove(item);
				} else {
					doAdd = false;
				}
			}
			if (doAdd) {
				this.add(item, listSortIndex);
			}
			details.sortIndex = viewSortIndex;
		}
		item._notify(event, details);
	}
};

ZmMailList.prototype._isItemInSpecialFolder =
function(item) {
//	if (item.folderId) { //case of one message in conv, even if not loaded yet, we know the folder.
//		return ZmMailList._SPECIAL_FOLDERS_HASH[item.folderId];
//	}
	var msgs = item.msgs;
	if (!msgs) { //might not be loaded yet. In this case, tough luck - the tcon will be set as usual - based on searched folder, if set
		return false;
	}
	for (var i = 0; i < msgs.size(); i++) {
		var msg = msgs.get(i);
		var msgFolder = appCtxt.getById(msg.folderId);
		var msgFolderId = msgFolder && msgFolder.nId;

		if (!ZmMailList._SPECIAL_FOLDERS_HASH[msgFolderId]) {
			return false;
		}
	}
	return true;
};

ZmMailList.prototype._getTcon =
function(items, nFromFolderId) {

	//if all items are in a special folder (draft/trash/spam/sent) - then just allow the move without any restriction
	var allItemsSpecial = true;
	for (var i = 0; i < items.length; i++) {
		if (!this._isItemInSpecialFolder(items[i])) {
			allItemsSpecial = false;
			break;
		}
	}

	if (allItemsSpecial) {
		return "";
	}

	var fromFolderId = nFromFolderId || (this.search && this.search.folderId);
	var	fromFolder = fromFolderId && appCtxt.getById(fromFolderId);

	fromFolderId = fromFolder && fromFolder.nId;
	var tcon = [];
	for (i = 0; i < ZmMailList._SPECIAL_FOLDERS.length; i++) {
		var specialFolderId = ZmMailList._SPECIAL_FOLDERS[i];
		if (!fromFolder) {
			tcon.push(ZmFolder.TCON_CODE[specialFolderId]);
			continue;
		}
		// == instead of === since we compare numbers to strings and want conversion.
		if (fromFolderId == specialFolderId) {
			continue; //we're moving out of the special folder - allow  items under it
		}
        var specialFolder;
        // get folder object from qualified Ids for multi-account
        if (appCtxt.multiAccounts) {
            var acct  = items && items[0].getAccount && items[0].getAccount();
            var acctId = acct ? acct.id : appCtxt.getActiveAccount().id;
			var fId = [acctId, ":", specialFolderId].join("");
			specialFolder = appCtxt.getById(fId);
        }
		else {
            specialFolder = appCtxt.getById(specialFolderId);
        }

		if (!fromFolder.isChildOf(specialFolder)) {
			//if origin folder (searched folder) not descendant of the special folder - add the tcon code - don't move items from under the special folder.
			tcon.push(ZmFolder.TCON_CODE[specialFolderId]);
		}
	}
	return (tcon.length) ?  ("-" + tcon.join("")) : "";
};

// If this list is the result of a search that is constrained by the read
// status, and the user has marked all read in a folder, redo the search.
ZmMailList.prototype._folderTreeChangeListener = 
function(ev) {
	if (this.size() == 0) { return; }

	var flag = ev.getDetail("flag");
	var view = appCtxt.getCurrentViewId();
	var ctlr = appCtxt.getCurrentController();

	if (ev.event == ZmEvent.E_FLAGS && (flag == ZmItem.FLAG_UNREAD)) {
		if (this.type == ZmItem.CONV) {
			if ((view == ZmId.VIEW_CONVLIST) && ctlr._currentSearch.hasUnreadTerm()) {
				this._redoSearch(ctlr);
			}
		} else if (this.type == ZmItem.MSG) {
			if (view == ZmId.VIEW_TRAD && ctlr._currentSearch.hasUnreadTerm()) {
				this._redoSearch(ctlr);
			} else {
				var on = ev.getDetail("state");
				var organizer = ev.getDetail("item");
				var flaggedItems = [];
				var list = this.getArray();
				for (var i = 0; i < list.length; i++) {
					var msg = list[i];
					if ((organizer.type == ZmOrganizer.FOLDER && msg.folderId == organizer.id) ||
						(organizer.type == ZmOrganizer.TAG && msg.hasTag(organizer.id))) {
						msg.isUnread = on;
						flaggedItems.push(msg);
					}
				}
				ZmModel.notifyEach(flaggedItems, ZmEvent.E_FLAGS, {flags:[flag]});
			}
		}
	} else {
		ZmList.prototype._folderTreeChangeListener.call(this, ev);
	}
};

ZmMailList.prototype._tagTreeChangeListener = 
function(ev) {
	if (this.size() == 0) return;

	var flag = ev.getDetail("flag");
	if (ev.event == ZmEvent.E_FLAGS && (flag == ZmItem.FLAG_UNREAD)) {
		this._folderTreeChangeListener(ev);
	} else {
		ZmList.prototype._tagTreeChangeListener.call(this, ev);
	}
};
}
if (AjxPackage.define("zimbraMail.mail.view.ZmRecipients")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @class
 * This class provides a central area for managing email recipient fields. It is not a control,
 * and does not exist within the widget hierarchy.
 * 
 * @param {hash}		params						a hash of params:
 * @param {function}	resetContainerSizeMethod	callback for when size needs to be adjusted
 * @param {function}	enableContainerInputs		callback for enabling/disabling input fields
 * @param {function}	reenter						callback to enable design mode
 * @param {AjxListener}	contactPopdownListener		listener called when contact picker pops down
 * @param {string}		contextId					ID of owner (used for autocomplete list)
 */
ZmRecipients = function(params) {

	this._divId			    = {};
	this._buttonTdId	    = {};
	this._fieldId		    = {};
	this._using			    = {};
	this._button		    = {};
	this._field			    = {};
	this._divEl			    = {};
	this._addrInputField    = {};

    this._resetContainerSize = params.resetContainerSizeMethod;
    this._enableContainerInputs = params.enableContainerInputs;
    this._reenter = params.reenter;
    this._contactPopdownListener = params.contactPopdownListener;
	this._contextId = params.contextId;

    this._bubbleOps = {};
    this._bubbleOps[AjxEmailAddress.TO]  = ZmOperation.MOVE_TO_TO;
    this._bubbleOps[AjxEmailAddress.CC]  = ZmOperation.MOVE_TO_CC;
    this._bubbleOps[AjxEmailAddress.BCC] = ZmOperation.MOVE_TO_BCC;
    this._opToField = {};
    this._opToField[ZmOperation.MOVE_TO_TO]  = AjxEmailAddress.TO;
    this._opToField[ZmOperation.MOVE_TO_CC] = AjxEmailAddress.CC;
    this._opToField[ZmOperation.MOVE_TO_BCC] = AjxEmailAddress.BCC;
};

ZmRecipients.OP = {};
ZmRecipients.OP[AjxEmailAddress.TO]		= ZmId.CMP_TO;
ZmRecipients.OP[AjxEmailAddress.CC]		= ZmId.CMP_CC;
ZmRecipients.OP[AjxEmailAddress.BCC]	= ZmId.CMP_BCC;

ZmRecipients.BAD = "_bad_addrs_";


ZmRecipients.prototype.attachFromSelect =
function(fromSelect) {
    this._fromSelect = fromSelect;
}

ZmRecipients.prototype.createRecipientIds =
function(htmlElId, typeStr) {
    var ids = {};
    var components = ["row", "picker", "control", "cell"];
    for (var i = 0; i < components.length; i++) {
        ids[components[i]] = [htmlElId, typeStr, components[i]].join("_")
    }
    return ids;
}


ZmRecipients.prototype.createRecipientHtml =
function(parent, viewId, htmlElId, fieldNames) {

    this._fieldNames = fieldNames;
	var contactsEnabled = appCtxt.get(ZmSetting.CONTACTS_ENABLED);
	var galEnabled = appCtxt.get(ZmSetting.GAL_ENABLED);

    	// init autocomplete list
    if (contactsEnabled || galEnabled || appCtxt.isOffline) {
		var params = {
			dataClass:		appCtxt.getAutocompleter(),
			matchValue:		ZmAutocomplete.AC_VALUE_FULL,
			keyUpCallback:	this._acKeyupHandler.bind(this),
			contextId:		this._contextId
		};
		this._acAddrSelectList = new ZmAutocompleteListView(params);
	}

	var isPickerEnabled = contactsEnabled || galEnabled || appCtxt.multiAccounts;	
	
	this._pickerButton = {};

	// process compose fields
	for (var i = 0; i < fieldNames.length; i++) {
		var type = fieldNames[i];
		var typeStr = AjxEmailAddress.TYPE_STRING[type];

		// save identifiers
        var ids = this.createRecipientIds(htmlElId, typeStr);
		this._divId[type] = ids.row;
		this._buttonTdId[type] = ids.picker;
		var inputId = this._fieldId[type] = ids.control;
		var label = AjxMessageFormat.format(ZmMsg.addressFieldLabel, ZmMsg[AjxEmailAddress.TYPE_STRING[this._fieldNames[i]]]);

		// save field elements
		this._divEl[type] = document.getElementById(this._divId[type]);
		var aifId;
		var aifParams = {
			parent:								parent,
			autocompleteListView:				this._acAddrSelectList,
			bubbleAddedCallback:				this._bubblesChangedCallback.bind(this),
			bubbleRemovedCallback:				this._bubblesChangedCallback.bind(this),
			bubbleMenuCreatedCallback:			this._bubbleMenuCreated.bind(this),
			bubbleMenuResetOperationsCallback:	this._bubbleMenuResetOperations.bind(this),
			inputId:							inputId,
			label: 								label,
			type:								type
		}
		var aif = this._addrInputField[type] = new ZmAddressInputField(aifParams);
		aifId = aif._htmlElId;
		aif.reparentHtmlElement(ids.cell);

		// save field control
		var fieldEl = this._field[type] = document.getElementById(this._fieldId[type]);
		if (fieldEl) {
			fieldEl.addrType = type;
			fieldEl.supportsAutoComplete = true;
		}

		// create picker
		if (isPickerEnabled) {

			// bug 78318 - if GAL enabled but not contacts, we need some things defined to handle GAL search
			if (!contactsEnabled) {
				appCtxt.getAppController()._createApp(ZmApp.CONTACTS);
			}

			var pickerId = this._buttonTdId[type];
			var pickerEl = document.getElementById(pickerId);
			if (pickerEl) {
				var buttonId = ZmId.getButtonId(viewId, ZmRecipients.OP[type]);
				var button = this._pickerButton[type] = new DwtButton({parent:parent, id:buttonId});
				button.setText(pickerEl.innerHTML);
				button.replaceElement(pickerEl);

				button.addSelectionListener(this.addressButtonListener.bind(this));
				button.addrType = type;

				// autocomplete-related handlers
				// Enable this even if contacts are not enabled, to provide GAL autoComplete
				this._acAddrSelectList.handle(fieldEl, aifId);

				this._button[type] = button;
			}
		} else {
			// Mark the field, so that it will be sized properly in ZmAddressInputField._resizeInput.
			// Otherwise, it is set to 30px wide, which makes it rather hard to type into.
			fieldEl.supportsAutoComplete = false;
		}
	}
};

ZmRecipients.prototype.reset =
function() {

	// reset To/CC/BCC fields
	for (var i = 0; i < this._fieldNames.length; i++) {
		var type = this._fieldNames[i];
		var textarea = this._field[type];
		textarea.value = "";
		var addrInput = this._addrInputField[type];
		if (addrInput) {
			addrInput.clear();
		}
	}
};

ZmRecipients.prototype.resetPickerButtons =
function(account) {
	var ac = window.parentAppCtxt || window.appCtxt;
	var isEnabled = ac.get(ZmSetting.CONTACTS_ENABLED, null, account) ||
					ac.get(ZmSetting.GAL_ENABLED, null, account);

	for (var i in this._pickerButton) {
		var button = this._pickerButton[i];
		button.setEnabled(isEnabled);
	}
};

ZmRecipients.prototype.setup =
function() {
    // reset To/Cc/Bcc fields
    if (this._field[AjxEmailAddress.TO]) {
        this._showAddressField(AjxEmailAddress.TO, true, true, true);
    }
    if (this._field[AjxEmailAddress.CC]) {
        this._showAddressField(AjxEmailAddress.CC, true, true, true);
    }
    if (this._field[AjxEmailAddress.BCC]) {
        this._showAddressField(AjxEmailAddress.BCC, false, true, true);
    }
};

ZmRecipients.prototype.getPicker =
function(type) {
    return this._pickerButton[type];
};

ZmRecipients.prototype.getField =
function(type) {
    return document.getElementById(this._fieldId[type]);
};

ZmRecipients.prototype.getUsing =
function(type) {
    return this._using[type];
};

ZmRecipients.prototype.getACAddrSelectList =
function() {
    return this._acAddrSelectList;
};

ZmRecipients.prototype.getTabGroupMember = function() {
	var tg = new DwtTabGroup('ZmRecipients');

	for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
		var type = ZmMailMsg.COMPOSE_ADDRS[i];
		tg.addMember(this.getPicker(type));
		tg.addMember(this.getAddrInputField(type).getTabGroupMember());
	}

	return tg;
};

ZmRecipients.prototype.getAddrInputField =
function(type) {
    return this._addrInputField[type];
};

// Adds the given addresses to the form. We need to add each address separately in case it's a DL.
ZmRecipients.prototype.addAddresses =
function(type, addrVec, used) {

	var addrAdded = false;
	used = used || {};
	var addrList = [];
	var addrs = AjxUtil.toArray(addrVec);
	if (addrs && addrs.length) {
		for (var i = 0, len = addrs.length; i < len; i++) {
			var addr = addrs[i];
			var email = addr.isAjxEmailAddress ? addr && addr.getAddress() : addr;
			if (!email) { continue; }
			email = email.toLowerCase();
			if (!used[email]) {
				this.setAddress(type, addr);	// add the bubble now
				used[email] = true;
				addrAdded = true;
			}
		}
	}
	return addrAdded;
};


/**
 * Sets an address field.
 *
 * @param type	the address type
 * @param addr	the address string
 *
 * XXX: if addr empty, check if should hide field
 *
 * @private
 */
ZmRecipients.prototype.setAddress =
function(type, addr) {

	addr = addr || "";

	var addrStr = addr.isAjxEmailAddress ? addr.toString() : addr;

	//show first, so focus works on IE.
	if (addrStr.length && !this._using[type]) {
		this._using[type] = true;
		this._showAddressField(type, true);
	}

	var addrInput = this._addrInputField[type];
	if (!addrStr) {
		addrInput.clear();
	}
	else {
		if (addr.isAjxEmailAddress) {
			var match = {isDL: addr.isGroup && addr.canExpand, email: addrStr};
			addrInput.addBubble({address:addrStr, match:match, skipNotify:true, noFocus:true});
		}
		else {
			this._setAddrFieldValue(type, addrStr);
		}
	}
};


/**
 * Gets the field values for each of the addr fields.
 *
 * @return	{Array}	an array of addresses
 */
ZmRecipients.prototype.getRawAddrFields =
function() {
	var addrs = {};
	for (var i = 0; i < this._fieldNames.length; i++) {
		var type = this._fieldNames[i];
		if (this._using[type]) {
			addrs[type] = this.getAddrFieldValue(type);
		}
	}
	return addrs;
};

// returns address fields that are currently visible
ZmRecipients.prototype.getAddrFields =
function() {
	var addrs = [];
	for (var i = 0; i < this._fieldNames.length; i++) {
		var type = this._fieldNames[i];
		if (this._using[type]) {
			addrs.push(this._field[type]);
		}
	}
	return addrs;
};


// Grab the addresses out of the form. Optionally, they can be returned broken
// out into good and bad addresses, with an aggregate list of the bad ones also
// returned. If the field is hidden, its contents are ignored.
ZmRecipients.prototype.collectAddrs =
function() {

	var addrs = {};
	addrs[ZmRecipients.BAD] = new AjxVector();
	for (var i = 0; i < this._fieldNames.length; i++) {
		var type = this._fieldNames[i];

		if (!this._field[type]) { //this check is in case we don't have all fields set up (might be configurable. Didn't look deeply).
			continue;
		}

		var val = this.getAddrFieldValue(type);
		if (val.length == 0) { continue; }
		val = val.replace(/[; ,]+$/, "");	// ignore trailing (and possibly extra) separators
		var result = AjxEmailAddress.parseEmailString(val, type, false);
		if (result.all.size() == 0) { continue; }
		addrs.gotAddress = true;
		addrs[type] = result;
		if (result.bad.size()) {
			addrs[ZmRecipients.BAD].addList(result.bad);
			if (!addrs.badType) {
				addrs.badType = type;
			}
		}
	}
	return addrs;
};


ZmRecipients.prototype.getAddrFieldValue =
function(type) {
	var addrInput = this._addrInputField[type];
	return addrInput ? addrInput.getValue() : '';
};

ZmRecipients.prototype.enableInputs =
function(bEnable) {
	// disable input elements so they dont bleed into top zindex'd view
	for (var i = 0; i < this._fieldNames.length; i++) {
		this._field[this._fieldNames[i]].disabled = !bEnable;
	}
};

// Address buttons invoke contact picker
ZmRecipients.prototype.addressButtonListener =
function(ev, addrType) {
	if (appCtxt.isWebClientOffline()) return;

	var obj = ev ? DwtControl.getTargetControl(ev) : null;
	if (this._enableContainerInputs) {
		this._enableContainerInputs(false);
	}

	if (!this._contactPicker) {
		AjxDispatcher.require("ContactsCore");
		var buttonInfo = [];
        for (var i = 0; i < this._fieldNames.length; i++) {
            buttonInfo[i] = { id: this._fieldNames[i],
                              label : ZmMsg[AjxEmailAddress.TYPE_STRING[this._fieldNames[i]]]};
        }
		this._contactPicker = new ZmContactPicker(buttonInfo);
		this._contactPicker.registerCallback(DwtDialog.OK_BUTTON, this._contactPickerOkCallback, this);
		this._contactPicker.registerCallback(DwtDialog.CANCEL_BUTTON, this._contactPickerCancelCallback, this);
	}

	var curType = obj ? obj.addrType : addrType;
	var addrList = {};
	for (var i = 0; i < this._fieldNames.length; i++) {
		var type = this._fieldNames[i];
		addrList[type] = this._addrInputField[type].getAddresses(true);
	}
	if (this._contactPopdownListener) {
		this._contactPicker.addPopdownListener(this._contactPopdownListener);
	}
	var str = (this._field[curType].value && !(addrList[curType] && addrList[curType].length))
		? this._field[curType].value : "";

	var account;
	if (appCtxt.multiAccounts && this._fromSelect) {
		var addr = this._fromSelect.getSelectedOption().addr;
		account = appCtxt.accountList.getAccountByEmail(addr.address);
	}
	this._contactPicker.popup(curType, addrList, str, account);
};




// Private methods

// Show address field
ZmRecipients.prototype._showAddressField =
function(type, show, skipNotify, skipFocus) {
	this._using[type] = show;
	Dwt.setVisible(this._divEl[type], show);
	this._setAddrFieldValue(type, "");	 // bug fix #750 and #3680
	this._field[type].noTab = !show;
	this._addrInputField[type].noTab = !show;
	if (this._pickerButton[type]) {
		this._pickerButton[type].noTab = !show;
	}
	if (this._resetContainerSize) {
		this._resetContainerSize();
	}
};

ZmRecipients.prototype._acKeyupHandler =
function(ev, acListView, result, element) {
	var key = DwtKeyEvent.getCharCode(ev);
	// process any printable character or enter/backspace/delete keys
	if (result && element && (ev.inputLengthChanged ||
		(DwtKeyEvent.IS_RETURN[key] || key === DwtKeyEvent.KEY_BACKSPACE || key === DwtKeyEvent.KEY_DELETE ||
		(AjxEnv.isMac && key === DwtKeyEvent.KEY_COMMAND)))) // bug fix #24670
	{
		element.value = element.value && element.value.replace(/;([^\s])/g, function(all, group){return "; "+group}) || ""; // Change ";" to "; " if it is not succeeded by a whitespace
	}
};

/**
 * a callback that's called when bubbles are added or removed, since we need to resize the msg body in those cases.
 */
ZmRecipients.prototype._bubblesChangedCallback =
function() {
	if (this._resetContainerSize) {
		this._resetContainerSize(); // body size might change due to change in size of address field (due to new bubbles).
	}
};

ZmRecipients.prototype._bubbleMenuCreated =
function(addrInput, menu) {

	this._bubbleActionMenu = menu;
    if (this._fieldNames.length > 1) {
        menu.addOp(ZmOperation.SEP);
        var listener = new AjxListener(this, this._bubbleMove);

        for (var i = 0; i < this._fieldNames.length; i++) {
            var type = this._fieldNames[i];
            var op = this._bubbleOps[type];
            menu.addOp(op);
            menu.addSelectionListener(op, listener);
        }
    }
};

ZmRecipients.prototype._bubbleMenuResetOperations =
function(addrInput, menu) {
	var sel = addrInput.getSelection();
    for (var i = 0; i < this._fieldNames.length; i++) {
        var type = this._fieldNames[i];
		var op = this._bubbleOps[type];
		menu.enable(op, sel.length > 0 && (type != addrInput.type));
	}
};

ZmRecipients.prototype._bubbleMove =
function(ev) {

	var sourceInput = ZmAddressInputField.menuContext.addrInput;
	var op = ev && ev.item && ev.item.getData(ZmOperation.KEY_ID);
	var type = this._opToField[op];
	var targetInput = this._addrInputField[type];
	if (sourceInput && targetInput) {
		var sel = sourceInput.getSelection();
		if (sel.length) {
			for (var i = 0; i < sel.length; i++) {
				var bubble = sel[i];
				this._showAddressField(type, true);
				targetInput.addBubble({bubble:bubble});
				sourceInput.removeBubble(bubble.id);
			}
		}
	}
};

ZmRecipients.prototype._setAddrFieldValue =
function(type, value) {

	var addrInput = this._addrInputField[type];
	if (addrInput) {
		addrInput.setValue(value, true);
	}
};

// Generic routine for attaching an event handler to a field. Since "this" for the handlers is
// the incoming event, we need a way to get at ZmComposeView, so it's added to the event target.
ZmRecipients.prototype._setEventHandler =
function(id, event, addrType) {
	var field = document.getElementById(id);
	field._recipients = this;
	if (addrType) {
		field._addrType = addrType;
	}
	var lcEvent = event.toLowerCase();
	field[lcEvent] = ZmRecipients["_" + event];
};

// set focus within tab group to element so tabbing works
ZmRecipients._onFocus =
function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	var element = DwtUiEvent.getTargetWithProp(ev, "id");
	if (!element) { return true; }

	var kbMgr = appCtxt.getKeyboardMgr();
	if (kbMgr.__currTabGroup) {
		kbMgr.__currTabGroup.setFocusMember(element);
	}
};

// Transfers addresses from the contact picker to the compose view.
ZmRecipients.prototype._contactPickerOkCallback =
function(addrs) {

	if (this._enableContainerInputs) {
		this._enableContainerInputs(true);
	}
	for (var i = 0; i < this._fieldNames.length; i++) {
		var type = this._fieldNames[i];
		this.setAddress(type, "");
        // If there was only one button, the picker will just return the list of selections,
        // not a list per button type
        var typeAddrs = (this._fieldNames.length == 1) ? addrs :  addrs[type];
		var addrVec = ZmRecipients.expandAddrs(typeAddrs);
		this.addAddresses(type, addrVec);
	}

	// Still need this here since REMOVING stuff with the picker does not call removeBubble in the ZmAddressInputField.
	// Also - it's better to do it once than for every bubble in this case. user might add many addresses with the picker
	this._bubblesChangedCallback();

	if (this._contactPopdownListener) {
		this._contactPicker.removePopdownListener(this._contactPopdownListener);
	}
	this._contactPicker.popdown();
	if (this._reenter) {
		this._reenter();
	}
};

// Expands any addresses that are groups
ZmRecipients.expandAddrs =
function(addrs) {
	var addrsNew = [];
	var addrsArray = (addrs instanceof AjxVector) ? addrs.getArray() : addrs;
	if (addrsArray && addrsArray.length) {
		for (var i = 0; i < addrsArray.length; i++) {
			var addr = addrsArray[i];
			if (addr) {
				if (addr.isGroup && !(addr.__contact && addr.__contact.isDL)) {
					var members = addr.__contact ? addr.__contact.getGroupMembers().good.getArray() :
												   AjxEmailAddress.split(addr.address);
					addrsNew = addrsNew.concat(members);
				}
				else {
					addrsNew.push(addr);
				}
			}
		}
	}
	return AjxVector.fromArray(addrsNew);
};

ZmRecipients.prototype._contactPickerCancelCallback =
function() {
	if (this._enableContainerInputs) {
		this._enableContainerInputs(true);
	}
	if (this._reenter) {
		this._reenter();
	}
};

ZmRecipients.prototype._toggleBccField =
function(show) {
	var visible = AjxUtil.isBoolean(show) ? show : !Dwt.getVisible(this._divEl[AjxEmailAddress.BCC]);
	this._showAddressField(AjxEmailAddress.BCC, visible);
};
}
if (AjxPackage.define("zimbraMail.mail.view.ZmComposeView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a new compose view. The view does not display itself on construction.
 * @constructor
 * @class
 * This class provides a form for composing a message.
 *
 * @author Conrad Damon
 * 
 * @param {DwtControl}		parent			the element that created this view
 * @param {ZmController}	controller		the controller managing this view
 * @param {constant}		composeMode 	passed in so detached window knows which mode to be in on startup
 * 
 * @extends		DwtComposite
 * 
 * @private
 */
ZmComposeView = function(parent, controller, composeMode, action) {

	if (arguments.length === 0) { return; }
		
	this.TEMPLATE = "mail.Message#Compose";
	this._view = controller.getCurrentViewId();
	this._sessionId = controller.getSessionId();

	DwtComposite.call(this, {parent:parent, className:"ZmComposeView", posStyle:Dwt.ABSOLUTE_STYLE, id:ZmId.getViewId(this._view)});

	ZmComposeView.NOTIFY_ACTION_MAP = {};
	ZmComposeView.NOTIFY_ACTION_MAP[ZmOperation.REPLY_ACCEPT]		= ZmOperation.REPLY_ACCEPT_NOTIFY;
	ZmComposeView.NOTIFY_ACTION_MAP[ZmOperation.REPLY_DECLINE]		= ZmOperation.REPLY_DECLINE_NOTIFY;
	ZmComposeView.NOTIFY_ACTION_MAP[ZmOperation.REPLY_TENTATIVE]	= ZmOperation.REPLY_TENTATIVE_NOTIFY;

	ZmComposeView.MOVE_TO_FIELD = {};
	ZmComposeView.MOVE_TO_FIELD[ZmOperation.MOVE_TO_TO]		= AjxEmailAddress.TO;
	ZmComposeView.MOVE_TO_FIELD[ZmOperation.MOVE_TO_CC]		= AjxEmailAddress.CC;
	ZmComposeView.MOVE_TO_FIELD[ZmOperation.MOVE_TO_BCC]	= AjxEmailAddress.BCC;
		
	this._onMsgDataChange = this._onMsgDataChange.bind(this);

	this._controller = controller;

	var recipParams = {};
	recipParams.resetContainerSizeMethod	= this._resetBodySize.bind(this);
	recipParams.enableContainerInputs		= this.enableInputs.bind(this);
	recipParams.reenter						= this.reEnableDesignMode.bind(this);
	recipParams.contactPopdownListener		= this._controller._dialogPopdownListener;
	recipParams.contextId					= this._controller.getCurrentViewId();

	this._recipients = new ZmRecipients(recipParams);
	this._attcTabGroup = new DwtTabGroup('ZmComposeViewAttachments');

	this._firstTimeFixImages = true;

	this._initialize(composeMode, action);

	// make sure no unnecessary scrollbars show up
	this.setScrollStyle(Dwt.CLIP);
};

ZmComposeView.prototype = new DwtComposite;
ZmComposeView.prototype.constructor = ZmComposeView;

ZmComposeView.prototype.isZmComposeView = true;
ZmComposeView.prototype.toString = function() {	return "ZmComposeView"; };

//
// Constants
//

// Consts related to compose fields
ZmComposeView.QUOTED_HDRS = [
		ZmMailMsg.HDR_FROM,
		ZmMailMsg.HDR_TO,
		ZmMailMsg.HDR_CC,
		ZmMailMsg.HDR_DATE,
		ZmMailMsg.HDR_SUBJECT
];

ZmComposeView.BAD						= "_bad_addrs_";

// Message dialog placement
ZmComposeView.DIALOG_X 					= 50;
ZmComposeView.DIALOG_Y 					= 100;

// Attachment related
ZmComposeView.UPLOAD_FIELD_NAME			= "attUpload";
ZmComposeView.FORWARD_ATT_NAME			= "ZmComposeView_forAttName";
ZmComposeView.FORWARD_MSG_NAME			= "ZmComposeView_forMsgName";
ZmComposeView.ADD_ORIG_MSG_ATTS			= "add_original_attachments";
ZmComposeView.MAX_ATTM_NAME_LEN	        = 30;

// max # of attachments to show
ZmComposeView.SHOW_MAX_ATTACHMENTS		= AjxEnv.is800x600orLower ? 2 : 3;
ZmComposeView.MAX_ATTACHMENT_HEIGHT 	= (ZmComposeView.SHOW_MAX_ATTACHMENTS * 23) + "px";

// Reply/forward stuff
ZmComposeView.EMPTY_FORM_RE				= /^[\s\|]*$/;
ZmComposeView.HTML_TAG_RE				= /(<[^>]+>)/g;
ZmComposeView.QUOTED_CONTENT_RE			= new RegExp("^----- ", "m");
ZmComposeView.HTML_QUOTED_CONTENT_RE	= new RegExp("<br>----- ", "i");

// Address components
ZmComposeView.OP = {};
ZmComposeView.OP[AjxEmailAddress.TO]	= ZmId.CMP_TO;
ZmComposeView.OP[AjxEmailAddress.CC]	= ZmId.CMP_CC;
ZmComposeView.OP[AjxEmailAddress.BCC]	= ZmId.CMP_BCC;

// Upload sources
ZmComposeView.UPLOAD_COMPUTER           = 'computer';
ZmComposeView.UPLOAD_INLINE             = 'inline';
ZmComposeView.UPLOAD_BRIEFCASE          = 'briefcase';

// Quoted content - distinguish "" from a lack of quoted content
ZmComposeView.EMPTY                     = '__empty__';

// Public methods

/**
 * Sets the current view, based on the given action. The compose form is
 * created and laid out and everything is set up for interaction with the user.
 *
 * @param {Hash}		params			a hash of parameters:
 * @param {constant}	action				new message, reply, forward, or an invite action
 * @param {ZmMailMsg}	msg					the original message (reply/forward), or address (new message)
 * @param {ZmIdentity}	identity			identity of sender
 * @param {String}		toOverride			To: addresses (optional)
 * @param {String}		ccOverride			Cc: addresses (optional)
 * @param {String}		subjectOverride		subject for new msg (optional)
 * @param {String}		extraBodyText		text to prepend to body
 * @param {Array}		msgIds				list of msg Id's to be added as attachments
 * @param {String}		accountName			on-behalf-of From address
 */
ZmComposeView.prototype.set =
function(params) {

	var action = this._action = params.action;
	this._origAction = this._action;
	if (this._msg) {
		this._msg.onChange = null;
	}

	this._isIncludingOriginalAttachments = false;
	this._originalAttachmentsInitialized = false;

	this.isEditAsNew = params.isEditAsNew;

	this._acceptFolderId = params.acceptFolderId;
	var msg = this._msg = this._origMsg = params.msg;
	var oboMsg = msg || (params.selectedMessages && params.selectedMessages.length && params.selectedMessages[0]);
	var obo = this._getObo(params.accountName, oboMsg);
	if (msg) {
		msg.onChange = this._onMsgDataChange;
	}

	// list of msg Id's to add as attachments
	this._msgIds = params.msgIds;

	this.reset(true);

	this._setFromSelect(msg);

	if (obo) {
		this.identitySelect.setSelectedValue(obo);
		this._controller.resetIdentity(obo);
	}

	if (params.identity) {
		if (this.identitySelect) {
			this.identitySelect.setSelectedValue(params.identity.id);
			this._controller.resetIdentity(params.identity.id);
		}
		if (appCtxt.get(ZmSetting.SIGNATURES_ENABLED) || appCtxt.multiAccounts) {
			var selected = this._getSignatureIdForAction(params.identity) || "";
			var account = appCtxt.multiAccounts && this.getFromAccount();
			this._controller.resetSignatureToolbar(selected, account);
		}
	}

	this._recipients.setup();

	if (!ZmComposeController.IS_FORWARD[action]) {
		// populate fields based on the action and user prefs
		this._setAddresses(action, AjxEmailAddress.TO, params.toOverride);
		if (params.ccOverride) {
			this._setAddresses(action, AjxEmailAddress.CC, params.ccOverride);
		}
		if (params.bccOverride) {
			this._setAddresses(action, AjxEmailAddress.BCC, params.bccOverride);
		}
	}

	this._setSubject(action, msg || (params.selectedMessages && params.selectedMessages[0]), params.subjOverride);
	this._setBody(action, msg, params.extraBodyText, false, false, params.extraBodyTextIsExternal, params.incOptions);
	if (params.extraBodyText) {
		this._isDirty = true;
	}

    //Force focus on body only for reply and replyAll
    if (ZmComposeController.IS_REPLY[action]) {
        this._moveCaretOnTimer(params.extraBodyText ? params.extraBodyText.length : 0);
    }

	if (action !== ZmOperation.FORWARD_ATT) {
		this._saveExtraMimeParts();
	}

	// save form state (to check for change later)
	if (this._composeMode === Dwt.HTML) {
		var ta = new AjxTimedAction(this, this._setFormValue);
		AjxTimedAction.scheduleAction(ta, 10);
	} else {
		this._setFormValue();
	}
	// Force focus on the TO field
	if (!ZmComposeController.IS_REPLY[action]) {
		appCtxt.getKeyboardMgr().grabFocus(this._recipients.getAddrInputField(AjxEmailAddress.TO));
	}
};

ZmComposeView.prototype._getObo =
function(obo, msg) {
	if (msg) {
		var folder = !obo ? appCtxt.getById(msg.folderId) : null;
		obo = (folder && folder.isRemote()) ? folder.getOwner() : null;

		// check if this is a draft that was originally composed obo
		var isFromDataSource = msg.identity && msg.identity.isFromDataSource;
		if (!obo && msg.isDraft && !appCtxt.multiAccounts && !isFromDataSource && !appCtxt.get(ZmSetting.ALLOW_ANY_FROM_ADDRESS)) {
			var ac = window.parentAppCtxt || window.appCtxt;
			var from = msg.getAddresses(AjxEmailAddress.FROM).get(0);
			if (from && (from.address.toLowerCase() !== ac.accountList.mainAccount.getEmail().toLowerCase()) && !appCtxt.isMyAddress(from.address.toLowerCase())) {
				obo = from.address;
			}
		}
	}
	return obo;
};

ZmComposeView.prototype._saveExtraMimeParts =
function() {
		
	var bodyParts = this._msg ? this._msg.getBodyParts() : [];
	for (var i = 0; i < bodyParts.length; i++) {
		var bodyPart = bodyParts[i];
		var contentType = bodyPart.contentType;

		if (contentType === ZmMimeTable.TEXT_PLAIN) { continue; }
		if (contentType === ZmMimeTable.TEXT_HTML) { continue; }
		if (ZmMimeTable.isRenderableImage(contentType) && bodyPart.contentDisposition === "inline") { continue; } // bug: 28741

		var mimePart = new ZmMimePart();
		mimePart.setContentType(contentType);
		mimePart.setContent(bodyPart.getContent());
		this.addMimePart(mimePart);
	}
};

/**
 * Called automatically by the attached ZmMailMsg object when data is
 * changed, in order to support Zimlets modify subject or other values
 * (bug: 10540)
 * 
 * @private
 */
ZmComposeView.prototype._onMsgDataChange =
function(what, val) {
	if (what === "subject") {
		this._subjectField.value = val;
		this.updateTabTitle();
	}
};

ZmComposeView.prototype.getComposeMode =
function() {
	return this._composeMode;
};

ZmComposeView.prototype.getController =
function() {
	return this._controller;
};

ZmComposeView.prototype.getHtmlEditor =
function() {
	return this._htmlEditor;
};

/**
 * Gets the title.
 * 
 * @return	{String}	the title
 */
ZmComposeView.prototype.getTitle =
function() {
	var text;
	if (ZmComposeController.IS_REPLY[this._action]) {
		text = ZmMsg.reply;
	} else if (ZmComposeController.IS_FORWARD[this._action]) {
		text = ZmMsg.forward;
	} else {
		text = ZmMsg.compose;
	}
	return [ZmMsg.zimbraTitle, text].join(": ");
};

/**
 * Gets the field values for each of the addr fields.
 * 
 * @return	{Array}	an array of addresses
 */
ZmComposeView.prototype.getRawAddrFields =
function() {
	return this._recipients.getRawAddrFields();
};

// returns address fields that are currently visible
ZmComposeView.prototype.getAddrFields =
function() {
	return this._recipients.getAddrFields();
};

ZmComposeView.prototype.getTabGroupMember = function() {

    if (!this._tabGroup) {
        var tg = this._tabGroup = new DwtTabGroup('ZmComposeView');
        tg.addMember(this._fromSelect);
        tg.addMember(this.identitySelect);
        tg.addMember(this._recipients.getTabGroupMember());
        tg.addMember(this._subjectField);
        tg.addMember(this._attButton);
        tg.addMember(this._attcTabGroup);
        tg.addMember(this._htmlEditor.getTabGroupMember());
    }

	return this._tabGroup;
};

ZmComposeView.prototype.getAddrInputField =
function(type) {
	return this._recipients.getAddrInputField(type);
};

ZmComposeView.prototype.getRecipientField =
function(type) {
	return this._recipients.getField(type);
};

ZmComposeView.prototype.getAddressButtonListener =
function(ev, addrType) {
	return this._recipients.addressButtonListener(ev, addrType);
};

ZmComposeView.prototype.setAddress =
function(type, addr) {
	return this._recipients.setAddress(type, addr);
};

ZmComposeView.prototype.collectAddrs =
function() {
	return this._recipients.collectAddrs();
};

// returns list of attachment field values (used by detachCompose)
ZmComposeView.prototype.getAttFieldValues =
function() {
	var attList = [];
	var atts = document.getElementsByName(ZmComposeView.UPLOAD_FIELD_NAME);

	for (var i = 0; i < atts.length; i++) {
		attList.push(atts[i].value);
	}

	return attList;
};

ZmComposeView.prototype.setBackupForm =
function() {
	this.backupForm = this._backupForm();
};

/**
* Saves *ALL* form value data to test against whether user made any changes
* since canceling SendMsgRequest. If user attempts to send again, we compare
* form data with this value and if not equal, send a new UID otherwise, re-use.
* 
* @private
*/
ZmComposeView.prototype._backupForm =
function() {
	var val = this._formValue(true, true);

	// keep track of attachments as well
	var atts = document.getElementsByName(ZmComposeView.UPLOAD_FIELD_NAME);
	for (var i = 0; i < atts.length; i++) {
		if (atts[i].value.length) {
			val += atts[i].value;
		}
	}

	// keep track of "uploaded" attachments as well :/
	val += this._getForwardAttIds(ZmComposeView.FORWARD_ATT_NAME + this._sessionId).join("");
	val += this._getForwardAttIds(ZmComposeView.FORWARD_MSG_NAME + this._sessionId).join("");

	return val;
};

ZmComposeView.prototype._setAttInline =
function(opt){
  this._isAttachInline = (opt === true);
};

ZmComposeView.prototype._getIsAttInline =
function(opt){
  return(this._isAttachInline);
};


ZmComposeView.prototype._isInline =
function(msg) {

	if (this._attachDialog) {
		return this._attachDialog.isInline();
	}

	msg = msg || this._origMsg;

	if (msg && this._msgAttId && msg.id === this._msgAttId) {
		return false;
	}

	if (msg && msg.attachments) {
		var atts = msg.attachments;
		for (var i = 0; i < atts.length; i++) {
			if (atts[i].contentId) {
				return true;
			}
		}
	}

	return false;
};


ZmComposeView.prototype._addReplyAttachments =
function(){
	this._showForwardField(this._msg, ZmComposeView.ADD_ORIG_MSG_ATTS, true);
};

ZmComposeView.prototype._handleInlineAtts =
function(msg, handleInlineDocs){

	var handled = false, ci, cid, dfsrc, inlineAtt, attached = {};

	var idoc = this._htmlEditor._getIframeDoc();
	var images = idoc ? idoc.getElementsByTagName("img") : [];
	for (var i = 0; i < images.length; i++) {
		dfsrc = images[i].getAttribute("dfsrc") || images[i].getAttribute("data-mce-src") || images[i].src;
		if (dfsrc) {
			if (dfsrc.substring(0,4) === "cid:") {
				cid = dfsrc.substring(4).replace("%40","@");
				var docpath = images[i].getAttribute("doc");
				var mid = images[i].getAttribute('data-zimbra-id');
				var part = images[i].getAttribute('data-zimbra-part');

				if (docpath){
					msg.addInlineDocAttachment(cid, null, docpath);
					handled = true;
				} else if (mid && part) {
					images[i].removeAttribute('data-zimbra-id');
					images[i].removeAttribute('data-zimbra-part');
					msg.addInlineAttachmentId(cid, mid, part, true);
					handled = true;
				} else {
					ci = "<" + cid + ">";
					inlineAtt = msg.findInlineAtt(ci);
					if (!inlineAtt && this._msg) {
						inlineAtt = this._msg.findInlineAtt(ci);
					}
						if (inlineAtt) {
						var id = [cid, inlineAtt.part].join("_");
						if (!attached[id]) {
							msg.addInlineAttachmentId(cid, null, inlineAtt.part);
							handled = true;
							attached[id] = true;
						}
					}
				}
			}
		}
	}

	return handled;
};

ZmComposeView.prototype._generateCid =
function() {
	var timeStr = "" + new Date().getTime();
	var hash = AjxSHA1.hex_sha1(timeStr + Dwt.getNextId());
	return hash + "@zimbra";
};

/**
* Returns the message from the form, after some basic input validation.
*/
ZmComposeView.prototype.getMsg =
function(attId, isDraft, dummyMsg, forceBail, contactId) {

	// Check destination addresses.
	var addrs = this._recipients.collectAddrs();

	// Any addresses at all provided? If not, bail.
	if ((!isDraft || forceBail) && !addrs.gotAddress) {
		this.enableInputs(false);
		var msgDialog = appCtxt.getMsgDialog();
		msgDialog.setMessage(ZmMsg.noAddresses, DwtMessageDialog.CRITICAL_STYLE);
		msgDialog.popup();
		msgDialog.registerCallback(DwtDialog.OK_BUTTON, this._okCallback, this);
		this.enableInputs(true);
		return;
	}

	var cd = appCtxt.getOkCancelMsgDialog();
	cd.reset();

	// Is there a subject? If not, ask the user if they want to send anyway.
	var subject = AjxStringUtil.trim(this._subjectField.value);
	if ((!isDraft || forceBail) && subject.length === 0 && !this._noSubjectOkay) {
		this.enableInputs(false);
		cd.setMessage(ZmMsg.compSubjectMissing, DwtMessageDialog.WARNING_STYLE);
		cd.registerCallback(DwtDialog.OK_BUTTON, this._noSubjectOkCallback, this, cd);
		cd.registerCallback(DwtDialog.CANCEL_BUTTON, this._noSubjectCancelCallback, this, cd);
		cd.popup();
		return;
	}

	// Any bad addresses?  If there are bad ones, ask the user if they want to send anyway.
	if ((!isDraft || forceBail) && addrs[ZmComposeView.BAD].size() && !this._badAddrsOkay) {
		this.enableInputs(false);
		var bad = AjxStringUtil.htmlEncode(addrs[ZmComposeView.BAD].toString(AjxEmailAddress.SEPARATOR));
		var msg = AjxMessageFormat.format(ZmMsg.compBadAddresses, bad);
		cd.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
		cd.registerCallback(DwtDialog.OK_BUTTON, this._badAddrsOkCallback, this, cd);
		cd.registerCallback(DwtDialog.CANCEL_BUTTON, this._badAddrsCancelCallback, this, [addrs.badType, cd]);
		cd.setVisible(true); // per fix for bug 3209
		cd.popup();
		return;
	} else {
		this._badAddrsOkay = false;
	}

	// Mandatory Spell Check
	if ((!isDraft || forceBail) && appCtxt.get(ZmSetting.SPELL_CHECK_ENABLED) && 
		appCtxt.get(ZmSetting.MAIL_MANDATORY_SPELLCHECK) && !this._spellCheckOkay) {
		if (this._htmlEditor.checkMisspelledWords(this._spellCheckShield.bind(this), null, this._spellCheckErrorShield.bind(this))) {
			return;
		}
	} else {
		this._spellCheckOkay = false;
	}

	// Create Msg Object - use dummy if provided
	var msg = dummyMsg || (new ZmMailMsg());
	msg.setSubject(subject);

	var zeroSizedAttachments = false;
	// handle Inline Attachments
	if (attId && (this._getIsAttInline() || (this._attachDialog && this._attachDialog.isInline()) || attId.clipboardPaste)) {
		for (var i = 0; i < attId.length; i++) {
			var att = attId[i];
			if (att.s === 0) {
				zeroSizedAttachments = true;
				continue;
			}
			var contentType = att.ct;
			if (contentType && contentType.indexOf("image") !== -1) {
				var cid = this._generateCid();
				if( att.hasOwnProperty("id") ){
					this._htmlEditor.replaceImage(att.id, "cid:" + cid);
				}
				else {
					this._htmlEditor.insertImage("cid:" + cid, AjxEnv.isIE);
				}
				msg.addInlineAttachmentId(cid, att.aid);
			} else {
				msg.addAttachmentId(att.aid);
			}
		}
	} else if (attId && typeof attId !== "string") {
		for (var i = 0; i < attId.length; i++) {
			if (attId[i].s === 0) {
				zeroSizedAttachments = true;
				continue;
			}
			msg.addAttachmentId(attId[i].aid);
		}
	} else if (attId) {
		msg.addAttachmentId(attId);
	}

	if (zeroSizedAttachments) {
		appCtxt.setStatusMsg(ZmMsg.zeroSizedAtts);
	}

	// check if this is a resend
	if (this.sendUID && this.backupForm) {
		// if so, check if user changed anything since canceling the send
		if (isDraft || this._backupForm() !== this.backupForm) {
			this.sendUID = (new Date()).getTime();
		}
	} else {
		this.sendUID = (new Date()).getTime();
	}

	// get list of message part id's for any forwarded attachments
	var forwardAttIds = this._getForwardAttIds(ZmComposeView.FORWARD_ATT_NAME + this._sessionId, !isDraft && this._hideOriginalAttachments),
        forwardAttObjs = this._getForwardAttObjs(forwardAttIds),
        attachedMsgIds = AjxUtil.arrayAsHash(AjxUtil.map(forwardAttObjs, function(m) { return m.mid; })),
	    forwardMsgIds = [];

	if (this._msgIds) {
		// Get any message ids added via the attachment dialog (See
		// _attsDoneCallback which adds new forwarded attachments to msgIds)
		forwardMsgIds = this._msgIds;
		this._msgIds = null;
	}
    if (this._msgAttId) {
		// Forward one message or Reply as attachment
		forwardMsgIds.push(this._msgAttId);
	}
    if (this._origMsgAtt) {
        attachedMsgIds[this._origMsgAtt.mid] = true;
    }
    // make sure we're not attaching a msg twice by checking for its ID in our list of forwarded attachments
    forwardMsgIds = AjxUtil.filter(forwardMsgIds, function(m) { return !attachedMsgIds[m]; });

	// --------------------------------------------
	// Passed validation checks, message ok to send
	// --------------------------------------------

	// build MIME
	var top = this._getTopPart(msg, isDraft);

	msg.setTopPart(top);
	msg.setSubject(subject);
	msg.setForwardAttIds(forwardAttIds);
	msg.setForwardAttObjs(forwardAttObjs);
	if (!contactId) {
		//contactId not passed in, but vcard signature may be set
		if (this._msg && this._msg._contactAttIds) {
			contactId = this._msg._contactAttIds;
			this._msg.setContactAttIds([]);
		}
	}
	msg.setContactAttIds(contactId);
	for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
		var type = ZmMailMsg.COMPOSE_ADDRS[i];
		if (addrs[type] && addrs[type].all.size() > 0) {
			msg.setAddresses(type, addrs[type].all);
		}
	}
	msg.identity = this.getIdentity();
	msg.sendUID = this.sendUID;

	if (!msg.identity) {
		msg.delegatedSenderAddr = this.identitySelect.getValue();
		var option = this.identitySelect.getSelectedOption();
		msg.delegatedSenderAddrIsDL = option.getExtraData("isDL");
		msg.isOnBehalfOf = option.getExtraData("isObo");
	}
	// save a reference to the original message
	msg._origMsg = this._msg;
	if (this._msg && this._msg._instanceDate) {
		msg._instanceDate = this._msg._instanceDate;
	}

	this._setMessageFlags(msg);

	if (this._action === ZmOperation.DRAFT && this._origAcctMsgId) {
		msg.origAcctMsgId = this._origAcctMsgId;
	}

	// replied/forw msg or draft shouldn't have att ID (a repl/forw voicemail mail msg may)
	if (this._msg && this._msg.attId) {
		msg.addAttachmentId(this._msg.attId);
	}

	msg.setMessageAttachmentId(forwardMsgIds);

	var priority = this._controller._getPriority();
	if (priority) {
		msg.flagLocal(priority, true);
	}

	if (this._fromSelect) {
		msg.fromSelectValue = this._fromSelect.getSelectedOption();
	}

	if (!this._zimletCheck(msg, isDraft, forceBail)) {
		return;
	}
		
	return msg;
};

ZmComposeView.prototype._getTopPart =
function(msg, isDraft, bodyContent) {
		
	// set up message parts as necessary
	var top = new ZmMimePart();
	var textContent;
	var content = bodyContent || this._getEditorContent();

	if (this._composeMode == Dwt.HTML) {
		top.setContentType(ZmMimeTable.MULTI_ALT);
		
		// experimental code for generating text part
		if (false && this._htmlEditor) {
			var userText = AjxStringUtil.convertHtml2Text(this.getUserText());
			this.setComponent(ZmComposeView.BC_TEXT_PRE, userText)
			this._setReturns(Dwt.TEXT);
			var xxx = this._layoutBodyComponents(this._compList, Dwt.TEXT);
//			this.resetBody({ extraBodyText:userText }, true);
//			this._composeMode = Dwt.HTML;
			this._setReturns(Dwt.HTML);
		}

		// create two more mp's for text and html content types
		var textPart = new ZmMimePart();
		textPart.setContentType(ZmMimeTable.TEXT_PLAIN);
		textContent = this._htmlToText(content);
		textPart.setContent(textContent);
		top.children.add(textPart);

		var htmlPart = new ZmMimePart();
		htmlPart.setContentType(ZmMimeTable.TEXT_HTML);		

		if (this._htmlEditor) {
			var idoc = this._htmlEditor._getIframeDoc();
			this._cleanupFileRefImages(idoc);
			this._restoreMultipartRelatedImages(idoc);
			if (!isDraft) {
				this._cleanupSignatureIds(idoc);
			}
			htmlPart.setContent(this._fixStyles(this._getEditorContent(!isDraft)));
		}
		else {
			htmlPart.setContent(bodyContent);
		}

		var content = "<html><body>" + AjxStringUtil.defangHtmlContent(htmlPart.getContent()) + "</body></html>";

		htmlPart.setContent(content);

		if (this._htmlEditor) {
			this._handleInlineAtts(msg, true);
		}
		var inlineAtts = msg.getInlineAttachments();
		var inlineDocAtts = msg.getInlineDocAttachments();
		var iAtts = [].concat(inlineAtts, inlineDocAtts);
		if (iAtts &&  iAtts.length > 0) {
			var relatedPart = new ZmMimePart();
			relatedPart.setContentType(ZmMimeTable.MULTI_RELATED);
			relatedPart.children.add(htmlPart);
			top.children.add(relatedPart);
		} else {
			top.children.add(htmlPart);
		}
	}
	else {
		var inline = this._isInline();

		var textPart = (this._extraParts || inline) ? new ZmMimePart() : top;
		textPart.setContentType(ZmMimeTable.TEXT_PLAIN);
		textContent = content;
		textPart.setContent(textContent);

		if (inline) {
			top.setContentType(ZmMimeTable.MULTI_ALT);
			var relatedPart = new ZmMimePart();
			relatedPart.setContentType(ZmMimeTable.MULTI_RELATED);
			relatedPart.children.add(textPart);
			top.children.add(relatedPart);
		} else {
			if (this._extraParts) {
				top.setContentType(ZmMimeTable.MULTI_ALT);
				top.children.add(textPart);
			}
		}
	}

	// add extra message parts
	if (this._extraParts) {
		for (var i = 0; i < this._extraParts.length; i++) {
			var mimePart = this._extraParts[i];
			top.children.add(mimePart);
		}
	}

	// store text-content of the current email for zimlets to work with
	// TODO: zimlets are being lazy here, and text content could be large; zimlets should get content from parts
	msg.textBodyContent = !this._htmlEditor ? textContent : (this._composeMode === Dwt.HTML)
		? this._htmlEditor.getTextVersion()
		: this._getEditorContent();
		
	return top;
};

// Returns the editor content with any markers stripped (unless told not to strip them)
ZmComposeView.prototype._getEditorContent =
function(leaveMarkers) {
	var content = "";
	if (this._htmlEditor) {
		content = this._htmlEditor.getContent(true);
		if (!leaveMarkers && (this._composeMode === Dwt.TEXT)) {
			content = this._removeMarkers(content);
		}
	}
	return content;
};

// Bug 27422 - Firefox and Safari implementation of execCommand("bold")
// etc use styles, and some email clients (Entourage) don't process the
// styles and the text remains plain. So we post-process and convert
// those to the tags (which are what the IE version of execCommand() does).
ZmComposeView.prototype._fixStyles =
function(text) {
	if (AjxEnv.isFirefox) {
		text = text.replace(/<span style="font-weight: bold;">(.+?)<\/span>/, "<strong>$1</strong>");
		text = text.replace(/<span style="font-style: italic;">(.+?)<\/span>/, "<em>$1</em>");
		text = text.replace(/<span style="text-decoration: underline;">(.+?)<\/span>/, "<u>$1</u>");
		text = text.replace(/<span style="text-decoration: line-through;">(.+?)<\/span>/, "<strike>$1</strike>");
	} else if (AjxEnv.isSafari) {
		text = text.replace(/<span class="Apple-style-span" style="font-weight: bold;">(.+?)<\/span>/, "<strong>$1</strong>");
		text = text.replace(/<span class="Apple-style-span" style="font-style: italic;">(.+?)<\/span>/, "<em>$1</em>");
		text = text.replace(/<span class="Apple-style-span" style="text-decoration: underline;">(.+?)<\/span>/, "<u>$1</u>");
		text = text.replace(/<span class="Apple-style-span" style="text-decoration: line-through;">(.+?)<\/span>/, "<strike>$1</strike>");
	}
	return text;
};

ZmComposeView.prototype._setMessageFlags =
function(msg) {
		
	if (this._msg) {
		var isInviteReply = ZmComposeController.IS_INVITE_REPLY[this._action];
		if (this._action === ZmOperation.DRAFT || this._msg.isDraft) {
			msg.isReplied = (this._msg.rt === "r");
			msg.isForwarded = (this._msg.rt === "w");
			msg.isDraft = this._msg.isDraft;
			// check if we're resaving a draft that was originally a reply/forward
			if (msg.isDraft) {
				// if so, set both origId and the draft id
				msg.origId = (msg.isReplied || msg.isForwarded) ? this._msg.origId : null;
				msg.id = this._msg.id;
				msg.nId = this._msg.nId;
			}
		} else {
			msg.isReplied = ZmComposeController.IS_REPLY[this._action];
			msg.isForwarded = ZmComposeController.IS_FORWARD[this._action];
			msg.origId = this._msg.id;
		}
        msg.isOfflineCreated = this._msg.isOfflineCreated;
		msg.isInviteReply = isInviteReply;
		msg.acceptFolderId = this._acceptFolderId;
		var notifyActionMap = ZmComposeView.NOTIFY_ACTION_MAP || {};
		var inviteMode = notifyActionMap[this._action] ? notifyActionMap[this._action] : this._action;
		msg.inviteMode = isInviteReply ? inviteMode : null;
        if (!this.isEditAsNew && this._action !== ZmOperation.NEW_MESSAGE && (!msg.isDraft || msg.isReplied)){  //Bug: 82942 - in-reply-to shouldn't be added to new messages.
			 //when editing a saved draft (only from the drafts folder "edit") - _origMsg is the draft msg instead of the replied to message.
            msg.irtMessageId = this._origMsg.isDraft ? this._origMsg.irtMessageId : this._origMsg.messageId;
        }
        msg.folderId = this._msg.folderId;
    }
};

ZmComposeView.prototype._zimletCheck =
function(msg, isDraft, forceBail) {
		
	/*
	* finally, check for any errors via zimlets..
	* A Zimlet can listen to emailErrorCheck action to perform further check and
	* alert user about the error just before sending email. We will be showing
	* yes/no dialog. This zimlet must return an object {hasError:<true or false>,
	* errorMsg:<Some Error msg>, zimletName:<zimletName>} e.g: {hasError:true,
	* errorMsg:"you might have forgotten attaching an attachment, do you want to
	* continue?", zimletName:"com_zimbra_attachmentAlert"}
	**/
	if ((!isDraft || forceBail) && appCtxt.areZimletsLoaded()) {
		var boolAndErrorMsgArray = [];
		var showErrorDlg = false;
		var errorMsg = "";
		var zimletName = "";
		appCtxt.notifyZimlets("emailErrorCheck", [msg, boolAndErrorMsgArray]);
		var blen =  boolAndErrorMsgArray.length;
		for (var k = 0; k < blen; k++) {
			var obj = boolAndErrorMsgArray[k];
			if (obj === null || obj === undefined) { continue; }

			var hasError = obj.hasError;
			zimletName = obj.zimletName;
			if (Boolean(hasError)) {
				if (this._ignoredZimlets) {
					if (this._ignoredZimlets[zimletName]) { // if we should ignore this zimlet
						delete this._ignoredZimlets[zimletName];
						continue; // skip
					}
				}
				showErrorDlg = true;
				errorMsg = obj.errorMsg;
				break;
			}
		}
		if (showErrorDlg) {
			this.enableInputs(false);
			var cd = appCtxt.getOkCancelMsgDialog();
			cd.setMessage(errorMsg, DwtMessageDialog.WARNING_STYLE);
			var params = {errDialog:cd, zimletName:zimletName};
			cd.registerCallback(DwtDialog.OK_BUTTON, this._errViaZimletOkCallback, this, params);
			cd.registerCallback(DwtDialog.CANCEL_BUTTON, this._errViaZimletCancelCallback, this, params);
			cd.popup();
			return false;
		}
	}

	return true;
};

ZmComposeView.prototype.setDocAttachments =
function(msg, docIds) {

	if (!docIds) { return; }

	var zeroSizedAttachments = false;
	var inline = this._isInline();
	for (var i = 0; i < docIds.length; i++) {
		var docAtt = docIds[i];
		var contentType = docAtt.ct;
		if (docAtt.s === 0) {
			zeroSizedAttachments = true;
			continue;
		}
		if (this._attachDialog && inline) {
			if (contentType && contentType.indexOf("image") !== -1) {
				var cid = this._generateCid();
				this._htmlEditor.insertImage("cid:" + cid, AjxEnv.isIE);
				msg.addInlineDocAttachment(cid, docAtt.id);
			} else {
				msg.addDocumentAttachment(docAtt);
			}
		} else {
			msg.addDocumentAttachment(docAtt);
		}
	}
	if (zeroSizedAttachments){
		appCtxt.setStatusMsg(ZmMsg.zeroSizedAtts);
	}
};

// Sets the mode the editor should be in.
ZmComposeView.prototype.setComposeMode =
function(composeMode, initOnly) {

	if (composeMode === this._composeMode) { return; }
		
	var htmlMode = (composeMode === Dwt.HTML);
	if (htmlMode && !appCtxt.get(ZmSetting.HTML_COMPOSE_ENABLED)) { return; }
		
	var previousMode = this._composeMode;
	var modeSwitch = (!initOnly && previousMode && composeMode && previousMode !== composeMode);
	var userText = modeSwitch && this.getUserText();
	var quotedText = modeSwitch && this._getQuotedText();
	this._composeMode = composeMode;
	this._setReturns();

	// switch the editor's mode
	this._htmlEditor.setContent("");
	this._htmlEditor.setMode(composeMode);
		
	if (modeSwitch) {
		userText = htmlMode ? AjxStringUtil.convertToHtml(userText) : AjxStringUtil.trim(this._htmlToText(userText)) + this._crlf;
		var op = htmlMode ? ZmOperation.FORMAT_HTML : ZmOperation.FORMAT_TEXT;
		this.resetBody({ extraBodyText:userText, quotedText:quotedText, op:op, keepAttachments:true });
	}

	// reset the body field Id and object ref
	this._bodyFieldId = this._htmlEditor.getBodyFieldId();
	this._bodyField = Dwt.byId(this._bodyFieldId);
	if (this._bodyField.disabled) {
		this._bodyField.disabled = false;
	}

	this._resetBodySize();

	// recalculate form value since HTML mode inserts HTML tags
	this._setFormValue();

	if (!htmlMode) {
		this._retryHtmlEditorFocus(); //this was previously in a block I removed, so keeping it here. (don't want to create rare focus regressions)
		this._moveCaretOnTimer();
	}

	if (this._msg && this._isInline(this._msg) && composeMode === Dwt.TEXT) {
		this._showForwardField(this._msg, this._action, true);
	}
};

ZmComposeView.prototype._retryHtmlEditorFocus =
function() {
	if (this._htmlEditor.hasFocus()) {
		setTimeout(this._focusHtmlEditor, 10);
	}
};

/**
 * Handles compose in new window.
 * 
 * @param params
 */
ZmComposeView.prototype.setDetach =
function(params) {

	this._action = params.action;
    this._controller._origAction = params.origAction;
	this._msg = params.msg;

	// set the addr fields as populated
	for (var type in params.addrs) {
		this._recipients.setAddress(type, "");
		var addrs = AjxUtil.toArray(params.addrs[type]);
		this._recipients.addAddresses(type, AjxVector.fromArray(addrs));
	}

	this._subjectField.value = params.subj || "";
	this._controller._setPriority(params.priority);
	this.updateTabTitle();

	var content = params.body || "";
	if ((content == "") && (this.getComposeMode() == Dwt.HTML)) {
		content	= "<br>";
	}
	this._htmlEditor.setContent(content);

	this._msgAttId = params.msgAttId;
    if (params.attHtml) {
        this._attcDiv.innerHTML = params.attHtml;
    }
    if (params.partMap && params.partMap.length) {
        this._partToAttachmentMap = params.partMap;
    }
    if (params.origMsgAtt && params.origMsgAtt.part) {
        this._origMsgAtt = params.origMsgAtt;
    }

    if (params.identityId && this.identitySelect) {
		var opt = this.identitySelect.getOptionAtIndex(params.identityId);
		this.identitySelect.setSelectedOption(opt);
		this._controller.resetIdentity(params.identity.id);
	}

	this.backupForm = params.backupForm;
	this.sendUID = params.sendUID;

	// bug 14322 -- in Windows Firefox, DEL/BACKSPACE don't work
	// when composing in new window until we (1) enter some text
	// or (2) resize the window (!).  I chose the latter.
	if (AjxEnv.isGeckoBased && AjxEnv.isWindows) {
		window.resizeBy(1, 1);
	}
};

ZmComposeView.prototype.reEnableDesignMode =
function() {
	if (this._composeMode === Dwt.HTML) {
		this._htmlEditor.reEnableDesignMode();
	}
};

// user just saved draft, update compose view as necessary
ZmComposeView.prototype.processMsgDraft =
function(msgDraft) {

	if (this._isInline(msgDraft)) {
		this._handleInline(msgDraft);
	}
	this.reEnableDesignMode();
    this._msg = msgDraft;

    var incOptions = this._controller._curIncOptions;
    if (!this._origMsgAtt && this._msgAttId && incOptions && incOptions.what === ZmSetting.INC_ATTACH) {
        var msgIdx = AjxUtil.indexOf(msgDraft._msgAttIds, this._msgAttId),
            attMsgs = AjxUtil.filter(msgDraft.attachments, function(att) {
            return att.getContentType() === ZmMimeTable.MSG_RFC822;
        }),
            attMsg = attMsgs[msgIdx];
        if (attMsg) {
            this._origMsgAtt = {
                size:       attMsg.size,
                part:       attMsg.part,
                mid:        this._msgAttId,
                draftId:    msgDraft.id
            }
        }
    }

	this._msgAttId = null;
	// always redo att links since user couldve removed att before saving draft
	this.cleanupAttachments(true);
	this._showForwardField(msgDraft, ZmOperation.DRAFT);
	this._resetBodySize();
	// save form state (to check for change later)
	this._setFormValue();
};

ZmComposeView.prototype._handleInline =
function(msgObj) {
	return this._fixMultipartRelatedImages(msgObj || this._msg, this._htmlEditor._getIframeDoc());
};

ZmComposeView.prototype._fixMultipartRelatedImages_onTimer =
function(msg, account) {
	// The first time the editor is initialized, idoc.getElementsByTagName("img") is empty.
	// Use a callback to fix images after editor is initialized.
	var idoc = this._htmlEditor._getIframeDoc();
	if (this._firstTimeFixImages) {
		var callback = this._fixMultipartRelatedImages.bind(this, msg, idoc, account);
		this._htmlEditor.addOnContentInitializedListener(callback);
		//set timeout in case ZmHtmlEditor.prototype.onLoadContent is never called in which case the listener above won't be called.
		window.setTimeout(callback, 3000);
	} else {
		this._fixMultipartRelatedImages(msg, idoc, account);
	}
};

/**
 * Twiddle the img tags so that the HTML editor can display the images. Instead of
 * a cid (which is relevant only within the MIME msg), point to the img with a URL.
 * 
 * @private
 */
ZmComposeView.prototype._fixMultipartRelatedImages =
function(msg, idoc, account) {

	if (this._firstTimeFixImages) {
		this._htmlEditor.clearOnContentInitializedListeners();
		var self = this; // Fix possible hiccups during compose in new window
		setTimeout(function() {
				self._fixMultipartRelatedImages(msg, self._htmlEditor._getIframeDoc(), account);
		}, 10);
		this._firstTimeFixImages = false;
		return;
	}

	idoc = idoc || this._htmlEditor._getIframeDoc();
	if (!idoc) { return; }

	var showImages = false;
	if (msg) {
		var addr = msg.getAddress(AjxEmailAddress.FROM);
		var sender = msg.getAddress(AjxEmailAddress.SENDER); // bug fix #10652 - check invite if sentBy is set (means on-behalf-of)
		var sentBy = (sender && sender.address) ? sender : addr;
		var sentByAddr = sentBy && sentBy.getAddress();
		if (sentByAddr) {
			msg.sentByAddr = sentByAddr;
			msg.sentByDomain = sentByAddr.substr(sentByAddr.indexOf("@")+1);
			showImages = this._isTrustedSender(msg);
		}
	}

	var images = idoc.getElementsByTagName("img");
	var num = 0;
	for (var i = 0; i < images.length; i++) {
		var dfsrc = images[i].getAttribute("dfsrc") || images[i].getAttribute("data-mce-src") || images[i].src;
		if (dfsrc) {
			if (dfsrc.substring(0,4) === "cid:") {
				num++;
				var cid = "<" + dfsrc.substring(4).replace("%40","@") + ">";
				var src = msg && msg.getContentPartAttachUrl(ZmMailMsg.CONTENT_PART_ID, cid);
				if (src) {
					//Cache cleared, becoz part id's may change.
					src = src + "&t=" + (new Date()).getTime();
					images[i].src = src;
					images[i].setAttribute("dfsrc", dfsrc);
				}
			} else if (dfsrc.substring(0,4) === "doc:") {
                var src = [appCtxt.get(ZmSetting.REST_URL, null, account), ZmFolder.SEP, dfsrc.substring(4)].join('');
				images[i].src = AjxStringUtil.fixCrossDomainReference(src, false, true);;
			} else if (dfsrc.indexOf("//") === -1) { // check for content-location verison
				var src = msg && msg.getContentPartAttachUrl(ZmMailMsg.CONTENT_PART_LOCATION, dfsrc);
				if (src) {
					//Cache cleared, becoz part id's may change.
					src = src + "&t=" + (new Date()).getTime();
					num++;
					images[i].src = src;
					images[i].setAttribute("dfsrc", dfsrc);
				}
			}
			else if (showImages) {
				var src = dfsrc;//x + "&t=" + (new Date()).getTime();
				num++;
				images[i].src = src;
				images[i].setAttribute("dfsrc", dfsrc);
			}
		}
	}
	return num === images.length;
};

ZmComposeView.prototype._isTrustedSender =
function(msg) {
	var trustedList = this.getTrustedSendersList();
	return trustedList.contains(msg.sentByAddr.toLowerCase()) || trustedList.contains(msg.sentByDomain.toLowerCase());
};

ZmComposeView.prototype.getTrustedSendersList =
function() {
	return this._controller.getApp().getTrustedSendersList();
};

ZmComposeView.prototype._cleanupFileRefImages =
function(idoc) {

	function removeImg(img){
		var parent = img.parentNode;
		parent.removeChild(img);
	}

	if (idoc) {
		var images = idoc.getElementsByTagName("img");
		var len = images.length, fileImgs=[], img, src;
		for (var i = 0; i < images.length; i++) {
			img = images[i];
			try {
				src = img.src;
			} catch(e) {
				//IE8 throws invalid pointer exception for src attribute when src is a data uri
			}
			if (img && src && src.indexOf('file://') == 0) {
				removeImg(img);
				i--; //removeImg reduces the images.length by 1.
			}
		}
	}
};

/**
 * the comment below is no longer true, but I keep it for history purposes as this is so complicated. Bug 50178 changed to setting dfsrc instead of src...
 * todo - perhaps rewrite the whole thing regarding inline attachments.
 * Change the src tags on inline img's to point to cid's, which is what we
 * want for an outbound MIME msg.
 */
ZmComposeView.prototype._restoreMultipartRelatedImages =
function(idoc) {

	if (idoc) {
		var images = idoc.getElementsByTagName("img");
		var num = 0;
		for (var i = 0; i < images.length; i++) {
			var img = images[i];
			var cid = "";
			var src = img.src && unescape(img.src);
			var dfsrc = img.getAttribute("dfsrc") || img.getAttribute("data-mce-src");
			if (dfsrc && dfsrc.indexOf("cid:") === 0) {
				return; //dfsrc already set so nothing to do
			} else if (img.src && img.src.indexOf("cid:") === 0) {
				cid = img.src;
			} else if ( dfsrc && dfsrc.substring(0,4) === "doc:"){
				cid = "cid:" + this._generateCid();
				img.removeAttribute("dfsrc");
				img.setAttribute("doc", dfsrc.substring(4, dfsrc.length));
			} else if (src && src.indexOf(appCtxt.get(ZmSetting.CSFE_MSG_FETCHER_URI)) === 0) {
				// bug 85129 - handle images copied from another mail
				var qsparams = AjxStringUtil.parseQueryString(src);

				if (qsparams.id && qsparams.part) {
					cid = "cid:" + this._generateCid();
					img.setAttribute('data-zimbra-id', qsparams.id);
					img.setAttribute('data-zimbra-part', qsparams.part);
				}
			} else {
				// If "Display External Images" is false then handle Reply/Forward
				if (dfsrc && (!this._msg || this._msg.showImages))
					//IE: Over HTTPS, http src urls for images might cause an issue.
					try {
						img.src = dfsrc;
					} catch(ex) {};
				}
			if (cid) {
				img.setAttribute("dfsrc", cid);
			}
		}
	}
};

ZmComposeView.prototype._cleanupSignatureIds =
function(idoc){
	var signatureEl = idoc && idoc.getElementById(this._controller._currentSignatureId);
	if (signatureEl) {
		signatureEl.removeAttribute("id");
	}
};

/**
 * Display an attachment dialog - either a direct and native upload dialog or
 * the legacy dialog.
 *
 * @param {constant}  type      One of the <code>ZmComposeView.UPLOAD_</code> constants.
 */
ZmComposeView.prototype.showAttachmentDialog =
function(type) {

	if (this._disableAttachments) { return };

	// collapse the attachment menu, just in case
	this.collapseAttMenu();

	if (AjxEnv.supportsHTML5File &&
	    type !== ZmComposeView.UPLOAD_BRIEFCASE) {
		var isinline = (type === ZmComposeView.UPLOAD_INLINE);
		var fileInputElement = ZmComposeView.FILE_INPUT;
		if (fileInputElement) {
			fileInputElement.value = "";
		}
		else {
			ZmComposeView.FILE_INPUT = fileInputElement = document.createElement('INPUT');
			fileInputElement.type = "file";
			fileInputElement.title = ZmMsg.uploadNewFile;
			fileInputElement.multiple = true;
			fileInputElement.style.display = "none";
			document.body.appendChild(fileInputElement);
		}
		fileInputElement.onchange = this._submitMyComputerAttachments.bind(this, null, fileInputElement, isinline);
		fileInputElement.click();
		return;
	}

	var attachDialog = this._attachDialog = appCtxt.getAttachDialog();

	if (type === ZmComposeView.UPLOAD_BRIEFCASE) {
		attachDialog.getBriefcaseView();
	} else {
		attachDialog.getMyComputerView();
	}

	var callback = this._attsDoneCallback.bind(this, true);
	attachDialog.setUploadCallback(callback);
	attachDialog.popup();
	attachDialog.enableInlineOption(this._composeMode === Dwt.HTML);

	if (type === ZmComposeView.UPLOAD_INLINE)
		attachDialog.setInline(true);

};

/**
 * Revert compose view to a clean state (usually called before popping compose view).
 * 
 * @param	{Boolean}	bEnableInputs		if <code>true</code>, enable the input fields
 */
ZmComposeView.prototype.reset = function(bEnableInputs) {

    DBG.println('draft', 'ZmComposeView.reset for ' + this._view);
	this.backupForm = null;
	this.sendUID = null;

	// reset autocomplete list
	if (this._acAddrSelectList) {
		this._acAddrSelectList.reset();
		this._acAddrSelectList.show(false);
	}

	this._recipients.reset();

	// reset subject / body fields
	this._subjectField.value = this._subject = "";
	this.updateTabTitle();

	this._htmlEditor.resetSpellCheck();
	this._htmlEditor.clear();

	// this._htmlEditor.clear() resets html editor body field.
	// Setting this._bodyField to its latest value
	this._bodyField = this._htmlEditor.getBodyField();
	this._bodyContent = {};

	// the div that holds the attc.table and null out innerHTML
	this.cleanupAttachments(true);

	this._resetBodySize();
	this._controller._curIncOptions = null;
	this._msgAttId = null;
    this._origMsgAtt = null;
    this._clearFormValue();
	this._components = {};
		
	// reset dirty shields
	this._noSubjectOkay = this._badAddrsOkay = this._spellCheckOkay = false;

	Dwt.setVisible(this._oboRow, false);

	// Resetting Add attachments from original link option
	Dwt.setVisible(ZmId.getViewId(this._view, ZmId.CMP_REPLY_ATT_ROW), false);

	// remove extra mime parts
	this._extraParts = null;

	// enable/disable input fields
	this.enableInputs(bEnableInputs);

	// reset state of the spell check button
	this._controller.toggleSpellCheckButton(false);

	//reset state of previous Signature cache variable.
	this._previousSignature = null;
	this._previousSignatureMode = null;

	// used by drafts handling in multi-account
	this._origAcctMsgId = null;
};

ZmComposeView.prototype.enableInputs =
function(bEnable) {
    DBG.println('draft', 'ZmComposeView.enableInputs for ' + this._view + ': ' + bEnable);
    this._recipients.enableInputs(bEnable);
	this._subjectField.disabled = this._bodyField.disabled = !bEnable;
};

/**
 * Adds an extra MIME part to the message. The extra parts will be
 * added, in order, to the end of the parts after the primary message
 * part.
 * 
 * @private
 */
ZmComposeView.prototype.addMimePart =
function(mimePart) {
	if (!this._extraParts) {
		this._extraParts = [];
	}
	this._extraParts.push(mimePart);
};

// Returns the full content for the signature, including surrounding tags if in HTML mode.
ZmComposeView.prototype._getSignatureContentSpan =
function(params) {

	var signature = params.signature || this.getSignatureById(this._controller.getSelectedSignature(), params.account);
	if (!signature) { return ""; }

	var signatureId = signature.id;
	var mode = params.mode || this._composeMode;
	var sigContent = params.sigContent || this.getSignatureContent(signatureId, mode);
	if (mode === Dwt.HTML) {
		var markerHtml = "";
		if (params.style === ZmSetting.SIG_OUTLOOK) {
			markerHtml = " " + ZmComposeView.BC_HTML_MARKER_ATTR + "='" + params.marker + "'";
		}
		sigContent = ["<div id=\"", signatureId, "\"", markerHtml, ">", sigContent, "</div>"].join('');
	}

	return this._getSignatureSeparator(params) + sigContent;
};

ZmComposeView.prototype._attachSignatureVcard =
function(signatureId) {

	var signature = this.getSignatureById(signatureId);
	if (signature && signature.contactId && !this._findVcardAtt(this._msg, signature, false)) {
		if (!this._msg) {
			this._msg = new ZmMailMsg();
		}
		if (this._msg._contactAttIds) {
			this._msg._contactAttIds.push(signature.contactId);
		} else {
			this._msg.setContactAttIds(signature.contactId);
		}

		//come back later and see if we need to save the draft
		AjxTimedAction.scheduleAction(this._checkSaveDraft.bind(this), 500);
	}
};

ZmComposeView.prototype._updateSignatureVcard =
function(oldSignatureId, newSignatureId) {

	if (oldSignatureId) {
		var hadVcard = false;
		// uncheck box for previous vcard att so it gets removed
		var oldSig = this.getSignatureById(oldSignatureId);
		if (oldSig && oldSig.contactId) {
            var vcardPart = this._findVcardAtt(this._msg, oldSig, true),
			    inputs = document.getElementsByName(ZmComposeView.FORWARD_ATT_NAME + this._sessionId);

			if (inputs && inputs.length) {
				for (var i = 0; i < inputs.length; i++) {
					if (inputs[i].value === vcardPart) {
						var span = inputs[i].parentNode && inputs[i].parentNode.parentNode;
						if (span && span.id) {
							this._removeAttachedMessage(span.id, vcardPart);
							hadVcard = true;
						}
					}
				}
			}
		}
		if (hadVcard && !newSignatureId) {
			this._controller.saveDraft(ZmComposeController.DRAFT_TYPE_MANUAL);
		}
	}
};

/**
 * Searches for a vcard in a message's attachments. If the contact has not yet been loaded, we assume that
 * a vcard attachment that we find is for that contact. Multiple vcard attachment where the first one is not
 * from the signature should be very rare.
 *
 * @param {ZmMailMsg}       msg         mail message
 * @param {ZmSignature}     signature   a signature
 * @param {boolean}         removeAtt   if true, remove the vcard attachment from the msg
 *
 * @returns {string}    part number of vcard, or "undefined" if not found
 * @private
 */
ZmComposeView.prototype._findVcardAtt = function(msg, signature, removeAtt) {

    if (signature && signature.contactId) {

        var vcardPart,
            atts = msg && msg.attachments;

        if (atts && atts.length) {
            //we need to figure out what input to uncheck
            var sigContact,
                item = appCtxt.cacheGet(signature.contactId);

            if (item && item.isZmContact) {
                sigContact = item;
            }

            for (var i = 0; i < atts.length && !vcardPart; i++) {
                var att = atts[i];
                if (ZmMimeTable.isVcard(att.contentType)) {
                    //we may have multiple vcards, determine which one to remove based on signature in cache
                    if (sigContact) {
                        // remove the .vcf file extension and try to match on the contact's name
                        var name = att.fileName.substring(0, att.fileName.length - 4);
                        if (name === sigContact._fileAs) {
                            vcardPart = att.part;
                        }
                    }
                    else {
                        vcardPart = att.part;
                    }
                    if (removeAtt) {
                        atts.splice(i, 1);
                    }
                }
            }
        }
    }

    return vcardPart;
};

ZmComposeView.prototype._checkSaveDraft =
function() {
	if (this._msg && this._msg._contactAttIds && this._msg._contactAttIds.length > 0) {
		this._controller.saveDraft(ZmComposeController.DRAFT_TYPE_MANUAL, null, null, null, this._msg._contactAttIds);
	}
};

/*
 * Convertor for text nodes that, unlike the one in AjxStringUtil._traverse, doesn't append spaces to the results
*/
ZmComposeView._convertTextNode =
function(el, ctxt) {

	if (el.nodeValue.search(AjxStringUtil._NON_WHITESPACE) !== -1) {
		if (ctxt.lastNode === "ol" || ctxt.lastNode === "ul") {
			return "\n";
		}
		if (ctxt.isPreformatted) {
			return AjxStringUtil.trim(el.nodeValue);
		} else {
			return AjxStringUtil.trim(el.nodeValue.replace(AjxStringUtil._LF, ""));
		}
	}
	return "";
};

ZmComposeView.prototype.dispose =
function() {
	if (this._identityChangeListenerObj) {
		var collection = appCtxt.getIdentityCollection();
        if (collection) {
		    collection.removeChangeListener(this._identityChangeListenerObj);
        }
	}
	DwtComposite.prototype.dispose.call(this);
};

ZmComposeView.prototype.getSignatureById =
function(signatureId, account) {
	signatureId = signatureId || this._controller.getSelectedSignature();
	return appCtxt.getSignatureCollection(account).getById(signatureId);
};

ZmComposeView.prototype.getSignatureContent =
function(signatureId, mode) {

	var extraSignature = this._getExtraSignature();
	signatureId = signatureId || this._controller.getSelectedSignature();

	if (!signatureId && !extraSignature) { return; }

	var signature;

	// for multi-account, search all accounts for this signature ID
	if (appCtxt.multiAccounts) {
		var ac = window.parentAppCtxt || window.appCtxt;
		var list = ac.accountList.visibleAccounts;
		for (var i = 0; i < list.length; i++) {
			var collection = appCtxt.getSignatureCollection(list[i]);
			if (collection) {
				signature = collection.getById(signatureId);
				if (signature) {
					break;
				}
			}
		}
	} else {
		signature = appCtxt.getSignatureCollection().getById(signatureId);
	}

	if (!signature && !extraSignature) { return; }

	mode = mode || this._composeMode;
    var htmlMode = (mode === Dwt.HTML);
    var sig = signature ? signature.getValue(htmlMode ? ZmMimeTable.TEXT_HTML : ZmMimeTable.TEXT_PLAIN) : "";
    sig = AjxStringUtil.trim(sig + extraSignature) + (htmlMode ? "" : this._crlf);

	return sig;
};

/**
 * Returns "" or extra signature (like a quote or legal disclaimer) via zimlet
 */
ZmComposeView.prototype._getExtraSignature =
function() {
	var extraSignature = "";
	if (appCtxt.zimletsPresent()) {
		var buffer = [];
		appCtxt.notifyZimlets("appendExtraSignature", [buffer]);
		extraSignature = buffer.join(this._crlf);
		if (extraSignature) {
			extraSignature = this._crlf + extraSignature;
		}
	}
	return extraSignature;
};

ZmComposeView.prototype._getSignatureSeparator =
function(params) {

	var sep = "";
	params = params || {};
	if (params.style === ZmSetting.SIG_INTERNET) {
		var mode = params.mode || this._composeMode;
		if (mode === Dwt.HTML) {
			sep = "<div " + ZmComposeView.BC_HTML_MARKER_ATTR + "='" + params.marker + "'>-- " + this._crlf + "</div>";
		}
		else {
			sep += "-- " + this._crlf;
		}
	}
	return sep;
};

ZmComposeView.prototype._getSignatureIdForAction =
function(identity, action) {

	identity = identity || this.getIdentity();
	action = action || this._action;
	var field = (ZmComposeController.IS_REPLY[action] || ZmComposeController.IS_FORWARD[action]) ? ZmIdentity.REPLY_SIGNATURE : ZmIdentity.SIGNATURE;
	return identity && identity.getField(field);
};

/**
* Returns true if form contents have changed, or if they are empty.
*
* @param incAddrs		takes addresses into consideration
* @param incSubject		takes subject into consideration
* 
* @private
*/
ZmComposeView.prototype.isDirty =
function(incAddrs, incSubject) {

	if (this._isDirty) {
        DBG.println('draft', 'ZmComposeView.isDirty ' + this._view + ': true');
		return true;
	}

    // Addresses, Subject, non-html mode edit content
	var curFormValue = this._formValue(incAddrs, incSubject);
    // Html editor content changed
    var htmlEditorDirty =  this._htmlEditor && this._htmlEditor.isDirty(),
        dirty = (curFormValue !== this._origFormValue) || htmlEditorDirty;

    DBG.println('draft', 'ZmComposeView.isDirty ' + this._view + ': '  + dirty);

    return dirty;
};

ZmComposeView.removeAttachedFile = function(ev, cvId, spanId, partId) {

	var composeView = DwtControl.fromElementId(cvId);
	if (composeView) {
		if (ev.type === 'click' || (ev.type === 'keypress' && DwtKeyEvent.getCharCode(ev) === 13)) {
			composeView._removeAttachedFile(spanId, partId);
		}
	}
};

ZmComposeView.prototype._removeAttachedFile  =
function(spanId, attachmentPart) {

	var node = document.getElementById(spanId),
	    parent = node && node.parentNode;
	this._attachCount--;

	if (parent) {
		parent.removeChild(node);
	}

	/* Not sure about the purpose of below code so commenting it out instead of deleting.
	When a attachment is removed it should not change the original message. See bug 76776.

	if (attachmentPart) {
	var numAttachments = (this._msg &&  this._msg.attachments && this._msg.attachments.length ) || 0;
		for (var i = 0; i < numAttachments; i++) {
			if (this._msg.attachments[i].part === attachmentPart) {
			   this._msg.attachments.splice(i, 1);
			   break;
			}
		}
	}*/

	if (!parent.childNodes.length) {
		this.cleanupAttachments(true);
	}
};

ZmComposeView.prototype._removeAttachedMessage =
function(spanId, id){
  
	// Forward/Reply one message
	if (!id) {
		this._msgAttId = this._origMsgAtt = null;
	}
	else {
		var index = this._msgIds && this._msgIds.length ? AjxUtil.indexOf(this._msgIds, id) : -1;
		if (index !== -1) {
			// Remove message from attached messages
			this._msgIds.splice(index, 1);
		}
	}

	this._removeAttachedFile(spanId);
};

ZmComposeView.prototype.cleanupAttachments =
function(all) {

	var attachDialog = this._attachDialog;
	if (attachDialog && attachDialog.isPoppedUp()) {
		attachDialog.popdown();
	}

	if (all) {
		var hint = AjxEnv.supportsHTML5File && !this._disableAttachments ?
			ZmMsg.dndTooltip : "&nbsp;";

		this._attcDiv.innerHTML =
			AjxTemplate.expand('mail.Message#NoAttachments', { hint: hint });
		this._attcDiv.style.height = "";
		this._attcTabGroup.removeAllMembers();
		this._attachCount = 0;
	}

	// make sure att IDs don't get reused
	if (this._msg) {
		this._msg.attId = null;
		this._msg._contactAttIds = [];
	}
};

ZmComposeView.prototype.sendMsgOboIsOK =
function() {
	return Dwt.getVisible(this._oboRow) ? this._oboCheckbox.checked : false;
};

ZmComposeView.prototype.updateTabTitle =
function() {
	var buttonText = this._subjectField.value
		? this._subjectField.value.substr(0, ZmAppViewMgr.TAB_BUTTON_MAX_TEXT)
		: ZmComposeController.DEFAULT_TAB_TEXT;
	appCtxt.getAppViewMgr().setTabTitle(this._controller.getCurrentViewId(), buttonText);
};

/**
 * Used in multi-account mode to determine which account this composer is
 * belongs to.
 */
ZmComposeView.prototype.getFromAccount =
function() {
	var ac = window.parentAppCtxt || window.appCtxt;
	return this._fromSelect
		? (ac.accountList.getAccount(this._fromSelect.getSelectedOption().accountId))
		: (ac.accountList.defaultAccount || ac.accountList.activeAccount || ac.accountList.mainAccount);
};

// Private / protected methods

ZmComposeView.prototype._getForwardAttObjs =
function(parts) {
	var forAttObjs = [];
	for (var i = 0; i < this._partToAttachmentMap.length; i++) {
		for (var j = 0; j < parts.length; j++) {
			if (this._partToAttachmentMap[i].part === parts[j]) {
				forAttObjs.push( { part : parts[j], mid : this._partToAttachmentMap[i].mid } );
				break;
			}
		}
	}
	return forAttObjs;
};

ZmComposeView.prototype._getForwardAttIds =
function(name, removeOriginalAttachments) {

	var forAttIds = [];
	var forAttList = document.getElementsByName(name);

	// walk collection of input elements
	for (var i = 0; i < forAttList.length; i++) {
			var part = forAttList[i].value;
			if (this._partToAttachmentMap.length && removeOriginalAttachments) {
				var att = this._partToAttachmentMap[i].part;
				var original = this._originalAttachments[att.label];
				original = original && att.sizeInBytes;
				if (removeOriginalAttachments && original) {
					continue;
				}
			}
			forAttIds.push(part);
	}

	return forAttIds;
};

/**
 * Set various address headers based on the original message and the mode we're in.
 * Make sure not to duplicate any addresses, even across fields. Figures out what
 * addresses to put in To: and Cc: unless the caller passes addresses to use (along
 * with their type).
 * 
 * @param {string}				action		compose action
 * @param {string}				type		address type
 * @param {AjxVector|array}		override	addresses to use
 */
ZmComposeView.prototype._setAddresses =
function(action, type, override) {

	if (override) {
		this._recipients.addAddresses(type, override);
	}
	else {
		var identityId = this.identitySelect && this.identitySelect.getValue();
		var addresses = ZmComposeView.getReplyAddresses(action, this._msg, this._origMsg, identityId);
		if (addresses) {
			var toAddrs = addresses[AjxEmailAddress.TO];
			if (!(toAddrs && toAddrs.length)) {
				// make sure we have at least one TO address if possible
				var addrVec = this._origMsg.getAddresses(AjxEmailAddress.TO);
				addresses[AjxEmailAddress.TO] = addrVec.getArray().slice(0, 1);
			}
			for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
				var type = ZmMailMsg.COMPOSE_ADDRS[i];
				this._recipients.addAddresses(type, addresses[type]);
			}
		}
	}
};

ZmComposeView.getReplyAddresses =
function(action, msg, addrsMsg, identityId) {
		
	addrsMsg = addrsMsg || msg;
	var addresses = {};
	if ((action == ZmOperation.NEW_MESSAGE) || !msg || !addrsMsg) {
		return null;
	}
		
	ZmComposeController._setStatics();
	if (ZmComposeController.IS_REPLY[action]) {
		var ac = window.parentAppCtxt || window.appCtxt;

		// Prevent user's login name and aliases from becoming recipient addresses
		var userAddrs = {};
		var account = appCtxt.multiAccounts && msg.getAccount();
		var uname = ac.get(ZmSetting.USERNAME, null, account);
		if (uname) {
			userAddrs[uname.toLowerCase()] = true;
		}
		var aliases = ac.get(ZmSetting.MAIL_ALIASES, null, account);
		for (var i = 0, count = aliases.length; i < count; i++) {
			userAddrs[aliases[i].toLowerCase()] = true;
		}

		// Check for canonical addresses
		var defaultIdentity = ac.getIdentityCollection(account).defaultIdentity;
		if (defaultIdentity && defaultIdentity.sendFromAddress) {
			// Note: sendFromAddress is same as appCtxt.get(ZmSetting.USERNAME)
			// if the account does not have any canonical address assigned.
			userAddrs[defaultIdentity.sendFromAddress.toLowerCase()] = true;
		}

		// When updating address lists, use addresses msg instead of msg, because
		// msg changes after a draft is saved.
		var isDefaultIdentity = !identityId || (identityId && (defaultIdentity.id === identityId)); 
		var addrVec = addrsMsg.getReplyAddresses(action, userAddrs, isDefaultIdentity, true);
		addresses[AjxEmailAddress.TO] = addrVec ? addrVec.getArray() : [];
		if (action === ZmOperation.REPLY_ALL || action === ZmOperation.CAL_REPLY_ALL) {
			var toAddrs = addrsMsg.getAddresses(AjxEmailAddress.TO, userAddrs, false, true);
			var ccAddrs = addrsMsg.getAddresses(AjxEmailAddress.CC, userAddrs, false, true);
			toAddrs.addList(ccAddrs);
			addresses[AjxEmailAddress.CC] = toAddrs.getArray();
		}
	} else if (action === ZmOperation.DRAFT || action === ZmOperation.SHARE) {
		for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
			var type = ZmMailMsg.COMPOSE_ADDRS[i];
			var addrs = msg.getAddresses(type);
			addresses[type] = addrs ? addrs.getArray() : [];
		}
	} else if (action === ZmOperation.DECLINE_PROPOSAL) {
		var toAddrs = addrsMsg.getAddresses(AjxEmailAddress.FROM);
		addresses[AjxEmailAddress.TO] = toAddrs ? toAddrs.getArray() : [];
	}

	if (action === ZmOperation.DRAFT) {
		//don't mess with draft addresses, this is what the user wanted, this is what they'll get, including duplicates.
		return addresses;
	}

	// Make a pass to remove duplicate addresses
	var addresses1 = {}, used = {};
	for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
		var type = ZmMailMsg.COMPOSE_ADDRS[i];
		var addrs1 = addresses1[type] = [];
		var addrs = addresses[type];
		if (addrs && addrs.length) {
			for (var j = 0, len = addrs.length; j < len; j++) {
				var addr = addrs[j];
				if (!used[addr.address]) {
					addrs1.push(addr);
				}
				used[addr.address] = true;
			}
		}
	}
	return addresses1;
};

ZmComposeView.prototype._setSubject =
function(action, msg, subjOverride) {

	if ((action === ZmOperation.NEW_MESSAGE && !subjOverride)) {
		return;
	}

	var subj = subjOverride || (msg ? msg.subject : "");

	if (action === ZmOperation.REPLY_CANCEL && !subj) {
		var inv = msg && msg.invite;
		if (inv) {
			subj = inv.getName();
		}
	}

	if (action !== ZmOperation.DRAFT && subj) {
		subj = ZmMailMsg.stripSubjectPrefixes(subj);
	}

	var prefix = "";
	switch (action) {
		case ZmOperation.CAL_REPLY:
		case ZmOperation.CAL_REPLY_ALL:
		case ZmOperation.REPLY:
		case ZmOperation.REPLY_ALL: 		prefix = "Re: "; break;
		case ZmOperation.REPLY_CANCEL: 		prefix = ZmMsg.cancelled + ": "; break;
		case ZmOperation.FORWARD_INLINE:
		case ZmOperation.FORWARD_ATT: 		prefix = "Fwd: "; break;
		case ZmOperation.REPLY_ACCEPT:		prefix = ZmMsg.subjectAccept + ": "; break;
		case ZmOperation.REPLY_DECLINE:		prefix = ZmMsg.subjectDecline + ": "; break;
		case ZmOperation.REPLY_TENTATIVE:	prefix = ZmMsg.subjectTentative + ": "; break;
		case ZmOperation.REPLY_NEW_TIME:	prefix = ZmMsg.subjectNewTime + ": "; break;
	}
		
	subj = this._subject = prefix + (subj || "");
	if (this._subjectField) {
		this._subjectField.value = subj;
		this.updateTabTitle();
	}
};

ZmComposeView.prototype._setBody = function(action, msg, extraBodyText, noEditorUpdate, keepAttachments, extraBodyTextIsExternal, incOptions) {

	this._setReturns();
	var htmlMode = (this._composeMode === Dwt.HTML);

	var isDraft = (action === ZmOperation.DRAFT);

	// get reply/forward prefs as necessary
	var incOptions = this._controller._curIncOptions = this._controller._curIncOptions || incOptions;
	var ac = window.parentAppCtxt || window.appCtxt;
	if (!incOptions) {
		if (ZmComposeController.IS_REPLY[action]) {
			incOptions = {what:		ac.get(ZmSetting.REPLY_INCLUDE_WHAT),
						  prefix:	ac.get(ZmSetting.REPLY_USE_PREFIX),
						  headers:	ac.get(ZmSetting.REPLY_INCLUDE_HEADERS)};
		} else if (isDraft) {
			incOptions = {what:		ZmSetting.INC_BODY};
		} else if (action === ZmOperation.FORWARD_INLINE) {
			incOptions = {what:		ZmSetting.INC_BODY,
						  prefix:	ac.get(ZmSetting.FORWARD_USE_PREFIX),
						  headers:	ac.get(ZmSetting.FORWARD_INCLUDE_HEADERS)};
        } else if (action === ZmOperation.FORWARD_ATT && msg && !msg.isDraft) {
            incOptions = {what:		ZmSetting.INC_ATTACH};
		} else if (action === ZmOperation.DECLINE_PROPOSAL) {
			incOptions = {what:		ZmSetting.INC_BODY};
		} else if (action === ZmOperation.NEW_MESSAGE) {
			incOptions = {what:		ZmSetting.INC_NONE};
		} else {
			incOptions = {};
		}
		this._controller._curIncOptions = incOptions;	// pointer, not a copy
	}
	if (incOptions.what === ZmSetting.INC_ATTACH && !this._msg) {
		incOptions.what = ZmSetting.INC_NONE;
	}
		
	// make sure we've loaded the part with the type we want to reply in, if it's available
	if (msg && (incOptions.what === ZmSetting.INC_BODY || incOptions.what === ZmSetting.INC_SMART)) {
		var desiredPartType = htmlMode ? ZmMimeTable.TEXT_HTML : ZmMimeTable.TEXT_PLAIN;
		msg.getBodyPart(desiredPartType, this._setBody1.bind(this, action, msg, extraBodyText, noEditorUpdate, keepAttachments, extraBodyTextIsExternal));
	}
	else {
		this._setBody1(action, msg, extraBodyText, noEditorUpdate, keepAttachments, extraBodyTextIsExternal);
	}
};

ZmComposeView.prototype._setReturns =
function(mode) {
	mode = mode || this._composeMode;
	var htmlMode = (mode === Dwt.HTML);
	this._crlf = htmlMode ? AjxStringUtil.CRLF_HTML : AjxStringUtil.CRLF;
	this._crlf2 = htmlMode ? AjxStringUtil.CRLF2_HTML : AjxStringUtil.CRLF2;
};

// body components
ZmComposeView.BC_NOTHING		= "NOTHING";		// marks beginning and ending
ZmComposeView.BC_TEXT_PRE		= "TEXT_PRE";		// canned text (might be user-entered or some form of extraBodyText) 
ZmComposeView.BC_SIG_PRE		= "SIG_PRE";		// a sig that goes above quoted text
ZmComposeView.BC_DIVIDER		= "DIVIDER";		// tells reader that quoted text is coming
ZmComposeView.BC_HEADERS		= "HEADERS";		// from original msg
ZmComposeView.BC_QUOTED_TEXT	= "QUOTED_TEXT";	// quoted text
ZmComposeView.BC_SIG_POST		= "SIG_POST";		// a sig that goes below quoted text

ZmComposeView.BC_ALL_COMPONENTS = [
		ZmComposeView.BC_NOTHING,
		ZmComposeView.BC_TEXT_PRE,
		ZmComposeView.BC_SIG_PRE,
		ZmComposeView.BC_DIVIDER,
		ZmComposeView.BC_HEADERS,
		ZmComposeView.BC_QUOTED_TEXT,
		ZmComposeView.BC_SIG_POST,
		ZmComposeView.BC_NOTHING
];

// Zero-width space character we can use to create invisible separators for text mode
// Note: as of 10/31/14, Chrome Canary does not recognize \u200B (though it does find \uFEFF)
ZmComposeView.BC_MARKER_CHAR = '\u200B';
ZmComposeView.BC_MARKER_REGEXP = new RegExp(ZmComposeView.BC_MARKER_CHAR, 'g');

// Create a unique marker sequence (vary by length) for each component, and regexes to find them
ZmComposeView.BC_TEXT_MARKER = {};
ZmComposeView.BC_TEXT_MARKER_REGEX1 = {};
ZmComposeView.BC_TEXT_MARKER_REGEX2 = {};

AjxUtil.foreach(ZmComposeView.BC_ALL_COMPONENTS, function(comp, index) {
	if (comp !== ZmComposeView.BC_NOTHING) {
		// Note: relies on BC_NOTHING coming first
		var markerChar = ZmComposeView.BC_MARKER_CHAR;
		var marker = ZmComposeView.BC_TEXT_MARKER[comp] = AjxStringUtil.repeat(markerChar, index);

		ZmComposeView.BC_TEXT_MARKER_REGEX1[comp] = new RegExp("^" + marker + "[^" + markerChar + "]");
		ZmComposeView.BC_TEXT_MARKER_REGEX2[comp] = new RegExp("[^" + markerChar + "]" + marker + "[^" + markerChar + "]");
	}
});

// HTML marker is an expando attr whose value is the name of the component
ZmComposeView.BC_HTML_MARKER_ATTR = "data-marker";

ZmComposeView.prototype._setBody1 =
function(action, msg, extraBodyText, noEditorUpdate, keepAttachments, extraBodyTextIsExternal) {
		
	var htmlMode = (this._composeMode === Dwt.HTML);
	var isDraft = (action === ZmOperation.DRAFT);
	var incOptions = this._controller._curIncOptions;

	// clear in case of switching from "as attachment" back to "include original message" or to "don't include original"
	this._msgAttId = null;

	if (extraBodyText) {
        // convert text if composing as HTML (check for opening < to see if content is already HTML, should work most of the time)
        if (extraBodyTextIsExternal && htmlMode && extraBodyText.charAt(0) !== '<') {
            extraBodyText = AjxStringUtil.convertToHtml(extraBodyText);
        }
		this.setComponent(ZmComposeView.BC_TEXT_PRE, this._normalizeText(extraBodyText, htmlMode));
	}

	var compList = ZmComposeView.BC_ALL_COMPONENTS;
		
	if (action === ZmOperation.DRAFT) {
		compList = [ZmComposeView.BC_QUOTED_TEXT];
	}
	else if (action === ZmOperation.REPLY_CANCEL) {
		compList = [ZmComposeView.BC_TEXT_PRE, ZmComposeView.BC_SIG_PRE, ZmComposeView.BC_SIG_POST];
	}
	else if (incOptions.what === ZmSetting.INC_NONE || incOptions.what === ZmSetting.INC_ATTACH) {
		compList = [ZmComposeView.BC_NOTHING, ZmComposeView.BC_TEXT_PRE, ZmComposeView.BC_SIG_PRE, ZmComposeView.BC_SIG_POST];
		if (this._msg && incOptions.what == ZmSetting.INC_ATTACH) {
			this._msgAttId = this._origMsg ? this._origMsg.id : this._msg.id;
		}
	}

	var isHtmlEditorInitd = this._htmlEditor && this._htmlEditor.isHtmlModeInited();
	if (this._htmlEditor && !noEditorUpdate && !isHtmlEditorInitd) {
		this._fixMultipartRelatedImages_onTimer(msg);
		this._htmlEditor.addOnContentInitializedListener(this._saveComponentContent.bind(this, true));
		//set timeout in case ZmHtmlEditor.prototype.onLoadContent is never called in which case the listener above won't be called.
		//but don't pass "force" so if the above was called first, don't do anything.
		window.setTimeout(this._saveComponentContent.bind(this), 3000);
	}

	var bodyInfo = {};
	var what = incOptions.what;
	if (msg && (what === ZmSetting.INC_BODY || what === ZmSetting.INC_SMART)) {
		bodyInfo = this._getBodyContent(msg, htmlMode, what);
	}
	var params = {action:action, msg:msg, incOptions:incOptions, bodyInfo:bodyInfo};
	var value = this._layoutBodyComponents(compList, null, params);
		
	if (this._htmlEditor && !noEditorUpdate) {
		this._htmlEditor.setContent(value);
	    if (!htmlMode && ZmComposeController.IS_REPLY[action]) {
                this._setBodyFieldCursor();
           }
	}
		
	if (isHtmlEditorInitd && !noEditorUpdate) {
		this._fixMultipartRelatedImages_onTimer(msg);
		this._saveComponentContent(true);
	}

	var ac = window.parentAppCtxt || window.appCtxt;
	var hasInlineImages = (bodyInfo.hasInlineImages) || !ac.get(ZmSetting.VIEW_AS_HTML);
	if (!keepAttachments) {
		//do not call this when switching between text and html editor.
		this._showForwardField(msg || this._msg, action, hasInlineImages, bodyInfo.hasInlineAtts);
	}

	var sigId = this._controller.getSelectedSignature();
	if (sigId && !isDraft) {
		this._attachSignatureVcard(sigId);
	}

	if (!this._htmlEditor && htmlMode) {
		// wrap <html> and <body> tags around content, and set font style
		value = ZmHtmlEditor._embedHtmlContent(value, true);
	}
				
	this._bodyContent[this._composeMode] = value;
};

/**
 * Sets the value of the given component.
 * 
 * @param {string}		comp		component identifier (ZmComposeView.BC_*)
 * @param {string}		compValue	value
 * @param {string}		mode		compose mode
 */
ZmComposeView.prototype.setComponent =
function(comp, compValue, mode) {

	this._components[Dwt.TEXT] = this._components[Dwt.TEXT] || {};
	this._components[Dwt.HTML] = this._components[Dwt.HTML] || {};

	mode = mode || this._composeMode;
	this._components[mode][comp] = compValue;
};

/**
 * Returns the current value of the given component.
 * 
 * @param {string}		comp		component identifier (ZmComposeView.BC_*)
 * @param {string}		mode		compose mode
 * @param {hash}		params		msg, include options, and compose mode
 */
ZmComposeView.prototype.getComponent =
function(comp, mode, params) {
		
	mode = mode || this._composeMode;
	var value = this._components[mode] && this._components[mode][comp];
	if (value || value === ZmComposeView.EMPTY) {
		return value === ZmComposeView.EMPTY ? "" : value;
	}

	switch (comp) {
		case ZmComposeView.BC_SIG_PRE: {
			return this._getSignatureComponent(ZmSetting.SIG_OUTLOOK, mode);
		}
		case ZmComposeView.BC_DIVIDER: {
			return this._getDivider(mode, params);
		}
		case ZmComposeView.BC_HEADERS: {
			return this._getHeaders(mode, params);
		}
		case ZmComposeView.BC_QUOTED_TEXT: {
			return this._getBodyComponent(mode, params || {});
		}
		case ZmComposeView.BC_SIG_POST:
			return this._getSignatureComponent(ZmSetting.SIG_INTERNET, mode);
	}
};

/**
 * Returns true if the given component is part of the compose body.
 * 
 * @param {string}		comp		component identifier (ZmComposeView.BC_*)
 */
ZmComposeView.prototype.hasComponent =
function(comp) {
	return AjxUtil.arrayContains(this._compList, comp);
};

/**
 * Takes the given list of components and returns the text that represents the aggregate of
 * their content.
 * 
 * @private
 * @param {array}	components		list of component IDs
 * @param {hash}	params			msg, include options, and compose mode
 */
ZmComposeView.prototype._layoutBodyComponents =
function(components, mode, params) {
		
	if (!(components && components.length)) {
		return "";
	}
		
	mode = mode || this._composeMode;
	var htmlMode = (mode === Dwt.HTML);
	this._headerText = "";
	this._compList = [];
	var value = "";
	var prevComp, prevValue;
	for (var i = 0; i < components.length; i++) {
		var comp = components[i];
		var compValue = this.getComponent(comp, mode, params) || "";
		var spacing = (prevComp && compValue) ? this._getComponentSpacing(prevComp, comp, prevValue, compValue) : "";
		if (compValue || (comp === ZmComposeView.BC_NOTHING)) {
			prevComp = comp;
			prevValue = compValue;
		}
		if (compValue) {
			if (!htmlMode) {
				compValue = this._getMarker(Dwt.TEXT, comp) + compValue;
			}
			value += spacing + compValue;
			this._compList.push(comp);
		}
	}

	return value;
};

ZmComposeView.prototype._getMarker =
function(mode, comp) {
	return (this._marker && this._marker[mode] &&  this._marker[mode][comp]) || "";
};

// Chart for determining number of blank lines between non-empty components.
ZmComposeView.BC_SPACING = AjxUtil.arrayAsHash(ZmComposeView.BC_ALL_COMPONENTS,
                                               function() { return Object() });

ZmComposeView.BC_SPACING[ZmComposeView.BC_NOTHING][ZmComposeView.BC_SIG_PRE]		= 2;
ZmComposeView.BC_SPACING[ZmComposeView.BC_NOTHING][ZmComposeView.BC_DIVIDER]		= 2;
ZmComposeView.BC_SPACING[ZmComposeView.BC_NOTHING][ZmComposeView.BC_SIG_POST]		= 2;
ZmComposeView.BC_SPACING[ZmComposeView.BC_TEXT_PRE][ZmComposeView.BC_SIG_PRE]		= 1;
ZmComposeView.BC_SPACING[ZmComposeView.BC_TEXT_PRE][ZmComposeView.BC_DIVIDER]		= 1;
ZmComposeView.BC_SPACING[ZmComposeView.BC_TEXT_PRE][ZmComposeView.BC_SIG_POST]		= 1;
ZmComposeView.BC_SPACING[ZmComposeView.BC_SIG_PRE][ZmComposeView.BC_DIVIDER]		= 1;
ZmComposeView.BC_SPACING[ZmComposeView.BC_DIVIDER][ZmComposeView.BC_QUOTED_TEXT]	= 1;
ZmComposeView.BC_SPACING[ZmComposeView.BC_HEADERS][ZmComposeView.BC_QUOTED_TEXT]	= 1;
ZmComposeView.BC_SPACING[ZmComposeView.BC_QUOTED_TEXT][ZmComposeView.BC_SIG_POST]	= 1;

// Returns the proper amount of space (blank lines) between two components.
ZmComposeView.prototype._getComponentSpacing =
function(comp1, comp2, val1, val2) {

	if (!(comp1 && comp2)) {
		return "";
	}
		
	val1 = val1 || !!(this.getComponent(comp1) || comp1 == ZmComposeView.BC_NOTHING);
	val2 = val2 || !!(this.getComponent(comp2) || comp2 == ZmComposeView.BC_NOTHING);
		
	var num = (val1 && val2) && ZmComposeView.BC_SPACING[comp1][comp2];
	// special case - HTML with headers or prefixes will create space after divider, so we don't need to add spacing
	var incOptions = this._controller._curIncOptions;
	var htmlMode = (this._composeMode === Dwt.HTML);
	if (htmlMode && comp1 === ZmComposeView.BC_DIVIDER && comp2 === ZmComposeView.BC_QUOTED_TEXT &&
			(incOptions.prefix || incOptions.headers)) {
		num = 0;
	}
	// minimize the gap between two BLOCKQUOTE sections (which have the blue line on the left)
	if (htmlMode && comp1 === ZmComposeView.BC_HEADERS && comp2 === ZmComposeView.BC_QUOTED_TEXT && incOptions.prefix) {
		num = 0;
	}

	return (num === 2) ? this._crlf2 : (num === 1) ? this._crlf : "";
};

ZmComposeView.prototype._getSignatureComponent =
function(style, mode) {
		
	var value = "";
	var ac = window.parentAppCtxt || window.appCtxt;
	var account = ac.multiAccounts && this.getFromAccount();
	if (ac.get(ZmSetting.SIGNATURES_ENABLED, null, account) && ac.get(ZmSetting.SIGNATURE_STYLE, null, account) === style) {
		var comp = (style === ZmSetting.SIG_OUTLOOK) ? ZmComposeView.BC_SIG_PRE : ZmComposeView.BC_SIG_POST;
		var params = {
			style:		style,
			account:	account,
			mode:		mode,
			marker:		this._getMarker(mode, comp)
		}
		value = this._getSignatureContentSpan(params);
	}
	return value;
};

ZmComposeView.prototype._getDivider =
function(mode, params) {

	mode = mode || this._composeMode;
	var htmlMode = (mode === Dwt.HTML);
	var action = (params && params.action) || this._action;
	var msg = (params && params.msg) || this._msg;
	var incOptions = (params && params.incOptions) || this._controller._curIncOptions;
	var preface = "";
	var marker = htmlMode && this._getMarker(mode, ZmComposeView.BC_DIVIDER);
	if (incOptions && incOptions.headers) {
		// divider is just a visual separator if there are headers below it
		if (htmlMode) {
			preface = '<hr id="' + AjxStringUtil.HTML_SEP_ID + '" ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">';
		} else {
			var msgText = (action === ZmOperation.FORWARD_INLINE) ? AjxMsg.forwardedMessage : AjxMsg.origMsg;
			preface = [ZmMsg.DASHES, " ", msgText, " ", ZmMsg.DASHES, this._crlf].join("");
		}
	}
	else if (msg) {
		// no headers, so summarize them by showing date, time, name, email
		var msgDate = msg.sentDate || msg.date;
		var now = new Date(msgDate);
		var date = AjxDateFormat.getDateInstance(AjxDateFormat.MEDIUM).format(now);
		var time = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT).format(now);
		var fromAddr = msg.getAddress(AjxEmailAddress.FROM);
		var fromName = fromAddr && fromAddr.getName();
		var fromEmail = fromAddr && fromAddr.getAddress();
		var address = fromName;
		if (fromEmail) {
			fromEmail = htmlMode ? AjxStringUtil.htmlEncode("<" + fromEmail + ">") : fromEmail;
			address = [address, fromEmail].join(" "); 
		}
		preface = AjxMessageFormat.format(ZmMsg.replyPrefix, [date, time, address]);
		preface += this._crlf;
		if (htmlMode) {
			preface = '<span id="' + AjxStringUtil.HTML_SEP_ID + '" ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">' + preface + '</span>';
		}
	}
		
	return preface;
};

ZmComposeView.prototype._getHeaders =
function(mode, params) {

	mode = mode || this._composeMode;
	var htmlMode = (mode === Dwt.HTML);
	params = params || {};
	var action = (params && params.action) || this._action;
	var msg = (params && params.msg) || this._msg;
	var incOptions = (params && params.incOptions) || this._controller._curIncOptions;

	var value = "";
	var headers = [];
	if (incOptions.headers && msg) {
		for (var i = 0; i < ZmComposeView.QUOTED_HDRS.length; i++) {
			var hdr = msg.getHeaderStr(ZmComposeView.QUOTED_HDRS[i], htmlMode);
			if (hdr) {
				headers.push(hdr);
			}
		}
	}

	if (headers.length) {
		//TODO: this could be simplified and maybe refactored with the similar code in _getBodyComponent()
		//(see bug 91743)
		//Revisit this after the release.
		var text = headers.join(this._crlf) + this._crlf;
		var wrapParams = {
			text:				text,
			preserveReturns:	true,
			htmlMode:			htmlMode,
			isHeaders:			true
		}
		var marker = this._getMarker(Dwt.HTML, ZmComposeView.BC_HEADERS);
		if (incOptions.prefix) {
			incOptions.pre = !htmlMode && appCtxt.get(ZmSetting.REPLY_PREFIX);
			wrapParams.prefix = incOptions.pre;
			if (htmlMode) {
				wrapParams.before = '<div ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">' + AjxStringUtil.HTML_QUOTE_PREFIX_PRE;
				wrapParams.after = AjxStringUtil.HTML_QUOTE_PREFIX_POST + '</div>';
			}
			value = AjxStringUtil.wordWrap(wrapParams);
		}
		else if (htmlMode) {
			wrapParams.before = '<div ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">';
			wrapParams.after = '</div>';
			value = AjxStringUtil.wordWrap(wrapParams);
		}
		else {
			value = text;
		}
	}

	return value;
};

ZmComposeView.prototype._getBodyComponent =
function(mode, params) {

	mode = mode || this._composeMode;
	params = params || {};
	var action = (params && params.action) || this._action;
	var htmlMode = (mode === Dwt.HTML);
	var msg = (params && params.msg) || this._msg;
	var incOptions = (params && params.incOptions) || this._controller._curIncOptions;
	var what = incOptions.what;
	var bodyInfo = params.bodyInfo || this._getBodyContent(msg, htmlMode, what);

	var value = "";
	var body = "";
	if (msg && (what === ZmSetting.INC_BODY || what === ZmSetting.INC_SMART)) {
		body = bodyInfo.body;
		// Bug 7160: Strip off the ~*~*~*~ from invite replies.
		if (ZmComposeController.IS_INVITE_REPLY[action]) {
			body = body.replace(ZmItem.NOTES_SEPARATOR, "");
		}
		if (htmlMode && body) {
			body = this._normalizeText(body, htmlMode);
		}
	}

	body = AjxStringUtil.trim(body);
	if (body) {
		//TODO: this could be simplified and maybe refactored with the similar code in _getHeaders()
		//(see bug 91743)
		//Revisit this after the release.
		var wrapParams = {
			text:				body,
			preserveReturns:	true,
			htmlMode:			htmlMode
		}
		if (htmlMode) {
			var marker = this._getMarker(Dwt.HTML, ZmComposeView.BC_QUOTED_TEXT);
			if (incOptions.prefix) {
				wrapParams.before = '<div ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">' + AjxStringUtil.HTML_QUOTE_PREFIX_PRE;
				wrapParams.after = AjxStringUtil.HTML_QUOTE_PREFIX_POST + '</div>';
				wrapParams.prefix = appCtxt.get(ZmSetting.REPLY_PREFIX);
			}
			else {
				wrapParams.before = '<div ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">';
				wrapParams.after = '</div>';
			}
			value = AjxStringUtil.wordWrap(wrapParams);
		}
		else {
			if (incOptions.prefix) {
				wrapParams.prefix = appCtxt.get(ZmSetting.REPLY_PREFIX);
				value = AjxStringUtil.wordWrap(wrapParams);
			}
			else {
				value = body;
			}
		}
	}

	return value;
};

// Removes the invisible markers we use in text mode, since we should not send those out as part of the msg
ZmComposeView.prototype._removeMarkers =
function(text) {
	return text.replace(ZmComposeView.BC_MARKER_REGEXP, '');
};

ZmComposeView.prototype._normalizeText =
function(text, isHtml) {
		
	text = AjxStringUtil.trim(text);
	if (isHtml) {
        text = AjxStringUtil.trimHtml(text);
	}
	else {
		text = this._removeMarkers(text);
		text = text.replace(/\n+$/g, "\n");	// compress trailing line returns
	}

	return AjxStringUtil._NON_WHITESPACE.test(text) ? text + this._crlf : "";
};

/**
 * Returns the value of the given component as extracted from the content of the editor.
 * 
 * @param {string}		comp		component identifier (ZmComposeView.BC_*)
 */
ZmComposeView.prototype.getComponentContent =
function(comp) {
	
	var htmlMode = (this._composeMode === Dwt.HTML);
	var content = this._getEditorContent(true);
	var compContent = "";

	var firstComp = this._compList[0];
	for (var i = 0; i < this._compList.length; i++) {
		if (this._compList[i] === comp) { break; }
	}
	var nextComp = this._compList[i + 1];
	var lastComp = this._compList[this._compList.length - 1];
	
	if (htmlMode) {
		var marker = this._getMarker(this._composeMode, comp);
		var idx1 = content.indexOf(marker);
		if (idx1 !== -1) {
			var chunk = content.substring(0, idx1);
			// found the marker (an element ID), now back up to opening of tag
			idx1 = chunk.lastIndexOf("<");
			if (idx1 !== -1) {
				if (comp === lastComp) {
					compContent = content.substring(idx1);
				}
				else {
					marker = this._getMarker(Dwt.HTML, nextComp);
					var idx2 = marker && content.indexOf(marker);
					if (idx2 !== -1) {
						chunk = content.substring(0, idx2);
						idx2 = chunk.lastIndexOf("<");
						if (idx2 !== -1) {
							compContent = content.substring(idx1, idx2);
						}
					}
				}
			}
		}
	}
	else {
		// In text mode, components are separated by markers which are varying lengths of a zero-width space
		var marker1 = this._getMarker(this._composeMode, comp),
			regex1 = ZmComposeView.BC_TEXT_MARKER_REGEX1[comp],     // matches marker at beginning
			regex2 = ZmComposeView.BC_TEXT_MARKER_REGEX2[comp],     // matches marker elsewhere
			start, marker2;

		var prePreText = "";
		// look for this component's marker
		if (regex1.test(content)) {
			// found it at the start of content
			start = marker1.length;
		}
		else if (regex2.test(content)) {
			// found it somewhere after the start
			var markerIndex = content.search(regex2) + 1; // add one to account for non-matching char at beginning of regex
			start = markerIndex + marker1.length;
			if (comp === ZmComposeView.BC_TEXT_PRE) {
				//special case - include stuff before the first marker for the pre text (user can add stuff before it by clicking and/or moving the cursor beyond the invisible marker)
				prePreText = content.substring(0, markerIndex);
			}
		}
		if (start > 0) {
			marker2 = this._getMarker(this._composeMode, nextComp);
			// look for the next component's marker so we know where this component's content ends
			regex2 = marker2 && ZmComposeView.BC_TEXT_MARKER_REGEX2[nextComp];
			idx2 = regex2 && content.search(regex2) + 1;
			if (idx2) {
				// found it, take what's in between
				compContent = content.substring(start, idx2);
			}
			else {
				// this comp is last component
				compContent = content.substr(start);
			}
			compContent = prePreText + compContent;
		}
	}

	return this._normalizeText(compContent, htmlMode);
};

ZmComposeView.prototype._saveComponentContent =
function(force) {
	if (this._compContent && !force) {
		return;
	}
	this._compContent = {};
	for (var i = 0; i < this._compList.length; i++) {
		var comp = this._compList[i];
		this._compContent[comp] = this.getComponentContent(comp);
	}
};

ZmComposeView.prototype.componentContentChanged =
function(comp) {
	return this._compContent && this.hasComponent(comp) && (this._compContent[comp] !== this.getComponentContent(comp));
};

/**
 * Returns text that the user has typed into the editor, as long as it comes first.
 */
ZmComposeView.prototype.getUserText =
function() {
		
	var htmlMode = (this._composeMode === Dwt.HTML);
	var content = this._getEditorContent(true);
	var userText = content;
	if (htmlMode) {
		var firstComp;
		for (var i = 0; i < this._compList.length; i++) {
			if (this._compList[i] !== ZmComposeView.BC_TEXT_PRE) {
				firstComp = this._compList[i];
				break;
			}
		}
		var marker = this._getMarker(this._composeMode, firstComp);
		var idx = content.indexOf(marker);
		if (idx !== -1) {
			var chunk = content.substring(0, idx);
			// found the marker (an element ID), now back up to opening of tag
			idx = chunk.lastIndexOf("<");
			if (idx !== -1) {
				// grab everything before the marked element
				userText = chunk.substring(0, idx);
			}
		}
	}
	else {
		if (this.hasComponent(ZmComposeView.BC_TEXT_PRE)) {
			userText = this.getComponentContent(ZmComposeView.BC_TEXT_PRE);
		}
		else if (this._compList.length > 0) {
			var idx = content.indexOf(this._getMarker(this._composeMode, this._compList[0]));
			if (idx !== -1) {
				userText = content.substring(0, idx);
			}
		}
	}
				
	return this._normalizeText(userText, htmlMode);
};

// Returns the block of quoted text from the editor, so that we can see if the user has changed it.
ZmComposeView.prototype._getQuotedText =
function() {
	return this.getComponentContent(ZmComposeView.BC_QUOTED_TEXT);
};

// If the user has changed the section of quoted text (eg by inline replying), preserve the changes
// across whatever operation the user is performing. If we're just checking whether changes can be
// preserved, return true if they can be preserved (otherwise we need to warn the user).
ZmComposeView.prototype._preserveQuotedText =
function(op, quotedText, check) {

	var savedQuotedText = this._compContent && this._compContent[ZmComposeView.BC_QUOTED_TEXT];
	if (check && !savedQuotedText) {
		return true;
	}
	quotedText = quotedText || this._getQuotedText();
	var changed = (quotedText !== savedQuotedText);
	if (check && (!quotedText || !changed)) {
		return true;
	}

	// track whether user has changed quoted text during this compose session
	this._quotedTextChanged = this._quotedTextChanged || changed;

	if (op === ZmId.OP_ADD_SIGNATURE || op === ZmOperation.INCLUDE_HEADERS || (this._quotedTextChanged && !changed)) {
		// just retain quoted text as is, no conversion needed
	}
	if (op === ZmOperation.USE_PREFIX) {
		if (check) {
			return true;
		}
		var htmlMode = (this._composeMode === Dwt.HTML);
		var incOptions = this._controller._curIncOptions;
		if (incOptions.prefix) {
			var wrapParams = {
				text:				quotedText,
				htmlMode:			htmlMode,
				preserveReturns:	true,
				prefix:				appCtxt.get(ZmSetting.REPLY_PREFIX)
			}
			if (htmlMode) {
				var marker = this._getMarker(Dwt.HTML, ZmComposeView.BC_QUOTED_TEXT);
				wrapParams.before = '<div ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">' + AjxStringUtil.HTML_QUOTE_PREFIX_PRE;
				wrapParams.after = AjxStringUtil.HTML_QUOTE_PREFIX_POST + '</div>';
			}
			quotedText = AjxStringUtil.wordWrap(wrapParams);
		}
		else {
			if (htmlMode) {
				quotedText = this._removeHtmlPrefix(quotedText);
			}
			else {
				// remove leading > or | (prefix) with optional space after it (for text there's a space, for additional level prefix there isn't)
				quotedText = quotedText.replace(/^[>|] ?/, "");
				quotedText = quotedText.replace(/\n[>|] ?/g, "\n");
			}
		}
	}
	else if (ZmComposeController.INC_MAP[op]) {
		return false;
	}
	else if (op === ZmOperation.FORMAT_HTML || op === ZmOperation.FORMAT_TEXT) {
		if (check) {
			return true;
		}
		if (op === ZmOperation.FORMAT_HTML) {
			var marker = this._getMarker(Dwt.HTML, ZmComposeView.BC_QUOTED_TEXT);
			var openTag =  AjxStringUtil.HTML_QUOTE_PREFIX_PRE;
			var closeTag = AjxStringUtil.HTML_QUOTE_PREFIX_POST;
			quotedText = AjxStringUtil.convertToHtml(quotedText, true, openTag, closeTag);
			quotedText = '<div ' + ZmComposeView.BC_HTML_MARKER_ATTR + '="' + marker + '">' + quotedText + '</div>';
		}
		else {
			quotedText = this._htmlToText(quotedText);
		}
	}

	if (!check) {
		this.setComponent(ZmComposeView.BC_QUOTED_TEXT, quotedText || ZmComposeView.EMPTY);
	}
		
	return true;
};

// Removes the first level of <blockquote> styling
ZmComposeView.prototype._removeHtmlPrefix =
function(html, prefixEl) {
	prefixEl = prefixEl || "blockquote";
	var oldDiv = Dwt.parseHtmlFragment(html);
	var newDiv = document.createElement("div");
	newDiv[ZmComposeView.BC_HTML_MARKER_ATTR] = this._getMarker(Dwt.HTML, ZmComposeView.BC_QUOTED_TEXT);
	while (oldDiv.childNodes.length) {
		var el = oldDiv.childNodes[0];
		if (el.nodeName.toLowerCase() === prefixEl) {
			while (el.childNodes.length) {
				newDiv.appendChild(el.removeChild(el.childNodes[0]));
			}
			oldDiv.removeChild(el);
		}
		else {
			newDiv.appendChild(oldDiv.removeChild(el));
		}
	}
	
	return newDiv.outerHTML;
};

/**
 * Returns true unless changes have been made to quoted text and they cannot be preserved.
 * 
 * @param 	{string}	op			action user is performing
 * @param	{string}	quotedText	quoted text (optional)
 */
ZmComposeView.prototype.canPreserveQuotedText =
function(op, quotedText) {
	return this._preserveQuotedText(op, quotedText, true);
};

ZmComposeView.prototype._getBodyContent =
function(msg, htmlMode, incWhat) {

	var body, bodyPart, hasInlineImages, hasInlineAtts;
	var crlf = htmlMode ? AjxStringUtil.CRLF_HTML : AjxStringUtil.CRLF;
	var crlf2 = htmlMode ? AjxStringUtil.CRLF2_HTML : AjxStringUtil.CRLF2;
	var getOrig = (incWhat === ZmSetting.INC_SMART);

	var content;
		
	// bug fix #7271 - if we have multiple body parts, append them all first
	var parts = msg.getBodyParts();
	if (msg.hasMultipleBodyParts()) {
		var bodyArr = [];
		for (var k = 0; k < parts.length; k++) {
			var part = parts[k];
			// bug: 28741
			if (ZmMimeTable.isRenderableImage(part.contentType)) {
				bodyArr.push([crlf, "[", part.contentType, ":", (part.fileName || "..."), "]", crlf].join(""));
				hasInlineImages = true;
			} else if (part.fileName && part.contentDisposition === "inline") {
				var attInfo = ZmMimeTable.getInfo(part.contentType);
				attInfo = attInfo ? attInfo.desc : part.contentType;
				bodyArr.push([crlf, "[", attInfo, ":", (part.fileName||"..."), "]", crlf].join(""));
				hasInlineAtts = true;
			} else if (part.contentType === ZmMimeTable.TEXT_PLAIN || (part.body && ZmMimeTable.isTextType(part.contentType))) {
				content = getOrig ? AjxStringUtil.getOriginalContent(part.getContent(), false) : part.getContent();
				bodyArr.push( htmlMode ? AjxStringUtil.convertToHtml(content) : content );
			} else if (part.contentType === ZmMimeTable.TEXT_HTML) {
				content = getOrig ? AjxStringUtil.getOriginalContent(part.getContent(), true) : part.getContent();
				if (htmlMode) {
					bodyArr.push(content);
				} else {
					var div = document.createElement("div");
					div.innerHTML = content;
					bodyArr.push(AjxStringUtil.convertHtml2Text(div));
				}
			}
		}
		body = bodyArr.join(crlf);
	} else {
		// at this point, we should have the type of part we want if we're dealing with multipart/alternative
		if (htmlMode) {
			content = msg.getBodyContent(ZmMimeTable.TEXT_HTML);
			if (!content) {
				// just grab the first body part and convert it to HTML
				content = AjxStringUtil.convertToHtml(msg.getBodyContent());
			}
			body = getOrig ? AjxStringUtil.getOriginalContent(content, true) : content;
		} else {
			hasInlineImages = msg.hasInlineImagesInMsgBody();
			bodyPart = msg.getTextBodyPart();
			if (bodyPart) {
				// cool, got a textish body part
				content = bodyPart.getContent();
			}
			else {
				// if we can find an HTML body part, convert it to text
				var html = msg.getBodyContent(ZmMimeTable.TEXT_HTML, true);
				content = html ? this._htmlToText(html) : "";
			}
			content = content || msg.getBodyContent();	// just grab first body part
			body = getOrig ? AjxStringUtil.getOriginalContent(content, false) : content;
		}
	}

	body = body || "";
		
	if (bodyPart && AjxUtil.isObject(bodyPart) && bodyPart.isTruncated) {
		body += crlf2 + ZmMsg.messageTruncated + crlf2;
	}
		
	if (!this._htmlEditor && this.getComposeMode() === Dwt.HTML) {
		// strip wrapper tags from original msg
		body = body.replace(/<\/?(html|head|body)[^>]*>/gi, '');
	}

	return {body:body, bodyPart:bodyPart, hasInlineImages:hasInlineImages, hasInlineAtts:hasInlineAtts};
};

ZmComposeView.BQ_BEGIN	= "BQ_BEGIN";
ZmComposeView.BQ_END	= "BQ_END";

ZmComposeView.prototype._htmlToText =
function(html) {

	var convertor = {
		"blockquote": function(el) {
			return "\n" + ZmComposeView.BQ_BEGIN + "\n";
		},
		"/blockquote": function(el) {
			return "\n" + ZmComposeView.BQ_END + "\n";
		},
		"_after": AjxCallback.simpleClosure(this._applyHtmlPrefix, this, ZmComposeView.BQ_BEGIN, ZmComposeView.BQ_END)
	}
	return AjxStringUtil.convertHtml2Text(html, convertor);
};

ZmComposeView.prototype._applyHtmlPrefix =
function(tagStart, tagEnd, text) {

	var incOptions = this._controller._curIncOptions;
	if (incOptions && incOptions.prefix) {
		var wrapParams = {
			preserveReturns:	true,
			prefix:				appCtxt.get(ZmSetting.REPLY_PREFIX)
		}

		var lines = text.split("\n");
		var level = 0;
		var out = [];
		var k = 0;
		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];
			if (line === tagStart) {
				level++;
			} else if (line === tagEnd) {
				level--;
			} else {
				if (!line) {
					var lastLine = lines[i-1];
					if (lastLine && (lastLine !== tagStart && lastLine !== tagEnd)) {
						out[k++] = line;
					}
				} else {
					for (var j = 0; j < level; j++) {
						wrapParams.text = line;
						line = AjxStringUtil.wordWrap(wrapParams);
					}
					line = line.replace(/^\n|\n$/, "");
					out[k++] = line;
				}
			}
		}
		return out.join("\n");
	} else {
		return text.replace(tagStart, "").replace(tagEnd, "");
	}
};

/**
 * Reconstructs the content of the body area after some sort of change (for example: format,
 * signature, or include options).
 * 
 * @param {string}			action				compose action
 * @param {ZmMailMsg}		msg					original msg (in case of reply)
 * @param {string}			extraBodyText		canned text to include
 * @param {hash}			incOptions			include options
 * @param {boolean}			keepAttachments		do not cleanup the attachments
 * @param {boolean}			noEditorUpdate		if true, do not change content of HTML editor
 */
ZmComposeView.prototype.resetBody =
function(params, noEditorUpdate) {

	params = params || {};
	var action = params.action || this._origAction || this._action;
	if (this._action === ZmOperation.DRAFT) {
		action = this._origAction;
	}
	var msg = (this._action === ZmOperation.DRAFT) ? this._origMsg : params.msg || this._origMsg;
	var incOptions = params.incOptions || this._controller._curIncOptions;
		
	this._components = {};
	
	this._preserveQuotedText(params.op, params.quotedText);
	if (!params.keepAttachments) {
		this.cleanupAttachments(true);
	}
	this._isDirty = this._isDirty || this.isDirty();
	this._setBody(action, msg, params.extraBodyText, noEditorUpdate, params.keepAttachments);
	this._setFormValue();
	this._resetBodySize();
};

/**
 * Removes the attachment corresponding to the original message.
 */
ZmComposeView.prototype.removeOrigMsgAtt = function() {

    for (var i = 0; i < this._partToAttachmentMap.length; i++) {
        var att = this._partToAttachmentMap[i];
        if (att.rfc822Part && this._origMsgAtt && att.sizeInBytes === this._origMsgAtt.size) {
            this._removeAttachedMessage(att.spanId);
        }
    }
};

// Generic routine for attaching an event handler to a field. Since "this" for the handlers is
// the incoming event, we need a way to get at ZmComposeView, so it's added to the event target.
ZmComposeView.prototype._setEventHandler =
function(id, event, addrType) {
	var field = document.getElementById(id);
	field._composeViewId = this._htmlElId;
	if (addrType) {
		field._addrType = addrType;
	}
	var lcEvent = event.toLowerCase();
	field[lcEvent] = ZmComposeView["_" + event];
};

ZmComposeView.prototype._setBodyFieldCursor =
function(extraBodyText) {

	if (this._composeMode === Dwt.HTML) { return; }

	// this code moves the cursor to the beginning of the body
	if (AjxEnv.isIE) {
		var tr = this._bodyField.createTextRange();
		if (extraBodyText) {
			tr.move('character', extraBodyText.length + 1);
		} else {
			tr.collapse(true);
		}
		tr.select();
	} else {
		var index = extraBodyText ? (extraBodyText.length + 1) : 0;
		Dwt.setSelectionRange(this._bodyField, index, index);
	}
};

/**
 * This should be called only once for when compose view loads first time around
 * 
 * @private
 */
ZmComposeView.prototype._initialize =
function(composeMode, action) {

	this._internalId = AjxCore.assignId(this);

	// init html
	this._createHtml();

	// init drag and drop
	this._initDragAndDrop();

	// init compose view w/ based on user prefs
	var bComposeEnabled = appCtxt.get(ZmSetting.HTML_COMPOSE_ENABLED);
	var composeFormat = appCtxt.get(ZmSetting.COMPOSE_AS_FORMAT);
	var defaultCompMode = bComposeEnabled && composeFormat === ZmSetting.COMPOSE_HTML
		? Dwt.HTML : Dwt.TEXT;
	this._composeMode = composeMode || defaultCompMode;
	this._clearFormValue();

	// init html editor
	var attmcallback =
		this.showAttachmentDialog.bind(this, ZmComposeView.UPLOAD_INLINE);

	// Focus on the editor body if its not a new message/forwarded message (where it focuses on the 'To' field).
	var autoFocus = (action !== ZmOperation.NEW_MESSAGE) &&
					(action !== ZmOperation.FORWARD_INLINE) &&
					(action !== ZmOperation.FORWARD_ATT);

	this._htmlEditor =
		new ZmHtmlEditor({
			parent: this,
			posStyle: DwtControl.RELATIVE_STYLE,
			mode: this._composeMode,
			autoFocus: autoFocus,
			initCallback: this._controlListener.bind(this),
			pasteCallback: this._uploadDoneCallback.bind(this),
			attachmentCallback: attmcallback
		});
	this._bodyFieldId = this._htmlEditor.getBodyFieldId();
	this._bodyField = document.getElementById(this._bodyFieldId);
	this._includedPreface = "";
	
	this._marker = {};
	this._marker[Dwt.TEXT] = ZmComposeView.BC_TEXT_MARKER;
	this._marker[Dwt.HTML] = {};
	for (var i = 0; i < ZmComposeView.BC_ALL_COMPONENTS.length; i++) {
		var comp = ZmComposeView.BC_ALL_COMPONENTS[i];
		this._marker[Dwt.HTML][comp] = '__' + comp + '__';
	}
	
	// misc. inits
	this.setScrollStyle(DwtControl.SCROLL);
	this._attachCount = 0;

	// init listeners
	this.addControlListener(new AjxListener(this, this._controlListener));
};

ZmComposeView.prototype._createHtml =
function(templateId) {

	var data = {
		id:					this._htmlElId,
		headerId:			ZmId.getViewId(this._view, ZmId.CMP_HEADER),
		fromSelectId:		ZmId.getViewId(this._view, ZmId.CMP_FROM_SELECT),
		toRowId:			ZmId.getViewId(this._view, ZmId.CMP_TO_ROW),
		toPickerId:			ZmId.getViewId(this._view, ZmId.CMP_TO_PICKER),
		toInputId:			ZmId.getViewId(this._view, ZmId.CMP_TO_INPUT),
		toCellId:			ZmId.getViewId(this._view, ZmId.CMP_TO_CELL),
		ccRowId:			ZmId.getViewId(this._view, ZmId.CMP_CC_ROW),
		ccPickerId:			ZmId.getViewId(this._view, ZmId.CMP_CC_PICKER),
		ccInputId:			ZmId.getViewId(this._view, ZmId.CMP_CC_INPUT),
		ccCellId:			ZmId.getViewId(this._view, ZmId.CMP_CC_CELL),
		bccRowId:			ZmId.getViewId(this._view, ZmId.CMP_BCC_ROW),
		bccPickerId:		ZmId.getViewId(this._view, ZmId.CMP_BCC_PICKER),
		bccInputId:			ZmId.getViewId(this._view, ZmId.CMP_BCC_INPUT),
		bccCellId:			ZmId.getViewId(this._view, ZmId.CMP_BCC_CELL),
		subjectRowId:		ZmId.getViewId(this._view, ZmId.CMP_SUBJECT_ROW),
		subjectInputId:		ZmId.getViewId(this._view, ZmId.CMP_SUBJECT_INPUT),
		oboRowId:			ZmId.getViewId(this._view, ZmId.CMP_OBO_ROW),
		oboCheckboxId:		ZmId.getViewId(this._view, ZmId.CMP_OBO_CHECKBOX),
		oboLabelId:			ZmId.getViewId(this._view, ZmId.CMP_OBO_LABEL),
		identityRowId:		ZmId.getViewId(this._view, ZmId.CMP_IDENTITY_ROW),
		identitySelectId:	ZmId.getViewId(this._view, ZmId.CMP_IDENTITY_SELECT),
		replyAttRowId:		ZmId.getViewId(this._view, ZmId.CMP_REPLY_ATT_ROW),
		attRowId:			ZmId.getViewId(this._view, ZmId.CMP_ATT_ROW),
		attDivId:			ZmId.getViewId(this._view, ZmId.CMP_ATT_DIV),
		attBtnId:			ZmId.getViewId(this._view, ZmId.CMP_ATT_BTN)
	};

	this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

ZmComposeView.prototype._addSendAsAndSendOboAddresses  =
function(menu) {

	var optData = null;
	var myDisplayName = appCtxt.getUsername();
	this._addSendAsOrSendOboAddresses(menu, appCtxt.sendAsEmails, false, function(addr, displayName) {
		return displayName ? AjxMessageFormat.format(ZmMsg.sendAsAddress, [addr, displayName]) : addr;
	});
	this._addSendAsOrSendOboAddresses(menu, appCtxt.sendOboEmails, true, function(addr, displayName) {
		return  AjxMessageFormat.format(displayName ? ZmMsg.sendOboAddressAndDispName : ZmMsg.sendOboAddress, [myDisplayName, addr, displayName]);
	});
};

ZmComposeView.prototype._addSendAsOrSendOboAddresses  =
function(menu, emails, isObo, displayValueFunc) {
	for (var i = 0; i < emails.length; i++) {
		var email = emails[i];
		var addr = email.addr;
		var extraData = {isDL: email.isDL, isObo: isObo};
		var displayValue = displayValueFunc(addr, email.displayName);
		var optData = new DwtSelectOptionData(addr, displayValue, null, null, null, null, extraData);
		menu.addOption(optData);
	}
};


ZmComposeView.prototype._createHtmlFromTemplate =
function(templateId, data) {

	DwtComposite.prototype._createHtmlFromTemplate.call(this, templateId, data);

	// global identifiers
	this._identityDivId = data.identityRowId;

	this._recipients.createRecipientHtml(this, this._view, data.id, ZmMailMsg.COMPOSE_ADDRS);
	this._acAddrSelectList = this._recipients.getACAddrSelectList();

	// save reference to DOM objects per ID's
	this._headerEl = document.getElementById(data.headerId);
	this._subjectField = document.getElementById(data.subjectInputId);
	this._oboRow = document.getElementById(data.oboRowId);
	this._oboCheckbox = document.getElementById(data.oboCheckboxId);
	this._oboLabel = document.getElementById(data.oboLabelId);
	this._attcDiv = document.getElementById(data.attDivId);
	this._attcBtn = document.getElementById(data.attBtnId);

	this._setEventHandler(data.subjectInputId, "onKeyUp");
	this._setEventHandler(data.subjectInputId, "onFocus");

	if (appCtxt.multiAccounts) {
		if (!this._fromSelect) {
			this._fromSelect = new DwtSelect({parent:this, index: 0, id:this.getHTMLElId() + "_fromSelect", parentElement:data.fromSelectId});
			//this._addSendAsAndSendOboAddresses(this._fromSelect);
			this._fromSelect.addChangeListener(new AjxListener(this, this._handleFromListener));
			this._recipients.attachFromSelect(this._fromSelect);
		}
	} else {
		// initialize identity select
		var identityOptions = this._getIdentityOptions();
		this.identitySelect = new DwtSelect({parent:this, index: 0, id:this.getHTMLElId() + "_identitySelect", options:identityOptions});
		this._addSendAsAndSendOboAddresses(this.identitySelect);
		this.identitySelect.setToolTipContent(ZmMsg.chooseIdentity, true);

		if (!this._identityChangeListenerObj) {
			this._identityChangeListenerObj = new AjxListener(this, this._identityChangeListener);
		}
		var ac = window.parentAppCtxt || window.appCtxt;
		var accounts = ac.accountList.visibleAccounts;
		for (var i = 0; i < accounts.length; i++) {
			var identityCollection = ac.getIdentityCollection(accounts[i]);
			identityCollection.addChangeListener(this._identityChangeListenerObj);
		}

		this.identitySelect.replaceElement(data.identitySelectId);
		this._setIdentityVisible();
	}

	var attButtonId = ZmId.getButtonId(this._view, ZmId.CMP_ATT_BTN);
	this._attButton = new DwtButton({parent:this, id:attButtonId});
	this._attButton.setText(ZmMsg.attach);

	this._attButton.setMenu(new AjxCallback(this, this._attachButtonMenuCallback));
	this._attButton.reparentHtmlElement(data.attBtnId);
	this._attButton.setToolTipContent(ZmMsg.attach, true);
	this._attButton.addSelectionListener(
		this.showAttachmentDialog.bind(this, ZmComposeView.UPLOAD_COMPUTER, false)
	);
};

ZmComposeView.prototype._initDragAndDrop =
function() {
	this._dnd = new ZmDragAndDrop(this);
};

ZmComposeView.prototype.collapseAttMenu =
function() {
	var menu = this._attButton && this._attButton.getMenu();
	menu.popdown();
};

ZmComposeView.prototype._handleFromListener =
function(ev) {
	var newVal = ev._args.newValue;
	var oldVal = ev._args.oldValue;
	if (oldVal === newVal) { return; }

	var ac = window.parentAppCtxt || window.appCtxt;
	var newOption = this._fromSelect.getOptionWithValue(newVal);
	var newAccount = ac.accountList.getAccount(newOption.accountId);
	var collection = ac.getIdentityCollection(newAccount);
	var identity = collection && collection.getById(newVal);

	var sigId = this._getSignatureIdForAction(identity || collection.defaultIdentity) || "";

	this._controller._accountName = newAccount.name;
	this._controller.resetSignatureToolbar(sigId, newAccount);
	this._controller.resetSignature(sigId, newAccount);
	this._controller._resetReadReceipt(newAccount);

	// reset account for autocomplete to use
	if (this._acAddrSelectList) {
		this._acAddrSelectList.setActiveAccount(newAccount);
	}

	// if this message is a saved draft, check whether it needs to be moved
	// based on newly selected value.
	if (this._msg && this._msg.isDraft) {
		var oldOption = this._fromSelect.getOptionWithValue(oldVal);
		var oldAccount = ac.accountList.getAccount(oldOption.accountId);

		// cache old info so we know what to delete after new save
		var msgId = this._origAcctMsgId = this._msg.id;

		this._msg = this._origMsg = null;
		var callback = new AjxCallback(this, this._handleMoveDraft, [oldAccount.name, msgId]);
		this._controller.saveDraft(this._controller._draftType, null, null, callback);
	}

	this._recipients.resetPickerButtons(newAccount);
};

ZmComposeView.prototype._handleMoveDraft =
function(accountName, msgId) {
	var jsonObj = {
		ItemActionRequest: {
			_jsns:  "urn:zimbraMail",
			action: { id:msgId, op:"delete" }
		}
	};
	var params = {
		jsonObj: jsonObj,
		asyncMode: true,
		accountName: accountName
	};
	appCtxt.getAppController().sendRequest(params);
};


ZmComposeView.prototype._createAttachMenuItem =
function(menu, text, listner) {
	var item = DwtMenuItem.create({parent:menu, text:text});
	item.value = text;
	if (listner) {
		item.addSelectionListener(listner);
	}
	return item;
};

ZmComposeView.prototype._startUploadAttachment =
function() {
	this._attButton.setEnabled(false);
	this.enableToolbarButtons(this._controller, false);
	this._controller._uploadingProgress = true;
};

ZmComposeView.prototype.checkAttachments =
function() {
	if (!this._attachCount) { return; }
};

ZmComposeView.prototype.updateAttachFileNode =
function(files,index, aid) {
	var curFileName = this._clipFile(files[index].name, true);

	this._loadingSpan.firstChild.innerHTML = curFileName;
	this._loadingSpan.firstChild.nextSibling.innerHTML = curFileName;
    // Set the next files progress back to 0
    this._setLoadingProgress(this._loadingSpan, 0);
    if (aid){
        var prevFileName = this._clipFile(files[index-1].name, true);
        var element = document.createElement("span");
        element.innerHTML = AjxTemplate.expand("mail.Message#MailAttachmentBubble", {fileName:prevFileName, id:aid});
        var newSpan = element.firstChild;
        if (this._loadingSpan.nextSibling) {
            this._loadingSpan.parentNode.insertBefore(newSpan, this._loadingSpan.nextSibling);
        } else {
            this._loadingSpan.parentNode.appendChild(element);
        }
        // Set the previous files progress to 100%
        this._setLoadingProgress(newSpan, 1);
    }

};

ZmComposeView.prototype.enableToolbarButtons =
function(controller, enabled) {
	var toolbar = controller._toolbar;
	var sendLater = appCtxt.get(ZmSetting.MAIL_SEND_LATER_ENABLED);
	toolbar.getButton(sendLater ? ZmId.OP_SEND_MENU : ZmId.OP_SEND).setEnabled(enabled);
	toolbar.getButton(ZmId.OP_SAVE_DRAFT).setEnabled(enabled);
	var optionsButton = toolbar.getButton(ZmId.OP_COMPOSE_OPTIONS);
	if (optionsButton) {
		var optionsMenu = optionsButton.getMenu();
		if (optionsMenu) {
			var menuItemsToEnable = [ZmId.OP_INC_NONE, ZmId.OP_INC_BODY, ZmId.OP_INC_SMART, ZmId.OP_INC_ATTACHMENT, ZmId.OP_USE_PREFIX, ZmId.OP_INCLUDE_HEADERS];
			AjxUtil.foreach(menuItemsToEnable, function(menuItemId) {
				var menuItem = optionsMenu.getMenuItem(menuItemId);
				if (menuItem) {
					menuItem.setEnabled(enabled);
				}
			});
		}
	}
	var detachComposeButton = toolbar.getButton(ZmId.OP_DETACH_COMPOSE);
	if (detachComposeButton) {
		detachComposeButton.setEnabled(enabled);
	}
	appCtxt.notifyZimlets("enableComposeToolbarButtons", [toolbar, enabled]);
};

ZmComposeView.prototype.enableAttachButton =
function(option) {
	if (this._attButton) {
	   this._attButton.setEnabled(option);
		var attachElement = this._attButton.getHtmlElement();
		var node = attachElement && attachElement.getElementsByTagName("input");
		if (node && node.length) {
			node[0].disabled = !(option);
		}
	}

	this._disableAttachments = !(option);
};


ZmComposeView.prototype._resetUpload =
function(err) {
	this._attButton.setEnabled(true);
	this.enableToolbarButtons(this._controller, true);
	this._setAttInline(false);
	this._controller._uploadingProgress = false;
	if (this._controller._uploadAttReq) {
		this._controller._uploadAttReq = null;
	}

	if (this.si) {
		clearTimeout(this.si);
	}
	if (err === true && this._loadingSpan) {
		this._loadingSpan.parentNode.removeChild(this._loadingSpan);
		this._controller.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO);// Save the previous state
	}

	if (this._loadingSpan) {
		this._loadingSpan = null;
	}

	if (this._uploadElementForm) {
		this._uploadElementForm.reset();
		this._uploadElementForm = null;
	}
};

ZmComposeView.prototype._uploadDoneCallback =
function(resp) {
	var response = resp && resp.length && resp[2];
	this._controller.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO, response);
};


ZmComposeView.prototype._uploadFileProgress =
function(params, progress) {
	if (!this._loadingSpan ||  (!progress.lengthComputable) ) { 
		return;
	}
	this._setLoadingProgress(this._loadingSpan, progress.loaded / progress.total);
};

ZmComposeView.prototype._abortUploadFile =
function() {
	if (this._controller._uploadAttReq){
        this._controller._uploadAttReq.aborted = true;
        this._controller._uploadAttReq.abort();
    }
};

ZmComposeView.prototype._progress =
function() {
	var span1 = this._loadingSpan && this._loadingSpan.firstChild;
	var span2 = span1 && span1.nextSibling;
    if (span2){
        span1.style.width = ((span1.offsetWidth + 1) % span2.offsetWidth) + "px";
    }
};

/*
 Set the loading progress to a specific percentage
 @param {Number} progress - fraction of progress (0 to 1, 1 is 100%).
 */
ZmComposeView.prototype._setLoadingProgress =
function(loadingSpan, progress) {
	var finishedSpan = loadingSpan.childNodes[0];
	var allSpan = loadingSpan.childNodes[1];
	finishedSpan.style.width = (allSpan.offsetWidth * progress) + "px";
};

ZmComposeView.prototype._initProgressSpan =
function(fileName) {
	fileName = this._clipFile(fileName, true);

	var firstBubble = this._attcDiv.getElementsByTagName("span")[0];
	if (firstBubble) {
		var tempBubbleWrapper = document.createElement("span");
		tempBubbleWrapper.innerHTML = AjxTemplate.expand("mail.Message#MailAttachmentBubble", {fileName: fileName});
		var newBubble = tempBubbleWrapper.firstChild;
		firstBubble.parentNode.insertBefore(newBubble, firstBubble); //insert new bubble before first bubble.
	}
	else {
		//first one is enclosed in a wrapper (the template already expands the mail.Message#MailAttachmentBubble template inside the wrapper)
		this._attcDiv.innerHTML = AjxTemplate.expand("mail.Message#UploadProgressContainer", {fileName: fileName});
	}
	this._loadingSpan = this._attcDiv.getElementsByTagName("span")[0];
};


ZmComposeView.prototype._submitMyComputerAttachments =
function(files, node, isInline) {
	var name = "";

	if (!AjxEnv.supportsHTML5File) {
		// IE, FF 3.5 and lower
		this.showAttachmentDialog(ZmMsg.myComputer);
		return;
	}

	if (!files)
		files = node.files;

	var size = 0;
	if (files) {
		for (var j = 0; j < files.length; j++) {
			var file = files[j];
			//Check the total size of the files we upload this time (we don't know the previously uploaded files total size so we do the best we can).
			//NOTE - we compare to the MTA message size limit since there's no limit on specific attachments.
			size += file.size || file.fileSize /*Safari*/ || 0;
			if ((-1 /* means unlimited */ != appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT)) &&
				(size > appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT))) {
				var msgDlg = appCtxt.getMsgDialog();
				var errorMsg = AjxMessageFormat.format(ZmMsg.attachmentSizeError, AjxUtil.formatSize(appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT)));
				msgDlg.setMessage(errorMsg, DwtMessageDialog.WARNING_STYLE);
				msgDlg.popup();
				return false;
			}
		}
	}

	this._setAttInline(isInline);
	this._initProgressSpan(files[0].name);

	this._controller._initUploadMyComputerFile(files);

};

ZmComposeView.prototype._clipFile = function(name, encode) {
	var r = AjxStringUtil.clipFile(name, ZmComposeView.MAX_ATTM_NAME_LEN);

	return encode ? AjxStringUtil.htmlEncode(r) : r;
};

ZmComposeView.prototype._checkMenuItems =
function(menuItem) {
	var isHTML = (this._composeMode === Dwt.HTML);
	menuItem.setEnabled(isHTML);
};

ZmComposeView.prototype._attachButtonMenuCallback =
function() {
	var menu = new DwtMenu({parent:this._attButton});

	var listener =
		this.showAttachmentDialog.bind(this, ZmComposeView.UPLOAD_COMPUTER);
	this._createAttachMenuItem(menu, ZmMsg.myComputer, listener);

	if (AjxEnv.supportsHTML5File) {
		// create the item for making inline attachments
		var listener =
			this.showAttachmentDialog.bind(this, ZmComposeView.UPLOAD_INLINE);
		var mi = this._createAttachMenuItem(menu, ZmMsg.attachInline, listener);
		menu.addPopupListener(new AjxListener(this, this._checkMenuItems,[mi]));
	}

	if (appCtxt.multiAccounts || appCtxt.get(ZmSetting.BRIEFCASE_ENABLED)) {
		var listener =
			this.showAttachmentDialog.bind(this,
			                               ZmComposeView.UPLOAD_BRIEFCASE);
		var briefcaseItem = this._createAttachMenuItem(menu, ZmMsg.briefcase, listener);
		briefcaseItem.setEnabled(!appCtxt.isWebClientOffline());

	}
	appCtxt.notifyZimlets("initializeAttachPopup", [menu, this], {waitUntilLoaded:true});

	return menu;
};

ZmComposeView.prototype._getIdentityOptions =
function() {
	var options = [];
	var identityCollection = appCtxt.getIdentityCollection();
	var identities = identityCollection.getIdentities(true);
	for (var i = 0, count = identities.length; i < count; i++) {
		var identity = identities[i];
		options.push(new DwtSelectOptionData(identity.id, this._getIdentityText(identity)));
	}
	return options;
};

ZmComposeView.prototype._getIdentityText =
function(identity, account) {
	var name = identity.name;
	if (identity.isDefault && name === ZmIdentity.DEFAULT_NAME) {
		name = account ? account.getDisplayName() : ZmMsg.accountDefault;
	}

	// default replacement parameters
	var defaultIdentity = appCtxt.getIdentityCollection().defaultIdentity;
	var addr = (identity.sendFromAddressType === ZmSetting.SEND_ON_BEHALF_OF) ? (appCtxt.getUsername() + " " + ZmMsg.sendOnBehalfOf + " " + identity.sendFromAddress) : identity.sendFromAddress;
	var params = [
		name,
		(identity.sendFromDisplay || ""),
		addr,
		ZmMsg.accountDefault,
		appCtxt.get(ZmSetting.DISPLAY_NAME),
		defaultIdentity.sendFromAddress
	];

	// get appropriate pattern
	var pattern;
	if (identity.isDefault) {
		pattern = ZmMsg.identityTextPrimary;
	}
	else if (identity.isFromDataSource) {
		var ds = appCtxt.getDataSourceCollection().getById(identity.id);
		params[1] = params[1] || ds.userName || "";
		params[2] = ds.getEmail();
		var provider = ZmDataSource.getProviderForAccount(ds);
		if (provider) {
			pattern = ZmMsg["identityText-"+provider.id];
		}
		else if (params[0] && params[1] && params[2] &&
				(params[0] !== params[1] !== params[2]))
		{
			pattern = ZmMsg.identityTextPersona;
		}
		else {
			pattern = ZmMsg.identityTextExternal;
		}
	}
	else {
		pattern = ZmMsg.identityTextPersona;
	}

	// format text
	return AjxMessageFormat.format(pattern, params);
};

ZmComposeView.prototype._identityChangeListener =
function(ev) {

	if (!this.identitySelect) { return; }

	var identity = ev.getDetail("item");
	if (!identity) { return; }
	if (ev.event === ZmEvent.E_CREATE) {
		// TODO: add identity in sort position
		var text = this._getIdentityText(identity);
		var option = new DwtSelectOptionData(identity.id, text);
		this.identitySelect.addOption(option);
        this._setIdentityVisible();
	} else if (ev.event === ZmEvent.E_DELETE) {
		this.identitySelect.removeOptionWithValue(identity.id);
		this._setIdentityVisible();
	} else if (ev.event === ZmEvent.E_MODIFY) {
		// TODO: see if it was actually name that changed
		// TODO: re-sort list
		var text = this._getIdentityText(identity);
		this.identitySelect.rename(identity.id, text);
	}
};

ZmComposeView.prototype._setIdentityVisible =
function() {
	var div = document.getElementById(this._identityDivId);
	if (!div) { return; }

	var visible = this.identitySelect.getOptionCount() > 1;
	Dwt.setVisible(div, visible);
	this.identitySelect.setVisible(visible);
};

ZmComposeView.prototype.getIdentity =
function() {
	var ac = window.parentAppCtxt || window.appCtxt;

	if (appCtxt.multiAccounts) {
		var newVal = this._fromSelect.getValue();
		var newOption = this._fromSelect.getOptionWithValue(newVal);
		var newAccount = ac.accountList.getAccount(newOption.accountId);
		var collection = ac.getIdentityCollection(newAccount);
		return collection && collection.getById(newVal);
	}

	if (this.identitySelect) {
		var collection = ac.getIdentityCollection();
		var val = this.identitySelect.getValue();
		var identity = collection.getById(val);
		return identity;
	}
};

ZmComposeView.prototype._showForwardField =
function(msg, action, includeInlineImages, includeInlineAtts) {

	var html = "";
	var attIncludeOrigLinkId = null;
	this._partToAttachmentMap = [];
	var appCtxt = window.parentAppCtxt || window.appCtxt
	var messages = [];

	var hasAttachments = msg && msg.attachments && msg.attachments.length > 0;

	if (!this._originalAttachmentsInitialized) {  //only the first time we determine which attachments are original
		this._originalAttachments = []; //keep it associated by label and size (label => size => true) since that's the only way the client has to identify attachments from previous msg version.
		this._hideOriginalAttachments = msg && hasAttachments && (action === ZmOperation.REPLY || action === ZmOperation.REPLY_ALL);
	}
	if (msg && (hasAttachments || includeInlineImages || includeInlineAtts || (action === ZmComposeView.ADD_ORIG_MSG_ATTS))) {
		var attInfo = msg.getAttachmentInfo(false, includeInlineImages, includeInlineAtts);

		if (action === ZmComposeView.ADD_ORIG_MSG_ATTS) {
			if (this._replyAttachments !== this._msg.attachments) {
				attInfo = attInfo.concat(this._replyAttachInfo);
				this._msg.attachments = this._msg.attachments.concat(this._replyAttachments);
			}
				this._replyAttachInfo = this._replyAttachments = [];
				Dwt.setVisible(ZmId.getViewId(this._view, ZmId.CMP_REPLY_ATT_ROW), false);
		} else if (action === ZmOperation.REPLY || action === ZmOperation.REPLY_ALL) {
			if (attInfo && attInfo.length && !appCtxt.isWebClientOffline()) {
				this._replyAttachInfo = attInfo;
				this._replyAttachments = this._msg.attachments;
				this._attachCount = 0;
				Dwt.setVisible(ZmId.getViewId(this._view, ZmId.CMP_REPLY_ATT_ROW), true);
			}

			return;
		}

		if (attInfo.length > 0 && !(action === ZmOperation.FORWARD_INLINE && appCtxt.isWebClientOffline())) {
			var rowId = this._htmlElId + '_attach';
			for (var i = 0; i < attInfo.length; i++) {
				var att = attInfo[i];
				var params = {
					att:		att,
					id:			[this._view, att.part, ZmMailMsgView.ATT_LINK_MAIN].join("_"),
					text:		this._clipFile(att.label),
					mid:		att.mid,
					rfc822Part: att.rfc822Part
				};
				att.link = ZmMailMsgView.getMainAttachmentLinkHtml(params);
				this._partToAttachmentMap[i] = att;
				if (!this._originalAttachmentsInitialized) {
					if (!this._originalAttachments[att.label]) {
						this._originalAttachments[att.label] = [];
					}
					this._originalAttachments[att.label][att.sizeInBytes] = true;
				}
				att.spanId = Dwt.getNextId(rowId);
				att.closeHandler = "ZmComposeView.removeAttachedFile(event, '" + [ this._htmlElId, att.spanId, att.part ].join("', '") + "');";
			}
			attIncludeOrigLinkId = Dwt.getNextId(ZmId.getViewId(this._view, ZmId.CMP_ATT_INCL_ORIG_LINK));


			if (action === ZmComposeView.ADD_ORIG_MSG_ATTS) {
				action = this._action;
			}

			var data = {
				attachments:				attInfo,
				messagesFwdFieldName: 		(ZmComposeView.FORWARD_MSG_NAME + this._sessionId),
				isNew:						(action === ZmOperation.NEW_MESSAGE),
				isForward:					(action === ZmOperation.FORWARD),
				isForwardInline:			(action === ZmOperation.FORWARD_INLINE),
				isDraft: 					(action === ZmOperation.DRAFT),
				hideOriginalAttachments:	this._hideOriginalAttachments,
				attIncludeOrigLinkId:		attIncludeOrigLinkId,
				originalAttachments: 		this._originalAttachments,
				fwdFieldName:				(ZmComposeView.FORWARD_ATT_NAME + this._sessionId),
				rowId:                      rowId
			};
			html = AjxTemplate.expand("mail.Message#ForwardAttachments", data);
			this._attachCount = attInfo.length;
			this.checkAttachments();
		}
	}

	this._originalAttachmentsInitialized  = true; //ok, done setting it for the first time.

	if (this._attachCount > 0) {
		this._attcDiv.innerHTML = html;
	} else if (!this._loadingSpan) {
		this.cleanupAttachments(true);
	}

	// include original attachments
	if (attIncludeOrigLinkId) {
		this._attIncludeOrigLinkEl = document.getElementById(attIncludeOrigLinkId);
		if (this._attIncludeOrigLinkEl) {
			Dwt.setHandler(this._attIncludeOrigLinkEl, DwtEvent.ONCLICK, AjxCallback.simpleClosure(this._includeOriginalAttachments, this));
		}
	}

	this._attcTabGroup.removeAllMembers();
	var links = Dwt.byClassName('AttLink', this._attcDiv),
		closeButtons = Dwt.byClassName('AttachmentClose', this._attcDiv);
	for (var i = 0; i < links.length; i++) {
		var link = links[i],
			closeButton = closeButtons[i];
		// MailMsg attachments are not displayed via the href, but rather using onClick.
		var onClick = link.onclick;
		this._makeFocusable(link);
		if (onClick) {
			Dwt.clearHandler(link, DwtEvent.ONCLICK);
			Dwt.setHandler(link, DwtEvent.ONCLICK, onClick);
		}
		this._attcTabGroup.addMember(link);
		this._attcTabGroup.addMember(closeButton);
	}
};

ZmComposeView.prototype._includeOriginalAttachments =
function(ev, force) {
	this._hideOriginalAttachments = false;
	this._isIncludingOriginalAttachments = true;
	this._showForwardField(this._msg, this._action, true);
};


// Miscellaneous methods
ZmComposeView.prototype._resetBodySize =
function() {
	if (!this._htmlEditor)
		return;

	var size = Dwt.insetBounds(this.getInsetBounds(),
	                           this._htmlEditor.getInsets());

	if (size) {
		size.height -= Dwt.getSize(this._headerEl).y;

		this._htmlEditor.setSize(size.width, size.height);
	}
};


ZmComposeView.prototype._setFromSelect =
function(msg) {
	if (!this._fromSelect) { return; }

	this._fromSelect.clearOptions();

	var ac = window.parentAppCtxt || window.appCtxt;
	var identity;
	var active = ac.getActiveAccount();
	var accounts = ac.accountList.visibleAccounts;

	for (var i = 0; i < accounts.length; i++) {
		var acct = accounts[i];
		if (appCtxt.isOffline && acct.isMain) { continue; }

		var identities = ac.getIdentityCollection(acct).getIdentities();
		if (ac.isFamilyMbox || ac.get(ZmSetting.OFFLINE_SMTP_ENABLED, null, acct)) {
			for (var j = 0; j < identities.length; j++) {
				identity = identities[j];

				var text = this._getIdentityText(identity, acct);
				var icon = appCtxt.isOffline ? acct.getIcon() : null;
				var option = new DwtSelectOption(identity.id, false, text, null, null, icon);
				option.addr = new AjxEmailAddress(identity.sendFromAddress, AjxEmailAddress.FROM, identity.sendFromDisplay);
				option.accountId = acct.id;

				this._fromSelect.addOption(option);
			}
		}
	}

	var selectedIdentity;
	if (msg) {
		var coll = ac.getIdentityCollection(msg.getAccount());
		selectedIdentity = (msg.isDraft)
			? coll.selectIdentity(msg, AjxEmailAddress.FROM)
			: coll.selectIdentity(msg);
		if (!selectedIdentity) {
			selectedIdentity = coll.defaultIdentity;
		}
	}

	if (!selectedIdentity) {
		selectedIdentity = ac.getIdentityCollection(active).defaultIdentity;
	}

	if (selectedIdentity && selectedIdentity.id) {
		this._fromSelect.setSelectedValue(selectedIdentity.id);
	}

	// for cross account searches, the active account isn't necessarily the
	// account of the selected conv/msg so reset it based on the selected option.
	// if active-account is local/main acct, reset it based on selected option.
	if ((appCtxt.getSearchController().searchAllAccounts && this._fromSelect) || active.isMain) {
		active = this.getFromAccount();
		this._controller._accountName = active.name;
	}

	if (this._acAddrSelectList) {
		this._acAddrSelectList.setActiveAccount(active);
	}

	this._recipients.resetPickerButtons(active);
};



// Returns a string representing the form content
ZmComposeView.prototype._formValue = function(incAddrs, incSubject) {

	var vals = [];
	if (incAddrs) {
		for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
			var type = ZmMailMsg.COMPOSE_ADDRS[i];
			if (this._recipients.getUsing(type)) {
				vals.push(this._recipients.getAddrFieldValue(type));
			}
		}
	}

	if (incSubject) {
		vals.push(this._subjectField.value);
	}

    var htmlMode = (this._composeMode === Dwt.HTML);
    if (!htmlMode) {
        var content = this._getEditorContent();
        vals.push(content);
    }

	return AjxUtil.collapseList(vals).join("|");
};

// Listeners


ZmComposeView.prototype._controlListener =
function() {
	this._resetBodySize();
};


// Callbacks

// this callback is triggered when an event occurs inside the html editor (when in HTML mode)
// it is used to set focus to the To: field when user hits the TAB key
ZmComposeView.prototype._htmlEditorEventCallback =
function(args) {
	var rv = true;
	if (args.type === "keydown") {
		var key = DwtKeyEvent.getCharCode(args);
		if (key === DwtKeyEvent.KEY_TAB) {
			var toField = this._recipients.getField(AjxEmailAddress.TO);
			if (toField) {
				appCtxt.getKeyboardMgr().grabFocus(toField);
			}
			rv = false;
		}
	}
	return rv;
};

// needed to reset design mode when in html compose format for gecko
ZmComposeView.prototype._okCallback =
function() {
	appCtxt.getMsgDialog().popdown();
	this._controller.resetToolbarOperations();
	this.reEnableDesignMode();
};

// User has agreed to send message without a subject
ZmComposeView.prototype._noSubjectOkCallback =
function(dialog) {
	this._noSubjectOkay = true;
	this._popDownAlertAndSendMsg(dialog);
};

//this is used by several kinds of alert dialogs
ZmComposeView.prototype._popDownAlertAndSendMsg =
function(dialog) {
	// not sure why: popdown (in FF) seems to create a race condition,
	// we can't get the attachments from the document anymore.
	// W/in debugger, it looks fine, but remove the debugger and any
	// alerts, and gotAttachments will return false after the popdown call.

	if (AjxEnv.isIE) {
		dialog.popdown();
	}
	// bug fix# 3209
	// - hide the dialog instead of popdown (since window will go away anyway)
	if (AjxEnv.isNav && appCtxt.isChildWindow) {
		dialog.setVisible(false);
	}

	// dont make any calls after sendMsg if child window since window gets destroyed
	if (appCtxt.isChildWindow && !AjxEnv.isNav) {
		// bug fix #68774 Empty warning window when sending message without subject in chrome
		dialog.popdown();
		this._controller.sendMsg();
	} else {
		// bug fix #3251 - call popdown BEFORE sendMsg
		dialog.popdown();
		this._controller.sendMsg();
	}
};

// User has canceled sending message without a subject
ZmComposeView.prototype._noSubjectCancelCallback =
function(dialog) {
	this.enableInputs(true);
	dialog.popdown();
	appCtxt.getKeyboardMgr().grabFocus(this._subjectField);
	this._controller.resetToolbarOperations();
	this.reEnableDesignMode();
};

ZmComposeView.prototype._errViaZimletOkCallback =
function(params) {
	var dialog = params.errDialog; 
	var zimletName = params.zimletName;
	//add this zimlet to ignoreZimlet string
	this._ignoredZimlets = this._ignoredZimlets || {};
	this._ignoredZimlets[zimletName] = true;
	this._popDownAlertAndSendMsg(dialog);
};

ZmComposeView.prototype._errViaZimletCancelCallback =
function(params) {
	var dialog = params.errDialog; 
	var zimletName = params.zimletName;
	this.enableInputs(true);
	dialog.popdown();
	this._controller.resetToolbarOperations();
	this.reEnableDesignMode();
};

// User has agreed to send message with bad addresses
ZmComposeView.prototype._badAddrsOkCallback =
function(dialog) {
	this.enableInputs(true);
	this._badAddrsOkay = true;
	dialog.popdown();
	this._controller.sendMsg();
};

// User has declined to send message with bad addresses - set focus to bad field
ZmComposeView.prototype._badAddrsCancelCallback =
function(type, dialog) {
	this.enableInputs(true);
	this._badAddrsOkay = false;
	dialog.popdown();
	if (this._recipients.getUsing(type)) {
		appCtxt.getKeyboardMgr().grabFocus(this._recipients.getField(type));
	}
	this._controller.resetToolbarOperations();
	this.reEnableDesignMode();
};

ZmComposeView.prototype._closeAttachDialog =
function() {
	if (this._attachDialog)
		this._attachDialog.popdown();

	this._initProgressSpan(ZmMsg.uploadingAttachment);

	var progress = function (obj) {
					var selfobject = obj;
					obj.si = window.setInterval (function() {selfobject._progress();}, 500);
	 };
	progress(this);
};

ZmComposeView.prototype._setAttachedMsgIds =
function(msgIds) {
	this._msgIds = msgIds;
};

// Files have been uploaded, re-initiate the send with an attachment ID.
ZmComposeView.prototype._attsDoneCallback =
function(isDraft, status, attId, docIds, msgIds) {
	DBG.println(AjxDebug.DBG1, "Attachments: isDraft = " + isDraft + ", status = " + status + ", attId = " + attId);
	this._closeAttachDialog();
	if (status === AjxPost.SC_OK) {
		if (msgIds) {
		  this._setAttachedMsgIds(msgIds);
		}
		var callback = this._resetUpload.bind(this);
		this._startUploadAttachment(); 
		this._controller.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO, attId, docIds, callback);
	} else if (status === AjxPost.SC_UNAUTHORIZED) {
		// auth failed during att upload - let user relogin, continue with compose action
		this._resetUpload(true);
		var ex = new AjxException("401 response during attachment upload", ZmCsfeException.SVC_AUTH_EXPIRED);
		var callback = new AjxCallback(this._controller, isDraft ? this._controller.saveDraft : this._controller._send);
		this._controller._handleException(ex, {continueCallback:callback});
	} else {
		// bug fix #2131 - handle errors during attachment upload.
		this._resetUpload(true);
		this._controller.popupUploadErrorDialog(ZmItem.MSG, status,
		                                        ZmMsg.errorTryAgain);
		this._controller.resetToolbarOperations();
	}
};


//Mandatory Spellcheck Callback
ZmComposeView.prototype._spellCheckShield =
function(words) {
	if (words && words.available && words.misspelled && words.misspelled.length !== 0) {
		var msgDialog = new DwtMessageDialog({parent: appCtxt.getShell(), buttons:[DwtDialog.YES_BUTTON, DwtDialog.NO_BUTTON], id: Dwt.getNextId("SpellCheckConfirm_")});
		msgDialog.setMessage(AjxMessageFormat.format(ZmMsg.misspellingsMessage, [words.misspelled.length]), DwtMessageDialog.WARNING_STYLE);
		msgDialog.registerCallback(DwtDialog.YES_BUTTON, this._spellCheckShieldOkListener, this, [ msgDialog, words ] );
		msgDialog.registerCallback(DwtDialog.NO_BUTTON, this._spellCheckShieldCancelListener, this, msgDialog);
		msgDialog.associateEnterWithButton(DwtDialog.NO_BUTTON);
		msgDialog.getButton(DwtDialog.YES_BUTTON).setText(ZmMsg.correctSpelling);
		msgDialog.getButton(DwtDialog.NO_BUTTON).setText(ZmMsg.sendAnyway);
		var composeView = this;
		msgDialog.handleKeyAction = function(actionCode, ev) { if (actionCode && actionCode==DwtKeyMap.CANCEL) { composeView._spellCheckShieldOkListener(msgDialog, words, ev); return(true); } };
		msgDialog.popup(null, DwtDialog.NO_BUTTON);
	} else {
		this._spellCheckOkay = true;
		this._controller.sendMsg();
	}
};

ZmComposeView.prototype._spellCheckShieldOkListener =
function(msgDialog, words, ev) {

	this._controller._toolbar.enableAll(true);
	this.enableInputs(true);
	this._controller.toggleSpellCheckButton(true);
	this._htmlEditor.discardMisspelledWords();

	this._spellCheckOkay = false;
	msgDialog.popdown();

	this._htmlEditor.onExitSpellChecker = new AjxCallback(this._controller, this._controller.toggleSpellCheckButton, true)
	this._htmlEditor._spellCheckCallback(words);
};

ZmComposeView.prototype._spellCheckShieldCancelListener =
function(msgDialog, ev) {
	this._spellCheckOkay = true;
	msgDialog.popdown();
	this._controller.sendMsg();
};

ZmComposeView.prototype._spellCheckErrorShield =
function(ex) {
	var msgDialog = appCtxt.getYesNoMsgDialog();
	msgDialog.setMessage(ZmMsg.spellCheckFailed);
	msgDialog.registerCallback(DwtDialog.YES_BUTTON, this._spellCheckErrorShieldOkListener, this, msgDialog );
	msgDialog.registerCallback(DwtDialog.NO_BUTTON, this._spellCheckErrorShieldCancelListener, this, msgDialog);
	msgDialog.associateEnterWithButton(DwtDialog.NO_BUTTON);
	msgDialog.popup(null, DwtDialog.NO_BUTTON);

	return true;
};

ZmComposeView.prototype._spellCheckErrorShieldOkListener =
function(msgDialog, ev) {

	this._controller._toolbar.enableAll(true);
	this._controller.toggleSpellCheckButton(false);
	this._htmlEditor.discardMisspelledWords();
	msgDialog.popdown();

	this._spellCheckOkay = true;
	this._controller.sendMsg();
		
};

ZmComposeView.prototype._spellCheckErrorShieldCancelListener =
function(msgDialog, ev) {
	this._controller._toolbar.enableAll(true);
	this._controller.toggleSpellCheckButton(false);
	this._htmlEditor.discardMisspelledWords();
	msgDialog.popdown();
};

ZmComposeView.prototype._setFormValue =
function() {
	this._origFormValue = this._formValue(true, true);
};

ZmComposeView.prototype._clearFormValue = function() {

    DBG.println('draft', 'ZmComposeView._clearFormValue for ' + this._view);
	this._origFormValue = "";
	this._isDirty = false;
    if (this._htmlEditor) {
        this._htmlEditor.clearDirty();
    }
};

ZmComposeView.prototype._focusHtmlEditor =
function() {
	this._htmlEditor.focus();
};


// Static methods

// Update tab text when content of Subject field changes
ZmComposeView._onKeyUp = function(ev) {

    var cv = ZmComposeView._getComposeViewFromEvent(ev);
    if (cv) {
        cv.updateTabTitle();
    }

	return true;
};

// Subject field has gotten focus
ZmComposeView._onFocus = function(ev) {

    var cv = ZmComposeView._getComposeViewFromEvent(ev);
    if (cv) {
        appCtxt.getKeyboardMgr().updateFocus(cv._subjectField);
    }
};

ZmComposeView._getComposeViewFromEvent = function(ev) {

    ev = DwtUiEvent.getEvent(ev);
    var element = DwtUiEvent.getTargetWithProp(ev, "id");
    return element && DwtControl.fromElementId(element._composeViewId);
};

// for com.zimbra.dnd zimlet
ZmComposeView.prototype.uploadFiles =
function() {
	var attachDialog = appCtxt.getAttachDialog();
	var callback = new AjxCallback(this, this._attsDoneCallback, [true]);
	attachDialog.setUploadCallback(callback);
	attachDialog.upload(callback, document.getElementById("zdnd_form"));
};

ZmComposeView.prototype.deactivate =
function() {
	this._controller.inactive = true;
};

ZmComposeView.prototype._getIframeDoc =
function() {
	return this._htmlEditor && this._htmlEditor._getIframeDoc();
};

/**
 * Moves the cursor to the beginning of the editor.
 * 
 * @param {number}		delay			timer delay in ms
 * @param {number}		offset			number of characters to skip ahead when placing cursor
 * 
 * @private
 */
ZmComposeView.prototype._moveCaretOnTimer =
function(offset, delay) {

	delay = (delay !== null) ? delay : 200;
	var len = this._getEditorContent().length;
	AjxTimedAction.scheduleAction(new AjxTimedAction(this, function() {
		if (this._getEditorContent().length === len) {
			this.getHtmlEditor().moveCaretToTop(offset);
		}
	}), delay);
};


/**
 * @overview
 * This class is used to manage the creation of a composed message, without a UI. For example,
 * it an be used to reply to a msg with some canned or user-provided text.
 * 
 * @param controller
 * @param composeMode
 */
ZmHiddenComposeView = function(controller, composeMode) {
	// no need to invoke parent ctor since we don't need to create a UI
	this._controller = controller;
	this._composeMode = composeMode;
	this.reset();
};

ZmHiddenComposeView.prototype = new ZmComposeView;
ZmHiddenComposeView.prototype.constructor = ZmHiddenComposeView;

ZmHiddenComposeView.prototype.isZmHiddenComposeView = true;
ZmHiddenComposeView.prototype.toString = function() { return "ZmHiddenComposeView"; };

/**
 * Sets the current view, based on the given action. The compose form is
 * created and laid out and everything is set up for interaction with the user.
 *
 * @param {Hash}		params			a hash of parameters:
 * @param {constant}	action				new message, reply, or forward
 * @param {ZmMailMsg}	msg					the original message (reply/forward), or address (new message)
 * @param {ZmIdentity}	identity			identity of sender
 * @param {String}		toOverride			To: addresses (optional)
 * @param {String}		ccOverride			Cc: addresses (optional)
 * @param {String}		subjectOverride		subject for new msg (optional)
 * @param {String}		extraBodyText		text for new msg
 * @param {String}		accountName			on-behalf-of From address
 */
ZmHiddenComposeView.prototype.set =
function(params) {

	this.reset();
		
	var action = this._action = params.action;
	var msg = this._msg = this._origMsg = params.msg;

	if (!ZmComposeController.IS_FORWARD[action]) {
		this._setAddresses(action, AjxEmailAddress.TO, params.toOverride);
		if (params.ccOverride) {
			this._setAddresses(action, AjxEmailAddress.CC, params.ccOverride);
		}
		if (params.bccOverride) {
			this._setAddresses(action, AjxEmailAddress.BCC, params.bccOverride);
		}
	}
	this._setSubject(action, msg, params.subjectOverride);
	this._setBody(action, msg, params.extraBodyText, true);
	var oboMsg = msg || (params.selectedMessages && params.selectedMessages.length && params.selectedMessages[0]);
	var obo = this._getObo(params.accountName, oboMsg);
		
	if (action !== ZmOperation.FORWARD_ATT) {
		this._saveExtraMimeParts();
	}
};

ZmHiddenComposeView.prototype.setComposeMode =
function(composeMode) {
	this._composeMode = composeMode;
};

// no-op anything that relies on UI components
ZmHiddenComposeView.prototype.applySignature = function() {};
ZmHiddenComposeView.prototype.enableInputs = function() {};
ZmHiddenComposeView.prototype._showForwardField = function() {};
ZmHiddenComposeView.prototype.cleanupAttachments = function() {};
ZmHiddenComposeView.prototype.resetBody = function() {};
ZmHiddenComposeView.prototype._resetBodySize = function() {};

/**
 * Returns a msg created from prior input.
 */
ZmHiddenComposeView.prototype.getMsg =
function() {

	var addrs = this._recipients.collectAddrs();
	var subject = this._subject;

	// Create Msg Object - use dummy if provided
	var msg = new ZmMailMsg();
	msg.setSubject(subject);

	this.sendUID = (new Date()).getTime();

	// build MIME
	var top = this._getTopPart(msg, false, this._bodyContent[this._composeMode]);

	msg.setTopPart(top);
	msg.setSubject(subject);

    //vcard signature may be set
    if (this._msg && this._msg._contactAttIds) {
        msg.setContactAttIds(this._msg._contactAttIds);
        this._msg.setContactAttIds([]);
    }

	for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
		var type = ZmMailMsg.COMPOSE_ADDRS[i];
		var a = addrs[type];
		if (a && a.length) {
			msg.setAddresses(type, AjxVector.fromArray(a));
		}
	}
	msg.identity = this.getIdentity();
	msg.sendUID = this.sendUID;

	// save a reference to the original message
	msg._origMsg = this._msg;
	if (this._msg && this._msg._instanceDate) {
		msg._instanceDate = this._msg._instanceDate;
	}

	this._setMessageFlags(msg);

	return msg;
};

ZmHiddenComposeView.prototype.reset =
function(bEnableInputs) {

	this.sendUID = null;
	this._recipients = new ZmHiddenRecipients();
	this._subject = "";
	this._controller._curIncOptions = null;
	this._msgAttId = null;
	this._addresses = {};
	this._bodyContent = {};
	this._components = {};
	this._quotedTextChanged = false;

	// remove extra mime parts
	this._extraParts = null;
};

ZmHiddenComposeView.prototype.getIdentity =
function() {
	//get the same identity we would have gotten as the selected one in full compose view persona select.
	return this._controller._getIdentity(this._msg);
};

ZmHiddenComposeView.prototype.__initCtrl = function() {};

/**
 * Minimal version of ZmRecipients that has no UI. Note that addresses are stored in
 * arrays rather than vectors.
 */
ZmHiddenRecipients = function() {
	this._addresses = {};
};

ZmHiddenRecipients.prototype.setAddress =
function(type, addr) {
	if (type && addr) {
		this._addresses[type] = this._addresses[type] || [];
		this._addresses[type].push(addr);
	}
};

ZmHiddenRecipients.prototype.addAddresses =
function(type, addrVec, used) {

	var addrAdded = false;
	used = used || {};
	var addrs = AjxUtil.toArray(addrVec);
	if (addrs && addrs.length) {
		if (!this._addresses[type]) {
			this._addresses[type] = [];
		}
		for (var i = 0, len = addrs.length; i < len; i++) {
			var addr = addrs[i];
			addr = addr.isAjxEmailAddress ? addr : AjxEmailAddress.parse(addr);
			if (addr) {
				var email = addr.getAddress();
				if (!email) { continue; }
				email = email.toLowerCase();
				if (!used[email]) {
					this._addresses[type].push(addr);
					used[email] = true;
					addrAdded = true;
				}
			}
		}
	}
	return addrAdded;
};

ZmHiddenRecipients.prototype.collectAddrs =
function() {
	return this._addresses;
};
}
if (AjxPackage.define("zimbraMail.mail.view.ZmInviteMsgView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file contains an invite mail message singleton class.
 *
 */


/**
 * Default constructor for invite mail message class.
 * @class
 * When a user receives an invite, this class is instatiated to help
 * ZmMailMsgView deal with invite-specific rendering/logic.
 *
 * @author Parag Shah
 */
ZmInviteMsgView = function(params) {
	if (arguments.length == 0) { return; }

	this.parent = params.parent; // back reference to ZmMailMsgView
	this.mode = params.mode;
};

// Consts
ZmInviteMsgView.REPLY_INVITE_EVENT	= "inviteReply";


ZmInviteMsgView.prototype.toString =
function() {
	return "ZmInviteMsgView";
};

ZmInviteMsgView.prototype.reset =
function(cleanupHTML) {
	if (this._inviteToolbar) {
		if (cleanupHTML) {
			this._inviteToolbar.dispose();
			this._inviteToolbar = null;
		} else {
			this._inviteToolbar.setDisplay(Dwt.DISPLAY_NONE);
		}
	}

	if (this._counterToolbar) {
		if (cleanupHTML) {
			this._counterToolbar.dispose();
			this._counterToolbar = null;
		} else {
			this._counterToolbar.setDisplay(Dwt.DISPLAY_NONE);
		}
	}

	if (this._dayView) {
		if (cleanupHTML) {
			this._dayView.dispose();
			this._dayView = null;
		} else {
			this._dayView.setDisplay(Dwt.DISPLAY_NONE);
		}
		Dwt.delClass(this.parent.getHtmlElement(), "RightBorderSeparator");
	}

	this._msg = null;
	this._invite = null;
};

ZmInviteMsgView.prototype.isActive =
function() {
	return ((this._invite && !this._invite.isEmpty()) ||
			(this._inviteToolbar && this._inviteToolbar.getVisible()) ||
			(this._counterToolbar && this._counterToolbar.getVisible()));
};

ZmInviteMsgView.prototype.set =
function(msg) {

	this._msg = msg;
	var invite = this._invite = msg.invite;

	this.parent._lazyCreateObjectManager();

    // Can operate the toolbar if user is the invite recipient, or invite is in a
    // non-trash shared folder with admin/workflow access permissions
    var folder   =  appCtxt.getById(msg.folderId);
    var enabled  = !appCtxt.isExternalAccount();
    if (enabled && folder && folder.isRemote()) {
        var workflow = folder.isPermAllowed(ZmOrganizer.PERM_WORKFLOW);
        var admin    = folder.isPermAllowed(ZmOrganizer.PERM_ADMIN);
        var enabled  = (admin || workflow) &&
                       (ZmOrganizer.normalizeId(msg.folderId) != ZmFolder.ID_TRASH);
    }
	if (invite && invite.hasAcceptableComponents() && msg.folderId != ZmFolder.ID_SENT)	{
		if (msg.isInviteCanceled()) {
			//appointment was canceled (not necessarily on this instance, but by now it is canceled. Do not show the toolbar.
			return;
		}
		if (invite.hasCounterMethod()) {
			if (!this._counterToolbar) {
				this._counterToolbar = this._getCounterToolbar();
			}
			this._counterToolbar.reparentHtmlElement(this.parent.getHtmlElement(), 0);
			this._counterToolbar.setVisible(enabled);
		}
		else if (!invite.isOrganizer() && invite.hasInviteReplyMethod()) {
			var ac = window.parentAppCtxt || window.appCtxt;
			if (AjxEnv.isIE && this._inviteToolbar) {
				//according to fix to bug 52412 reparenting doestn't work on IE. so I don't reparent for IE but also if the toolbar element exists,
				//I remove it from parent since in the case of double-click message view, it appears multiple times without removing it
				this._inviteToolbar.dispose();
				this._inviteToolbar = null;
			}

			var inviteToolbar = this.getInviteToolbar();
			inviteToolbar.setVisible(enabled);

			// show on-behalf-of info?
			this._respondOnBehalfLabel.setContent(msg.cif ? AjxMessageFormat.format(ZmMsg.onBehalfOfText, [msg.cif]) : "");
			this._respondOnBehalfLabel.setVisible(!!msg.cif);

			// logic for showing calendar/folder chooser
			var cc = AjxDispatcher.run("GetCalController");
			//note that for a msg from a mountpoint, msgAcct returns the main account, so it's not really msgAcct.
			var msgAcct = msg.getAccount();
			var calendars = ac.get(ZmSetting.CALENDAR_ENABLED, null, msgAcct) && (!msg.cif)
				? cc.getCalendars({includeLinks:true, account:msgAcct, onlyWritable:true}) : [];

			var msgFolder = ac.getById(msg.getFolderId());
			var msgAcctId = msgFolder && msgFolder.isMountpoint ? ZmOrganizer.parseId(msgFolder.id).acctId : msgAcct.id;

			if (appCtxt.multiAccounts) {
				var accounts = ac.accountList.visibleAccounts;
				for (var i = 0; i < accounts.length; i++) {
					var acct = accounts[i];
					if (acct == msgAcct || !ac.get(ZmSetting.CALENDAR_ENABLED, null, acct)) { continue; }
					if (appCtxt.isOffline && acct.isMain) { continue; }

					calendars = calendars.concat(cc.getCalendars({includeLinks:true, account:acct, onlyWritable:true}));
				}

				// always add the local account *last*
				if (appCtxt.isOffline) {
					calendars.push(appCtxt.getById(ZmOrganizer.ID_CALENDAR));
				}
			}

			var visible = (calendars.length > 1 || appCtxt.multiAccounts);
			if (visible) {
				this._inviteMoveSelect.clearOptions();
				for (var i = 0; i < calendars.length; i++) {
					var calendar = calendars[i];
					var calAcct = null;
					var calAcctId;
					if (calendar.isMountpoint) {
						//we can't get account object for mountpoint, just get the ID.
						calAcctId = ZmOrganizer.parseId(calendar.id).acctId;
					}
					else {
						calAcct = calendar.getAccount();
						calAcctId = calAcct.id;
					}
					var icon = (appCtxt.multiAccounts && calAcct) ? calAcct.getIcon() : (calendar.getIcon() + ",color=" + calendar.color);
					var name = (appCtxt.multiAccounts && calAcct)
						? ([calendar.name, " (", calAcct.getDisplayName(), ")"].join(""))
						: calendar.name;
					var isSelected = (calAcctId && msgAcctId)
						? (calAcctId == msgAcctId && calendar.nId == ZmOrganizer.ID_CALENDAR)
						: calendar.nId == ZmOrganizer.ID_CALENDAR;
                    //bug: 57538 - this invite is intended for owner of shared calendar which should be selected
                    if(msg.cif && calendar.owner == msg.cif && calendar.rid == ZmOrganizer.ID_CALENDAR) isSelected = true;
					var option = new DwtSelectOptionData(calendar.id, name, isSelected, null, icon);
					this._inviteMoveSelect.addOption(option);
				}

				// for accounts that don't support calendar, always set the
				// selected calendar to the Local calendar
				if (!ac.get(ZmSetting.CALENDAR_ENABLED, null, msgAcct)) {
					this._inviteMoveSelect.setSelectedValue(ZmOrganizer.ID_CALENDAR);
				}
			}
			this._inviteMoveSelect.setVisible(visible);
		}
	}
};

/**
 * This method does two things:
 * 1) Checks if invite was responded to with accept/decline/tentative, and if so,
 *    a GetAppointmentRequest is made to get the status for the other attendees.
 *
 * 2) Requests the free/busy status for the start date and renders the day view
 *    with the results returned.
 */
ZmInviteMsgView.prototype.showMoreInfo =
function(callback, dayViewCallback) {
	var apptId = this._invite && this._invite.hasAttendeeResponse() && this._invite.getAppointmentId();

    // Fix for bug: 83785. apptId: 0 is default id for an appointment without any parent.
    // Getting apptId: 0 when external user takes action on appointment and organizer gets reply mail.
	if (apptId !== '0' && apptId) {
		var jsonObj = {GetAppointmentRequest:{_jsns:"urn:zimbraMail"}};
		var request = jsonObj.GetAppointmentRequest;
		var msgId = this._invite.msgId;
		var inx = msgId.indexOf(":");
		if (inx !== -1) {
			apptId = [msgId.substr(0, inx), apptId].join(":");
		}
		request.id = apptId;

		appCtxt.getAppController().sendRequest({
			jsonObj: jsonObj,
			asyncMode: true,
			callback: (new AjxCallback(this, this._handleShowMoreInfo, [callback, dayViewCallback]))
		});
	}
	else {
		this._showFreeBusy(dayViewCallback);
		if (callback) {
			callback.run();
		}
	}
};

ZmInviteMsgView.prototype._handleShowMoreInfo =
function(callback, dayViewCallback, result) {
	var appt = result && result.getResponse().GetAppointmentResponse.appt[0];
	if (appt) {
		var om = this.parent._objectManager;
		var html = [];
		var idx = 0;
		var attendees = appt.inv[0].comp[0].at || [];
        AjxDispatcher.require(["MailCore", "CalendarCore"]);

        var options = {};
	    options.shortAddress = appCtxt.get(ZmSetting.SHORT_ADDRESS);

		for (var i = 0; i < attendees.length; i++) {
			var at = attendees[i];
			var subs = {
				icon: ZmCalItem.getParticipationStatusIcon(at.ptst),
				attendee: this.parent._getBubbleHtml(new AjxEmailAddress(at.a), options)
			};
			html[idx++] = AjxTemplate.expand("mail.Message#InviteHeaderPtst", subs);
		}

		var ptstEl = document.getElementById(this._ptstId);
        if(ptstEl)
            ptstEl.innerHTML = html.join("");
	}

	if (callback) {
		callback.run();
	}

	this._showFreeBusy(dayViewCallback);
};

ZmInviteMsgView.prototype._showFreeBusy =
function(dayViewCallback) {
	var ac = window.parentAppCtxt || window.appCtxt;

	if (!appCtxt.isChildWindow &&
		(ac.get(ZmSetting.CALENDAR_ENABLED) || ac.multiAccounts) &&
		(this._invite && this._invite.type != "task"))
	{
        var inviteDate = this._getInviteDate();
        if (inviteDate == null) {
            return;
        }

		AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar"]);
		var cc = AjxDispatcher.run("GetCalController");

		if (!this._dayView) {
			// create a new ZmCalDayView under msgview's parent otherwise, we
			// cannot position the day view correctly.
			var dayViewParent = (this.mode && (this.mode == ZmId.VIEW_CONV2)) ?
			    this.parent : this.parent.parent;
			this._dayView = new ZmCalDayView(dayViewParent, DwtControl.ABSOLUTE_STYLE, cc, null,
                this.parent._viewId, null, true, true, this.isRight());
			this._dayView.addSelectionListener(new AjxListener(this, this._apptSelectionListener));
			this._dayView.setZIndex(Dwt.Z_VIEW); // needed by ZmMsgController's msgview
		}

		this._dayView.setDisplay(Dwt.DISPLAY_BLOCK);
		this._dayView.setDate(inviteDate, 0, false);
        this.resize();

        var acctFolderIds = [].concat(cc.getCheckedCalendarFolderIds()); // create a *copy*
        if(this._msg.cif) {
            acctFolderIds = acctFolderIds.concat(cc.getUncheckedCalendarIdsByOwner(this._msg.cif));
        }
		var rt = this._dayView.getTimeRange();
		var params = {
			start: rt.start,
			end: rt.end,
			fanoutAllDay: this._dayView._fanoutAllDay(),
			callback: (new AjxCallback(this, this._dayResultsCallback, [dayViewCallback, inviteDate.getHours()])),
			accountFolderIds: [acctFolderIds] // pass in array of array
		};
		cc.apptCache.batchRequest(params);
	}
};

ZmInviteMsgView.prototype._getInviteDate =
function() {
	if (!this._invite) { return null; }
    var inviteDate = this._invite.getServerStartDate(null, true);
    // Not sure when null inviteDate happens (probably a bug) but this is defensive
    // check for bug 51754
    if (inviteDate != null) {
        var inviteTz = this._invite.getServerStartTimeTz();
        inviteDate = AjxTimezone.convertTimezone(inviteDate,
            AjxTimezone.getClientId(inviteTz), AjxTimezone.DEFAULT);
    }
    return inviteDate;
}

ZmInviteMsgView.prototype.isRight =
function() {
	return this.parent._controller.isReadingPaneOnRight();
};

ZmInviteMsgView.prototype.convResize =
function() {
	var parentSize = this.parent.getSize();
	if (this._dayView) {
		this._dayView.setSize(parentSize.x - 5, 218);
		var el = this._dayView.getHtmlElement();
		el.style.left = el.style.top = "auto";
		this._dayView.layout();
	}
}

/**
 * Resizes the view depending on whether f/b is being shown or not.
 *
 * @param reset		Boolean		If true, day view is not shown and msgview's bounds need to be "reset"
 */
ZmInviteMsgView.prototype.resize =
function(reset) {
	if (appCtxt.isChildWindow) { return; }
	if (this.parent.isZmMailMsgCapsuleView) { return; }

	var isRight = this.isRight();
	var grandParentSize = this.parent.parent.getSize();

	if (reset) {
		if (isRight) {
			this.parent.setSize(Dwt.DEFAULT, grandParentSize.y);
		}
		else {
			this.parent.setSize(grandParentSize.x, Dwt.DEFAULT);
		}
	} else if (this._dayView) {
		// bug: 50412 - fix day view for stand-alone message view which is a parent
		// of DwtShell and needs to be resized manually.
		var padding = 0;
		if (this.parent.getController() instanceof ZmMsgController) {
			// get the bounds for the app content area so we can position the day view
			var appContentBounds = appCtxt.getAppViewMgr()._getContainerBounds(ZmAppViewMgr.C_APP_CONTENT);
            if (!isRight)
			    grandParentSize = {x: appContentBounds.width, y: appContentBounds.height};

			// set padding so we can add it to the day view's x-location since it is a child of the shell
			padding = appContentBounds.x;
		}

		var mvBounds = this.parent.getBounds();

		/* on IE sometimes the value of top and left is "auto", in which case we get a NaN value here due to parseInt in getLocation. */
		/* not sure if 0 is the right value we should use in this case, but it seems to work */
		if (isNaN(mvBounds.x)) {
			mvBounds.x = 0;
		}
		if (isNaN(mvBounds.y)) {
			mvBounds.y = 0;
		}

		if (isRight) {
			var parentHeight = grandParentSize.y;
			var dvHeight = Math.floor(parentHeight / 3);
			var mvHeight = parentHeight - dvHeight;

			this._dayView.setBounds(mvBounds.x, mvHeight, mvBounds.width, dvHeight);
            if (this.parent && this.parent instanceof ZmMailMsgView){
                var el = this.parent.getHtmlElement();
                if (this.mode && this.mode != ZmId.VIEW_MSG) {
                    if (el){
                        el.style.height = mvHeight + "px";
                        Dwt.setScrollStyle(el, Dwt.SCROLL);
                    }
                }
                else {
                    var bodyDiv = this.parent.getMsgBodyElement();
                    if (bodyDiv) Dwt.setScrollStyle(bodyDiv, Dwt.CLIP);
                    if (el) {
                        Dwt.setScrollStyle(el, Dwt.SCROLL);
                        var yOffset = this.parent.getBounds().y || 0;
                        el.style.height = (mvHeight - yOffset) + "px";
                    }
                }
            }

			// don't call DwtControl's setSize() since it triggers control
			// listener and leads to infinite loop

			Dwt.delClass(this.parent.getHtmlElement(), "RightBorderSeparator");
		} else {
			var parentWidth = grandParentSize.x;
			var dvWidth = Math.floor(parentWidth / 3);
			var separatorWidth = 5;
			var mvWidth = parentWidth - dvWidth - separatorWidth; 

			this._dayView.setBounds(mvWidth + padding + separatorWidth, mvBounds.y, dvWidth, mvBounds.height);
			// don't call DwtControl's setSize() since it triggers control
			// listener and leads to infinite loop
			Dwt.setSize(this.parent.getHtmlElement(), mvWidth, Dwt.DEFAULT);
			Dwt.addClass(this.parent.getHtmlElement(), "RightBorderSeparator");
		}
	}
};

/**
 * enables all invite toolbar buttons, except one that matches the current ptst
 * @param ptst participant status
 */
ZmInviteMsgView.prototype.enableToolbarButtons =
function(ptst) {
	var disableButtonIds = {};
	switch (ptst) {
		case ZmCalBaseItem.PSTATUS_ACCEPT:
			disableButtonIds[ZmOperation.REPLY_ACCEPT] = true;
			break;
		case ZmCalBaseItem.PSTATUS_DECLINED:
			disableButtonIds[ZmOperation.REPLY_DECLINE] = true;
			break;
		case ZmCalBaseItem.PSTATUS_TENTATIVE:
			disableButtonIds[ZmOperation.REPLY_TENTATIVE] = true;
			break;
	}
	if (appCtxt.isWebClientOffline()) {
		 disableButtonIds[ ZmOperation.PROPOSE_NEW_TIME] = true;
	}
	var inviteToolbar = this.getInviteToolbar();

	var buttonIds = [ZmOperation.REPLY_ACCEPT, ZmOperation.REPLY_DECLINE, ZmOperation.REPLY_TENTATIVE, ZmOperation.PROPOSE_NEW_TIME];
	for (var i = 0; i < buttonIds.length; i++) {
		var buttonId = buttonIds[i];
		inviteToolbar.getButton(buttonId).setEnabled(appCtxt.isExternalAccount() ? false : !disableButtonIds[buttonId]);
	}
};

/**
 * hide the participant status message (no longer relevant)
 */
ZmInviteMsgView.prototype.updatePtstMsg =
function(ptst) {
	var ptstMsgBannerDiv = document.getElementById(this._ptstMsgBannerId);
	if (!ptstMsgBannerDiv) {
		return;
	}
	ptstMsgBannerDiv.className = ZmInviteMsgView.PTST_MSG[ptst].className;
	ptstMsgBannerDiv.style.display = "block"; // since it might be display none if there's no message to begin with (this is the first time ptst is set by buttons)

	var ptstMsgElement = document.getElementById(this._ptstMsgId);
	ptstMsgElement.innerHTML = ZmInviteMsgView.PTST_MSG[ptst].msg;

	var ptstIconImg = document.getElementById(this._ptstMsgIconId);
	var icon = ZmCalItem.getParticipationStatusIcon(ptst);
	ptstIconImg.innerHTML = AjxImg.getImageHtml(icon)


};


ZmInviteMsgView.PTST_MSG = [];
ZmInviteMsgView.PTST_MSG[ZmCalBaseItem.PSTATUS_ACCEPT] = {msg: AjxMessageFormat.format(ZmMsg.inviteAccepted), className: "InviteStatusAccept"};
ZmInviteMsgView.PTST_MSG[ZmCalBaseItem.PSTATUS_DECLINED] = {msg: AjxMessageFormat.format(ZmMsg.inviteDeclined), className: "InviteStatusDecline"};
ZmInviteMsgView.PTST_MSG[ZmCalBaseItem.PSTATUS_TENTATIVE] = {msg: AjxMessageFormat.format(ZmMsg.inviteAcceptedTentatively), className: "InviteStatusTentative"};
ZmInviteMsgView.PTST_MSG[ZmCalBaseItem.PSTATUS_NEEDS_ACTION] = {msg: AjxMessageFormat.format(ZmMsg.ptstMsgNeedsAction), className: "InviteStatusTentative"};

ZmInviteMsgView.prototype.addSubs =
function(subs, sentBy, sentByAddr, obo) {

    AjxDispatcher.require(["MailCore", "CalendarCore", "Calendar"]);
	subs.invite = this._invite;

	if (!this._msg.isInviteCanceled() && !subs.invite.isOrganizer() && subs.invite.hasInviteReplyMethod()) {
		var yourPtst = this._msg.getPtst();
		this.enableToolbarButtons(yourPtst);
		if (yourPtst) {
			subs.ptstMsg = ZmInviteMsgView.PTST_MSG[yourPtst].msg;
			subs.ptstClassName = ZmInviteMsgView.PTST_MSG[yourPtst].className;
			subs.ptstIcon = ZmCalItem.getParticipationStatusIcon(yourPtst);
		}
	}
	//ids for updating later
	subs.ptstMsgBannerId = this._ptstMsgBannerId = (this.parent._htmlElId + "_ptstMsgBanner");
	subs.ptstMsgId = this._ptstMsgId = (this.parent._htmlElId + "_ptstMsg");
	subs.ptstMsgIconId = this._ptstMsgIconId = (this.parent._htmlElId + "_ptstMsgIcon");

	var isOrganizer = this._invite && this._invite.isOrganizer();
    var isInviteCancelled = this._invite.components && this._invite.components[0].method === ZmId.OP_CANCEL;
	// counter proposal
	if (this._invite.hasCounterMethod() &&
		this._msg.folderId != ZmFolder.ID_SENT)
	{
        var from = this._msg.getAddress(AjxEmailAddress.FROM) && this._msg.getAddress(AjxEmailAddress.FROM).getAddress();
        subs.counterInvMsg =  (!sentByAddr || sentByAddr == from) ?
            AjxMessageFormat.format(ZmMsg.counterInviteMsg, [from]):AjxMessageFormat.format(ZmMsg.counterInviteMsgOnBehalfOf, [sentByAddr, from]);
	}
	// Fix for bug: 88052 and 77237. Display cancellation banner to organizer or attendee
	else if (isInviteCancelled) {
		var organizer = this._invite.getOrganizerName() || this._invite.getOrganizerEmail();
		subs.ptstMsg = AjxMessageFormat.format(ZmMsg.inviteMsgCancelled, organizer.split());
		subs.ptstIcon = ZmCalItem.getParticipationStatusIcon(ZmCalBaseItem.PSTATUS_DECLINED);
		subs.ptstClassName = "InviteStatusDecline";
	}
	// if this an action'ed invite, show the status banner
	else if (isOrganizer && this._invite.hasAttendeeResponse()) {
		var attendee = this._invite.getAttendees()[0];
		var ptst = attendee && attendee.ptst;
		if (ptst) {
            var names = [];
			var dispName = attendee.d || attendee.a;
            var sentBy = attendee.sentBy;
            var ptstStr = null;
            if (sentBy) names.push(attendee.sentBy);
            names.push(dispName);
			subs.ptstIcon = ZmCalItem.getParticipationStatusIcon(ptst);
			switch (ptst) {
				case ZmCalBaseItem.PSTATUS_ACCEPT:
					ptstStr = (!sentBy) ? ZmMsg.inviteMsgAccepted : ZmMsg.inviteMsgOnBehalfOfAccepted;
					subs.ptstClassName = "InviteStatusAccept";
					break;
				case ZmCalBaseItem.PSTATUS_DECLINED:
					ptstStr = (!sentBy) ? ZmMsg.inviteMsgDeclined : ZmMsg.inviteMsgOnBehalfOfDeclined;
					subs.ptstClassName = "InviteStatusDecline";
					break;
				case ZmCalBaseItem.PSTATUS_TENTATIVE:
					ptstStr = (!sentBy) ? ZmMsg.inviteMsgTentative:ZmMsg.inviteMsgOnBehalfOfTentative;
					subs.ptstClassName = "InviteStatusTentative";
					break;
			}
            if (ptstStr){
                subs.ptstMsg = AjxMessageFormat.format(ptstStr, names);
            }
		}
	}

    if (isOrganizer && this._invite && this._invite.hasAttendeeResponse() && this._invite.getAppointmentId()){
        // set an Id for adding more detailed info later
        subs.ptstId = this._ptstId = (this.parent._htmlElId + "_ptst");
    }

    var options = {};
	options.shortAddress = appCtxt.get(ZmSetting.SHORT_ADDRESS);

	var om = this.parent._objectManager;
	// organizer
	var org = new AjxEmailAddress(this._invite.getOrganizerEmail(), null, this._invite.getOrganizerName());
	subs.invOrganizer = this.parent._getBubbleHtml(org, options);

    if (obo) {
	    subs.obo = this.parent._getBubbleHtml(obo, options);
    }

	// sent-by
	var sentBy = this._invite.getSentBy();
	if (sentBy) {
		subs.invSentBy = this.parent._getBubbleHtml(sentBy, options);
	}

    if(this._msg.cif) {
        subs.intendedForMsg = AjxMessageFormat.format(ZmMsg.intendedForInfo, [this._msg.cif]);
        subs.intendedForClassName = "InviteIntendedFor";
    }

	// inviteees
	var invitees = [];
    var optInvitees = [];

	var list = this._invite.getAttendees();
	for (var i = 0; i < list.length; i++) {
		var at = list[i];
		var attendee = new AjxEmailAddress(at.a, null, at.d);
        if (at.role == ZmCalItem.ROLE_OPTIONAL) {
            optInvitees.push(attendee);
        }
        else {
            invitees.push(attendee);
        }
	}
    var addressInfo = this.parent.getAddressesFieldInfo(invitees, options, "inv");
    subs.invitees = addressInfo.html;
    addressInfo = this.parent.getAddressesFieldInfo(optInvitees, options, "opt");
    subs.optInvitees = addressInfo.html;

	// convert to local timezone if necessary
	var inviteTz = this._invite.getServerStartTimeTz();
	var defaultTz = AjxTimezone.getServerId(AjxTimezone.DEFAULT);

    if (inviteTz) {
        var sd = AjxTimezone.convertTimezone(this._invite.getServerStartDate(null, true), AjxTimezone.getClientId(inviteTz), AjxTimezone.DEFAULT);
        var ed = AjxTimezone.convertTimezone(this._invite.getServerEndDate(null, true), AjxTimezone.getClientId(inviteTz), AjxTimezone.DEFAULT);

        subs.timezone = AjxTimezone.getMediumName(defaultTz);
    }

	// duration text
	var durText = this._invite.getDurationText(null, null, null, true, sd, ed);
	subs.invDate = durText;

	// recurrence
	if (this._invite.isRecurring()) {
		var recur = new ZmRecurrence();
		recur.setRecurrenceRules(this._invite.getRecurrenceRules(), this._invite.getServerStartDate());
		subs.recur = recur.getBlurb();
	}

	// set changes to the invite
	var changes = this._invite.getChanges();
	if (changes && changes[ZmInvite.CHANGES_LOCATION]) {
		subs.locChangeClass = "InvChanged";
	}
	if (changes && changes[ZmInvite.CHANGES_SUBJECT]) {
		subs.subjChangeClass = "InvChanged";
	}
	if (changes && changes[ZmInvite.CHANGES_TIME]) {
		subs.timeChangeClass = "InvChanged";
	}
};

ZmInviteMsgView.truncateBodyContent =
function(content, isHtml) {
    if (!content) return content;
	var sepIdx = content.indexOf(ZmItem.NOTES_SEPARATOR);
	if (sepIdx == -1) {
		return content;
	}
	if (isHtml) {
		//if it is a html content then just remove the content and preserve the html tags
		//surrounding the content.
        content = content.replace("<div>"+ ZmItem.NOTES_SEPARATOR +"</div>", ZmItem.NOTES_SEPARATOR); // Striping div if ZmItem.NOTES_SEPARATOR is part of div.
        content = content.replace(ZmItem.NOTES_SEPARATOR, "<div id='separatorId'>" + ZmItem.NOTES_SEPARATOR + "</div>");
        var divEle = document.createElement("div");
        divEle.innerHTML = content;
        var node = Dwt.byId("separatorId",divEle) ;
        if (node){
            var parent = node.parentNode
            // Removing all previousSiblings of node that contains ZmItem.NOTES_SEPARATOR
            while(node.previousSibling){
                parent.removeChild(node.previousSibling);
            }
            parent.removeChild(node);
        }
        return divEle.innerHTML;
	}
	return content.substring(sepIdx+ZmItem.NOTES_SEPARATOR.length);
};

ZmInviteMsgView.prototype._getCounterToolbar =
function() {
	var params = {
		parent: this.parent,
		buttons: [ZmOperation.ACCEPT_PROPOSAL, ZmOperation.DECLINE_PROPOSAL],
		posStyle: DwtControl.STATIC_STYLE,
		className: "ZmCounterToolBar",
		buttonClassName: "DwtToolbarButton",
		context: this.mode,
		toolbarType: ZmId.TB_COUNTER
	};
	var tb = new ZmButtonToolBar(params);

	var listener = new AjxListener(this, this._inviteToolBarListener);
	for (var i = 0; i < tb.opList.length; i++) {
		tb.addSelectionListener(tb.opList[i], listener);
	}

	return tb;
};

/**
 * returns the toolbar. Creates a new one only if it's not already set to the internal field
 */
ZmInviteMsgView.prototype.getInviteToolbar =
function() {
	if (!this._inviteToolbar) {
		this._inviteToolbar = this._createInviteToolbar();
		//hide it till needed. Just in case after the fix I submit with this, some future change will call it before needs to be displayed.
		this._inviteToolbar.setDisplay(Dwt.DISPLAY_NONE);
		
	}
	return this._inviteToolbar;
};


ZmInviteMsgView.prototype._createInviteToolbar =
function() {
	var replyButtonIds = [
		ZmOperation.INVITE_REPLY_ACCEPT,
		ZmOperation.INVITE_REPLY_TENTATIVE,
		ZmOperation.INVITE_REPLY_DECLINE
	];
	var notifyOperationButtonIds = [
		ZmOperation.REPLY_ACCEPT_NOTIFY,
		ZmOperation.REPLY_TENTATIVE_NOTIFY,
		ZmOperation.REPLY_DECLINE_NOTIFY
	];
	var ignoreOperationButtonIds = [
		ZmOperation.REPLY_ACCEPT_IGNORE,
		ZmOperation.REPLY_TENTATIVE_IGNORE,
		ZmOperation.REPLY_DECLINE_IGNORE
	];
	var inviteOps = [
		ZmOperation.REPLY_ACCEPT,
		ZmOperation.REPLY_TENTATIVE,
		ZmOperation.REPLY_DECLINE,
		ZmOperation.PROPOSE_NEW_TIME
	];

	var params = {
		parent: this.parent,
		buttons: inviteOps,
		posStyle: DwtControl.STATIC_STYLE,
		className: "ZmInviteToolBar",
		buttonClassName: "DwtToolbarButton",
		context: this.parent.getHTMLElId(),
		toolbarType: ZmId.TB_INVITE
	};
	var tb = new ZmButtonToolBar(params);

	var listener = new AjxListener(this, this._inviteToolBarListener);
	for (var i = 0; i < tb.opList.length; i++) {
		var id = tb.opList[i];

		tb.addSelectionListener(id, listener);

		if (id == ZmOperation.PROPOSE_NEW_TIME) { continue; }

		var button = tb.getButton(id);
		var standardItems = [notifyOperationButtonIds[i], replyButtonIds[i], ignoreOperationButtonIds[i]];
		var menu = new ZmActionMenu({parent:button, menuItems:standardItems});
		standardItems = menu.opList;
		for (var j = 0; j < standardItems.length; j++) {
			var menuItem = menu.getItem(j);
			menuItem.addSelectionListener(listener);
		}
		button.setMenu(menu);
	}

	this._respondOnBehalfLabel = tb.addFiller();
	tb.addFiller();

	// folder picker
	this._inviteMoveSelect = new DwtSelect({parent:tb});
	this._inviteMoveSelect.setVisible(false); //by default hide it. bug 74254

	return tb;
};

ZmInviteMsgView.prototype._inviteToolBarListener =
function(ev) {
	ev._inviteReplyType = ev.item.getData(ZmOperation.KEY_ID);
	ev._inviteReplyFolderId = ((this._inviteMoveSelect && this._inviteMoveSelect.getValue()) || ZmOrganizer.ID_CALENDAR);
	ev._inviteComponentId = null;
	ev._msg = this._msg;
	this.parent.notifyListeners(ZmInviteMsgView.REPLY_INVITE_EVENT, ev);
};

ZmInviteMsgView.prototype._dayResultsCallback =
function(dayViewCallback, invitedHour, list, skipMiniCalUpdate, query) {
	if (this._dayView) {
	    this._dayView.set(list, true);
	    this._dayView._scrollToTime(invitedHour);
	}
    if (dayViewCallback) {
        dayViewCallback.run();
    }
};

ZmInviteMsgView.prototype.getDayView =
function() {
    return this._dayView;
};

ZmInviteMsgView.prototype._apptSelectionListener =
function(ev) {
	if (ev.detail == DwtListView.ITEM_DBL_CLICKED) {
		var appt = ev.item;
		if (appt.isPrivate() && appt.getFolder().isRemote() && !appt.getFolder().hasPrivateAccess()) {
			var msgDialog = appCtxt.getMsgDialog();
			msgDialog.setMessage(ZmMsg.apptIsPrivate, DwtMessageDialog.INFO_STYLE);
			msgDialog.popup();
		} else {
			// open a appointment view
			var cc = AjxDispatcher.run("GetCalController");
			cc._showAppointmentDetails(appt);
		}
	}
};

ZmInviteMsgView.prototype.scrollToInvite =
function() {
    var inviteDate = this._getInviteDate();
    if ((inviteDate != null) && this._dayView) {
        this._dayView._scrollToTime(inviteDate.getHours());
    }
}

ZmInviteMsgView.prototype.repositionCounterToolbar =
function(hdrTableId) {
    if (this._invite && this._invite.hasCounterMethod() && hdrTableId && this._counterToolbar) {
        this._counterToolbar.reparentHtmlElement(hdrTableId + '_counterToolbar', 0);
    }
}
}
if (AjxPackage.define("zimbraMail.mail.view.ZmMailItemView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @class
 * Base class for a view displaying a single mail item (msg or conv).
 *
 * @author Conrad Damon
 *
 * @param {string}					id				ID for HTML element
 * @param {ZmListController}		controller		containing controller
 *
 * @extends		DwtComposite
 */
ZmMailItemView = function(params) {

	if (arguments.length == 0) { return; }
	
	DwtComposite.call(this, params);

	this._controller = params.controller;
};

ZmMailItemView.prototype = new DwtComposite;
ZmMailItemView.prototype.constructor = ZmMailItemView;

ZmMailItemView.prototype.isZmMailItemView = true;
ZmMailItemView.prototype.toString = function() { return "ZmMailItemView"; };

ZmMailItemView.prototype.set =
function(item, force) {
};

ZmMailItemView.prototype.getItem =
function() {
};

ZmMailItemView.prototype.reset =
function() {
};

ZmMailItemView.prototype.getMinHeight =
function() {
	return 20;
};

ZmMailItemView.prototype.getMinWidth =
function() {
	return 20;
};

ZmMailItemView.prototype.getHtmlBodyElement =
function() {
};

ZmMailItemView.prototype.hasHtmlBody =
function() {
	return false;
};

ZmMailItemView.prototype.getItem =
function() {
	return this._item;
};

ZmMailItemView.prototype.getTitle =
function() {
	return this._item ? [ZmMsg.zimbraTitle, this._item.subject].join(": ") : ZmMsg.zimbraTitle;
};

ZmMailItemView.prototype.setReadingPane =
function() {
};

ZmMailItemView.prototype.getInviteMsgView =
function() {
	return this._inviteMsgView;
};

// Create the ObjectManager at the last minute just before we scan the message
ZmMailItemView.prototype._lazyCreateObjectManager =
function(view) {
	// objectManager will be 'true' at create time, after that it will be the
	// real object. NOTE: Replaced if (this._objectManager === true) as "==="
	// does deep comparision of objects which might take a while.
	var createObjectMgr = (AjxUtil.isBoolean(this._objectManager) && this._objectManager);
	var firstCallAfterZimletLoading = (!this.zimletLoadFlag && appCtxt.getZimletMgr().isLoaded());

	if (createObjectMgr || firstCallAfterZimletLoading) {
		this.zimletLoadFlag = appCtxt.getZimletMgr().isLoaded();
		// this manages all the detected objects within the view
		this._objectManager = new ZmObjectManager(view || this);
	}
};
}
if (AjxPackage.define("zimbraMail.mail.view.ZmMailMsgView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmMailMsgView = function(params) {

	if (arguments.length == 0) { return; }

	params.className = params.className || "ZmMailMsgView";
	ZmMailItemView.call(this, params);

	this._mode = params.mode;
	this._controller = params.controller;
	this._viewId = this._getViewId(params.sessionId);

	this._displayImagesId	= ZmId.getViewId(this._viewId, ZmId.MV_DISPLAY_IMAGES, this._mode);
	this._msgTruncatedId	= ZmId.getViewId(this._viewId, ZmId.MV_MSG_TRUNC, this._mode);
	this._infoBarId			= ZmId.getViewId(this._viewId, ZmId.MV_INFO_BAR, this._mode);
	this._tagRowId			= ZmId.getViewId(this._viewId, ZmId.MV_TAG_ROW, this._mode);
	this._tagCellId			= ZmId.getViewId(this._viewId, ZmId.MV_TAG_CELL, this._mode);
	this._attLinksId		= ZmId.getViewId(this._viewId, ZmId.MV_ATT_LINKS, this._mode);

	this._scrollWithIframe = params.scrollWithIframe;
	this._limitAttachments = this._scrollWithIframe ? 3 : 0; //making it local
	this._attcMaxSize = this._limitAttachments * 16 + 8;
	this.setScrollStyle(this._scrollWithIframe ? DwtControl.CLIP : DwtControl.SCROLL);

	ZmTagsHelper.setupListeners(this); //setup tags related listeners.

	this._setMouseEventHdlrs(); // needed by object manager
	this._objectManager = true;

	this._changeListener = this._msgChangeListener.bind(this);
	this.addListener(DwtEvent.ONSELECTSTART, this._selectStartListener.bind(this));
	this.addListener(DwtEvent.CONTROL, this._controlEventListener.bind(this));

	// bug fix #25724 - disable right click selection for offline
	if (!appCtxt.isOffline) {
		this._setAllowSelection();
	}

	this.noTab = true;
    this._attachmentLinkIdToFileNameMap = null;
	this._bubbleParams = {};

	if (this._controller && this._controller._checkKeepReading) {
		Dwt.setHandler(this.getHtmlElement(), DwtEvent.ONSCROLL, ZmDoublePaneController.handleScroll);
	};

	this._tabGroupMember = new DwtTabGroup("ZmMailMsgView");
	this._headerTabGroup = new DwtTabGroup("ZmMailMsgView (header)");
	this._attachmentTabGroup = new DwtTabGroup("ZmMailMsgView (attachments)");
	this._bodyTabGroup = new DwtTabGroup("ZmMailMsgView (body)");
	this._footerTabGroup = new DwtTabGroup("ZmMailMsgView (footer)");

	this._tabGroupMember.addMember([
		this._headerTabGroup, this._bodyTabGroup, this._footerTabGroup
	]);

	if (this._mode === ZmId.VIEW_TRAD) {
		this.setAttribute('role', 'region');
	}
};

ZmMailMsgView.prototype = new ZmMailItemView;
ZmMailMsgView.prototype.constructor = ZmMailMsgView;

ZmMailMsgView.prototype.isZmMailMsgView = true;
ZmMailMsgView.prototype.toString = function() {	return "ZmMailMsgView"; };


// displays any additional headers in messageView
//pass ZmMailMsgView.displayAdditionalHdrsInMsgView[<actualHeaderName>] = <DisplayName>
//pass ZmMailMsgView.displayAdditionalHdrsInMsgView["X-Mailer"] = "Sent Using:"
ZmMailMsgView.displayAdditionalHdrsInMsgView = {};


// Consts

ZmMailMsgView.SCROLL_WITH_IFRAME	= true;
ZmMailMsgView.LIMIT_ATTACHMENTS 	= ZmMailMsgView.SCROLL_WITH_IFRAME ? 3 : 0;
ZmMailMsgView.ATTC_COLUMNS			= 2;
ZmMailMsgView.ATTC_MAX_SIZE			= ZmMailMsgView.LIMIT_ATTACHMENTS * 16 + 8;
ZmMailMsgView.QUOTE_DEPTH_MOD 		= 3;
ZmMailMsgView.MAX_SIG_LINES 		= 8;
ZmMailMsgView.SIG_LINE 				= /^(- ?-+)|(__+)\r?$/;
ZmMailMsgView._inited 				= false;
ZmMailMsgView.SHARE_EVENT 			= "share";
ZmMailMsgView.SUBSCRIBE_EVENT 		= "subscribe";
ZmMailMsgView.IMG_FIX_RE			= new RegExp("(<img\\s+.*dfsrc\\s*=\\s*)[\"']http[^'\"]+part=([\\d\\.]+)[\"']([^>]*>)", "gi");
ZmMailMsgView.FILENAME_INV_CHARS_RE = /[\.\/?*:;{}'\\]/g; // Chars we do not allow in a filename
ZmMailMsgView.SETHEIGHT_MAX_TRIES	= 3;

ZmMailMsgView._URL_RE = /^((https?|ftps?):\x2f\x2f.+)$/;
ZmMailMsgView._MAILTO_RE = /^mailto:[\x27\x22]?([^@?&\x22\x27]+@[^@?&]+\.[^@?&\x22\x27]+)[\x27\x22]?/;

ZmMailMsgView.MAX_ADDRESSES_IN_FIELD = 10;

// tags that are trusted in HTML content that is not displayed in an iframe
ZmMailMsgView.TRUSTED_TAGS = ["#text", "a", "abbr", "acronym", "address", "article", "b", "basefont", "bdo", "big",
	"blockquote", "body", "br", "caption", "center", "cite", "code", "col", "colgroup", "dd", "del", "dfn", "dir",
	"div", "dl", "dt", "em", "font", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "i", "img",
	"ins", "kbd", "li", "mark", "menu", "meter", "nav", "ol", "p", "pre", "q", "s", "samp", "section", "small",
	"span", "strike", "strong", "sub", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "time", "tr", "tt",
	"u", "ul", "var", "wbr"];

// attributes that we don't want to appear in HTML displayed in a div
ZmMailMsgView.UNTRUSTED_ATTRS = ["id", "class", "name", "profile"];

// Public methods

ZmMailMsgView.prototype.getController =
function() {
	return this._controller;
};

ZmMailMsgView.prototype.reset =
function() {
	// Bug 23692: cancel any pending actions
	if (this._resizeAction) {
		AjxTimedAction.cancelAction(this._resizeAction);
		this._resizeAction = null;
	}
	if (this._objectsAction) {
		AjxTimedAction.cancelAction(this._objectsAction);
		this._objectsAction = null;
	}
	this._msg = this._item = null;
	this._htmlBody = null;
	this._containerEl = null;

	// TODO: reuse all these controls that are being disposed here.....
	if (this._ifw) {
		this._ifw.dispose();
		this._ifw = null;
	}
	if (this._inviteMsgView) {
		this._inviteMsgView.reset(true);
	}
	
	var el = this.getHtmlElement();
	if (el) {
		el.innerHTML = "";
	}
	if (this._objectManager && this._objectManager.reset) {
		this._objectManager.reset();
	}
	this.setScrollWithIframe(this._scrollWithIframe);
};

ZmMailMsgView.prototype.dispose =
function() {
	ZmTagsHelper.disposeListeners(this);
	ZmMailItemView.prototype.dispose.apply(this, arguments);
};

ZmMailMsgView.prototype.preventSelection =
function() {
	return false;
};

ZmMailMsgView.prototype.set =
function(msg, force, dayViewCallback) {
	
	if (!force && this._msg && msg && !msg.force && (this._msg == msg)) { return; }

	var oldMsg = this._msg;
	this.reset();
	var contentDiv = this._getContainer();
	this._msg = this._item = msg;

	if (!msg) {
		if (this._inviteMsgView) {
			this._inviteMsgView.resize(true); //make sure the msg preview pane takes the entire area, in case we were viewing an invite. (since then it was resized to allow for day view) - bug 53098
		}
		contentDiv.innerHTML = (this._controller.getList().size()) ? AjxTemplate.expand("mail.Message#viewMessage") : "";
		return;
	}

	msg.force = false;
	var respCallback = this._handleResponseSet.bind(this, msg, oldMsg, dayViewCallback);
	this._renderMessage(msg, contentDiv, respCallback);
};

ZmMailMsgView.prototype._getContainer =
function() {
	return this.getHtmlElement();
};

ZmMailMsgView.prototype.__hasMountpoint =
function(share) {
	var tree = appCtxt.getFolderTree();
	return tree
		? this.__hasMountpoint2(tree.root, share.grantor.id, share.link.id)
		: false;
};

ZmMailMsgView.prototype.__hasMountpoint2 =
function(organizer, zid, rid) {
	if (organizer.zid == zid && organizer.rid == rid)
		return true;

	if (organizer.children) {
		var children = organizer.children.getArray();
		for (var i = 0; i < children.length; i++) {
			var found = this.__hasMountpoint2(children[i], zid, rid);
			if (found) {
				return true;
			}
		}
	}
	return false;
};

ZmMailMsgView.prototype.highlightObjects =
function(origText) {
	if (origText != null) {
		// we get here only for text messages; it's a lot
		// faster to call findObjects on the whole text rather
		// than parsing the DOM.
		DBG.timePt("START - highlight objects on-demand, text msg.");
		this._lazyCreateObjectManager();
		var html = this._objectManager.findObjects(origText, true, null, true);
		html = html.replace(/^ /mg, "&nbsp;")
			.replace(/\t/g, "<pre style='display:inline;'>\t</pre>")
			.replace(/\n/g, "<br>");
		var container = this.getContentContainer();
		container.innerHTML = html;
		DBG.timePt("END - highlight objects on-demand, text msg.");
	} else {
		this._processHtmlDoc();
	}
};

ZmMailMsgView.prototype.resetMsg =
function(newMsg) {
	// Remove listener for current msg if it exists
	if (this._msg) {
		this._msg.removeChangeListener(this._changeListener);
	}
};

ZmMailMsgView.prototype.getMsg =
function() {
	return this._msg;
};

ZmMailMsgView.prototype.getItem = ZmMailMsgView.prototype.getMsg;

// Following two overrides are a hack to allow this view to pretend it's a list view
ZmMailMsgView.prototype.getSelection =
function() {
	return [this._msg];
};

ZmMailMsgView.prototype.getSelectionCount =
function() {
	return 1;
};

ZmMailMsgView.prototype.getMinHeight =
function() {
	if (!this._headerHeight) {
		var headerObj = document.getElementById(this._hdrTableId);
		this._headerHeight = headerObj ? Dwt.getSize(headerObj).y : 0;
	}
	return this._headerHeight;
};

// returns true if the current message was rendered in HTML
ZmMailMsgView.prototype.hasHtmlBody =
function() {
	return this._htmlBody != null;
};

// returns the IFRAME's document if we are using one, or the window document
ZmMailMsgView.prototype.getDocument =
function() {
	return this._usingIframe ? Dwt.getIframeDoc(this.getIframe()) : document;
};

// returns the IFRAME element if we are using one
ZmMailMsgView.prototype.getIframe =
function() {

	if (!this._usingIframe) { return null; }
	
	var iframe = this._iframeId && document.getElementById(this._iframeId);
	iframe = iframe || (this._ifw && this._ifw.getIframe());
	return iframe;
};
ZmMailMsgView.prototype.getIframeElement = ZmMailMsgView.prototype.getIframe;

// Returns a BODY element if we are using an IFRAME, the container DIV if we are not.
ZmMailMsgView.prototype.getContentContainer =
function() {
	if (this._usingIframe) {
		var idoc = this.getDocument();
		var body = idoc && idoc.body;
		return body && body.childNodes.length === 1 ? body.firstChild : body;
	}
	else {
		return this._containerEl;
	}
};

ZmMailMsgView.prototype.getContent =
function() {
	var container = this.getContentContainer();
	return container ? container.innerHTML : "";
};

ZmMailMsgView.prototype.addInviteReplyListener =
function(listener) {
	this.addListener(ZmInviteMsgView.REPLY_INVITE_EVENT, listener);
};

ZmMailMsgView.prototype.addShareListener =
function(listener) {
	this.addListener(ZmMailMsgView.SHARE_EVENT, listener);
};

ZmMailMsgView.prototype.addSubscribeListener =
function(listener) {
	this.addListener(ZmMailMsgView.SUBSCRIBE_EVENT, listener);
};

ZmMailMsgView.prototype.getTabGroupMember =
function() {
	return this._tabGroupMember;
};

ZmMailMsgView.prototype._getMessageTabMember =
function() {
	if (this._usingIframe) {
		return this.getIframe().parentNode;
	} else {
		return Dwt.byId(this._msgBodyDivId);
	}
};

ZmMailMsgView.prototype.setVisible =
function(visible, readingPaneOnRight,msg) {
	DwtComposite.prototype.setVisible.apply(this, arguments);
	var inviteMsgView = this._inviteMsgView;
	if (!inviteMsgView) {
		return;
	}

	if (visible && this._msg) {
		if (this._msg != msg) {
			var dayView = inviteMsgView.getDayView();
			if (!dayView) {
				return;
			}
			dayView.setIsRight(readingPaneOnRight);

			inviteMsgView.set(this._msg);
			inviteMsgView.repositionCounterToolbar(this._hdrTableId);
			inviteMsgView.showMoreInfo(null, null, readingPaneOnRight);
		}
	}
	else {
		inviteMsgView.reset();
	}
};


// Private / protected methods

ZmMailMsgView.prototype._getSubscribeToolbar =
function(req) {
	if (this._subscribeToolbar) {
		if (AjxEnv.isIE) {
			//reparenting on IE does not work. So recreating in this case. (similar to bug 52412 for the invite toolbar)
			this._subscribeToolbar.dispose();
			this._subscribeToolbar = null;
		}
		else {
			return this._subscribeToolbar;
		}
	}

	this._subscribeToolbar = this._getButtonToolbar([ZmOperation.SUBSCRIBE_APPROVE, ZmOperation.SUBSCRIBE_REJECT],
												ZmId.TB_SUBSCRIBE,
												this._subscribeToolBarListener.bind(this, req));

	return this._subscribeToolbar;
};



ZmMailMsgView.prototype._getShareToolbar =
function() {
	if (this._shareToolbar) {
		if (AjxEnv.isIE) {
			//reparenting on IE does not work. So recreating in this case. (similar to bug 52412 for the invite toolbar)
			this._shareToolbar.dispose();
			this._shareToolbar = null;
		}
		else {
			return this._shareToolbar;
		}
	}

	this._shareToolbar = this._getButtonToolbar([ZmOperation.SHARE_ACCEPT, ZmOperation.SHARE_DECLINE],
												ZmId.TB_SHARE,
												this._shareToolBarListener.bind(this));

	return this._shareToolbar;
};

ZmMailMsgView.prototype._getButtonToolbar =
function(buttonIds, toolbarType, listener) {

	var params = {
		parent: this,
		buttons: buttonIds,
		posStyle: DwtControl.STATIC_STYLE,
		className: "ZmShareToolBar",
		buttonClassName: "DwtToolbarButton",
		context: this._mode,
		toolbarType: toolbarType
	};
	var toolbar = new ZmButtonToolBar(params);

	for (var i = 0; i < buttonIds.length; i++) {
		var id = buttonIds[i];

		// HACK: IE doesn't support multiple class names.
		var b = toolbar.getButton(id);
		b._hoverClassName = b._className + "-" + DwtCssStyle.HOVER;
		b._activeClassName = b._className + "-" + DwtCssStyle.ACTIVE;

		toolbar.addSelectionListener(id, listener);
	}

	return toolbar;
};

ZmMailMsgView.prototype._handleResponseSet =
function(msg, oldMsg, dayViewCallback) {

	var bubblesCreated = false;
	if (this._inviteMsgView) {
		// always show F/B view if in stand-alone message view otherwise, check if reading pane is on
		if (this._inviteMsgView.isActive() && (this._controller.isReadingPaneOn() || (this._controller.isZmMsgController))) {
			bubblesCreated = true;
			appCtxt.notifyZimlets("onMsgView", [msg, oldMsg, this]);
			this._inviteMsgView.showMoreInfo(this._createBubbles.bind(this), dayViewCallback);
		}
		else {
			// resize the message view without F/B view
			this._inviteMsgView.resize(true);
		}
    }

	this._setTags(msg);
	// Remove listener for current msg if it exists
	if (oldMsg) {
		oldMsg.removeChangeListener(this._changeListener);
	}
	msg.addChangeListener(this._changeListener);

	if (msg.cloneOf) {
		msg.cloneOf.addChangeListener(this._changeListener);
	}
	if (oldMsg && oldMsg.cloneOf) {
		oldMsg.cloneOf.removeChangeListener(this._changeListener);
	}

	// reset scroll view to top most
	var htmlElement = this.getHtmlElement();
	htmlElement.scrollTop = 0;
	if (htmlElement.scrollTop != 0 && this._usingIframe) {
		/* situation that happens only on Chrome, without repro steps - bug 55775/57090 */
		AjxDebug.println(AjxDebug.SCROLL, "scrollTop not set to 0. scrollTop=" + htmlElement.scrollTop + " offsetHeight=" + htmlElement.offsetHeight + " scrollHeight=" + htmlElement.scrollHeight + " browser=" + navigator.userAgent);
		AjxDebug.dumpObj(AjxDebug.SCROLL, htmlElement.outerHTML);
		/*
			trying this hack for solution -
			explanation: The scroll bar does not appear if the scrollHeight of the div is bigger than the total height of the iframe and header together (i.e. if htmlElement.scrollHeight >= htmlElement.offsetHeight)
			If the scrollbar does not appear it's set to, and stays 0 when the scrollbar reappears due to resizing the iframe in _resetIframeHeight (which is later, I think always on timer).
			So what I do here is set the height of the iframe to very small (since the default is 150px), so the scroll bar disappears.
			it will reappear when we reset the size in _resetIframeHeight. I hope this will solve the issue.
		*/
		var iframe = this.getIframe();
		if (iframe) {
			iframe.style.height = "1px";
			AjxDebug.println(AjxDebug.SCROLL, "scrollTop after resetting it with the hack =" + htmlElement.scrollTop);
		}

	}

	if (!bubblesCreated) {
		this._createBubbles();
		appCtxt.notifyZimlets("onMsgView", [msg, oldMsg, this]);
	}

	if (!msg.isDraft && msg.readReceiptRequested) {
		this._controller.sendReadReceipt(msg);
	}
};

// This is needed for Gecko only: for some reason, clicking on a local link will
// open the full Zimbra chrome in the iframe :-( so we fake a scroll to the link
// target here. (bug 7927)
ZmMailMsgView.__localLinkClicked =
function(msgView, ev) {
	// note that this function is called in the context of the link ('this' is an A element)
	var id = this.getAttribute("href");
	var el = null;
	var doc = this.ownerDocument;

	if (id.substr(0, 1) == "#") {
		id = id.substr(1);
		el = doc.getElementById(id);
		if (!el) {
			try {
				el = doc.getElementsByName(id)[0];
			} catch(ex) {}
		}
		if (!el) {
			id = decodeURIComponent(id);
			el = doc.getElementById(id);
			if (!el) {
				try {
					el = doc.getElementsByName(id)[0];
				} catch(ex) {}
			}
		}
	}

	// attempt #1: doesn't work at all -- we're not scrolling with the IFRAME :-(
	// 		if (el) {
	// 			var pos = Dwt.getLocation(el);
	// 			doc.contentWindow.scrollTo(pos.x, pos.y);
	// 		}

	// attempt #2: works pretty well, but the target node will showup at the bottom of the frame
	// 		var foo = doc.createElement("a");
	// 		foo.href = "#";
	// 		foo.innerHTML = "foo";
	// 		el.parentNode.insertBefore(foo, el);
	// 		foo.focus();

	// the final monstrosity: scroll the containing DIV
	// (that is the whole msgView).  Note we have to take
	// into account the headers, "display images", etc --
	// so we add iframe.offsetTop/Left.
	if (el) {
		var div = msgView.getHtmlElement();
		var iframe = msgView.getIframe();
		var pos = Dwt.getLocation(el);
		div.scrollTop = pos.y + iframe.offsetTop - 20; // fuzz factor necessary for unknown reason :-(
		div.scrollLeft = pos.x + iframe.offsetLeft;
	}
	if (ev) {
		ev.stopPropagation();
		ev.preventDefault();
	}
	return false;
};

ZmMailMsgView.prototype.hasValidHref =
function (node) {
	// Bug 22958: IE can throw when you try and get the href if it doesn't like
	// the value, so we wrap the test in a try/catch.
	// hrefs formatted like http://www.name@domain.com can cause this to happen.
	try {
		var href = node.href;
		return ZmMailMsgView._URL_RE.test(href) || ZmMailMsgView._MAILTO_RE.test(href);
	} catch (e) {
		return false;
	}
};

// Dives recursively into the given DOM node.  Creates ObjectHandlers in text
// nodes and cleans the mess in element nodes.  Discards by default "script",
// "link", "object", "style", "applet" and "iframe" (most of them shouldn't
// even be here since (1) they belong in the <head> and (2) are discarded on
// the server-side, but we check, just in case..).
ZmMailMsgView.prototype._processHtmlDoc =
function() {

	var parent = this._usingIframe ? this.getDocument() : this._containerEl;
	if (!parent) { return; }

	DBG.timePt("Starting ZmMailMsgView.prototype._processHtmlDoc");
	// bug 8632
	var images = parent.getElementsByTagName("img");
	if (images.length > 0) {
		var length = images.length;
		for (var i = 0; i < images.length; i++) {
			this._checkImgInAttachments(images[i]);
		}
	}

	//Find Zimlet Objects lazly
	this.lazyFindMailMsgObjects(500);

	DBG.timePt("-- END _processHtmlDoc");
};

ZmMailMsgView.prototype.lazyFindMailMsgObjects = function(interval) {

    var isSpam = (this._msg && this._msg.folderId == ZmOrganizer.ID_SPAM);
    if (this._objectManager && !this._disposed && !isSpam) {
		this._lazyCreateObjectManager();
		this._objectsAction = new AjxTimedAction(this, this._findMailMsgObjects);
		AjxTimedAction.scheduleAction(this._objectsAction, ( interval || 500 ));
	}
};

ZmMailMsgView.prototype._findMailMsgObjects =
function() {
	var doc = this.getDocument();
	if (doc) {
		var container = this.getContentContainer();
		this._objectManager.processObjectsInNode(doc, container);
	}
};

ZmMailMsgView.prototype._checkImgInAttachments =
function(img) {
    if (!this._msg) { return; }

    if (img.getAttribute("zmforced")){
        img.className = "InlineImage";
        return;
    }

	var attachments = this._msg.attachments;
	var csfeMsgFetch = appCtxt.get(ZmSetting.CSFE_MSG_FETCHER_URI);
	try {
		var src = img.getAttribute("src") || img.getAttribute("dfsrc");
	}
	catch(e) {
		AjxDebug.println(AjxDebug.DATA_URI, "_checkImgInAttachments: couldn't access attribute src or dfsrc");
	}
	var cid;
	if (/^cid:(.*)/.test(src)) {
		cid = "<" + RegExp.$1 + ">";
	}

	for (var i = 0; i < attachments.length; i++) {
		var att = attachments[i];

		if (att.foundInMsgBody) { continue; }

		if (cid && att.contentId == cid) {
			att.foundInMsgBody = true;
			break;
		} else if (src && src.indexOf(csfeMsgFetch) == 0) {
			var mpId = src.substring(src.lastIndexOf("=") + 1);
			if (mpId == att.part) {
				att.foundInMsgBody = true;
				break;
			}
		} else if (att.contentLocation && src) {
			var filename = src.substring(src.lastIndexOf("/") + 1);
			if (filename == att.fileName) {
				att.foundInMsgBody = true;
				break;
			}
		}
	}
};

ZmMailMsgView.prototype._fixMultipartRelatedImages =
function(msg, parent) {
	// fix <img> tags
	var images = parent.getElementsByTagName("img");
	var hasExternalImages = false;
	if (this._usingIframe) {
		var self = this;
		var onload = function() {
			//resize iframe onload of image
			ZmMailMsgView._resetIframeHeight(self);
			this.onload = null; // *this* is reference to <img> el.
		};
	}
	for (var i = 0; i < images.length; i++) {
		var img = images[i];
		var external = ZmMailMsgView._isExternalImage(img);	// has "dfsrc" attr
		if (!external) { //Inline image
			ZmMailMsgView.__unfangInternalImage(msg, img, "src", false);
			if (onload) {
				img.onload = onload;
			}
		}
        else {
			img.src = "/img/zimbra/1x1-trans.png";
			img.setAttribute('savedDisplayMode', img.style.display);
			img.style.display = 'none';
        }
		hasExternalImages = external || hasExternalImages;
	}
	// fix all elems with "background" attribute
	hasExternalImages = this._fixMultipartRelatedImagesRecurse(msg, this._usingIframe ? parent.body : parent) || hasExternalImages;

	// did we get them all?
	return !hasExternalImages;
};

ZmMailMsgView.prototype._fixMultipartRelatedImagesRecurse =
function(msg, node) {

	var hasExternalImages = false;

	function recurse(node){
		var child = node.firstChild;
		while (child) {
			if (child.nodeType == AjxUtil.ELEMENT_NODE) {
				hasExternalImages = ZmMailMsgView.__unfangInternalImage(msg, child, "background", true) || hasExternalImages;
				recurse(child);
			}
			child = child.nextSibling;
		}
	}

	if (node.innerHTML.indexOf("dfbackground") != -1) {
		recurse(node);
	}
	else if (node.attributes && node.getAttribute("dfbackground") != -1) {
		hasExternalImages = ZmMailMsgView.__unfangInternalImage(msg, node, "background", true);	
	}
	
	if (!hasExternalImages && $(node).find("table[dfbackground], td[dfbackground]").length) {
		hasExternalImages = true;
	}

	return hasExternalImages;
};

/**
 * Determines if an img element references an external image
 * @param elem {HTMLelement}
 * @return {Boolean} true if image is external
 */
ZmMailMsgView._isExternalImage = 
function(elem) {
	if (!elem) {
		return false;
	}
	return Boolean(elem.getAttribute("dfsrc"));
}

/**
 * Reverses the work of the (server-side) defanger, so that images are displayed.
 * 
 * @param {ZmMailMsg}	msg			mail message
 * @param {Element}		elem		element to be checked (img)
 * @param {string}		aname		attribute name
 * @param {boolean}		external	if true, look only for external images
 * 
 * @return	true if the image is external
 */
ZmMailMsgView.__unfangInternalImage =
function(msg, elem, aname, external) {
	
	var avalue, pnsrc;
	try {
		if (external) {
			avalue = elem.getAttribute("df" + aname);
		}
		else {
			pnsrc = avalue = elem.getAttribute("pn" + aname);
			avalue = avalue || elem.getAttribute(aname);
		}
	}
	catch(e) {
		AjxDebug.println(AjxDebug.DATA_URI, "__unfangInternalImage: couldn't access attribute " + aname);
	}

	if (avalue) {
		if (avalue.substr(0,4) == "cid:") {
			var cid = "<" + AjxStringUtil.urlComponentDecode(avalue.substr(4)) + ">"; // Parse percent-escaping per bug #52085 (especially %40 to @)
			avalue = msg.getContentPartAttachUrl(ZmMailMsg.CONTENT_PART_ID, cid);
			if (avalue) {
				elem.setAttribute(aname, avalue);
			}
			return false;
		} else if (avalue.substring(0,4) == "doc:") {
			avalue = [appCtxt.get(ZmSetting.REST_URL), ZmFolder.SEP, avalue.substring(4)].join('');
			if (avalue) {
				elem.setAttribute(aname, avalue);
				return false;
			}
		} else if (pnsrc) { // check for content-location verison
			avalue = msg.getContentPartAttachUrl(ZmMailMsg.CONTENT_PART_LOCATION, avalue);
			if (avalue) {
				elem.setAttribute(aname, avalue);
				return false;
			}
		} else if (avalue.substring(0,5) == "data:") {
			return false;
		}
		return true;	// not recognized as inline img
	}
	return false;
};

ZmMailMsgView.prototype._createDisplayImageClickClosure =
function(msg, parent, id) {
	var self = this;
	return function(ev) {
        var target = DwtUiEvent.getTarget(ev),
            targetId = target ? target.id : null,
            addrToAdd = "";
        var diEl = document.getElementById(id);
        
        //This is required in case of the address is marked as trusted, the function is called without any target being set
        var force = (msg && msg.showImages) ||  appCtxt.get(ZmSetting.DISPLAY_EXTERNAL_IMAGES);

        if (!force) {
            if (!targetId) { return; }
            if (targetId.indexOf("domain") != -1) {
                //clicked on domain
                addrToAdd = msg.sentByDomain;
            }
            else if (targetId.indexOf("email") != -1) {
                //clicked on email
                addrToAdd = msg.sentByAddr;
            }
            else if (targetId.indexOf("dispImgs") != -1) {
               //do nothing here - just load the images
            }
            else if (targetId.indexOf("close") != -1) {
				Dwt.setVisible(diEl, false);
                return;
            }
            else {
                //clicked elsewhere in the info bar - DO NOTHING AND RETURN
                return;
            }
        }
        //Create a modifyprefs req and add the addr to modify
        if (addrToAdd) {
            var trustedList = self.getTrustedSendersList();
            trustedList.add(addrToAdd, null, true);
			var callback = self._addTrustedAddrCallback.bind(self, addrToAdd);
			var errorCallback = self._addTrustedAddrErrorCallback.bind(self, addrToAdd); 
            self._controller.addTrustedAddr(trustedList.getArray(), callback, errorCallback);
        }

		var images = parent.getElementsByTagName("img");
		var onload = null;
		if (self._usingIframe) {
			onload = function() {            
				ZmMailMsgView._resetIframeHeight(self);
				this.onload = null; // *this* is reference to <img> el.
				DBG.println(AjxDebug.DBG3, "external image onload called for  " + this.src);
			};
		}
		for (var i = 0; i < images.length; i++) {
			var dfsrc = images[i].getAttribute("dfsrc");
			if (dfsrc && dfsrc.match(/https?:\/\/([-\w\.]+)+(:\d+)?(\/([\w\_\.]*(\?\S+)?)?)?/)) {
                images[i].onload = onload;
				// Fix for IE: Over HTTPS, http src urls for images might cause an issue.
				try {
					DBG.println(AjxDebug.DBG3, "displaying external images. src = " + images[i].src);
					images[i].src = ''; //unload it first
					images[i].src = images[i].getAttribute("dfsrc");
					DBG.println(AjxDebug.DBG3, "displaying external images. src is now = " + images[i].src);
				} catch (ex) {
					// do nothing
				}
				images[i].style.display = images[i].getAttribute('savedDisplayMode');
			}
		}
		//determine if any tables or table cells have an external background image
		var tableCells = $(parent).find("table[dfbackground], td[dfbackground]");
		for (var i=0; i<tableCells.length; i++) {
			var dfbackground = $(tableCells[i]).attr("dfbackground");
			if (ZmMailMsgView._URL_RE.test(dfbackground)) {
				$(tableCells[i]).attr("background", dfbackground);
			}
		}

		Dwt.setVisible(diEl, false);
		self._htmlBody = self.getContentContainer().innerHTML;
		if (msg) {
			msg.setHtmlContent(self._htmlBody);
			msg.showImages = true;
		}
        //Make sure the link is not followed
        return false;
	};
};

ZmMailMsgView.prototype._resetIframeHeightOnTimer =
function(attempt) {
	
	if (!this._usingIframe) { return; }

	DBG.println(AjxDebug.DBG1, "_resetIframeHeightOnTimer attempt: " + (attempt != null ? attempt : "null"));
	// Because sometimes our view contains images that are slow to download, wait a
	// little while before resizing the iframe.
	var act = this._resizeAction = new AjxTimedAction(this, ZmMailMsgView._resetIframeHeight, [this, attempt]);
	AjxTimedAction.scheduleAction(act, 200);
};

ZmMailMsgView.prototype._makeHighlightObjectsDiv =
function(origText) {
	var self = this;
	function func() {
		var div = document.getElementById(self._highlightObjectsId);
		div.innerHTML = ZmMsg.pleaseWaitHilitingObjects;
		setTimeout(function() {
			self.highlightObjects(origText);
            div.parentNode.removeChild(div);
            ZmMailMsgView._resetIframeHeight(self);
        }, 3);
		return false;
	}
	// avoid closure memory leaks
	(function() {
		var infoBarDiv = document.getElementById(self._infoBarId);
		if (infoBarDiv) {
			self._highlightObjectsId = ZmId.getViewId(self._viewId, ZmId.MV_HIGHLIGHT_OBJ, self._mode);
			var subs = {
				id: self._highlightObjectsId,
				text: ZmMsg.objectsNotDisplayed,
				link: ZmMsg.hiliteObjects
			};
			var html = AjxTemplate.expand("mail.Message#InformationBar", subs);
			infoBarDiv.appendChild(Dwt.parseHtmlFragment(html));

			var div = document.getElementById(subs.id+"_link");
			Dwt.setHandler(div, DwtEvent.ONCLICK, func);
		}
	})();
};

ZmMailMsgView.prototype._stripHtmlComments =
function(html) {
	// bug: 38273 - Remove HTML Comments <!-- -->
	// But make sure not to remove inside style|script tags.
	var regex =  /<(?:!(?:--[\s\S]*?--\s*)?(>)\s*|(?:script|style|SCRIPT|STYLE)[\s\S]*?<\/(?:script|style|SCRIPT|STYLE)>)/g;
	html = html.replace(regex,function(m, $1) {
		return $1 ? '':m;
	});
	return html;
};

// Returns true (the default) if we should display content in an IFRAME as opposed to a DIV.
ZmMailMsgView.prototype._useIframe =
function(isTextMsg, html, isTruncated) {
	return true;
};

// Displays the given content in an IFRAME or a DIV.
ZmMailMsgView.prototype._displayContent =
function(params) {

	var html = params.html || "";
	
	if (!params.isTextMsg) {
		//Microsoft silly smilies
		html = html.replace(/<span style="font-family:Wingdings">J<\/span>/g, "\u263a"); // :)
		html = html.replace(/<span style="font-family:Wingdings">L<\/span>/g, "\u2639"); // :(
	}

	// The info bar allows the user to load external images. We show it if:
	// - msg is HTML
	// - user pref says not to show images up front, or this is Spam folder
	// - we're not already showing images
	// - there are <img> tags OR tags with dfbackground set
	var isSpam = (this._msg && this._msg.folderId == ZmOrganizer.ID_SPAM);
	var imagesNotShown = (!this._msg || !this._msg.showImages);
	this._needToShowInfoBar = (!params.isTextMsg &&
		(!appCtxt.get(ZmSetting.DISPLAY_EXTERNAL_IMAGES) || isSpam) &&
		imagesNotShown &&
		(/<img/i.test(html) || /<[^>]+dfbackground/.test(html)));

	var displayImages;
	if (this._needToShowInfoBar) {
		displayImages = this._showInfoBar(this._infoBarId);
	}

	var callback;
	var msgSize = (html.length / 1024);
	var maxHighlightSize = appCtxt.get(ZmSetting.HIGHLIGHT_OBJECTS);
	if (params.isTextMsg) {
		if (this._objectManager) {
			if (msgSize <= maxHighlightSize) {
				callback = this.lazyFindMailMsgObjects.bind(this, 500);
			} else {
				this._makeHighlightObjectsDiv(params.origText);
			}
		}
		if (AjxEnv.isSafari) {
			html = "<html><head></head><body>" + html + "</body></html>";
		}
	} else {
		html = this._stripHtmlComments(html);
		if (this._objectManager) {
			var images = html.match(/<img[^>]+>/ig);
			msgSize = (images) ? msgSize - (images.join().length / 1024) : msgSize; // Excluding images in the message
			
			if (msgSize <= maxHighlightSize) {
				callback = this._processHtmlDoc.bind(this);
			} else {
				this._makeHighlightObjectsDiv();
			}
		}
	}

	var msgTruncated;
	this._isMsgTruncated = false;
	if (params.isTruncated) {
		this._isMsgTruncated = true;
		var msgTruncatedDiv = document.getElementById(this._msgTruncatedId);
		if (!msgTruncatedDiv) {
			var infoBarDiv = document.getElementById(this._infoBarId);
			if (infoBarDiv) {
				var subs = {
					id: this._msgTruncatedId,
					text: ZmMsg.messageTooLarge,
					link: ZmMsg.viewEntireMessage
				};
				var msgTruncatedHtml = AjxTemplate.expand("mail.Message#InformationBar", subs);
				msgTruncated = Dwt.parseHtmlFragment(msgTruncatedHtml);
				infoBarDiv.appendChild(msgTruncated);
				Dwt.setHandler(msgTruncated, DwtEvent.ONCLICK, this._handleMsgTruncated.bind(this));
			}
		}
	}

	this._msgBodyDivId = [this._htmlElId, ZmId.MV_MSG_BODY].join("_");
	this._bodyTabGroup.removeAllMembers();
	
	this._usingIframe = this._useIframe(params.isTextMsg, html, params.isTruncated);
	DBG.println(AjxDebug.DBG1, "Use IFRAME: " + this._usingIframe);
	
	if (this._usingIframe) {
		// bug fix #9475 - IE isnt resolving MsgBody class in iframe so set styles explicitly
		var inner_styles = AjxEnv.isIE ? ".MsgBody-text, .MsgBody-text * { font: 10pt monospace; }" : "";
		var params1 = {
			parent:					this,
			parentElement:			params.container,
			index:					params.index,
			className:				this._getBodyClass(),
			id:						this._msgBodyDivId,
			hidden:					true,
			html:					"<div>" + (this._cleanedHtml || html) + "</div>",
			styles:					inner_styles,
			noscroll:				!this._scrollWithIframe,
			posStyle:				DwtControl.STATIC_STYLE,
			processHtmlCallback:	callback,
			useKbMgmt:				true,
			title:                  this._getIframeTitle()
		};

		// TODO: cache iframes
		var ifw = this._ifw = new DwtIframe(params1);
		if (ifw.initFailed) {
			AjxDebug.println(AjxDebug.MSG_DISPLAY, "Message display: IFRAME was not ready");
			appCtxt.setStatusMsg(ZmMsg.messageDisplayProblem);
			return;
		}
		this._iframeId = ifw.getIframe().id;

		var idoc = ifw.getDocument();

		if (AjxEnv.isGeckoBased) {
			// patch local links (pass null as object so it gets called in context of link)
			var geckoScrollCallback = ZmMailMsgView.__localLinkClicked.bind(null, this);
			var links = idoc.getElementsByTagName("a");
			for (var i = links.length; --i >= 0;) {
				var link = links[i];
				if (!link.target) {
					link.onclick = geckoScrollCallback; // has chances to be a local link
				}
			}
		}

		//update root html elment class to reflect user selected font size - so that if we use our relative font size properties in CSS inside (stuff from msgview.css) it would be relative to this and not to the browser default.
		Dwt.addClass(idoc.documentElement, "user_font_size_" + appCtxt.get(ZmSetting.FONT_SIZE));
		Dwt.addClass(idoc.documentElement, "user_font_" + appCtxt.get(ZmSetting.FONT_NAME));

		// assign the right class name to the iframe body
		idoc.body.className = this._getBodyClass() + (params.isTextMsg ? " MsgBody-text" : " MsgBody-html");

		idoc.body.style.height = "auto"; //see bug 56899 - if the body has height such as 100% or 94%, it causes a problem in FF in calcualting the iframe height. Make sure the height is clear.

		ifw.getIframe().onload = this._onloadIframe.bind(this, ifw);

		// import the object styles
		var head = idoc.getElementsByTagName("head")[0];
		if (!head) {
			head = idoc.createElement("head");
			idoc.body.parentNode.insertBefore(head, idoc.body);
		}
	
		if (!ZmMailMsgView._CSS) {
			// Make a synchronous request for the CSS. Should we do this earlier?
			var cssUrl = [appContextPath, "/css/msgview.css?v=", cacheKillerVersion, "&locale=", window.appRequestLocaleId, "&skin=", window.appCurrentSkin].join("");
			if (AjxEnv.supported.localstorage) {
				ZmMailMsgView._CSS = localStorage.getItem(cssUrl);
			}
			if (!ZmMailMsgView._CSS) {
				var result = AjxRpc.invoke(null, cssUrl, null, null, true);
				ZmMailMsgView._CSS = result && result.text;
			}
		}
		var style = document.createElement('style');
		var rules = document.createTextNode(ZmMailMsgView._CSS);
		style.type = 'text/css';
		if (style.styleSheet) {
			style.styleSheet.cssText = rules.nodeValue;
		}
		else {
			style.appendChild(rules);
		}
		head.appendChild(style);
	
		ifw.getIframe().style.visibility = "";

		this._bodyTabGroup.addMember(ifw);

	}
	else {
		var div = this._containerEl = document.createElement("div");
		div.id = this._msgBodyDivId;
		div.className = "MsgBody MsgBody-" + (params.isTextMsg ? "text" : "html");
		var parent = this.getHtmlElement();
		if (!parent) {
			AjxDebug.println(AjxDebug.MSG_DISPLAY, "Message display: DIV was not ready");
			appCtxt.setStatusMsg(ZmMsg.messageDisplayProblem);
			return;
		}
		if (params.index != null) {
			parent.insertBefore(div, parent.childNodes[params.index])
		}
		else {
			parent.appendChild(div);
		}
		div.innerHTML = this._cleanedHtml || html;

		this._makeFocusable(div);
		this._bodyTabGroup.addMember(div);
	}

	if (!params.isTextMsg) {
		this._htmlBody = this.getContentContainer().innerHTML;

		// TODO: only call this if top-level is multipart/related?
		// setup the click handler for the images
		var didAllImages = this._fixMultipartRelatedImages(this._msg, idoc || this._containerEl);
		if (didAllImages) {
			Dwt.setVisible(displayImages, false);
			this._needToShowInfoBar = false;
		} else {
			this._setupInfoBarClicks(displayImages);
		}
	}

	this._resetIframeHeightOnTimer();
	if (callback) {
		callback.run();
	}
};
ZmMailMsgView.prototype._makeIframeProxy = ZmMailMsgView.prototype._displayContent;

ZmMailMsgView.prototype._showInfoBar =
function(parentEl, html, isTextMsg) {

	parentEl = (typeof(parentEl) == "string") ? document.getElementById(parentEl) : parentEl;
	if (!parentEl) { return; }
	
	// prevent appending the "Display Images" info bar more than once
	var displayImages;
	var dispImagesDiv = document.getElementById(this._displayImagesId);
	if (!dispImagesDiv) {
		if (parentEl) {
			var subs = {
				id:			this._displayImagesId,
				text:		ZmMsg.externalImages,
				link:		ZmMsg.displayExternalImages,
				alwaysText:	ZmMsg.alwaysDisplayExternalImages,
				domain:		this._msg.sentByDomain,
				email:		this._msg.sentByAddr,
				or:			ZmMsg.or
			};
			var extImagesHtml = AjxTemplate.expand("mail.Message#ExtImageInformationBar", subs);
			displayImages = Dwt.parseHtmlFragment(extImagesHtml);
			parentEl.appendChild(displayImages);
		}
	}
	return displayImages;
};

ZmMailMsgView.prototype._setupInfoBarClicks =
function(displayImages) {

	var parent = this._usingIframe ? this.getDocument() : this._containerEl;
	var func = this._createDisplayImageClickClosure(this._msg, parent, this._displayImagesId);
	if (displayImages) {
		Dwt.setHandler(displayImages, DwtEvent.ONCLICK, func);
	}
	else if (appCtxt.get(ZmSetting.DISPLAY_EXTERNAL_IMAGES) ||
			 (this._msg && this._msg.showImages))
	{
		func.call();
	}
};

ZmMailMsgView.prototype._getBodyClass =
function() {
	return "MsgBody";
};

ZmMailMsgView.prototype._addTrustedAddrCallback =
function(addr) {
    this.getTrustedSendersList().add(addr, null, true);
    appCtxt.set(ZmSetting.TRUSTED_ADDR_LIST, this.getTrustedSendersList().getArray());
    var prefApp = appCtxt.getApp(ZmApp.PREFERENCES);
    var func = prefApp && prefApp["refresh"];
    if (func && (typeof(func) == "function")) {
        func.apply(prefApp, [null, addr]);
    }
};

ZmMailMsgView.prototype._addTrustedAddrErrorCallback =
function(addr) {
    this.getTrustedSendersList().remove(addr);
};

ZmMailMsgView.prototype._isTrustedSender =
function(msg) {
    var trustedList = this.getTrustedSendersList();
    if (trustedList.contains(msg.sentByAddr.toLowerCase()) || trustedList.contains(msg.sentByDomain.toLowerCase())){
        return true;
    }
    return false;
};

ZmMailMsgView.prototype.getTrustedSendersList =
function() {
    return this._controller.getApp().getTrustedSendersList();
};

ZmMailMsgView.showMore =
function(elementId, type) {

	var showMore = document.getElementById(this._getShowMoreId(elementId, type));
	if (showMore) {
		Dwt.setVisible(showMore, false);
	}
	var more = document.getElementById(this._getMoreId(elementId, type));
	if (more) {
		more.style.display = "inline";
	}
};

ZmMailMsgView._getShowMoreId =
function(elementId, type) {
	return elementId + 'showmore_' + type;
};

ZmMailMsgView._getMoreId =
function(elementId, type) {
	return elementId + 'more_addrs_' + type;
};

/**
 *
 * formats the array of addresses as HTML with possible "show more" expand link if more than a certain number of addresses are in the field.
 *
 * @param addrs array of addresses
 * @param options
 * @param type some type identifier (one per page)
 * @param om {ZmObjectManager}
 * @param htmlElId - unique view id so it works with multiple views open.
 *
 * returns object with the html and ShowMore link id
 */
ZmMailMsgView.prototype.getAddressesFieldHtmlHelper =
function(addrs, options, type) {

	var addressInfo = {};
	var idx = 0, parts = [];

	for (var i = 0; i < addrs.length; i++) {
		if (i > 0) {
			// no need for separator since we're showing addr bubbles
			parts[idx++] = " ";
		}

		if (i == ZmMailMsgView.MAX_ADDRESSES_IN_FIELD) {
			var showMoreId = ZmMailMsgView._getShowMoreId(this._htmlElId, type);
			addressInfo.showMoreLinkId = showMoreId + "_link";
			var moreId = ZmMailMsgView._getMoreId(this._htmlElId, type);
			parts[idx++] = "<span id='" + showMoreId + "' style='white-space:nowrap'>&nbsp;";
			parts[idx++] = "<a id='" + addressInfo.showMoreLinkId + "' href='' onclick='ZmMailMsgView.showMore(\"" + this._htmlElId + "\", \"" + type + "\"); return false;'>";
			parts[idx++] = ZmMsg.showMore;
			parts[idx++] = "</a></span><span style='display:none;' id='" + moreId + "'>";
		}
		var email = addrs[i];
		if (email.address) {
			parts[idx++] = this._getBubbleHtml(email, options);
		}
		else {
			parts[idx++] = AjxStringUtil.htmlEncode(email.name);
		}
	}
	if (addressInfo.showMoreLinkId) {
		parts[idx++] = "</span>";
	}
	addressInfo.html =  parts.join("");
	return addressInfo;
};

ZmMailMsgView.prototype._getBubbleHtml = function(addr, options) {
	if (!addr) {
		return "";
	}

	options = options || {};

	addr = addr.isAjxEmailAddress ? addr : new AjxEmailAddress(addr);

	var canExpand = addr.isGroup && addr.canExpand && appCtxt.get("EXPAND_DL_ENABLED"),
		ctlr = this._controller;

	if (canExpand && !this._aclv) {
		// create a hidden ZmAutocompleteListView to handle DL expansion
		var aclvParams = {
			dataClass:		    appCtxt.getAutocompleter(),
			matchValue:		    ZmAutocomplete.AC_VALUE_FULL,
			options:		    { massDLComplete:true },
			selectionCallback:	ctlr._dlAddrSelected.bind(ctlr),
			contextId:		    this.toString()
		};
		this._aclv = new ZmAutocompleteListView(aclvParams);
	}

	// We'll be creating controls (bubbles) later, so we provide the tooltip now and let the control manage
	// it instead of the zimlet framework.
	var id = ZmId.create({
		app:            ZmId.APP_MAIL,
		containingView: this._viewId,
		field:          ZmId.FLD_PARTICIPANT
	});

	var bubbleParams = {
		parent:		appCtxt.getShell(),
		parentId:	this._htmlElId,
		addrObj:	addr,
		id:			id,
		canExpand:	canExpand,
		email:		addr.address
	};
	ZmAddressInputField.BUBBLE_OBJ_ID[id] = this._htmlElId;	// pretend to be a ZmAddressInputField for DL expansion
	this._bubbleParams[id] = bubbleParams;

	return "<span id='" + id + "'></span>";
};

ZmMailMsgView.prototype._clearBubbles = function() {

	if (this._bubbleList) {
		this._bubbleList.clear();
	}
	this._bubbleList = new ZmAddressBubbleList();
	var ctlr = this._controller;
	this._bubbleList.addSelectionListener(ctlr._bubbleSelectionListener.bind(ctlr));
	this._bubbleList.addActionListener(ctlr._bubbleActionListener.bind(ctlr));
	this._bubbleParams = {};
};

ZmMailMsgView.prototype._createBubbles = function() {

	for (var id in this._bubbleParams) {
		// make sure SPAN was actually added to DOM (may have been ignored by template, for example)
		if (!document.getElementById(id)) {
			continue;
		}
		var bubbleParams = this._bubbleParams[id];
		if (bubbleParams.created) {
			continue;
		}
		bubbleParams.created = true;
		var bubble = new ZmAddressBubble(bubbleParams);
		bubble.replaceElement(id);
		if (this._bubbleList) {
			this._bubbleList.add(bubble);
			this._headerTabGroup.addMember(bubble);
		}
	}
};

/**
 *
 * formats the array of addresses as HTML with possible "show more" expand link if more than a certain number of addresses are in the field.
 *
 * @param addrs array of addresses
 * @param options
 * @param type some type identifier (one per page)
 *
 * returns object with the html and ShowMore link id
 */
ZmMailMsgView.prototype.getAddressesFieldInfo =
function(addrs, options, type, htmlElId) {
	return this.getAddressesFieldHtmlHelper(addrs, options, type, this._objectManager, htmlElId || this._htmlElId);
};

ZmMailMsgView.prototype._renderMessage =
function(msg, container, callback) {
	
	this._renderMessageHeader(msg, container);
	this._renderMessageBody(msg, container, callback);
	this._renderMessageFooter(msg, container);
	Dwt.setLoadedTime("ZmMailItem");
};

ZmMailMsgView.prototype._renderMessageHeader =
function(msg, container, doNotClearBubbles) {

	if (!doNotClearBubbles) {
		this._clearBubbles();
	}

	this._renderInviteToolbar(msg, container);
	
	var ai = this._getAddrInfo(msg);
	
	var subject = AjxStringUtil.htmlEncode(msg.subject || ZmMsg.noSubject);
	var dateFormatter = AjxDateFormat.getDateTimeInstance(AjxDateFormat.LONG, AjxDateFormat.SHORT);
	// bug fix #31512 - if no sent date then display received date
	var date = new Date(msg.sentDate || msg.date);
	var dateString = dateFormatter.format(date);

	var additionalHdrs = [];
	var invite = msg.invite;
	var autoSendTime = AjxUtil.isDate(msg.autoSendTime) ? AjxDateFormat.getDateTimeInstance(AjxDateFormat.FULL, AjxDateFormat.MEDIUM).format(msg.autoSendTime) : null;

	if (msg.attrs) {
		for (var hdrName in ZmMailMsgView.displayAdditionalHdrsInMsgView) {
			if (msg.attrs[hdrName]) {
				additionalHdrs.push({hdrName:ZmMailMsgView.displayAdditionalHdrsInMsgView[hdrName], hdrVal: msg.attrs[hdrName]});
			}
		}
	}

	var options = {};
	options.shortAddress = appCtxt.get(ZmSetting.SHORT_ADDRESS);
	
	var attachmentsCount = msg.getAttachmentCount(true);

	// do we add a close button in the header section?

	var folder = appCtxt.getById(msg.folderId);
	var isSyncFailureMsg = (folder && folder.nId == ZmOrganizer.ID_SYNC_FAILURES);
    if (!msg.showImages) {
        msg.showImages = folder && folder.isFeed();
    }

	this._hdrTableId		= ZmId.getViewId(this._viewId, ZmId.MV_HDR_TABLE, this._mode);
	var reportBtnCellId		= ZmId.getViewId(this._viewId, ZmId.MV_REPORT_BTN_CELL, this._mode);
	this._expandRowId		= ZmId.getViewId(this._viewId, ZmId.MV_EXPAND_ROW, this._mode);

	// the message view adapts to whatever height the image has, but
	// more than 96 pixels is a bit silly...
	var imageURL = ai.sentByContact && ai.sentByContact.getImageUrl(48, 96),
		imageAltText = imageURL && ai.sentByContact && ai.sentByContact.getFullName();

	var subs = {
		id: 				this._htmlElId,
		hdrTableId: 		this._hdrTableId,
		hdrTableTopRowId:	ZmId.getViewId(this._viewId, ZmId.MV_HDR_TABLE_TOP_ROW, this._mode),
		expandRowId:		this._expandRowId,
		attachId:			this._attLinksId,
		infoBarId:			this._infoBarId,
		subject:			subject,
		imageURL:			imageURL || ZmZimbraMail.DEFAULT_CONTACT_ICON,
		imageAltText:		imageAltText || ZmMsg.noContactImage,
		dateString:			dateString,
		hasAttachments:		(attachmentsCount != 0),
		attachmentsCount:	attachmentsCount,
		bwo:                ai.bwo,
		bwoAddr:            ai.bwoAddr,
		bwoId:              ZmId.getViewId(this._viewId, ZmId.CMP_BWO_SPAN, this._mode)
	};

	if (msg.isHighPriority || msg.isLowPriority) {
		subs.priority =			msg.isHighPriority ? "high" : "low";
		subs.priorityImg =		msg.isHighPriority ? "ImgPriorityHigh_list" : "ImgPriorityLow_list";
		subs.priorityDivId =	ZmId.getViewId(this._view, ZmId.MV_PRIORITY);
	}

	if (invite && !invite.isEmpty() && this._inviteMsgView) {
		this._getInviteSubs(subs, ai.sentBy, ai.sentByAddr, ai.sender ? ai.fromAddr : null);
	}
	else {
		subs.sentBy = ai.sentBy;
		subs.sentByNormal = ai.sentByAddr;
		subs.sentByAddr = ai.sentByAddr;
		subs.obo = ai.obo;
		subs.oboAddr = ai.oboAddr;
		subs.oboId = ZmId.getViewId(this._viewId, ZmId.CMP_OBO_SPAN, this._mode)
		subs.addressTypes = ai.addressTypes;
		subs.participants = ai.participants;
		subs.reportBtnCellId = reportBtnCellId;
		subs.isSyncFailureMsg = isSyncFailureMsg;
		subs.autoSendTime = autoSendTime;
		subs.additionalHdrs = additionalHdrs;
		subs.isOutDated = invite && invite.isEmpty();
	}

	var template = (invite && !invite.isEmpty() && this._inviteMsgView)
		? "mail.Message#InviteHeader" : "mail.Message#MessageHeader";
	var html = AjxTemplate.expand(template, subs);

	var el = container || this.getHtmlElement();
	el.setAttribute('aria-label', subject);
	el.appendChild(Dwt.parseHtmlFragment(html));
	this._headerElement = Dwt.byId(this._htmlElId + "_headerElement");
	this._makeFocusable(this._headerElement);

	this._headerTabGroup.removeAllMembers();
	this._headerTabGroup.addMember(this._headerElement);

    if (this._inviteMsgView) {
        if (this._inviteToolbarCellId && this._inviteToolbarCellId && this._inviteMsgView._inviteToolbar) {
            this._inviteMsgView._inviteToolbar.reparentHtmlElement(this._inviteToolbarCellId, 0);
        }
        if (this._calendarSelectCellId && this._inviteMsgView._inviteMoveSelect) {
            this._inviteMsgView._inviteMoveSelect.reparentHtmlElement(this._calendarSelectCellId, 0);
        }
        this._inviteMsgView.repositionCounterToolbar(this._hdrTableId);
		this._headerTabGroup.addMember(this._inviteMsgView._inviteToolbar);
    }


	/**************************************************************************/
	/* Add to DOM based on Id's used to generate HTML via templates           */
	/**************************************************************************/
	// add the report button if applicable
	var reportBtnCell = document.getElementById(reportBtnCellId);
	if (reportBtnCell) {
		var id = ZmId.getButtonId(this._mode, ZmId.REPORT, ZmId.MSG_VIEW);
		var reportBtn = new DwtButton({parent:this, id:id, parentElement:reportBtnCell});
		reportBtn.setText(ZmMsg.reportSyncFailure);
		reportBtn.addSelectionListener(this._reportButtonListener.bind(this, msg));
	}

	if (this._hasShareToolbar) {
		var topToolbar = this._getShareToolbar();
		topToolbar.reparentHtmlElement(container);
		topToolbar.setVisible(Dwt.DISPLAY_BLOCK);
		this._headerTabGroup.addMember(topToolbar);
	}
};

// Returns a hash with what we need to show the message's address headers
ZmMailMsgView.prototype._getAddrInfo =
function(msg) {
	
	var acctId = appCtxt.getActiveAccount().id;
	var cl;
	if (appCtxt.get(ZmSetting.CONTACTS_ENABLED) && appCtxt.getApp(ZmApp.CONTACTS).contactsLoaded[acctId]) {
		cl = AjxDispatcher.run("GetContacts");
	}
	var fromAddr = msg.getAddress(AjxEmailAddress.FROM);
	// if we have no FROM address and msg is in an outbound folder, assume current user is the sender
	if (!fromAddr) {
		var folder = msg.folderId && appCtxt.getById(msg.folderId);
		if (folder && folder.isOutbound()) {
			var identity = appCtxt.getIdentityCollection().defaultIdentity;
			if (identity) {
				fromAddr = new AjxEmailAddress(identity.sendFromAddress, AjxEmailAddress.FROM, identity.sendFromDisplay);
			}
		}
	}
	var sender = msg.getAddress(AjxEmailAddress.SENDER); // bug fix #10652 - Sender: header means on-behalf-of
	var sentBy = (sender && sender.address) ? sender : fromAddr;
	var from = AjxStringUtil.htmlEncode(fromAddr ? fromAddr.toString(true) : ZmMsg.unknown);
	var sentByAddr = sentBy && sentBy.getAddress();
    if (sentByAddr) {
        msg.sentByAddr = sentByAddr;
        msg.sentByDomain = sentByAddr.substr(sentByAddr.indexOf("@") + 1);
        msg.showImages = this._isTrustedSender(msg);
    }
	var sentByContact = cl && cl.getContactByEmail(sentBy && sentBy.getAddress()); //bug 78163 originally
	var obo = sender ? fromAddr : null;
	var oboAddr = obo && obo.getAddress();

	var bwo = msg.getAddress(AjxEmailAddress.RESENT_FROM);
	var bwoAddr = bwo ? bwo.getAddress() : null;
	
	// find addresses we may need to search for contacts for, so that we can
	// aggregate them into a single search
	var contactsApp = appCtxt.getApp(ZmApp.CONTACTS);
	if (contactsApp) {
		var lookupAddrs = [];
		if (sentBy) { lookupAddrs.push(sentBy); }
		if (obo) { lookupAddrs.push(obo); }
		for (var i = 1; i < ZmMailMsg.ADDRS.length; i++) {
			var type = ZmMailMsg.ADDRS[i];
			if ((type == AjxEmailAddress.SENDER) || (type == AjxEmailAddress.RESENT_FROM)) { continue; }
			var addrs = msg.getAddresses(type).getArray();
			for (var j = 0; j < addrs.length; j++) {
				if (addrs[j]) {
					lookupAddrs.push(addrs[j].address);
				}
			}
		}
		if (lookupAddrs.length > 1) {
			contactsApp.setAddrLookupGroup(lookupAddrs);
		}
	}

	var options = {};
	options.shortAddress = appCtxt.get(ZmSetting.SHORT_ADDRESS);

	if (this._objectManager) {
		this._lazyCreateObjectManager();
		appCtxt.notifyZimlets("onFindMsgObjects", [msg, this._objectManager, this]);
	}

	sentBy = this._getBubbleHtml(sentBy);
	obo = obo && this._getBubbleHtml(fromAddr);
	bwo = bwo && this._getBubbleHtml(bwo);

	var showMoreIds = {};
	var addressTypes = [], participants = {};
	for (var i = 0; i < ZmMailMsg.ADDRS.length; i++) {
		var type = ZmMailMsg.ADDRS[i];
		if ((type == AjxEmailAddress.FROM) || (type == AjxEmailAddress.SENDER) || (type == AjxEmailAddress.RESENT_FROM)) { continue; }

		var addrs = AjxEmailAddress.dedup(msg.getAddresses(type).getArray());

        if (type == AjxEmailAddress.REPLY_TO){  // bug: 79175 - Reply To shouldn't be shown when it matches From
            var k = addrs.length;
            for (var j = 0; j < k;){
                if (addrs[j].address === fromAddr.address){
                    addrs.splice(j,1);
                    k--;
                }
                else {
                    j++;
                }
            }
        }

		if (addrs.length > 0) {
			var prefix = AjxStringUtil.htmlEncode(ZmMsg[AjxEmailAddress.TYPE_STRING[type]]);
			var addressInfo = this.getAddressesFieldInfo(addrs, options, type);
			addressTypes.push(type);
			participants[type] = { prefix: prefix, partStr: addressInfo.html };
			if (addressInfo.showMoreLinkId) {
			    showMoreIds[addressInfo.showMoreLinkId] = true;
			}
		}
	}
	
	return {
		fromAddr:		fromAddr,
		from:			from,
		sender:			sender,
		sentBy:			sentBy,
		sentByAddr:		sentByAddr,
		sentByContact:	sentByContact,
		obo:			obo,
		oboAddr:		oboAddr,
		bwo:			bwo,
		bwoAddr:		bwoAddr,
		addressTypes:	addressTypes,
		participants:	participants,
        showMoreIds:    showMoreIds
	};
};

ZmMailMsgView.prototype._getInviteSubs =
function(subs, sentBy, sentByAddr, sender, addr) {
	this._inviteMsgView.addSubs(subs, sentBy, sentByAddr, sender ? addr : null);
    var imv = this._inviteMsgView;
    if (imv._inviteToolbar && imv._inviteToolbar.getVisible()) {
        subs.toolbarCellId = this._inviteToolbarCellId =
            [this._viewId, "inviteToolbarCell"].join("_");
    }
    if (imv._inviteMoveSelect && imv._inviteMoveSelect.getVisible()) {
        subs.calendarSelectCellId = this._calendarSelectCellId =
            [this._viewId, "calendarSelectToolbarCell"].join("_");
    }
};

ZmMailMsgView.prototype._renderInviteToolbar =
function(msg, container) {

	this._dateObjectHandlerDate = new Date(msg.sentDate || msg.date);
	this._hasShareToolbar = this._hasSubToolbar = false;

	var invite = msg.invite;
	var ac = window.parentAppCtxt || window.appCtxt;

	if ((ac.get(ZmSetting.CALENDAR_ENABLED) || ac.multiAccounts) && 
		(invite && !invite.isEmpty() && invite.type != "task"))
	{
		if (!this._inviteMsgView) {
			this._inviteMsgView = new ZmInviteMsgView({parent:this, mode:this._mode});
		}
		this._inviteMsgView.set(msg);
	}
	else if (appCtxt.get(ZmSetting.SHARING_ENABLED) && msg.share &&
             ZmOrganizer.normalizeId(msg.folderId) != ZmFolder.ID_TRASH &&
             ZmOrganizer.normalizeId(msg.folderId) != ZmFolder.ID_SENT &&
             appCtxt.getActiveAccount().id != msg.share.grantor.id)
	{
		AjxDispatcher.require("Share");
		var action = msg.share.action;
		var isNew = action == ZmShare.NEW;
		var isEdit = action == ZmShare.EDIT;
		var folder = appCtxt.getById(msg.folderId);
		var isDataSource = (folder && folder.isDataSource(null, true) && (msg.folderId != ZmFolder.ID_INBOX));

		if (!isDataSource &&
			(isNew || (isEdit && !this.__hasMountpoint(msg.share))) &&
			msg.share.link.perm)
		{
			this._hasShareToolbar = true;
		}
	}
	else if (msg.subscribeReq && msg.folderId != ZmFolder.ID_TRASH) {
		var topToolbar = this._getSubscribeToolbar(msg.subscribeReq);
		topToolbar.reparentHtmlElement(container);
		topToolbar.setVisible(Dwt.DISPLAY_BLOCK);
		this._hasSubToolbar = true;
	}
};

/**
 * Renders the message body. There is a chance a server call will be made to fetch an alternative part.
 * 
 * @param {ZmMailMsg}	msg
 * @param {Element}		container
 * @param {callback}	callback
 */
ZmMailMsgView.prototype._renderMessageBody =
function(msg, container, callback, index) {

	var htmlMode = appCtxt.get(ZmSetting.VIEW_AS_HTML);
	var contentType = htmlMode ? ZmMimeTable.TEXT_HTML : ZmMimeTable.TEXT_PLAIN;
	msg.getBodyPart(contentType, this._renderMessageBody1.bind(this, {
        msg:        msg,
        container:  container,
        callback:   callback,
        index:      index
    }));
};

// The second argument 'part' is added to the callback by getBodyPart() above. We ignore it
// and just get the body parts from the loaded msg.
ZmMailMsgView.prototype._renderMessageBody1 = function(params, part) {

	var msg = params.msg,
	    htmlMode = appCtxt.get(ZmSetting.VIEW_AS_HTML),
	    preferredContentType = params.forceType || (htmlMode ? ZmMimeTable.TEXT_HTML : ZmMimeTable.TEXT_PLAIN),
        hasHtmlPart = (preferredContentType === ZmMimeTable.TEXT_HTML && msg.hasContentType(ZmMimeTable.TEXT_HTML)) || msg.hasInlineImage(),
        hasMultipleBodyParts = msg.hasMultipleBodyParts(),
        bodyParts = hasMultipleBodyParts ? msg.getBodyParts(preferredContentType) : [ msg.getBodyPart(preferredContentType) || msg.getBodyPart() ],
        invite = msg.invite,
        hasInviteContent = invite && !invite.isEmpty(),
        origText,
        isTextMsg = !hasHtmlPart,
        isTruncated = false,
        hasViewableTextContent = false,
        html = [];

    bodyParts = AjxUtil.collapseList(bodyParts);

    // The server tells us which parts are worth displaying by marking them as body parts. In general,
    // we just append them in order to the output, with some special handling for each based on its content type.

    for (var i = 0; i < bodyParts.length; i++) {

        var bp = bodyParts[i],
            ct = bp.contentType,
            content = this._getBodyContent(bp),
            isImage = ZmMimeTable.isRenderableImage(ct),
            isHtml = (ct === ZmMimeTable.TEXT_HTML),
            isPlain = (ct === ZmMimeTable.TEXT_PLAIN);

        isTruncated = isTruncated || this.isTruncated(bp);

        // first let's check for invite notes and use those as content if present
        if (hasInviteContent && !hasMultipleBodyParts) {
            if (!msg.getMimeHeader(ZmMailMsg.HDR_INREPLYTO)) {
                // Hack - bug 70603 -  Do not truncate the message for forwarded invites
                // The InReplyTo rfc822 header would be present in most of the forwarded invites
                content = ZmInviteMsgView.truncateBodyContent(content, isHtml);
            }
            // if the notes are empty, don't bother rendering them
            var tmp = AjxStringUtil.stripTags(content);
            if (!AjxStringUtil._NON_WHITESPACE.test(tmp)) {
                content = "";
            }
        }

        // Handle the part based on its Content-Type

        // images
        if (isImage) {
            var src = (hasMultipleBodyParts && content.length > 0) ? content : msg.getUrlForPart(bp),
                classAttr = hasMultipleBodyParts ? "class='InlineImage' " : " ";

            content = "<img " + [ "zmforced='1' " + classAttr + "src='" + src + "'>"].join("");
        }

        // calendar part in ICS format
        else if (ct === ZmMimeTable.TEXT_CAL) {
            content = ZmMailMsg.getTextFromCalendarPart(bp);
        }

        // HTML
        else if (isHtml) {
            if (htmlMode) {
                // fix broken inline images - take one like this: <img dfsrc="http:...part=1.2.2">
                // and make it look like this: <img dfsrc="cid:DWT123"> by looking up the cid for that part
                if (msg._attachments && ZmMailMsgView.IMG_FIX_RE.test(content)) {
                    var partToCid = {};
                    for (var j = 0; j < msg._attachments.length; j++) {
                        var att = msg._attachments[j];
                        if (att.contentId) {
                            partToCid[att.part] = att.contentId.substring(1, att.contentId.length - 1);
                        }
                    }
                    content = content.replace(ZmMailMsgView.IMG_FIX_RE, function(s, p1, p2, p3) {
                        return partToCid[p2] ? [ p1, '"cid:', partToCid[p2], '"', p3 ].join("") : s;
                    });
                }
            }
            else {
                // this can happen if a message only has an HTML part and the user wants to view mail as text
                content = "<div style='white-space:pre-wrap;'>" + AjxStringUtil.convertHtml2Text(content) + "</div>"
            }
        }

        // plain text
        else if (isPlain) {
            origText = content;
            if (bp.format === ZmMimeTable.FORMAT_FLOWED) {
                var wrapParams = {
                    text:		content,
                    isFlowed:	true
                }
                content = AjxStringUtil.wordWrap(wrapParams);
            }
            content = AjxStringUtil.convertToHtml(content);
            if (content && hasMultipleBodyParts && hasHtmlPart) {
                content = "<pre>" + content + "</pre>";
            }
        }

        // something else
        else {
            content = AjxStringUtil.convertToHtml(content);
        }

        // wrap it in a DIV to be safe
        if (content && content.length) {
            if (!isImage && AjxStringUtil.trimHtml(content).length > 0) {
                content = "<div>" + content + "</div>";
                hasViewableTextContent = true;
            }
            html.push(content);
        }
    }

    // Handle empty messages
    if (!hasMultipleBodyParts && !hasViewableTextContent && msg.hasNoViewableContent()) {
        // if we got nothing for one alternative type, try the other
        if (msg.hasContentType(ZmMimeTable.MULTI_ALT) && !params.forceType) {
            var otherType = (preferredContentType === ZmMimeTable.TEXT_HTML) ? ZmMimeTable.TEXT_PLAIN : ZmMimeTable.TEXT_HTML;
            params.forceType = otherType;
            msg.getBodyPart(otherType, this._renderMessageBody1.bind(this, params));
            return;
        }
        var empty = AjxTemplate.expand("mail.Message#EmptyMessage");
        html.push(content ? [empty, content].join("<br><br>") : empty);
    }

    if (html.length > 0) {
        this._displayContent({
            container:		params.container || this.getHtmlElement(),
            html:			html.join(""),
            isTextMsg:		isTextMsg,
            isTruncated:	isTruncated,
            index:			params.index,
            origText:		origText
        });
    }

    this._completeMessageBody(params.callback, isTextMsg);
};

ZmMailMsgView.prototype.isTruncated =
function(part) {
	return part.isTruncated;
};

ZmMailMsgView.prototype._completeMessageBody = function(callback, isTextMsg) {

	// Used in ZmConvView2._setExpansion : if false, create the message body (the
	// first time a message is expanded).
	this._msgBodyCreated = true;
	this._setAttachmentLinks(AjxUtil.isBoolean(isTextMsg) ? isTextMsg : appCtxt.get(ZmSetting.VIEW_AS_HTML));

	if (callback) {
        callback.run();
    }
};

ZmMailMsgView.prototype._getBodyContent =
function(bodyPart) {
	return bodyPart ? bodyPart.getContent() : "";
};

ZmMailMsgView.prototype._renderMessageFooter = function(msg, container) {};

ZmMailMsgView.prototype._setTags =
function(msg) {
	if (!msg) {
		msg = this._item;
	}
	if (msg && msg.cloneOf) {
		msg = msg.cloneOf;
	}
	//use the helper to get the tags.
	var tagsHtml = ZmTagsHelper.getTagsHtml(msg, this);

	var table = document.getElementById(this._hdrTableId);
	if (!table) { return; }
	var tagRow = $(table).find(document.getElementById(this._tagRowId));
	
	if (tagRow.length) {
		tagRow.remove();
	}
	if (tagsHtml.length > 0) {
		var cell =  this._insertTagRow(table, this._tagCellId);
		cell.innerHTML = tagsHtml;
	}
};

ZmMailMsgView.prototype._insertTagRow =
function(table, tagCellId) {
	
	if (!table) { return; }
	
	var tagRow = table.insertRow(-1);
	tagRow.id = this._tagRowId;
	var tagLabelCell = tagRow.insertCell(-1);
	tagLabelCell.className = "LabelColName";
	tagLabelCell.innerHTML = ZmMsg.tags + ":";
	tagLabelCell.style.verticalAlign = "middle";
	var tagCell = tagRow.insertCell(-1);
	tagCell.id = tagCellId;
	return tagCell;
};


// Types of links for each attachment
ZmMailMsgView.ATT_LINK_MAIN			= "main";
ZmMailMsgView.ATT_LINK_CALENDAR		= "calendar";
ZmMailMsgView.ATT_LINK_DOWNLOAD		= "download";
ZmMailMsgView.ATT_LINK_BRIEFCASE	= "briefcase";
ZmMailMsgView.ATT_LINK_VCARD		= "vcard";
ZmMailMsgView.ATT_LINK_HTML			= "html";
ZmMailMsgView.ATT_LINK_REMOVE		= "remove";

ZmMailMsgView.prototype._setAttachmentLinks = function(isTextMsg) {

    this._attachmentLinkIdToFileNameMap = null;
	var attInfo = this._msg.getAttachmentInfo(true, false, isTextMsg);
	var el = document.getElementById(this._attLinksId + "_container");
	if (el) {
		el.style.display = (attInfo.length == 0) ? "none" : "";
	}
	if (attInfo.length == 0) { return; }

	// prevent appending attachment links more than once
	var attLinksTable = document.getElementById(this._attLinksId + "_table");
	if (attLinksTable) { return; }

	var htmlArr = [];
	var idx = 0;
	var imageAttsFound = 0;

	var attColumns = (this._controller.isReadingPaneOn() && this._controller.isReadingPaneOnRight()) ? 1 : ZmMailMsgView.ATTC_COLUMNS;
	var dividx = idx;	// we might get back here
	htmlArr[idx++] = "<table id='" + this._attLinksId + "_table' border=0 cellpadding=0 cellspacing=0>";

	var attLinkIds = [];
	var rows = 0;
	for (var i = 0; i < attInfo.length; i++) {
		var att = attInfo[i];
		
		if ((i % attColumns) == 0) {
			if (i != 0) {
				htmlArr[idx++] = "</tr>";
			}
			htmlArr[idx++] = "<tr>";
			++rows;
		}

		htmlArr[idx++] = "<td>";
		htmlArr[idx++] = "<table border=0 cellpadding=0 cellspacing=0 style='margin-right:1em; margin-bottom:1px'><tr>";
		htmlArr[idx++] = "<td style='width:18px'>";
		htmlArr[idx++] = AjxImg.getImageHtml({
			imageName: att.linkIcon,
			styles: "position:relative;",
			altText: ZmMsg.attachment
		});
		htmlArr[idx++] = "</td><td style='white-space:nowrap'>";

		if (appCtxt.get(ZmSetting.ATTACHMENTS_BLOCKED)) {
			// if attachments are blocked, just show the label
			htmlArr[idx++] = att.label;
		} else {
			// main link for the att name
			var linkArr = [];
			var j = 0;
            var displayFileName = AjxStringUtil.clipFile(att.label, 30);
			// if name got clipped, set up to show full name in tooltip
            if (displayFileName != att.label) {
                if (!this._attachmentLinkIdToFileNameMap) {
					this._attachmentLinkIdToFileNameMap = {};
				}
                this._attachmentLinkIdToFileNameMap[att.attachmentLinkId] = att.label;
            }
			var params = {
				att:	    att,
				id:		    this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_MAIN),
				text:	    displayFileName,
				mid:        att.mid,
				rfc822Part: att.rfc822Part
			};
			var link = ZmMailMsgView.getMainAttachmentLinkHtml(params);
			link = att.isHit ? "<span class='AttName-matched'>" + link + "</span>" : link;
			// objectify if this attachment is an image
			if (att.objectify && this._objectManager) {
				this._lazyCreateObjectManager();
				var imgHandler = this._objectManager.getImageAttachmentHandler();
				idx = this._objectManager.generateSpan(imgHandler, htmlArr, idx, link, {url:att.url});
			} else {
				htmlArr[idx++] = link;
			}
		}
		
		// add any discretionary links depending on the attachment and what's enabled
		var linkCount = 0;
		var vCardLink = (att.links.vcard && !appCtxt.isWebClientOffline());
		if (!appCtxt.isExternalAccount() && (att.size || att.links.html || vCardLink || att.links.download || att.links.briefcase || att.links.importICS)) {
			// size
			htmlArr[idx++] = "&nbsp;(";
			if (att.size) {
				htmlArr[idx++] = att.size;
				htmlArr[idx++] = ") ";
			}
			// convert to HTML
			if (att.links.html && !appCtxt.get(ZmSetting.ATTACHMENTS_BLOCKED)) {
				var params = {
					id:				this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_HTML),
					blankTarget:	true,
					href:			att.url + "&view=html",
					text:			ZmMsg.preview
				};
				htmlArr[idx++] = ZmMailMsgView.getAttachmentLinkHtml(params);
				linkCount++;
				attLinkIds.push(params.id);
			}
			// save as vCard
			else if (vCardLink) {
				var params = {
					id:				this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_VCARD),
					jsHref:			true,
					text:			ZmMsg.addressBook
				};
				htmlArr[idx++] = ZmMailMsgView.getAttachmentLinkHtml(params);
				linkCount++;
				attLinkIds.push(params.id);
			}
			// save locally
			if (att.links.download && !appCtxt.get(ZmSetting.ATTACHMENTS_BLOCKED) && !appCtxt.get(ZmSetting.ATTACHMENTS_VIEW_IN_HTML_ONLY)) {
				htmlArr[idx++] = linkCount ? " | " : "";
				var params = {
					id:				this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_DOWNLOAD),
                    text:			ZmMsg.download
                };
                if (att.url.indexOf("data:") === -1) {
                    params.href = att.url + "&disp=a";
                } else {
                    params.href = att.url;
                    params.download = true;
                    params.downloadLabel = att.label;
                }
                htmlArr[idx++] = ZmMailMsgView.getAttachmentLinkHtml(params);
				linkCount++;
				attLinkIds.push(params.id);
			}
			// add as Briefcase file
			if (att.links.briefcase && !appCtxt.get(ZmSetting.ATTACHMENTS_BLOCKED) && !appCtxt.isWebClientOffline()) {
				htmlArr[idx++] = linkCount ? " | " : "";
				var params = {
					id:				this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_BRIEFCASE),
					jsHref:			true,
					text:			ZmMsg.addToBriefcase
				};
				htmlArr[idx++] = ZmMailMsgView.getAttachmentLinkHtml(params);
				linkCount++;
				attLinkIds.push(params.id);
			}
			// add ICS as calendar event
			if (att.links.importICS) {
				htmlArr[idx++] = linkCount ? " | " : "";
				var params = {
					id:				this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_CALENDAR),
					jsHref:			true,
					text:			ZmMsg.addToCalendar
				};
				htmlArr[idx++] = ZmMailMsgView.getAttachmentLinkHtml(params);
				linkCount++;
				attLinkIds.push(params.id);
			}
			// remove attachment from msg
			if (att.links.remove && !appCtxt.isWebClientOffline()) {
				htmlArr[idx++] = linkCount ? " | " : "";
				var params = {
					id:				this._getAttachmentLinkId(att.part, ZmMailMsgView.ATT_LINK_REMOVE),
					jsHref:			true,
					text:			ZmMsg.remove
				};
				htmlArr[idx++] = ZmMailMsgView.getAttachmentLinkHtml(params);
				linkCount++;
				attLinkIds.push(params.id);
			}

			// Attachment Link Handlers (optional)
			if (ZmMailMsgView._attachmentHandlers) {
				var contentHandlers = ZmMailMsgView._attachmentHandlers[att.ct];
				var handlerFunc;
				if (contentHandlers) {
					for (var handlerId in contentHandlers) {
						handlerFunc = contentHandlers[handlerId];
						if (handlerFunc) {
							var customHandlerLinkHTML = handlerFunc.call(this, att);
							if (customHandlerLinkHTML) {
								htmlArr[idx++] = " | " + customHandlerLinkHTML;
							}
						}
					}
				}
			}
		}

		htmlArr[idx++] = "</td></tr></table>";
		htmlArr[idx++] = "</td>";

		if (att.ct.indexOf("image") != -1) {
			++imageAttsFound;
		}
	}

	// limit display size.  seems like an attc. row has exactly 16px; we set it
	// to 56px so that it becomes obvious that there are more attachments.
	if (this._limitAttachments != 0 && rows > ZmMailMsgView._limitAttachments) {
		htmlArr[dividx] = "<div style='height:";
		htmlArr[dividx] = this._attcMaxSize;
		htmlArr[dividx] = "px; overflow:auto;' />";
	}
	htmlArr[idx++] = "</tr></table>";

	var allAttParams;
	var hasGeneratedAttachments = false;

	for (var i = 0; i < attInfo.length; i++) {
		hasGeneratedAttachments = hasGeneratedAttachments || att.generated;
	}

	if (!hasGeneratedAttachments && attInfo.length > 1 && !appCtxt.isWebClientOffline()) {
		allAttParams = this._addAllAttachmentsLinks(attInfo, (imageAttsFound > 1), this._msg.subject);
		htmlArr[idx++] = allAttParams.html;
	}

	// Push all that HTML to the DOM
	var attLinksDiv = document.getElementById(this._attLinksId);
	if (attLinksDiv) {
		attLinksDiv.innerHTML = htmlArr.join("");
	}


	// add handlers for individual attachment links
	for (var i = 0; i < attInfo.length; i++) {
		var att = attInfo[i];
		if (att.ct == ZmMimeTable.MSG_RFC822) {
			this._addClickHandler(att.part, ZmMailMsgView.ATT_LINK_MAIN, ZmMailMsgView.rfc822Callback, null, this._msg.id, att.part);
		}
		if (att.links.importICS) {
			this._addClickHandler(att.part, ZmMailMsgView.ATT_LINK_CALENDAR, ZmMailMsgView.addToCalendarCallback, null, this._msg.id, att.part);
		}
		if (att.links.briefcase) {
			this._addClickHandler(att.part, ZmMailMsgView.ATT_LINK_BRIEFCASE, ZmMailMsgView.briefcaseCallback, null, this._msg.id, att.part, att.label.replace(/\x27/g, "&apos;"));
		}
		if (att.links.download) {
            if (att.url.indexOf("data:") === -1) {
                this._addClickHandler(att.part, ZmMailMsgView.ATT_LINK_DOWNLOAD, ZmMailMsgView.downloadCallback, null, att.url + "&disp=a");
            }
		}
		if (att.links.vcard) {
			this._addClickHandler(att.part, ZmMailMsgView.ATT_LINK_VCARD, ZmMailMsgView.vcardCallback, null, this._msg.id, att.part);
		}
		if (att.links.remove) {
			this._addClickHandler(att.part, ZmMailMsgView.ATT_LINK_REMOVE, this.removeAttachmentCallback, this, att.part);
		}
	}

	var offlineHandler = appCtxt.webClientOfflineHandler;
	if (offlineHandler) {
		var getLinkIdCallback = this._getAttachmentLinkId.bind(this);
		var linkIds = [ZmMailMsgView.ATT_LINK_MAIN, ZmMailMsgView.ATT_LINK_DOWNLOAD];
		offlineHandler._handleAttachmentsForOfflineMode(attInfo, getLinkIdCallback, linkIds);
	}

    // add handlers for "all attachments" links
	if (allAttParams) {
		var downloadAllLink = document.getElementById(allAttParams.downloadAllLinkId);
		if (downloadAllLink) {
			downloadAllLink.onclick = allAttParams.downloadAllCallback;
		}
		var removeAllLink = document.getElementById(allAttParams.removeAllLinkId);
		if (removeAllLink) {
			removeAllLink.onclick = allAttParams.removeAllCallback;
		}
	}

	// add all links to the header tab order
	var attLinks = attLinksDiv.querySelectorAll('A.AttLink');
	for (var i = 0; i < attLinks.length; i++) {
		this._headerTabGroup.addMember(attLinks[i]);
	}
};

/**
 * Returns the HTML for an attachment-related link (an <a> tag). The link will have an HREF
 * or an ID (so an onclick handler can be added after the element has been created).
 * 
 * @param {hash}	params		a hash of params:
 * @param {string}	id			ID for the link
 * @param {string}	href		link target
 * @param {boolean}	noUnderline	if true, do not include an underline style
 * @param {boolean} blankTarget	if true, set target to _blank
 * @param {boolean}	jsHref		empty link target so browser styles it as a link
 * @param {string}	text		visible link text
 * 
 * @private
 */
ZmMailMsgView.getAttachmentLinkHtml =
function(params) {
	var html = [], i = 0;
	html[i++] = "<a class='AttLink' ";
	html[i++] = params.id ? "id='" + params.id + "' " : "";
	html[i++] = !params.noUnderline ? "style='text-decoration:underline' " : "";
	html[i++] = params.blankTarget ? "target='_blank' " : "";
	var href = params.href || (params.jsHref && "javascript:;");
	html[i++] = href ? "href='" + href + "' " : "";
    html[i++] = params.download ? (" download='"+(params.downloadLabel||"") + "'") : "";
	if (params.isRfc822) {
		html[i++] = " onclick='ZmMailMsgView.rfc822Callback(\"";
		html[i++] = params.mid;
		html[i++] = "\",\"";
		html[i++] = params.rfc822Part;
		html[i++] = "\"); return false;'";
	}
	html[i++] = "title='" + AjxStringUtil.encodeQuotes(AjxStringUtil.htmlEncode(params.label || params.text));
	html[i++] = "'>" + AjxStringUtil.htmlEncode(params.text) + "</a>";

	return html.join("");
};

/**
 * Returns the HTML for the link for the attachment name (which usually opens the
 * content in a new browser tab).
 * 
 * @param id
 */
ZmMailMsgView.getMainAttachmentLinkHtml =
function(params) {
	var params1 = {
		id:				params.id,
		noUnderline:	true,
		text:			params.text,
		label:			params.att.label
	}; 
	// handle rfc/822 attachments differently
	if (params.att.ct == ZmMimeTable.MSG_RFC822) {
		params1.jsHref      = true;
		params1.isRfc822    = true;
		params1.mid         = params.mid;
		params1.rfc822Part  = params.rfc822Part;
	}
	else {
		// open non-JavaScript URLs in a blank target
		if (params.att.url && params.att.url.indexOf('javascript:') !== 0) {
			params1.blankTarget = true;
		}
		params1.href = params.att.url;
	}
	return ZmMailMsgView.getAttachmentLinkHtml(params1);
};

ZmMailMsgView.prototype._getAttachmentLinkId =
function(part, type) {
	if (!part)
		return;
	return [this._attLinksId, part, type].join("_");
};

// Adds an onclick handler to the link with the given part and type. I couldn't find an easy
// way to pass and bind a variable number of arguments, so went with three, which is the most
// any of the handlers takes.
ZmMailMsgView.prototype._addClickHandler =
function (part, type, func, obj, arg1, arg2, arg3) {
	var id = this._getAttachmentLinkId(part, type);
	var link = document.getElementById(id);
	if (link) {
		link.onclick = func.bind(obj, arg1, arg2, arg3);
	}
};

ZmMailMsgView.prototype._addAllAttachmentsLinks =
function(attachments, viewAllImages, filename) {

	var itemId = this._msg.id;
	if (AjxUtil.isString(filename)) {
		filename = filename.replace(ZmMailMsgView.FILENAME_INV_CHARS_RE, "");
	} else {
		filename = null;
	}
	filename = AjxStringUtil.urlComponentEncode(filename || ZmMsg.downloadAllDefaultFileName);
	var url = [appCtxt.get(ZmSetting.CSFE_MSG_FETCHER_URI), "&id=", itemId, "&filename=", filename,"&charset=", appCtxt.getCharset(), "&part="].join("");
	var parts = [];
	for (var j = 0; j < attachments.length; j++) {
		parts.push(attachments[j].part);
	}
	var partsStr = parts.join(",");
	var params = {
		url:				(url + partsStr),
		downloadAllLinkId:	this._viewId + "_downloadAll",
		removeAllLinkId:	this._viewId + "_removeAll"
	}
	if (viewAllImages) {
		params.viewAllUrl = "/h/viewimages?id=" + itemId;
	}
	params.html = AjxTemplate.expand("mail.Message#AllAttachments", params);
	
	params.downloadAllCallback = ZmZimbraMail.unloadHackCallback.bind(null);
	params.removeAllCallback = this.removeAttachmentCallback.bind(this, partsStr);
	return params;
};

ZmMailMsgView.prototype.getToolTipContent =
function(evt) {

	var tgt = DwtUiEvent.getTarget(evt, false);

	//see if this is the priority icon. If so, it has a "priority" attribute high/low.
	if (tgt.id == ZmId.getViewId(this._view, ZmId.MV_PRIORITY)) {
		return tgt.getAttribute('priority') =='high' ? ZmMsg.highPriorityTooltip : ZmMsg.lowPriorityTooltip;
	}
	
    if (!this._attachmentLinkIdToFileNameMap) {return null};

    if (tgt && tgt.nodeName.toLowerCase() == "a") {
        var id = tgt.getAttribute("id");
        if (id) {
            var fileName = this._attachmentLinkIdToFileNameMap[id];
            if (fileName) {
                return AjxStringUtil.htmlEncode(fileName);
            }
        }
    }
    return null;
};

// AttachmentLink Handlers
ZmMailMsgView.prototype.addAttachmentLinkHandler =
function(contentType,handlerId,handlerFunc){
	if (!ZmMailMsgView._attachmentHandlers) {
		ZmMailMsgView._attachmentHandlers = {};
	}

	if (!ZmMailMsgView._attachmentHandlers[contentType]) {
		ZmMailMsgView._attachmentHandlers[contentType] = {};
	}

	ZmMailMsgView._attachmentHandlers[contentType][handlerId] = handlerFunc;
};

// Listeners

ZmMailMsgView.prototype._controlEventListener =
function(ev) {
	// note - we may get here before we have a chance to initialize the IFRAME
	this._resetIframeHeightOnTimer();
	if (this._inviteMsgView && this._inviteMsgView.isActive()) {
		this._inviteMsgView.resize();
	}
};

ZmMailMsgView.prototype._shareToolBarListener =
function(ev) {
	ev._buttonId = ev.item.getData(ZmOperation.KEY_ID);
	ev._share = this._msg.share;
	this.notifyListeners(ZmMailMsgView.SHARE_EVENT, ev);
};

ZmMailMsgView.prototype._subscribeToolBarListener =
function(req, ev) {
	ev._buttonId = ev.item.getData(ZmOperation.KEY_ID);
	ev._subscribeReq = req;
	this.notifyListeners(ZmMailMsgView.SUBSCRIBE_EVENT, ev);
};


ZmMailMsgView.prototype._msgChangeListener =
function(ev) {
	if (ev.type != ZmEvent.S_MSG) { return; }
	if (ev.event == ZmEvent.E_DELETE || ev.event == ZmEvent.E_MOVE) {
		if (ev.source == this._msg && (appCtxt.getCurrentViewId() == this._viewId)) {
			this._controller._app.popView();
		}
	} else if (ev.event == ZmEvent.E_TAGS || ev.event == ZmEvent.E_REMOVE_ALL) {
		this._setTags(this._msg);
	} else if (ev.event == ZmEvent.E_MODIFY) {
		if (ev.source == this._msg) {
			this.set(ev.source, true);
		}
	}
};

ZmMailMsgView.prototype._selectStartListener =
function(ev) {
	// reset mouse event to propagate event to browser (allows text selection)
	ev._stopPropagation = false;
	ev._returnValue = true;
};


ZmMailMsgView.prototype._reportButtonListener =
function(msg, ev) {
	var proxy = AjxUtil.createProxy(msg);

	proxy.clearAddresses();
	var toAddress = new AjxEmailAddress(appCtxt.get(ZmSetting.OFFLINE_REPORT_EMAIL));
	proxy._addrs[AjxEmailAddress.TO] = AjxVector.fromArray([toAddress]);

	var bp = msg.getBodyPart();
	if (bp) {
		var top = new ZmMimePart();
		top.setContentType(bp.ct);
		top.setContent(msg.getBodyPart().getContent());
		proxy.setTopPart(top);
	}

	var respCallback = this._sendReportCallback.bind(this, msg);
	var errorCallback = this._sendReportError.bind(this);
	proxy.send(false, respCallback, errorCallback, null, true);
};

ZmMailMsgView.prototype._sendReportCallback =
function(msg) {
	this._controller._doDelete([msg], true);
};

ZmMailMsgView.prototype._sendReportError =
function() {
	appCtxt.setStatusMsg(ZmMsg.reportSyncError, ZmStatusView.LEVEL_WARNING);
};


// Callbacks


ZmMailMsgView.prototype._handleMsgTruncated =
function() {

	// redo selection to trigger loading and display of entire msg
	this._msg.viewEntireMessage = true;	// remember so we reply to entire msg
	this._msg.force = true;				// make sure view re-renders msg
	if (this._controller._setSelectedItem) {
		// list controller
		this._controller._setSelectedItem({noTruncate: true, forceLoad: true, markRead: false});
	}
	else if (this._controller.show) {
		// msg controller
		this._controller.show(this._msg, this._controller, null, false, false, true, true);
	}
	
	Dwt.setVisible(this._msgTruncatedId, false);
};

// Static methods

ZmMailMsgView._swapIdAndSrc =
function (image, i, len, msg, parent, view) {
	// Fix for IE: Over HTTPS, http src urls for images might cause an issue.
	try {
		image.src = image.getAttribute("dfsrc");
	}
	catch (ex) {
		// do nothing
	}

	if (i == len - 1) {
		if (msg) {
			msg.setHtmlContent(parent.innerHTML);
		}
		view._resetIframeHeightOnTimer();
	}
};

ZmMailMsgView.prototype._onloadIframe =
function(dwtIframe) {
	var iframe = dwtIframe.getIframe();
	try { iframe.onload = null; } catch(ex) {}
	ZmMailMsgView._resetIframeHeight(this);
};

ZmMailMsgView._resetIframeHeight =
function(self, attempt) {

	var iframe = self.getIframe();
	if (!iframe) { return; }

	DBG.println("cv2", "ZmMailMsgView::_resetIframeHeight " + (attempt || "0"));
	var h;
	if (self._scrollWithIframe) {
		h = self.getH();
		function subtract(el) {
			if (el) {
				if (typeof el == "string") {
					el = document.getElementById(el);
				}
				if (el) {
					h -= Dwt.getSize(el).y;
				}
			}
		}
		subtract(self._headerElement);
		subtract(self._displayImagesId);
		subtract(self._highlightObjectsId);
		if (self._isMsgTruncated) {
			subtract(self._msgTruncatedId);
		}
		if (self._inviteMsgView && self._inviteMsgView.isActive()) {
			if (self._inviteMsgView._inviteToolbar) {//if toolbar not created there's nothing to subtract (e.g. sent folder)
				subtract(self._inviteMsgView.getInviteToolbar().getHtmlElement());
			}
			if (self._inviteMsgView._dayView) {
				subtract(self._inviteMsgView._dayView.getHtmlElement());
			}
		}
		if (self._hasShareToolbar && self._shareToolbar) {
			subtract(self._shareToolbar.getHtmlElement());
		}
		iframe.style.height = h + "px";
	} else {
		if (attempt == null) { attempt = 0; }
		try {
			if (!iframe.contentWindow || !iframe.contentWindow.document) {
				if (attempt < ZmMailMsgView.SETHEIGHT_MAX_TRIES) {
					attempt++;
					self._resetIframeHeightOnTimer(attempt);
				}
				return; // give up
			}
		} catch(ex) {
			if (attempt < ZmMailMsgView.SETHEIGHT_MAX_TRIES) {
				attempt++;
				self._resetIframeHeightOnTimer(attempt++); // for IE
			}
			return; // give up
		}

		var doc = iframe.contentWindow.document;
		var origHeight = doc && doc.body && doc.body.scrollHeight || 0;

		// first off, make it wide enough to fill ZmMailMsgView.
		iframe.style.width = "100%"; // *** changes height!

		// remember the current width
		var view_width = iframe.offsetWidth;

		// if there's a long unbreakable string, the scrollWidth of the body
		// element will be bigger--we must make the iframe that wide, or there
		// won't be any scrollbars.
		var w = doc.body.scrollWidth;
		if (w > view_width) {
			iframe.style.width = w + "px"; // *** changes height!

			// Now (bug 20743), by forcing the body a determined width (that of
			// the view) we are making the browser wrap those paragraphs that
			// can be wrapped, even if there's a long unbreakable string in the message.
			doc.body.style.overflow = "visible";
			if (view_width > 20) {
				doc.body.style.width = view_width - 20 + "px"; // *** changes height!
			}
		}

		// we are finally in the right position to determine height.
		h = Math.max(doc.documentElement.scrollHeight, origHeight);

		iframe.style.height = h + "px";

		if (AjxEnv.isWebKitBased) {
			// bug: 39434, WebKit specific
			// After the iframe ht is set there is change is body.scrollHeight, weird.
			// So reset ht to make the entire body visible.
			var newHt = Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight);
			if (newHt > h) {
				iframe.style.height = newHt + "px";
			}
		}
	}
};

// note that IE doesn't seem to be able to reset the "scrolling" attribute.
// this function isn't safe to call for IE!
ZmMailMsgView.prototype.setScrollWithIframe =
function(val) {
	
	if (!this._usingIframe) { return; }
	
	this._scrollWithIframe = val;
	this._limitAttachments = this._scrollWithIframe ? 3 : 0; //making it local
	this._attcMaxSize = this._limitAttachments * 16 + 8;

	this.setScrollStyle(val ? DwtControl.CLIP : DwtControl.SCROLL);
	var iframe = this.getIframe();
	if (iframe) {
		iframe.style.width = "100%";
		iframe.scrolling = val;
		ZmMailMsgView._resetIframeHeight(this);
	}
};




ZmMailMsgView._detachCallback =
function(isRfc822, parentController, result) {
	var msgNode = result.getResponse().GetMsgResponse.m[0];
	var ac = window.parentAppCtxt || window.appCtxt;
	var ctlr = ac.getApp(ZmApp.MAIL).getMailListController();
	var msg = ZmMailMsg.createFromDom(msgNode, {list: ctlr.getList()}, true);
	msg._loaded = true; // bug fix #8868 - force load for rfc822 msgs since they may not return any content
	msg.readReceiptRequested = false; // bug #36247 - never allow read receipt for rfc/822 message
	ZmMailMsgView.detachMsgInNewWindow(msg, isRfc822, parentController);
};

ZmMailMsgView.detachMsgInNewWindow =
function(msg, isRfc822, parentController) {
	var appCtxt = window.parentAppCtxt || window.appCtxt;
	var newWinObj = appCtxt.getNewWindow(true);
	if(newWinObj) {// null check for popup blocker
		newWinObj.command = "msgViewDetach";
		newWinObj.params = { msg:msg, isRfc822:isRfc822, parentController:parentController };
	}
};

// loads a msg and displays it in a new window
ZmMailMsgView.rfc822Callback =
function(msgId, msgPartId, parentController) {
	var isRfc822 = Boolean((msgPartId != null));
	var appCtxt = window.parentAppCtxt || window.appCtxt;
	var params = {
		sender: appCtxt.getAppController(),
		msgId: msgId,
		partId: msgPartId,
		getHtml: appCtxt.get(ZmSetting.VIEW_AS_HTML),
		markRead: appCtxt.isExternalAccount() ? false : true,
		callback: ZmMailMsgView._detachCallback.bind(null, isRfc822, parentController)
	};
	ZmMailMsg.fetchMsg(params);
};

ZmMailMsgView.vcardCallback =
function(msgId, partId) {
	ZmZimbraMail.unloadHackCallback();

	var ac = window.parentAppCtxt || window.appCtxt;
	ac.getApp(ZmApp.CONTACTS).createFromVCard(msgId, partId);
};

ZmMailMsgView.downloadCallback =
function(downloadUrl) {
	ZmZimbraMail.unloadHackCallback();
	location.href = downloadUrl;
};

ZmMailMsgView.prototype.removeAttachmentCallback =
function(partIds) {
	ZmZimbraMail.unloadHackCallback();

	if (!(partIds instanceof Array)) { partIds = partIds.split(","); }

	var msg = (partIds.length > 1)
		? ZmMsg.attachmentConfirmRemoveAll
		: ZmMsg.attachmentConfirmRemove;

	var dlg = appCtxt.getYesNoMsgDialog();
	dlg.registerCallback(DwtDialog.YES_BUTTON, this._removeAttachmentCallback, this, [partIds]);
	dlg.setMessage(msg, DwtMessageDialog.WARNING_STYLE);
	dlg.popup();
};

ZmMailMsgView.prototype._removeAttachmentCallback =
function(partIds) {
	appCtxt.getYesNoMsgDialog().popdown();
	this._msg.removeAttachments(partIds, this._handleRemoveAttachment.bind(this));
};

ZmMailMsgView.prototype._handleRemoveAttachment =
function(result) {
	var msgNode = result.getResponse().RemoveAttachmentsResponse.m[0];
	var ac = window.parentAppCtxt || window.appCtxt;
	var listCtlr = ac.getApp(ZmApp.MAIL).getMailListController(); //todo - getting a list controller from appCtxt always seems suspicious to me (should we get the controller for the current view?)
	var msg = ZmMailMsg.createFromDom(msgNode, {list: listCtlr.getList()}, true);
	this._msg = this._item = null;
	// cache this actioned ID so we can reset selection to it once the CREATE
	// notifications have been processed.
	listCtlr.actionedMsgId = msgNode.id;
	if (this._controller.setMsg) {
		//for the ZmMsgController case. (standalone).
		this._controller.setMsg(msg);
	}
	this.set(msg);
};

ZmMailMsgView.briefcaseCallback =
function(msgId, partId, name) {
	ZmZimbraMail.unloadHackCallback();

	// force create deferred folders if not created
	AjxDispatcher.require("BriefcaseCore");
	var aCtxt = appCtxt.isChildWindow ? parentAppCtxt : appCtxt;
	var briefcaseApp = aCtxt.getApp(ZmApp.BRIEFCASE);
	briefcaseApp._createDeferredFolders();

	appCtxt.getApp(ZmApp.BRIEFCASE).createFromAttachment(msgId, partId, name);
};

ZmMailMsgView.prototype.deactivate =
function() {
	this._controller.inactive = true;
};

ZmMailMsgView.addToCalendarCallback =
function(msgId, partId, name) {
	ZmZimbraMail.unloadHackCallback();

	// force create deferred folders if not created
	AjxDispatcher.require(["MailCore", "CalendarCore"]);
	var aCtxt = appCtxt.isChildWindow ? parentAppCtxt : appCtxt;
	var calApp = aCtxt.getApp(ZmApp.CALENDAR);
	calApp._createDeferredFolders();

	appCtxt.getApp(ZmApp.CALENDAR).importAppointment(msgId, partId, name);
};

ZmMailMsgView.prototype.getMsgBodyElement =
function(){
    return document.getElementById(this._msgBodyDivId);
};

ZmMailMsgView.prototype._getViewId =
function() {
	var ctlrViewId = this._controller.getCurrentViewId();
	return this._controller.isZmMsgController ? ctlrViewId : [ctlrViewId, ZmId.VIEW_MSG].join("_");
};

ZmMailMsgView.prototype._keepReading =
function(check) {
	var cont = this.getHtmlElement();
	var contHeight = Dwt.getSize(cont).y;
	var canScroll = (cont.scrollHeight > contHeight && (cont.scrollTop + contHeight < cont.scrollHeight));
	if (canScroll) {
		if (!check) {
			cont.scrollTop = cont.scrollTop + contHeight;
		}
		return true;
	}
	return false;
};

ZmMailMsgView.prototype._getIframeTitle = function() {
	return AjxMessageFormat.format(ZmMsg.messageTitle, this._msg.subject);
};
}
if (AjxPackage.define("zimbraMail.mail.view.ZmMailConfirmView")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a new controller to show mail send confirmation.
 * @class
 * 
 * @param {DwtControl}	parent		the element that created this view
 * @param {ZmController}	controller	the controller managing this view
 * 
 * @extends		DwtComposite
 * 
 * @private
 */
ZmMailConfirmView = function(parent, controller) {

	this._view = controller.getCurrentViewId();
	DwtComposite.call(this, {parent:parent, className:"ZmMailConfirmView", posStyle:Dwt.ABSOLUTE_STYLE,
							 id:ZmId.getViewId(this._view)});

	this.setVisible(false);
	this._controller = controller;
	this._tabGroup = new DwtTabGroup(this._htmlElId);
	this._createHtmlFromTemplate("mail.Message#ZmMailConfirmView", { id: this._htmlElId } );
	var buttonArgs = {
		parent: this,
		parentElement: this._htmlElId + "_addButton"
	};
	this._addContactsButton = new DwtButton(buttonArgs);
	this._addContactsButton.setText(ZmMsg.ok);
	this._addContactsButton.addSelectionListener(new AjxListener(this, this._addContactsListener));

	this._summaryFormat = new AjxMessageFormat(ZmMsg.confirmSummary);
};

ZmMailConfirmView.prototype = new DwtComposite;
ZmMailConfirmView.prototype.constructor = ZmMailConfirmView;

ZmMailConfirmView.prototype.toString = function() {
	return "ZmMailConfirmView";
};

/**
 * Adds a listener for the Create Contacts button.
 * 
 * @param	{AjxListener}	listener		the listener
 */
ZmMailConfirmView.prototype.addNewContactsListener =
function(listener) {
	this.addListener(DwtEvent.ACTION, listener);
};

/**
 * Shows confirmation that the message was sent.
 *
 * @param {ZmMailMsg}	msg			the message that was sent
 */
ZmMailConfirmView.prototype.showConfirmation =
function(msg) {
	this._tabGroup.removeAllMembers();
	
	this._showLoading(true);
	var addresses = msg.getAddresses(AjxEmailAddress.TO).getArray().concat(msg.getAddresses(AjxEmailAddress.CC).getArray());

	if (!appCtxt.get(ZmSetting.CONTACTS_ENABLED) || appCtxt.get(ZmSetting.AUTO_ADD_ADDRESS)) {
		this._setView(msg, [], [], addresses);
	} else {
		var callback = new AjxCallback(this, this._handleResponseGetContacts, [msg]);
		appCtxt.getApp(ZmId.APP_CONTACTS).getContactsByEmails(addresses, callback);
	}

	appCtxt.notifyZimlets("onMailConfirm", [this, msg, Dwt.byId(this._htmlElId + "_ad")]);
};

ZmMailConfirmView.prototype.getController =
function() {
	return this._controller;
};

ZmMailConfirmView.prototype.getTitle =
function() {
	return [ZmMsg.zimbraTitle, ZmMsg.messageSent].join(": ");
};

ZmMailConfirmView.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

ZmMailConfirmView.prototype.getDefaultFocusItem =
function() {
	return this._addContactsButton;
};

ZmMailConfirmView.prototype._handleResponseGetContacts =
function(msg, contacts) {
	var newAddresses = [],
		existingContacts = [];
	for (var i = 0, count = contacts.length; i < count; i++) {
		if (contacts[i].contact) {
			existingContacts.push(contacts[i]);
		} else {
			newAddresses.push(contacts[i].address);
		}
	}
	this._setView(msg, newAddresses, existingContacts, []);
};

ZmMailConfirmView.prototype._setView =
function(msg, newAddresses, existingContacts, displayAddresses) {
	this._showLoading(false);
	Dwt.byId(this._htmlElId + "_summary").innerHTML = AjxStringUtil.htmlEncode(this._summaryFormat.format(msg.subject));
	this._showNewAddresses(newAddresses);
	this._showExistingContacts(existingContacts);
	this._showDisplayAddresses(displayAddresses);
};

ZmMailConfirmView.prototype._showLoading =
function(loading) {
	Dwt.setVisible(Dwt.byId(this._htmlElId + "_loading"), loading);
	Dwt.setVisible(Dwt.byId(this._htmlElId + "_notLoading"), !loading);
	this.setVisible(true);	
};

ZmMailConfirmView.prototype._showNewAddresses =
function(newAddresses) {
	var visible = newAddresses.length;
	Dwt.setVisible(Dwt.byId(this._htmlElId + "_newAddresses"), visible);
	this._addContactsButton.setVisible(visible);
	if (this._newAddressForms) {
		for (var i = 0, count = this._newAddressForms.length; i < count; i++) {
			this._newAddressForms[i].dispose();
		}
		this._newAddressForms = [];
	}
	this._newAddressForms = [];
	var newAddressBox = Dwt.byId(this._htmlElId + "_newAddressBox");
	for (var i = 0, count = newAddresses.length; i < count; i++) {
		var div = document.createElement("DIV");
		newAddressBox.appendChild(div);
		var address = newAddresses[i],
			first = "",
			last = "";
		var name = address.getName();
		if (name) {
			var index = name.lastIndexOf(" ");
			if (index != -1) {
				first = name.substring(0, index);
				last = name.substring(index + 1);
			} else {
				first = name;
			}
		}
		var args = { parent: this, parentElement: div };
		args.form = {
			items: [
				// default items
				{ id: "CHECKBOX", type: "DwtCheckbox", label: address.getAddress() },
				{ id: "FIRST", type: "DwtInputField", value: first, hint: ZmMsg.AB_FIELD_firstName },
				{ id: "LAST", type: "DwtInputField", value: last, hint: ZmMsg.AB_FIELD_lastName }
			],
			template: "mail.Message#ZmMailConfirmViewNewAddress"
		};
		var form = new DwtForm(args);
		this._newAddressForms.push(form);
		this._tabGroup.addMember(form.getTabGroupMember());
	}
	if (visible) {
		this._tabGroup.addMember(this._addContactsButton);
	}
};

ZmMailConfirmView.prototype._showExistingContacts =
function(existingContacts) {
	Dwt.setVisible(Dwt.byId(this._htmlElId + "_existingContacts"), existingContacts.length);
	var existingContactBox = Dwt.byId(this._htmlElId + "_existingContactBox");
	existingContactBox.innerHTML = "";
	for (var i = 0, count = existingContacts.length; i < count; i++) {
		var div = document.createElement("DIV");
		existingContactBox.appendChild(div);
		var data = existingContacts[i];
		var display;
		var fullName = data.contact.getFullName();
		if (fullName) {
			display = [fullName, " <", data.address.getAddress(), ">"].join("");
		} else {
			display = data.address.getAddress();
		}
		div.innerHTML = AjxTemplate.expand("mail.Message#ZmMailConfirmViewExistingContact", { text: AjxStringUtil.htmlEncode(display) });
	}
};

ZmMailConfirmView.prototype._showDisplayAddresses =
function(displayAddresses) {
	Dwt.setVisible(Dwt.byId(this._htmlElId + "_displayAddresses"), displayAddresses.length);
	var displayAddressBox = Dwt.byId(this._htmlElId + "_displayAddressBox");
	displayAddressBox.innerHTML = "";
	for (var i = 0, count = displayAddresses.length; i < count; i++) {
		var div = document.createElement("DIV");
		displayAddressBox.appendChild(div);
		var address = displayAddresses[i].toString();
		div.innerHTML = AjxTemplate.expand("mail.Message#ZmMailConfirmViewExistingContact", { text: AjxStringUtil.htmlEncode(address) });
	}
};

ZmMailConfirmView.prototype._addContactsListener =
function() {
	var newAddresses = [];
	for (var i = 0, count = this._newAddressForms.length; i < count; i++) {
		var form = this._newAddressForms[i];
		if (form.getValue("CHECKBOX")) {
			var data = {};
			data[ZmContact.F_email] = form.getControl("CHECKBOX").getText();
			data[ZmContact.F_firstName] = form.getValue("FIRST");
			data[ZmContact.F_lastName] = form.getValue("LAST");
			newAddresses.push(data);
		}
	}
	this.notifyListeners(DwtEvent.ACTION, newAddresses);
};

ZmMailConfirmView.prototype.deactivate =
function() {
	this._controller.inactive = true;
};
}
if (AjxPackage.define("zimbraMail.mail.controller.ZmComposeController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a new compose controller to manage message composition.
 * @constructor
 * @class
 * This class manages message composition.
 *
 * @author Conrad Damon
 *
 * @param {DwtShell}	container	the containing shell
 * @param {ZmApp}		mailApp		the containing app
 * @param {constant}	type		controller type
 * @param {string}		sessionId	the session id
 * 
 * @extends		ZmController
 */
ZmComposeController = function(container, mailApp, type, sessionId) {

	ZmController.apply(this, arguments);

	this._action = null;

	ZmComposeController._setStatics();

	this._listeners = {};
	this._listeners[ZmOperation.SEND]				= this._sendListener.bind(this);
	this._listeners[ZmOperation.SEND_MENU]			= this._sendListener.bind(this);
	this._listeners[ZmOperation.SEND_LATER]			= this._sendLaterListener.bind(this);
	this._listeners[ZmOperation.CANCEL]				= this._cancelListener.bind(this);
	this._listeners[ZmOperation.ATTACHMENT]			= this._attachmentListener.bind(this);
	this._listeners[ZmOperation.DETACH_COMPOSE]		= this._detachListener.bind(this);
	this._listeners[ZmOperation.SAVE_DRAFT]			= this._saveDraftListener.bind(this);
	this._listeners[ZmOperation.SPELL_CHECK]		= this._spellCheckListener.bind(this);
	this._listeners[ZmOperation.COMPOSE_OPTIONS]	= this._optionsListener.bind(this);

	this._dialogPopdownListener = this._dialogPopdownActionListener.bind(this);

	this._autoSaveTimer = null;
	this._draftType = ZmComposeController.DRAFT_TYPE_NONE;
	this._elementsToHide = ZmAppViewMgr.LEFT_NAV;
};

ZmComposeController.prototype = new ZmController();
ZmComposeController.prototype.constructor = ZmComposeController;

ZmComposeController.prototype.isZmComposeController = true;
ZmComposeController.prototype.toString = function() { return "ZmComposeController"; };

//
// Constants
//

ZmComposeController.SIGNATURE_KEY = "sigKeyId";

// Constants for defining the reason for saving a draft message.
/**
 * Defines the "none" draft type reason.
 */
ZmComposeController.DRAFT_TYPE_NONE		= "none";
/**
 * Defines the "manual" draft type reason.
 */
ZmComposeController.DRAFT_TYPE_MANUAL	= "manual";
/**
 * Defines the "auto" draft type reason.
 */
ZmComposeController.DRAFT_TYPE_AUTO		= "auto";
/**
 * Defines the "delaysend" draft type reason.
 */
ZmComposeController.DRAFT_TYPE_DELAYSEND	= "delaysend";

ZmComposeController.DEFAULT_TAB_TEXT = ZmMsg.compose;

ZmComposeController.NEW_WINDOW_WIDTH = 975;
ZmComposeController.NEW_WINDOW_HEIGHT = 475;

// Message dialogs
ZmComposeController.MSG_DIALOG_1	= 1;	// OK
ZmComposeController.MSG_DIALOG_2	= 2;	// OK Cancel

ZmComposeController._setStatics =
function() {

	if (ZmComposeController.RADIO_GROUP) {
		return;
	}

	// radio groups for options items
	ZmComposeController.RADIO_GROUP = {};
	ZmComposeController.RADIO_GROUP[ZmOperation.REPLY]				= 1;
	ZmComposeController.RADIO_GROUP[ZmOperation.REPLY_ALL]			= 1;
    ZmComposeController.RADIO_GROUP[ZmOperation.CAL_REPLY]			= 1;
	ZmComposeController.RADIO_GROUP[ZmOperation.CAL_REPLY_ALL]		= 1;
	ZmComposeController.RADIO_GROUP[ZmOperation.FORMAT_HTML]		= 2;
	ZmComposeController.RADIO_GROUP[ZmOperation.FORMAT_TEXT]		= 2;
	ZmComposeController.RADIO_GROUP[ZmOperation.INC_ATTACHMENT]		= 3;
    ZmComposeController.RADIO_GROUP[ZmOperation.INC_BODY]	    	= 3;
	ZmComposeController.RADIO_GROUP[ZmOperation.INC_NONE]			= 3;
	ZmComposeController.RADIO_GROUP[ZmOperation.INC_SMART]			= 3;

	// translate between include settings and operations
	ZmComposeController.INC_OP = {};
	ZmComposeController.INC_OP[ZmSetting.INC_ATTACH]		= ZmOperation.INC_ATTACHMENT;
	ZmComposeController.INC_OP[ZmSetting.INC_BODY]			= ZmOperation.INC_BODY;
	ZmComposeController.INC_OP[ZmSetting.INC_NONE]			= ZmOperation.INC_NONE;
	ZmComposeController.INC_OP[ZmSetting.INC_SMART]			= ZmOperation.INC_SMART;
	ZmComposeController.INC_MAP = {};
	for (var i in ZmComposeController.INC_OP) {
		ZmComposeController.INC_MAP[ZmComposeController.INC_OP[i]] = i;
	}

	ZmComposeController.OPTIONS_TT = {};
	ZmComposeController.OPTIONS_TT[ZmOperation.NEW_MESSAGE]		= "composeOptions";
	ZmComposeController.OPTIONS_TT[ZmOperation.REPLY]			= "replyOptions";
	ZmComposeController.OPTIONS_TT[ZmOperation.REPLY_ALL]		= "replyOptions";
    ZmComposeController.OPTIONS_TT[ZmOperation.CAL_REPLY]		= "replyOptions";
	ZmComposeController.OPTIONS_TT[ZmOperation.CAL_REPLY_ALL]	= "replyOptions";
	ZmComposeController.OPTIONS_TT[ZmOperation.FORWARD_ATT]		= "forwardOptions";
	ZmComposeController.OPTIONS_TT[ZmOperation.FORWARD_INLINE]	= "forwardOptions";

	ZmComposeController.OP_CHECK = {};
	ZmComposeController.OP_CHECK[ZmOperation.SHOW_BCC] 	            = true;
	ZmComposeController.OP_CHECK[ZmOperation.REQUEST_READ_RECEIPT] 	= true;
	ZmComposeController.OP_CHECK[ZmOperation.USE_PREFIX] 			= true;
	ZmComposeController.OP_CHECK[ZmOperation.INCLUDE_HEADERS] 		= true;

	// Classification hashes for a compose action
	ZmComposeController.IS_INVITE_REPLY = {};
	ZmComposeController.IS_INVITE_REPLY[ZmOperation.REPLY_ACCEPT]		= true;
	ZmComposeController.IS_INVITE_REPLY[ZmOperation.REPLY_CANCEL]		= true;
	ZmComposeController.IS_INVITE_REPLY[ZmOperation.REPLY_DECLINE]		= true;
	ZmComposeController.IS_INVITE_REPLY[ZmOperation.REPLY_TENTATIVE]	= true;
	ZmComposeController.IS_INVITE_REPLY[ZmOperation.REPLY_MODIFY]		= true;
	ZmComposeController.IS_INVITE_REPLY[ZmOperation.REPLY_NEW_TIME]		= true;

	ZmComposeController.IS_CAL_REPLY = AjxUtil.hashCopy(ZmComposeController.IS_INVITE_REPLY);
	ZmComposeController.IS_CAL_REPLY[ZmOperation.CAL_REPLY]		= true;
	ZmComposeController.IS_CAL_REPLY[ZmOperation.CAL_REPLY_ALL]	= true;
	
	ZmComposeController.IS_REPLY = AjxUtil.hashCopy(ZmComposeController.IS_CAL_REPLY);
	ZmComposeController.IS_REPLY[ZmOperation.REPLY]		 = true;
	ZmComposeController.IS_REPLY[ZmOperation.REPLY_ALL]	 = true;
	
	ZmComposeController.IS_FORWARD = {};
	ZmComposeController.IS_FORWARD[ZmOperation.FORWARD_INLINE]	= true;
	ZmComposeController.IS_FORWARD[ZmOperation.FORWARD_ATT]	 	= true;

	ZmComposeController.PRIORITY_FLAG_TO_OP = {};
	ZmComposeController.PRIORITY_FLAG_TO_OP[ZmItem.FLAG_LOW_PRIORITY]   = ZmOperation.PRIORITY_LOW;
	ZmComposeController.PRIORITY_FLAG_TO_OP[ZmItem.FLAG_HIGH_PRIORITY]  = ZmOperation.PRIORITY_HIGH;
};

//
// Public methods
//

ZmComposeController.getDefaultViewType =
function() {
	return ZmId.VIEW_COMPOSE;
};
ZmComposeController.prototype.getDefaultViewType = ZmComposeController.getDefaultViewType;

/**
* Called by ZmNewWindow.unload to remove ZmSettings listeners (which reside in
* the parent window). Otherwise, after the child window is closed, the parent
* window is still referencing the child window's compose controller, which has
* been unloaded!!
* 
* @private
*/
ZmComposeController.prototype.dispose =
function() {
	var settings = appCtxt.getSettings();
	if (ZmComposeController.SETTINGS) { //no SETTINGS in child window
		for (var i = 0; i < ZmComposeController.SETTINGS.length; i++) {
			settings.getSetting(ZmComposeController.SETTINGS[i]).removeChangeListener(this._settingChangeListener);
		}
	}
	this._composeView.dispose();

	var app = this.getApp();
	app.disposeTreeControllers();
	appCtxt.notifyZimlets("onDisposeComposeController", [this]);

};

/**
 * Begins a compose session by presenting a form to the user.
 *
 * @param {Hash}		params			a hash of parameters:
 * @param {constant}	action			the new message, reply, forward, or an invite action
 * @param {Boolean}		inNewWindow		if <code>true</code>, we are in detached window
 * @param {ZmMailMsg}	msg				the original message (reply/forward), or address (new message)
 * @param {String}		toOverride 		the initial value for To: field
 * @param {String}		ccOverride		Cc: addresses (optional)
 * @param {String}		subjOverride 	the initial value for Subject: field
 * @param {String}		extraBodyText	the canned text to prepend to body (invites)
 * @param {AjxCallback}	callback		the callback to run after view has been set
 * @param {String}		accountName		the on-behalf-of From address
 * @param {String}		accountName		on-behalf-of From address
 * @param {boolean}		hideView		if true, don't show compose view
 */
ZmComposeController.prototype.doAction =
function(params) {

	params = params || {};
	var ac = window.parentAppCtxt || window.appCtxt;
	
	// in zdesktop, it's possible there are no accounts that support smtp
	if (ac.isOffline && !ac.get(ZmSetting.OFFLINE_COMPOSE_ENABLED)) {
		this._showMsgDialog(ZmComposeController.MSG_DIALOG_1, ZmMsg.composeDisabled, DwtMessageDialog.CRITICAL_STYLE);
		return;
	}

	params.action = params.action || ZmOperation.NEW_MESSAGE;
	params.inNewWindow = !appCtxt.isWebClientOffline() && !this.isHidden && (params.inNewWindow || this._app._inNewWindow(params.ev));
	this._msgSent = false;
	if (params.inNewWindow) {
        var msgId = (params.msg && params.msg.nId) || Dwt.getNextId();
		var newWinObj = ac.getNewWindow(false, ZmComposeController.NEW_WINDOW_WIDTH, ZmComposeController.NEW_WINDOW_HEIGHT, ZmId.VIEW_COMPOSE + "_" + msgId.replace(/\s|\-/g, '_'));
		if (newWinObj) {
			// this is how child window knows what to do once loading:
			newWinObj.command = "compose";
			newWinObj.params = params;
	        if (newWinObj.win) {
	            newWinObj.win.focus();
	        }
		}
	} else {
		this._setView(params);
		this._listController = params.listController;
	}
};

/**
 * Toggles the spell check button.
 * 
 * @param	{Boolean}	selected		if <code>true</code>, toggle the spell check to "selected"
 * 
 */
ZmComposeController.prototype.toggleSpellCheckButton =
function(selected) {
	var spellCheckButton = this._toolbar.getButton(ZmOperation.SPELL_CHECK);
	if (spellCheckButton) {
		spellCheckButton.setSelected((selected || false));
		spellCheckButton.setAttribute('aria-pressed', selected);
	}
};

/**
 * Detaches compose view to child window.
 * 
 */
ZmComposeController.prototype.detach =
function() {
	// bug fix #7192 - disable detach toolbar button
	this._toolbar.enable(ZmOperation.DETACH_COMPOSE, false);

	var view = this._composeView;
	var msg = this._msg || view._origMsg || view._msg;
	var subj = view._subjectField.value;
	var msgAttId = view._msgAttId; //include original as attachment
	var body = this._getBodyContent();
	var composeMode = view.getComposeMode();
	var backupForm = view.backupForm;
	var sendUID = view.sendUID;
	var action = view._action || this._action;
	var identity = view.getIdentity();
    var requestReadReceipt = this.isRequestReadReceipt();
    var selectedIdentityIndex = view.identitySelect && view.identitySelect.getSelectedIndex();

	var addrList = {};
	for (var i = 0; i < ZmMailMsg.COMPOSE_ADDRS.length; i++) {
		var type = ZmMailMsg.COMPOSE_ADDRS[i];
		addrList[type] = view.getAddrInputField(type).getAddresses(true);
	}

    var partToAttachmentMap = AjxUtil.map(view._partToAttachmentMap, function(member) {
       return AjxUtil.hashCopy(member);
    });

	// this is how child window knows what to do once loading:
    var msgId = (msg && msg.nId) || Dwt.getNextId();
	var newWinObj = appCtxt.getNewWindow(false, ZmComposeController.NEW_WINDOW_WIDTH, ZmComposeController.NEW_WINDOW_HEIGHT, ZmId.VIEW_COMPOSE + "_" + msgId.replace(/\s|\-/g, '_'));
    if (newWinObj && newWinObj.win) {
        newWinObj.win.focus();
    }
	newWinObj.command = "composeDetach";
	newWinObj.params = {
		action:			action,
		msg:			msg,
		addrs:			addrList,
		subj:			subj,
		priority:		this._getPriority(),
        attHtml:        view._attcDiv.innerHTML,
		msgAttId:		msgAttId,
        msgIds:         msg && msg.isDraft ? null : this._msgIds,
		draftType: 		this._draftType,
		draftMsg:		this._draftMsg,
		body:			body,
		composeMode:	composeMode,
		identityId:		selectedIdentityIndex,
		accountName:	this._accountName,
		backupForm:		backupForm,
		sendUID:		sendUID,
		sessionId:		this.getSessionId(),
        readReceipt:	requestReadReceipt,
		sigId:			this.getSelectedSignature(),
        incOptions:     this._curIncOptions,
        partMap:        partToAttachmentMap,
        origMsgAtt:     view._origMsgAtt ? AjxUtil.hashCopy(view._origMsgAtt) : null,
        origAction:     this._origAction
	};
};

ZmComposeController.prototype.popShield =
function() {
	var dirty = this._composeView.isDirty(true, true);
	if (!dirty && (this._draftType != ZmComposeController.DRAFT_TYPE_AUTO)) {
		return true;
	}

	var ps = this._popShield = appCtxt.getYesNoCancelMsgDialog();
	if (this._draftType == ZmComposeController.DRAFT_TYPE_AUTO) {
		// Message has been saved, but never explicitly by the user.
		// Ask if he wants to keep the autosaved draft.
		ps.reset();
		ps.setMessage(ZmMsg.askSaveAutosavedDraft, DwtMessageDialog.WARNING_STYLE);
		if (dirty) {
			ps.registerCallback(DwtDialog.YES_BUTTON, this._popShieldYesCallback, this);
		} else {
			ps.registerCallback(DwtDialog.YES_BUTTON, this._popShieldNoCallback, this);
		}
		ps.registerCallback(DwtDialog.NO_BUTTON, this._popShieldDiscardCallback, this);
		ps.registerCallback(DwtDialog.CANCEL_BUTTON, this._popShieldDismissCallback, this);
	} else if (this._canSaveDraft()) {
		ps.reset();
		ps.setMessage(ZmMsg.askSaveDraft, DwtMessageDialog.WARNING_STYLE);
		ps.registerCallback(DwtDialog.YES_BUTTON, this._popShieldYesCallback, this);
		ps.registerCallback(DwtDialog.NO_BUTTON, this._popShieldNoCallback, this);
		ps.registerCallback(DwtDialog.CANCEL_BUTTON, this._popShieldDismissCallback, this);
	} else {
		ps = this._popShield = appCtxt.getYesNoMsgDialog();
		ps.setMessage(ZmMsg.askLeaveCompose, DwtMessageDialog.WARNING_STYLE);
		ps.registerCallback(DwtDialog.YES_BUTTON, this._popShieldYesCallback, this);
		ps.registerCallback(DwtDialog.NO_BUTTON, this._popShieldDismissCallback, this);
	}
	ps.addPopdownListener(this._dialogPopdownListener);
	ps.popup();

	return false;
};

// We don't call ZmController._preHideCallback here because it saves the current
// focus member, and we want to start over each time
ZmComposeController.prototype._preHideCallback = function(view, force) {

    DBG.println('draft', 'ZmComposeController._preHideCallback for ' + view + ': force = ' + force + ', _dontSavePreHide = ' + this._dontSavePreHide);
	if (this._autoSaveTimer) {
		//the following is a bit suspicious to me. I assume maybe this method might be called with force == true
		//in a way that is not after the popShield was activated? That would be the only explanation to have this.
		//I wonder if that's the case that leaves orphan drafts
		if (force) {
			// auto-save if we leave this compose tab and the message has not yet been sent
			// this is a refactoring/fix of code initially from bug 72106 (since it's confusing I mention this bug to keep this knowledge)
            if (this._dontSavePreHide) {
                this._dontSavePreHide = false;
            }
            else {
                this._autoSaveCallback(true);
            }
		}
	}

	return force ? true : this.popShield();
};

ZmComposeController.prototype._preUnloadCallback =
function(view) {
	return !this._composeView.isDirty(true, true);
};


ZmComposeController.prototype._preShowCallback = function() {

    this._composeView.enableInputs(true);

	return true;
};

ZmComposeController.prototype._postShowCallback =
function() {
	// always reset auto save every time this view is shown. This covers the
	// case where a compose tab is inactive and becomes active when user clicks
	// on compose tab.
	this._initAutoSave();

	if (!appCtxt.isChildWindow) {
		// no need to "restore" focus between windows
		ZmController.prototype._postShowCallback.call(this);
	}
    var view = this._composeView;
	var composeMode = view.getComposeMode();
	if (this._action != ZmOperation.NEW_MESSAGE &&
		this._action != ZmOperation.FORWARD_INLINE &&
		this._action != ZmOperation.FORWARD_ATT)
	{
		if (composeMode == Dwt.HTML) {
 			setTimeout(view._focusHtmlEditor.bind(view), 100);
		}
		this._composeView._setBodyFieldCursor();
	}
};

ZmComposeController.prototype._postHideCallback = function() {

    DBG.println('draft', 'ZmComposeController._postHideCallback for ' + this._currentViewId);
    if (this._autoSaveTimer) {
        this._autoSaveTimer.kill();
    }

	// hack to kill the child window when replying to an invite
	if (appCtxt.isChildWindow && ZmComposeController.IS_INVITE_REPLY[this._action]) {
		window.close();
	}
};

/**
 * This method gets called if user clicks on mailto link while compose view is
 * already being used.
 * 
 * @private
 */
ZmComposeController.prototype.resetComposeForMailto =
function(params) {
	if (this._popShield && this._popShield.isPoppedUp()) {
		return false;
	}

	var ps = this._popShield = appCtxt.getYesNoCancelMsgDialog();
	ps.reset();
	ps.setMessage(ZmMsg.askSaveDraft, DwtMessageDialog.WARNING_STYLE);
	ps.registerCallback(DwtDialog.YES_BUTTON, this._popShieldYesCallback, this, params);
	ps.registerCallback(DwtDialog.NO_BUTTON, this._popShieldNoCallback, this, params);
	ps.registerCallback(DwtDialog.CANCEL_BUTTON, this._popShieldDismissCallback, this);
	ps.addPopdownListener(this._dialogPopdownListener);
	ps.popup();

	return true;
};

/**
 * Sends the message represented by the content of the compose view.
 *
 * @param	{String}		attId					the id
 * @param	{constant}		draftType				the draft type (see <code>ZmComposeController.DRAFT_TYPE_</code> constants)
 * @param	{AjxCallback}	callback				the callback
 * @param	{Boolean}		processImages           remove webkit-fake-url images and upload data uri images
 */
ZmComposeController.prototype.sendMsg =
function(attId, draftType, callback, contactId, processImages) {

    if (processImages !== false && this._composeView) {
        //Dont use bind as its arguments cannot be modified before its execution.
        var processImagesCallback = new AjxCallback(this, this._sendMsg, [attId, null, draftType, callback, contactId]);
        var result = this._processImages(processImagesCallback);
        if (result) {
            return;
        }
    }
	return this._sendMsg(attId, null, draftType, callback, contactId);
};

/**
 * Sends the message represented by the content of the compose view with specified docIds as attachment.
 * 
 * @param	{Array}	docIds		the document Ids
 * @param	{constant}	draftType		the draft type (see <code>ZmComposeController.DRAFT_TYPE_</code> constants)
 * @param	{AjxCallback}	callback		the callback
 */
ZmComposeController.prototype.sendDocs =
function(docIds, draftType, callback, contactId) {
	return this._sendMsg(null, docIds, draftType, callback, contactId);
};

/**
 * Sends the message represented by the content of the compose view.
 * 
 * @private
 */
ZmComposeController.prototype._sendMsg =
function(attId, docIds, draftType, callback, contactId) {

	var isTimed = Boolean(this._sendTime);
	draftType = draftType || (isTimed ? ZmComposeController.DRAFT_TYPE_DELAYSEND : ZmComposeController.DRAFT_TYPE_NONE);
	var isDraft = draftType != ZmComposeController.DRAFT_TYPE_NONE;
	var isAutoSave = draftType == ZmComposeController.DRAFT_TYPE_AUTO;
	// bug fix #38408 - briefcase attachments need to be set *before* calling
	// getMsg() but we cannot do that without having a ZmMailMsg to store it in.
	// File this one under WTF.
	var tempMsg;
	if (docIds) {
		tempMsg = new ZmMailMsg();
		this._composeView.setDocAttachments(tempMsg, docIds);
	}
	var msg = this._composeView.getMsg(attId, isDraft, tempMsg, isTimed, contactId);

	if (!msg) {
		return;
	}

	if (this._autoSaveTimer) {
        //If this._autoSaveTimer._timer is null then this._autoSaveTimer.kill(); is already called.
        //Due to browsers cleartimeout taking some time, we are again checking this._autoSaveTimer._timer to prevent unnecessary autosave call
        //Bug:74148
        if (isAutoSave && isDraft && !this._autoSaveTimer._timer) {
            return;
        }
		//kill the timer, no save is attempted while message is pending
        this._autoSaveTimer.kill();
	}

	var origMsg = msg._origMsg;
	var isCancel = (msg.inviteMode == ZmOperation.REPLY_CANCEL);
	var isModify = (msg.inviteMode == ZmOperation.REPLY_MODIFY);

	if (isCancel || isModify) {
		var appt = origMsg._appt;
		var respCallback = this._handleResponseCancelOrModifyAppt.bind(this);
		if (isCancel) {
			appt.cancel(origMsg._mode, msg, respCallback);
		} else {
			appt.save();
		}
		return;
	}

	var ac = window.parentAppCtxt || window.appCtxt;
	var acctName = appCtxt.multiAccounts
		? this._composeView.getFromAccount().name : this._accountName;
	if (msg.delegatedSenderAddr && !msg.delegatedSenderAddrIsDL) {
		acctName = msg.delegatedSenderAddr;
	}

	if (isDraft) {
		if (appCtxt.multiAccounts) {
			// for offline, save drafts based on account owner of From: dropdown
			acctName = ac.accountList.getAccount(msg.fromSelectValue.accountId).name;
		} else {
			acctName = ac.getActiveAccount().name;
		}
		if (msg._origMsg && msg._origMsg.isDraft) {
			// if shared folder, make sure we save the draft under the owner account name
			var folder = msg.folderId ? ac.getById(msg.folderId) : null;
			if (folder && folder.isRemote()) {
				acctName = folder.getOwner();
			}
		}
	} else {
		// if shared folder, make sure we send the email on-behalf-of
		var folder = msg.folderId ? ac.getById(msg.folderId) : null;
		if (folder && folder.isRemote() && this._composeView.sendMsgOboIsOK()) {
			acctName = folder.getOwner();            
		}
	}

	if (origMsg) {
		origMsg.sendAsMe = !this._composeView.sendMsgOboIsOK();
	}

	// If this message had been saved from draft and it has a sender (meaning
	// it's a reply from someone else's account) then get the account name from
	// the from field.
	if (!acctName && !isDraft && origMsg && origMsg.isDraft) {
		if (this._composeView.sendMsgOboIsOK()) {
			if (origMsg._addrs[ZmMailMsg.HDR_FROM] &&
				origMsg._addrs[ZmMailMsg.HDR_SENDER] &&
				origMsg._addrs[ZmMailMsg.HDR_SENDER].size())
			{
				acctName = origMsg._addrs[ZmMailMsg.HDR_FROM].get(0).address;
			}
		} else {
			origMsg.sendAsMe = true; // hack.
		}
	}

	// check for read receipt
	var requestReadReceipt = !this.isHidden && this.isRequestReadReceipt();

	var respCallback = this._handleResponseSendMsg.bind(this, draftType, msg, callback);
	var errorCallback = this._handleErrorSendMsg.bind(this, draftType, msg);
	msg.send(isDraft, respCallback, errorCallback, acctName, null, requestReadReceipt, null, this._sendTime, isAutoSave);
	this._resetDelayTime();
};

ZmComposeController.prototype._handleResponseSendMsg =
function(draftType, msg, callback, result) {
	var resp = result.getResponse();
	// Reset the autosave interval to the default
	delete(this._autoSaveInterval);
	// Re-enable autosave
	if (draftType !== ZmComposeController.DRAFT_TYPE_NONE) {
		//only re-init autosave if it's a draft, NOT if it's an actual message send. (user clicked "send").
		//In order to avoid a potential race condition, and there's no reason to init auto save anyway.
		this._initAutoSave();
	}
	var needToPop = this._processSendMsg(draftType, msg, resp);

//	this._msg = msg;

	if (callback) {
		callback.run(result);
	}

    if(this.sendMsgCallback) {
        this.sendMsgCallback.run(result);
    }

	appCtxt.notifyZimlets("onSendMsgSuccess", [this, msg, draftType]);//notify Zimlets on success

	if (needToPop) {
		this._dontSavePreHide = true;
		this._app.popView(true, this._currentView);
	}
	
};

ZmComposeController.prototype._handleResponseCancelOrModifyAppt =
function() {
	this._app.popView(true);
    appCtxt.setStatusMsg(ZmMsg.messageSent);
};

ZmComposeController.prototype._handleErrorSendMsg = function(draftType, msg, ex, params) {

	if (draftType !== ZmComposeController.DRAFT_TYPE_NONE && !AjxUtil.isUndefined(this._wasDirty)) {
		this._composeView._isDirty = this._wasDirty;
		delete this._wasDirty;
	}

    var retVal = false;
	if (!this.isHidden) {
		this.resetToolbarOperations();
		this._composeView.enableInputs(true);
	}

    appCtxt.notifyZimlets("onSendMsgFailure", [this, ex, msg]);//notify Zimlets on failure
    if (ex && ex.code) {
	
        var errorMsg = null;
        var showMsg = false;
		var style = null;
        if (ex.code === ZmCsfeException.MAIL_SEND_ABORTED_ADDRESS_FAILURE) {
            var invalid = ex.getData ? ex.getData(ZmCsfeException.MAIL_SEND_ADDRESS_FAILURE_INVALID) : null;
            var invalidMsg = invalid && invalid.length ? AjxMessageFormat.format(ZmMsg.sendErrorInvalidAddresses, invalid.join(", ")) : null;
            errorMsg = ZmMsg.sendErrorAbort + "<br/>" +  AjxStringUtil.htmlEncode(invalidMsg);
            this.popupErrorDialog(errorMsg, ex, true, true, false, true);
            retVal = true;
        }
        else if (ex.code === ZmCsfeException.MAIL_SEND_PARTIAL_ADDRESS_FAILURE) {
            var invalid = ex.getData ? ex.getData(ZmCsfeException.MAIL_SEND_ADDRESS_FAILURE_INVALID) : null;
            errorMsg = invalid && invalid.length ? AjxMessageFormat.format(ZmMsg.sendErrorPartial, AjxStringUtil.htmlEncode(invalid.join(", "))) : ZmMsg.sendErrorAbort;
            showMsg = true;
        }
        else if (ex.code == AjxException.CANCELED) {
            if (draftType === ZmComposeController.DRAFT_TYPE_AUTO) {
				//note - this interval is not really used anymore. Only the idle timer is used. This is only used as a boolean checkbox now. I'm pretty sure.
                if (!this._autoSaveInterval) {
                    // Request was cancelled due to a ZmRequestMgr send timeout.
                    // The server can either be hung or this particular message is taking
                    // too long to process. Backoff the send interval - restored to
                    // default upon first successful save
                    this._autoSaveInterval = appCtxt.get(ZmSetting.AUTO_SAVE_DRAFT_INTERVAL);
                }
                if (this._autoSaveInterval) {
                    // Cap the save attempt interval at 5 minutes
                    this._autoSaveInterval *= 2;
                    if (this._autoSaveInterval > 300) {
                        this._autoSaveInterval = 300;
                    }
                }
            }
            errorMsg = ZmMsg.cancelSendMsgWarning;
            this._composeView.setBackupForm();
            retVal = true;
        }
        else if (ex.code === ZmCsfeException.MAIL_QUOTA_EXCEEDED) {
            errorMsg = ZmMsg.errorQuotaExceeded;
        }
        else if (ex.code === ZmCsfeException.MAIL_NO_SUCH_CONTACT) {
            errorMsg = ZmMsg.vcardContactGone;
            showMsg = true;
        }

        if (this._uploadingProgress){
            this._initAutoSave();
		    this._composeView._resetUpload(true);
			if (ex.code === ZmCsfeException.MAIL_MESSAGE_TOO_BIG) {
				errorMsg = AjxMessageFormat.format(ZmMsg.attachmentSizeError, AjxUtil.formatSize(appCtxt.get(ZmSetting.MESSAGE_SIZE_LIMIT)));
				style = DwtMessageDialog.WARNING_STYLE;
                showMsg = true;
			}
			else if (ex.code === ZmCsfeException.MAIL_NO_SUCH_MSG) {
                // The message was deleted while upload was in progress (likely a discarded draft). Ignore the error.
                DBG.println(AjxDebug.DBG1, "Message was deleted while uploading a file; ignore the SaveDraft 'No Such Message' error." );
                retVal  = true;
                showMsg = false;
            } else {
				errorMsg = errorMsg || ZmMsg.attachingFilesError + "<br>" + (ex.msg || "");
                showMsg = true;
			}
        }

        if (errorMsg && showMsg) {
			this._showMsgDialog(ZmComposeController.MSG_DIALOG_1, errorMsg, style || DwtMessageDialog.CRITICAL_STYLE, null, true);
            retVal = true;
        }
    }

    // Assume the user stays on the compose view, so we need the timer.
    // (it was canceled when send was called)
    this._initAutoSave();
    return retVal;
};


/**
 * Creates a new ZmComposeView if one does not already exist
 */
ZmComposeController.prototype.initComposeView =
function() {

	if (this._composeView) { return; }

	if (!this.isHidden) {
		this._composeView = new ZmComposeView(this._container, this, this._composeMode, this._action);
		var callbacks = {};
		callbacks[ZmAppViewMgr.CB_PRE_HIDE]		= this._preHideCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_PRE_UNLOAD]	= this._preUnloadCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_POST_SHOW]	= this._postShowCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_PRE_SHOW]		= this._preShowCallback.bind(this);
		callbacks[ZmAppViewMgr.CB_POST_HIDE]	= this._postHideCallback.bind(this);
		this._initializeToolBar();
		var elements = this.getViewElements(null, this._composeView, this._toolbar);
	
		this._app.createView({	viewId:		this._currentViewId,
								viewType:	this._currentViewType,
								elements:	elements,
								hide:		this._elementsToHide,
								controller:	this,
								callbacks:	callbacks,
								tabParams:	this._getTabParams()});

		if (this._composeView.identitySelect) {
			this._composeView.identitySelect.addChangeListener(this._identityChangeListener.bind(this));
		}
	}
	else {
		this._composeView = new ZmHiddenComposeView(this, this._composeMode);
	}
};

ZmComposeController.prototype._getTabParams =
function() {
	return {id:this.tabId, image:"CloseGray", hoverImage:"Close", text:ZmComposeController.DEFAULT_TAB_TEXT, textPrecedence:75,
			tooltip:ZmComposeController.DEFAULT_TAB_TEXT, style: DwtLabel.IMAGE_RIGHT};
};

ZmComposeController.prototype.isTransient =
function(oldView, newView) {
	return (appCtxt.getViewTypeFromId(newView) == ZmId.VIEW_MAIL_CONFIRM);
};

ZmComposeController.prototype._identityChangeListener =
function(event) {

	var cv = this._composeView;
	var signatureId = cv._getSignatureIdForAction(null, this._action);

	// don't do anything if signature is same
	if (signatureId == this._currentSignatureId) { return; }

	var okCallback = this._switchIdentityOkCallback.bind(this);
	var cancelCallback = this._switchIdentityCancelCallback.bind(this, cv.identitySelect.getValue());
	if (!this._warnUserAboutChanges(ZmId.OP_ADD_SIGNATURE, okCallback, cancelCallback)) {
		this._switchIdentityOkCallback();
	}
};

ZmComposeController.prototype._switchIdentityOkCallback =
function() {
    if(this._currentDlg) {
	    this._currentDlg.popdown();
    }
	this._switchIdentity();
};

ZmComposeController.prototype._switchIdentityCancelCallback =
function(identityId) {
	this._currentDlg.popdown();
	this._composeView.identitySelect.setSelectedValue(this._currentIdentityId);
};

ZmComposeController.prototype._switchIdentity =
function() {
	var identity = this._composeView.getIdentity();
	var sigId = this._composeView._getSignatureIdForAction(identity);
	this.setSelectedSignature(sigId);
	var params = {
		action:			this._action,
		msg:			this._msg,
		extraBodyText:	this._composeView.getUserText(),
		keepAttachments: true,
		op:				ZmId.OP_ADD_SIGNATURE
 	};
	this._composeView.resetBody(params);
	this._setAddSignatureVisibility();
	if (identity) {
		this.resetIdentity(identity.id);
	}
	this.resetSignature(sigId);
};

ZmComposeController.prototype._handleSelectSignature =
function(ev) {

	var sigId = ev.item.getData(ZmComposeController.SIGNATURE_KEY);
	var okCallback = this._switchSignatureOkCallback.bind(this, sigId);
	var cancelCallback = this._switchSignatureCancelCallback.bind(this);
	//TODO: There shouldn't be a need to warn the user now that we're preserving quoted text and headers.
	//(see bugs 91743 and 92086
	//However since it's the release time, it's safer to keep warning the user.
	//Revisit this after the release.
	if (!this._warnUserAboutChanges(ZmId.OP_ADD_SIGNATURE, okCallback, cancelCallback)) {
		this._switchSignature(sigId);
	}
};

ZmComposeController.prototype._switchSignatureOkCallback =
function(sigId) {
	this._currentDlg.popdown();
	this._switchSignature(sigId);
};

ZmComposeController.prototype._switchSignatureCancelCallback =
function() {
	this._currentDlg.popdown();
	this.setSelectedSignature(this._currentSignatureId);
};

ZmComposeController.prototype._switchSignature =
function(sigId) {
	this.setSelectedSignature(sigId);
	var params = {
		keepAttachments: true,
		action:			this._action,
		msg:			this._msg,
		extraBodyText:	this._composeView.getUserText(),
		op:				ZmId.OP_ADD_SIGNATURE
	};
	this._composeView._updateSignatureVcard(this._currentSignatureId, sigId);
	this._composeView.resetBody(params);
	this.resetSignature(sigId);
};

/**
 * Sets the tab stops for the compose form. All address fields are added; they're
 * not actual tab stops unless they're visible. The textarea for plain text and
 * the HTML editor for HTML compose are swapped in and out depending on the mode.
 * 
 * @private
 */
ZmComposeController.prototype._setComposeTabGroup =
function() {
	var tg = this._createTabGroup();
	var rootTg = appCtxt.getRootTabGroup();
	tg.newParent(rootTg);
	tg.addMember(this._toolbar);
	tg.addMember(this._composeView.getTabGroupMember());
};

ZmComposeController.prototype.getKeyMapName =
function() {
	return ZmKeyMap.MAP_COMPOSE;
};

ZmComposeController.prototype.handleKeyAction =
function(actionCode) {
	switch (actionCode) {
		case ZmKeyMap.CANCEL:
			this._cancelCompose();
			break;

		case ZmKeyMap.SAVE: // Save to draft
			if (this._uploadingProgress) {
				break;
			}
			if (this._canSaveDraft()) {
				this.saveDraft();
			}
			break;

		case ZmKeyMap.SEND: // Send message
			if (!appCtxt.get(ZmSetting.USE_SEND_MSG_SHORTCUT) || this._uploadingProgress) {
				break;
			}
			this._sendListener();
			break;

		case ZmKeyMap.ATTACHMENT:
			this._attachmentListener();
			break;

		case ZmKeyMap.SPELLCHECK:
            if (!appCtxt.isSpellCheckerAvailable()) {
                break;
            }
			this.toggleSpellCheckButton(true);
			this._spellCheckListener();
			break;

		case ZmKeyMap.HTML_FORMAT:
			if (appCtxt.get(ZmSetting.HTML_COMPOSE_ENABLED)) {
				var mode = this._composeView.getComposeMode();
				var newMode = (mode == Dwt.TEXT) ? Dwt.HTML : Dwt.TEXT;
				this._setFormat(newMode);
				this._setOptionsMenu(newMode);
			}
			break;

		case ZmKeyMap.ADDRESS_PICKER:
			this._composeView.getAddressButtonListener(null, AjxEmailAddress.TO);
			break;

		case ZmKeyMap.NEW_WINDOW:
			if (!appCtxt.isChildWindow) {
				this._detachListener();
			}
			break;

		default:
			return ZmMailListController.prototype.handleKeyAction.call(this, actionCode);
			break;
	}
	return true;
};

ZmComposeController.prototype.mapSupported =
function(map) {
	return (map == "editor");
};

/**
 * Gets the selected signature.
 * 
 * @return	{String}	the selected signature key or <code>null</code> if none selected
 */
ZmComposeController.prototype.getSelectedSignature =
function() {
	if (!this.isHidden) {
		var button = this._getSignatureButton();
		var menu = button ? button.getMenu() : null;
		if (menu) {
			var menuitem = menu.getSelectedItem(DwtMenuItem.RADIO_STYLE);
			return menuitem ? menuitem.getData(ZmComposeController.SIGNATURE_KEY) : null;
		}
	}
	else {
		// for hidden compose, return the default signature
		var ac = window.parentAppCtxt || window.appCtxt;
		var collection = ac.getIdentityCollection();
		return this._composeView._getSignatureIdForAction(collection.defaultIdentity);
	}
};

/**
 * Gets the selected signature.
 * 
 * @param	{String}	value 	the selected signature key
 */
ZmComposeController.prototype.setSelectedSignature =
function(value) {
	var button = this._getSignatureButton();
	var menu = button ? button.getMenu() : null;
	if (menu) {
        if (value === ZmIdentity.SIG_ID_NONE) {
            value = "";
        }
		menu.checkItem(ZmComposeController.SIGNATURE_KEY, value, true);
	}
};

ZmComposeController.prototype.resetSignature =
function(sigId) {
	this._currentSignatureId = sigId;
};

ZmComposeController.prototype.resetIdentity =
function(identityId) {
	this._currentIdentityId = identityId;
};

//
// Protected methods
//

ZmComposeController.prototype._deleteDraft =
function(delMsg) {

	if (!delMsg) { return; }
    var ac = window.parentAppCtxt || window.appCtxt;
    if (delMsg && delMsg.isSent) {
      var folder = delMsg.folderId ? ac.getById(delMsg.folderId) : null;
	  if (folder && folder.isRemote() && !folder.isPermAllowed(ZmOrganizer.PERM_DELETE)) {
         return;   //remote folder no permission to delete, exit
	  }
    }

	delMsg.doDelete();
};

/**
 * Creates the compose view based on the mode we're in. Lazily creates the
 * compose toolbar, a contact picker, and the compose view itself.
 *
 * @param action		[constant]		new message, reply, forward, or an invite action
 * @param msg			[ZmMailMsg]*	the original message (reply/forward), or address (new message)
 * @param toOverride 	[string]*		initial value for To: field
 * @param subjOverride 	[string]*		initial value for Subject: field
 * @param extraBodyText [string]*		canned text to prepend to body (invites)
 * @param composeMode	[constant]*		HTML or text compose
 * @param accountName	[string]*		on-behalf-of From address
 * @param msgIds		[Array]*		list of msg Id's to be added as attachments
 * @param readReceipt   [boolean]       true/false read receipt setting
 */
ZmComposeController.prototype._setView =
function(params) {

	if (this._autoSaveTimer) {
		this._autoSaveTimer.kill();
	}

	// msg is the original msg for a reply or when editing a draft (not a newly saved draft or sent msg)
	var msg = this._msg = params.msg;
	if (msg && msg.isInvite() && ZmComposeController.IS_FORWARD[params.action]) {
		params.action = ZmOperation.FORWARD_INLINE;
	}
	var action = this._action = params.action;
    this._origAction = params.origAction;
	
	this._toOverride = params.toOverride;
	this._ccOverride = params.ccOverride;
	this._subjOverride = params.subjOverride;
	this._extraBodyText = params.extraBodyText;
	this._msgIds = params.msgIds;
	this._accountName = params.accountName;
	var identity = params.identity = this._getIdentity(msg);

	this._composeMode = params.composeMode || this._getComposeMode(msg, identity, params);

    var cv = this._composeView;
	if (!cv) {
		this.initComposeView();
		cv = this._composeView;
	} else {
		cv.setComposeMode(this._composeMode, true);
	}

	if (identity) {
		this.resetSignature(cv._getSignatureIdForAction(identity, action));
	}

	if (!this.isHidden) {
		this._initializeToolBar();
		this.resetToolbarOperations();
		this._setOptionsMenu(this._composeMode, params.incOptions);
	}
	cv.set(params);

	if (!this.isHidden) {
		this._setOptionsMenu();	// reset now that compose view has figured out the inc options
		appCtxt.notifyZimlets("initializeToolbar", [this._app, this._toolbar, this, this._currentViewId], {waitUntilLoaded:true});
		this._setAddSignatureVisibility();
		if (params.sigId) {
			this.setSelectedSignature(params.sigId);
			this.resetSignature(params.sigId);
		}

		// preserve priority for drafts
		if (appCtxt.get(ZmSetting.MAIL_PRIORITY_ENABLED)) {
			if (msg && action === ZmOperation.DRAFT) {
				var priority = msg.isHighPriority ? ZmItem.FLAG_HIGH_PRIORITY : msg.isLowPriority ? ZmItem.FLAG_LOW_PRIORITY : "";
				if (priority) {
					this._setPriority(priority);
				}
			}
			else {
				this._setPriority();
			}
		}

		if (params.readReceipt) {
			var menu = this._optionsMenu[action];
			var mi = menu && menu.getOp(ZmOperation.REQUEST_READ_RECEIPT);
			if (mi && this.isReadReceiptEnabled()) {
				mi.setChecked(true, true);
			}
		}
	
		this._setComposeTabGroup();
		if (!params.hideView) {
			this._app.pushView(this._currentViewId);
		}
		if (!appCtxt.isChildWindow) {
			cv.updateTabTitle();
		}
		cv.reEnableDesignMode();

		this._draftMsg = params.draftMsg;
		this._draftType = params.draftType || ZmComposeController.DRAFT_TYPE_NONE;
		if ((this._msgIds || cv._msgAttId) && !appCtxt.isChildWindow) {
			this.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO);
		}
		else if (msg && (action == ZmOperation.DRAFT)) {
			this._draftType = ZmComposeController.DRAFT_TYPE_MANUAL;
			if (msg.autoSendTime) {
				this.saveDraft(ZmComposeController.DRAFT_TYPE_MANUAL, null, null, msg.setAutoSendTime.bind(msg));
				this._showMsgDialog(ZmComposeController.MSG_DIALOG_1, ZmMsg.messageAutoSaveAborted);
			}
		}
	}

    cv.checkAttachments();
    this.sendMsgCallback = params.sendMsgCallback;

	if (params.callback) {
		params.callback.run(this);
	}
};

ZmComposeController.prototype._getIdentity =
function(msg) {
	var account = (appCtxt.multiAccounts && appCtxt.getActiveAccount().isMain)
		? appCtxt.accountList.defaultAccount : null;
	var identityCollection = appCtxt.getIdentityCollection(account);
	if (!msg) {
		var ac = window.parentAppCtxt || window.appCtxt;
		var curSearch = ac.getApp(ZmApp.MAIL).currentSearch;
		var folderId = curSearch && curSearch.folderId;
		if (folderId) {
			return identityCollection.selectIdentityFromFolder(folderId);
		}
	} else {
		msg = this._getInboundMsg(msg);
	}
	return (msg && msg.identity) ? msg.identity : identityCollection.selectIdentity(msg);
};

/**
 * find the first message after msg (or msg itself) in the conv, that's inbound (not outbound). This is since inbound ones are
 * relevant to the rules to select identify (such as folder rules, outbound could be in "sent" for example, or "to" address rules)
 *
 * Also, just return the message if it does not have an associated folder - this occurs when a blank message is created in
 * Briefcase, for the 'Send as Attachment' command.
 * @param msg
 * @returns {ZmMailMsg}
 */
ZmComposeController.prototype._getInboundMsg =
function(msg) {
	var folder = appCtxt.getById(msg.folderId);
	if (!folder || !folder.isOutbound()) {
		return msg;
	}
	var conv = appCtxt.getById(msg.cid);
	if (!conv || !conv.msgs) {
		return msg;
	}
	//first find the message in the conv.
	var msgs = conv.msgs.getArray();
	for (var i = 0; i < msgs.length; i++) {
		if (msgs[i].id === msg.id) {
			break;
		}
	}
	//now find the first msg after it that's not outbound
	for (i = i + 1; i < msgs.length; i++) {
		var nextMsg = msgs[i];
		folder = appCtxt.getById(nextMsg.folderId);
		if (!folder.isOutbound()) {
			return nextMsg;
		}
	}
	return msg;
};

ZmComposeController.prototype._initializeToolBar =
function() {

	if (this._toolbar) { return; }
	
	var buttons = [];
	if (this._canSaveDraft() && appCtxt.get(ZmSetting.MAIL_SEND_LATER_ENABLED)) {
		buttons.push(ZmOperation.SEND_MENU);
	} else {
		buttons.push(ZmOperation.SEND);
	}

	buttons.push(ZmOperation.CANCEL, ZmOperation.SEP, ZmOperation.SAVE_DRAFT);

	if (appCtxt.isSpellCheckerAvailable()) {
		buttons.push(ZmOperation.SEP, ZmOperation.SPELL_CHECK);
	}
	buttons.push(ZmOperation.SEP, ZmOperation.COMPOSE_OPTIONS, ZmOperation.FILLER);

	if (appCtxt.get(ZmSetting.DETACH_COMPOSE_ENABLED) && !appCtxt.isChildWindow && !appCtxt.isWebClientOffline()) {
		buttons.push(ZmOperation.DETACH_COMPOSE);
	}

	var tb = this._toolbar = new ZmButtonToolBar({
		parent: this._container,
		buttons: buttons,
		className: (appCtxt.isChildWindow ? "ZmAppToolBar_cw" : "ZmAppToolBar") + " ImgSkin_Toolbar itemToolbar",
		context: this._currentViewId
	});

	for (var i = 0; i < tb.opList.length; i++) {
		var button = tb.opList[i];
		if (this._listeners[button]) {
			tb.addSelectionListener(button, this._listeners[button]);
		}
	}

	if (appCtxt.get(ZmSetting.SIGNATURES_ENABLED) || appCtxt.multiAccounts) {
		var sc = appCtxt.getSignatureCollection();
		sc.addChangeListener(this._signatureChangeListener.bind(this));

		var button = tb.getButton(ZmOperation.ADD_SIGNATURE);
		if (button) {
			button.setMenu(new AjxCallback(this, this._createSignatureMenu));
		}
	}

	var actions = [ZmOperation.NEW_MESSAGE, ZmOperation.REPLY, ZmOperation.FORWARD_ATT, ZmOperation.DECLINE_PROPOSAL, ZmOperation.CAL_REPLY];
	this._optionsMenu = {};
	for (var i = 0; i < actions.length; i++) {
		this._optionsMenu[actions[i]] = this._createOptionsMenu(actions[i]);
	}
	this._optionsMenu[ZmOperation.REPLY_ALL] = this._optionsMenu[ZmOperation.REPLY];
    this._optionsMenu[ZmOperation.CAL_REPLY_ALL] = this._optionsMenu[ZmOperation.CAL_REPLY];
	this._optionsMenu[ZmOperation.FORWARD_INLINE] = this._optionsMenu[ZmOperation.FORWARD_ATT];
	this._optionsMenu[ZmOperation.REPLY_CANCEL] = this._optionsMenu[ZmOperation.REPLY_ACCEPT] =
		this._optionsMenu[ZmOperation.DECLINE_PROPOSAL] = this._optionsMenu[ZmOperation.REPLY_DECLINE] = this._optionsMenu[ZmOperation.REPLY_TENTATIVE] =
		this._optionsMenu[ZmOperation.SHARE] = this._optionsMenu[ZmOperation.DRAFT] =
		this._optionsMenu[ZmOperation.NEW_MESSAGE];

	// change default button style to select for spell check button
	var spellCheckButton = tb.getButton(ZmOperation.SPELL_CHECK);
	if (spellCheckButton) {
		spellCheckButton.setAlign(DwtLabel.IMAGE_LEFT | DwtButton.TOGGLE_STYLE);
	}

	var button = tb.getButton(ZmOperation.SEND_MENU);
	if (button) {
		var menu = new ZmPopupMenu(button, null, null, this);
		var sendItem = menu.createMenuItem(ZmOperation.SEND, ZmOperation.defineOperation(ZmOperation.SEND));
		sendItem.addSelectionListener(this._listeners[ZmOperation.SEND]);
		var sendLaterItem = menu.createMenuItem(ZmOperation.SEND_LATER, ZmOperation.defineOperation(ZmOperation.SEND_LATER));
		sendLaterItem.addSelectionListener(this._listeners[ZmOperation.SEND_LATER]);
		button.setMenu(menu);
	}
};

ZmComposeController.prototype._initAutoSave =
function() {
	if (!this._canSaveDraft()) { return; }
    if (appCtxt.get(ZmSetting.AUTO_SAVE_DRAFT_INTERVAL)) {
        if (!this._autoSaveTimer) {
            this._autoSaveTimer = new DwtIdleTimer(ZmMailApp.AUTO_SAVE_IDLE_TIME * 1000, new AjxCallback(this, this._autoSaveCallback));
        }
        else{
            this._autoSaveTimer.resurrect(ZmMailApp.AUTO_SAVE_IDLE_TIME * 1000);
        }
    }
};

ZmComposeController.prototype._getOptionsMenu =
function() {
	return this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS).getMenu();
};


/**
 * returns the signature button - not exactly a button but a menu item in the options menu, that has a sub-menu attached to it.
 */
ZmComposeController.prototype._getSignatureButton =
function() {
	var menu = this._getOptionsMenu();
	return menu && menu.getItemById(ZmOperation.MENUITEM_ID, ZmOperation.ADD_SIGNATURE);
};

// only show signature submenu if the account has at least one signature
ZmComposeController.prototype._setAddSignatureVisibility =
function(account) {
	var ac = window.parentAppCtxt || window.appCtxt;
	if (!ac.get(ZmSetting.SIGNATURES_ENABLED, null, account)) {
		return;
	}
	
	var button = this._getSignatureButton();
	if (button) {
		var visible = ac.getSignatureCollection(account).getSize() > 0;
		button.setVisible(visible);
		button.parent.cleanupSeparators();
	}
	this._setOptionsVisibility();
};

ZmComposeController.prototype._setOptionsVisibility =
function() {

	var button = this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS);
	var menu = button.getMenu(),
		opList = menu && menu.opList,
		optionsEmpty = !opList || opList.length === 0;

	if (opList && opList.length === 1 && opList[0] === ZmOperation.ADD_SIGNATURE) {
		//this is kinda ugly, special case for the signature menu that is empty. It gets hidden instead of removed so it's still here.
		var sigButton = this._getSignatureButton();
		optionsEmpty = !sigButton.getVisible();
	}
	button.setVisible(!optionsEmpty);
};

ZmComposeController.prototype._createOptionsMenu =
function(action) {

	var isReply = ZmComposeController.IS_REPLY[action];
	var isCalReply = ZmComposeController.IS_CAL_REPLY[action];
	var isInviteReply = ZmComposeController.IS_INVITE_REPLY[action];
	var isForward = ZmComposeController.IS_FORWARD[action];
	var list = [];
    var ac = window.parentAppCtxt || window.appCtxt;
	if (isReply || isCalReply) {
		list.push(ZmOperation.REPLY, ZmOperation.REPLY_ALL, ZmOperation.SEP);
	}
	if (ac.get(ZmSetting.HTML_COMPOSE_ENABLED)) {
		list.push(ZmOperation.FORMAT_HTML, ZmOperation.FORMAT_TEXT, ZmOperation.SEP);
	}
	if (isInviteReply) { // Accept/decline/etc... an appointment invitation
		list.push(ZmOperation.SEP, ZmOperation.INC_NONE, ZmOperation.INC_BODY, ZmOperation.INC_SMART);
	}
	else if (isCalReply) { // Regular reply to an appointment
		list.push(ZmOperation.SEP, ZmOperation.INC_NONE, ZmOperation.INC_BODY, ZmOperation.INC_SMART);
	}
	else if (isReply) { // Message reply
        list.push(ZmOperation.SEP, ZmOperation.INC_NONE, ZmOperation.INC_BODY, ZmOperation.INC_SMART, ZmOperation.INC_ATTACHMENT);
	}
	else if (isForward) { // Message forwarding
        list.push(ZmOperation.SEP, ZmOperation.INC_BODY, ZmOperation.INC_ATTACHMENT);
	}

    if (isReply || isForward || isCalReply) {
        list.push(ZmOperation.SEP, ZmOperation.USE_PREFIX, ZmOperation.INCLUDE_HEADERS);
    }

	if (appCtxt.get(ZmSetting.SIGNATURES_ENABLED)) {
		list.push(ZmOperation.SEP, ZmOperation.ADD_SIGNATURE);
	}

	list.push(ZmOperation.SEP, ZmOperation.SHOW_BCC);

	if (appCtxt.get(ZmSetting.MAIL_PRIORITY_ENABLED)) {
		list.push(ZmOperation.SEP);
		list.push(ZmOperation.PRIORITY_HIGH);
		list.push(ZmOperation.PRIORITY_NORMAL);
		list.push(ZmOperation.PRIORITY_LOW);
	}

	if (ac.get(ZmSetting.MAIL_READ_RECEIPT_ENABLED, null, ac.getActiveAccount())) {
		list.push(ZmOperation.SEP, ZmOperation.REQUEST_READ_RECEIPT);
	}

	var button = this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS);

	var overrides = {};
	for (var i = 0; i < list.length; i++) {
		var op = list[i];
		if (op == ZmOperation.SEP) { continue; }
		overrides[op] = {};
		if (ZmComposeController.OP_CHECK[op]) {
			overrides[op].style = DwtMenuItem.CHECK_STYLE;
		} else {
			overrides[op].style = DwtMenuItem.RADIO_STYLE;
			overrides[op].radioGroupId = ZmComposeController.RADIO_GROUP[op];
		}
		if (op == ZmOperation.REPLY || op == ZmOperation.CAL_REPLY) {
			overrides[op].text = ZmMsg.replySender;
		}
	}

	var menu = new ZmActionMenu({parent:button, menuItems:list, overrides:overrides,
								 context:[this._currentViewId, action].join("_")});

	for (var i = 0; i < list.length; i++) {
		var op = list[i];
		var mi = menu.getOp(op);
		if (!mi) { continue; }
		if (op == ZmOperation.FORMAT_HTML) {
			mi.setData(ZmHtmlEditor.VALUE, Dwt.HTML);
		} else if (op == ZmOperation.FORMAT_TEXT) {
			mi.setData(ZmHtmlEditor.VALUE, Dwt.TEXT);
		}
		mi.setData(ZmOperation.KEY_ID, op);
		mi.addSelectionListener(this._listeners[ZmOperation.COMPOSE_OPTIONS]);
	}

	return menu;
};

ZmComposeController.prototype._setOptionsMenu =
function(composeMode, incOptions) {

	composeMode = composeMode || this._composeMode;
	incOptions = incOptions || this._curIncOptions || {};
    var ac = window.parentAppCtxt || window.appCtxt;

	var button = this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS);
	button.noMenuBar = true;
	button.setToolTipContent(ZmMsg[ZmComposeController.OPTIONS_TT[this._action]], true);
	var menu = this._optionsMenu[this._action];
	if (!menu) { return; }

	if (ac.get(ZmSetting.HTML_COMPOSE_ENABLED)) {
		menu.checkItem(ZmHtmlEditor.VALUE, composeMode, true);
	}

	if (ac.get(ZmSetting.MAIL_READ_RECEIPT_ENABLED) || ac.multiAccounts) {
		var mi = menu.getOp(ZmOperation.REQUEST_READ_RECEIPT);
		if (mi) {
			// did this draft have "request read receipt" option set?
			if (this._msg && this._msg.isDraft) {
				mi.setChecked(this._msg.readReceiptRequested);
			} else {
				// bug: 41329 - always re-init read-receipt option to be off
                //read receipt default state will be based on the preference configured
				mi.setChecked(appCtxt.get(ZmSetting.AUTO_READ_RECEIPT_ENABLED), true);
			}

			if (ac.multiAccounts) {
                mi.setEnabled(ac.get(ZmSetting.MAIL_READ_RECEIPT_ENABLED, null, this._composeView.getFromAccount()));
			}
		}
	}

	if (this._action == ZmOperation.REPLY || this._action == ZmOperation.REPLY_ALL  ||
        this._action == ZmOperation.CAL_REPLY || this._action == ZmOperation.CAL_REPLY_ALL) {
		menu.checkItem(ZmOperation.KEY_ID, this._action, true);
	}

	this._setDependentOptions(incOptions);

	var showBcc = appCtxt.get(ZmSetting.SHOW_BCC);
	var mi = menu.getOp(ZmOperation.SHOW_BCC);
	if (mi) {
		mi.setChecked(showBcc);
		this._composeView._recipients._toggleBccField(showBcc);
	}

	button.setMenu(menu);
	this._setOptionsVisibility();
};

ZmComposeController.prototype._setDependentOptions =
function(incOptions) {

	incOptions = incOptions || this._curIncOptions || {};

	var menu = this._optionsMenu[this._action];
	if (!menu) { return; }

	// handle options for what's included
	var what = incOptions.what;
	menu.checkItem(ZmOperation.KEY_ID, ZmComposeController.INC_OP[what], true);
	var allowOptions = (what == ZmSetting.INC_BODY || what == ZmSetting.INC_SMART);
	var mi = menu.getOp(ZmOperation.USE_PREFIX);
	if (mi) {
		mi.setEnabled(allowOptions);
		mi.setChecked(incOptions.prefix, true);
	}
	mi = menu.getOp(ZmOperation.INCLUDE_HEADERS);
	if (mi) {
		mi.setEnabled(allowOptions);
		mi.setChecked(incOptions.headers, true);
	}
	//If we attach multiple messages, disable changing from "include as attachment" to "include original" (inc_body, a.k.a. include inline). Bug 74467
	var incOptionsDisabled = (this._msgIds && this._msgIds.length > 1) || this._origAction === ZmOperation.FORWARD_CONV;
	mi = menu.getOp(ZmOperation.INC_BODY);
	if (mi) {
		mi.setEnabled(!incOptionsDisabled);
	}
	mi = menu.getOp(ZmOperation.INC_ATTACHMENT);
	if (mi) {
		mi.setEnabled(!incOptionsDisabled);
	}
	mi = menu.getOp(ZmOperation.REQUEST_READ_RECEIPT);
	if (mi) {
		var fid = this._msg && this._msg.folderId;
		var ac = window.parentAppCtxt || window.appCtxt;
		var folder = fid ? ac.getById(fid) : null;
		mi.setEnabled(!folder || (folder && !folder.isRemote()));
	}
};

/**
 * Called in multi-account mode, when an account has been changed
 */
ZmComposeController.prototype._resetReadReceipt =
function(newAccount) {
	var menu = this._optionsMenu[this._action];
	var mi = menu && menu.getOp(ZmOperation.REQUEST_READ_RECEIPT);
	if (mi) {
		var isEnabled = appCtxt.get(ZmSetting.MAIL_READ_RECEIPT_ENABLED, null, newAccount);
		if (!isEnabled) {
			mi.setChecked(false, true);
		}
		mi.setEnabled(isEnabled);
	}
};

ZmComposeController.prototype._getComposeMode =
function(msg, identity, params) {

	// depending on COS/user preference set compose format
	var composeMode = Dwt.TEXT;
    var ac = window.parentAppCtxt || window.appCtxt;
	if (ac.get(ZmSetting.HTML_COMPOSE_ENABLED)) {
        if (this._action == ZmOperation.NEW_MESSAGE) {
            if (ac.get(ZmSetting.COMPOSE_AS_FORMAT) == ZmSetting.COMPOSE_HTML) {
                composeMode = Dwt.HTML;
            }
        } 
		else if (this._action == ZmOperation.DRAFT) {
            if (params && params.isEditAsNew) { //For Edit As New option Bug:73479
                if (ac.get(ZmSetting.COMPOSE_AS_FORMAT) === ZmSetting.COMPOSE_HTML) {
                    composeMode = Dwt.HTML;
                }
            }
            else if (msg && msg.isHtmlMail()) {
                composeMode = Dwt.HTML;
            }
		}
		else if (identity) {
			var sameFormat = ac.get(ZmSetting.COMPOSE_SAME_FORMAT);
			var asFormat = ac.get(ZmSetting.COMPOSE_AS_FORMAT);
			if ((!sameFormat && asFormat == ZmSetting.COMPOSE_HTML) ||  (sameFormat && msg && msg.isHtmlMail())) {
				composeMode = Dwt.HTML;
			}
		}
	}

	return composeMode;
};

ZmComposeController.prototype._getBodyContent =
function() {
	return this._composeView.getHtmlEditor().getContent();
};

ZmComposeController.prototype._setFormat =
function(mode) {

	var curMode = this._composeView.getComposeMode();
	if (mode === curMode) { return false; }

	var op = (mode === Dwt.HTML) ? ZmOperation.FORMAT_HTML : ZmOperation.FORMAT_TEXT;
	var okCallback = this._formatOkCallback.bind(this, mode);
	var cancelCallback = this._formatCancelCallback.bind(this, curMode);
	//TODO: There shouldn't be a need to warn the user now that we're preserving quoted text and headers.
	//(see bugs 91743 and 92086
	//However since it's the release time, it's safer to keep warning the user.
	//Revisit this after the release.
	if (!this._warnUserAboutChanges(op, okCallback, cancelCallback)) {
		this._composeView.setComposeMode(mode);
		return true;
	}

	return false;
};

/**
 *
 * @return {Boolean} needToPop - whether we need to pop the view
 */
ZmComposeController.prototype._processSendMsg =
function(draftType, msg, resp) {

	this._msgSent = true;
	var isScheduled = draftType == ZmComposeController.DRAFT_TYPE_DELAYSEND;
	var isDraft = (draftType != ZmComposeController.DRAFT_TYPE_NONE && !isScheduled);
	var needToPop = false;
	if (!isDraft) {
		needToPop = true;
		var popped = false;
		if (appCtxt.get(ZmSetting.SHOW_MAIL_CONFIRM)) {
			var confirmController = AjxDispatcher.run("GetMailConfirmController");
			confirmController.showConfirmation(msg, this._currentViewId, this.tabId, this);
			needToPop = false;	// don't pop confirm page
		} else {
			if (appCtxt.isChildWindow && window.parentController) {
				window.onbeforeunload = null;
				if (draftType == ZmComposeController.DRAFT_TYPE_DELAYSEND) {
                    window.parentController.setStatusMsg(ZmMsg.messageScheduledSent);
                }
                else if (!appCtxt.isOffline) { // see bug #29372
					window.parentController.setStatusMsg(ZmMsg.messageSent);
				}
			} else {
				if (draftType == ZmComposeController.DRAFT_TYPE_DELAYSEND) {
					appCtxt.setStatusMsg(ZmMsg.messageScheduledSent);
				} else if (!appCtxt.isOffline) { // see bug #29372
					appCtxt.setStatusMsg(ZmMsg.messageSent);
				}
			}
		}

		if (resp || !appCtxt.get(ZmSetting.SAVE_TO_SENT)) {

			// bug 36341
			if (!appCtxt.isOffline && resp && appCtxt.get(ZmSetting.SAVE_TO_IMAP_SENT) && msg.identity) {
				var datasources = appCtxt.getDataSourceCollection();
				var datasource = datasources && datasources.getById(msg.identity.id);
				if (datasource && datasource.type == ZmAccount.TYPE_IMAP) {
					var parent = appCtxt.getById(datasource.folderId);
					var folder;
					if (parent) {
						// try to find the sent folder from list of possible choices
						var prefix = parent.getName(false, null, true, true) + "/";
						var folderNames = [
							appCtxt.get(ZmSetting.SENT_FOLDER_NAME) || "Sent",
							ZmMsg.sent, "Sent Messages", "[Gmail]/Sent Mail"
						];
						for (var i = 0; i < folderNames.length; i++) {
							folder = parent.getByPath(prefix+folderNames[i]);
							if (folder) break;
						}
					}
					if (folder) {
						var jsonObj = {
							ItemActionRequest: {
								_jsns:  "urn:zimbraMail",
								action: {
									id:     resp.m[0].id,
									op:     "move",
									l:      folder.id
								}
							}
						};
						var params = {
							jsonObj: jsonObj,
							asyncMode: true,
							noBusyOverlay: true
						};
						appCtxt.getAppController().sendRequest(params);
					}
				}
			}
		}
	} else {
		if (draftType != ZmComposeController.DRAFT_TYPE_AUTO) {
			var transitions = [ ZmToast.FADE_IN, ZmToast.IDLE, ZmToast.PAUSE, ZmToast.FADE_OUT ];
			appCtxt.setStatusMsg(ZmMsg.draftSaved, ZmStatusView.LEVEL_INFO, null, transitions);
		}
		this._draftMsg = msg;
		this._composeView.processMsgDraft(msg);
		// TODO - disable save draft button indicating a draft was saved

		var listController = this._listController; // non child window case
		if (appCtxt.isChildWindow) {
			//Check if Mail App view has been created and then update the MailListController
			if (window.parentAppCtxt.getAppViewMgr().getAppView(ZmApp.MAIL)) {
				listController = window.parentAppCtxt.getApp(ZmApp.MAIL).getMailListController();
			}
		}

		//listController is available only when editing an existing draft.
		if (listController && listController._draftSaved) {
			var savedMsg = appCtxt.isChildWindow ? null : msg;
			var savedResp = appCtxt.isChildWindow ? resp.m[0] : null; //Pass the mail response to the parent window such that the ZmMailMsg obj is created in the parent window.
			listController._draftSaved(savedMsg, savedResp);
		}
	}

	if (isScheduled) {
		if (appCtxt.isChildWindow) {
			var pAppCtxt = window.parentAppCtxt;
			if (pAppCtxt.getAppViewMgr().getAppView(ZmApp.MAIL)) {
				var listController = pAppCtxt.getApp(ZmApp.MAIL).getMailListController();
				if (listController && listController._draftSaved) {
					//Pass the mail response to the parent window such that the ZmMailMsg obj is created in the parent window.
					listController._draftSaved(null, resp.m[0]);
				}
			}
		} else {
			if (this._listController && this._listController._draftSaved) {
				this._listController._draftSaved(msg);
			}
		}
	}
	return needToPop;
};


// Listeners

// Send button was pressed
ZmComposeController.prototype._sendListener =
function(ev) {
	if (!appCtxt.notifyZimlets("onSendButtonClicked", [this, this._msg])) {
	    this._send();
    }
};

ZmComposeController.prototype._send =
function() {
	this._toolbar.enableAll(false); // thwart multiple clicks on Send button
	this._resetDelayTime();
	this.sendMsg();
};

ZmComposeController.prototype._sendLaterListener =
function(ev) {
	this.showDelayDialog();
};

// Cancel button was pressed
ZmComposeController.prototype._cancelListener =
function(ev) {
	this._cancelCompose();
};

ZmComposeController.prototype._cancelCompose = function() {

	var dirty = this._composeView.isDirty(true, true);
    // Prompt the user if compose view is dirty (they may want to save), or if a draft has been
    // auto-saved and they might want to delete it
	var needPrompt = dirty || (this._draftType === ZmComposeController.DRAFT_TYPE_AUTO);
    this._composeView.enableInputs(!needPrompt);
	this._composeView.reEnableDesignMode();
	this._app.popView(!needPrompt);
};

// Attachment button was pressed
ZmComposeController.prototype._attachmentListener =
function(isInline) {
	var type =
		isInline ? ZmComposeView.UPLOAD_INLINE : ZmComposeView.UPLOAD_COMPUTER;
	this._composeView.showAttachmentDialog(type);
};

ZmComposeController.prototype._optionsListener =
function(ev) {

	var op = ev.item.getData(ZmOperation.KEY_ID);
	if (op === ZmOperation.REQUEST_READ_RECEIPT) {
		return;
	}

	// Click on "Options" button.
	if (op === ZmOperation.COMPOSE_OPTIONS && this._optionsMenu[this._action]) {
		var button = this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS);
		var bounds = button.getBounds();
		this._optionsMenu[this._action].popup(0, bounds.x, bounds.y + bounds.height, false);
		return;
	}

	// ignore UNCHECKED for radio buttons
	if (ev.detail !== DwtMenuItem.CHECKED && !ZmComposeController.OP_CHECK[op]) {
		return;
	}

	if (op === ZmOperation.REPLY || op === ZmOperation.REPLY_ALL || op === ZmOperation.CAL_REPLY || op === ZmOperation.CAL_REPLY_ALL) {
		var cv = this._composeView;
		cv.setAddress(AjxEmailAddress.TO, "");
		cv.setAddress(AjxEmailAddress.CC, "");
		cv._setAddresses(op, AjxEmailAddress.TO, this._toOverride);
		if (this._ccOverride && (op === ZmOperation.REPLY_ALL || op === ZmOperation.CAL_REPLY_ALL)) {
			cv._setAddresses(op, AjxEmailAddress.CC, this._ccOverride);
		}
	}
	else if (op === ZmOperation.FORMAT_HTML || op === ZmOperation.FORMAT_TEXT) {
        if (op === ZmOperation.FORMAT_TEXT && this._msg) {
            this._msg._resetAllInlineAttachments();
        }
		this._setFormat(ev.item.getData(ZmHtmlEditor.VALUE));
	}
	else if (op === ZmOperation.SHOW_BCC) {
		this._composeView._recipients._toggleBccField();
		appCtxt.set(ZmSetting.SHOW_BCC, !appCtxt.get(ZmSetting.SHOW_BCC));
	}
	else if (ZmComposeController.INC_MAP[op] || op === ZmOperation.USE_PREFIX || op === ZmOperation.INCLUDE_HEADERS) {
		// user is changing include options
		if (this._setInclude(op)) {
			this._switchInclude(op);
			this._setDependentOptions();
		}
	}
};

ZmComposeController.prototype._setInclude =
function(op) {

	// Only give warning if user has typed text that can't be preserved
	var okCallback = this._switchIncludeOkCallback.bind(this, op);
	var cancelCallback = this._switchIncludeCancelCallback.bind(this, AjxUtil.hashCopy(this._curIncOptions));
	return (!this._warnUserAboutChanges(op, okCallback, cancelCallback));
};

/**
 * Returns the priority flag corresponding to the currently selected priority option.
 *
 * @returns {string}
 * @private
 */
ZmComposeController.prototype._getPriority = function() {

	var menu = this._optionsMenu[this._action],
		map = ZmComposeController.PRIORITY_FLAG_TO_OP;

	for (var flag in map) {
		var op = map[flag],
			mi = menu && menu.getOp(op);
		if (mi && mi.getChecked()) {
			return flag;
		}
	}

	return "";
};

/**
 * Sets the priority option in the options menu that corresponds to the given priority flag.
 *
 * @param {String}  priority        ZmItem.FLAG_*_PRIORITY
 * @private
 */
ZmComposeController.prototype._setPriority = function(priority) {

	var op = priority ? ZmComposeController.PRIORITY_FLAG_TO_OP[priority] : ZmOperation.PRIORITY_NORMAL,
		menu = this._optionsMenu[this._action],
		mi = menu && menu.getOp(op);

	if (mi) {
		mi.setChecked(true, true);
	}
};

ZmComposeController.prototype._switchInclude = function(op) {

	var menu = this._optionsMenu[this._action],
        cv = this._composeView;

	if (op === ZmOperation.USE_PREFIX || op === ZmOperation.INCLUDE_HEADERS) {
		var mi = menu.getOp(op);
		if (mi) {
			if (op === ZmOperation.USE_PREFIX) {
				this._curIncOptions.prefix = mi.getChecked();
			}
            else {
				this._curIncOptions.headers = mi.getChecked();
			}
		}
	}
    else if (ZmComposeController.INC_MAP[op]) {
        if (this._curIncOptions.what === ZmSetting.INC_ATTACH) {
            cv.removeOrigMsgAtt();
        }
		this._curIncOptions.what = ZmComposeController.INC_MAP[op];
	}

	var cv = this._composeView;
	if (op != ZmOperation.FORMAT_HTML && op != ZmOperation.FORMAT_TEXT) {
		if (cv._composeMode == Dwt.TEXT) {
			AjxTimedAction.scheduleAction(new AjxTimedAction(this, function() { cv.getHtmlEditor().moveCaretToTop(); }), 200);
		}
	}    

	// forwarding actions are tied to inc option
	var what = this._curIncOptions.what;
	if (this._action == ZmOperation.FORWARD_INLINE && what == ZmSetting.INC_ATTACH) {
		this._action = ZmOperation.FORWARD_ATT;
	}
	if (this._action == ZmOperation.FORWARD_ATT && what != ZmSetting.INC_ATTACH) {
		this._action = ZmOperation.FORWARD_INLINE;
	}

	var params = {
		action:			    this._action,
		msg:			    this._msg,
		extraBodyText:	    this._composeView.getUserText(),
		op:				    op,
        keepAttachments:    true
	};
	this._composeView.resetBody(params);
	if (op === ZmOperation.INC_ATTACHMENT) {
		this.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO);
	}
};

ZmComposeController.prototype._detachListener =
function(ev) {
	if (!appCtxt.isWebClientOffline()) {
		var atts = this._composeView.getAttFieldValues();
		if (atts.length) {
			this._showMsgDialog(ZmComposeController.MSG_DIALOG_2, ZmMsg.importErrorUpload, null, this._detachCallback.bind(this));
		} else {
			this.detach();
		}
	}
};

// Save Draft button was pressed
ZmComposeController.prototype._saveDraftListener =
function(ev) {
	this.saveDraft();
};

ZmComposeController.prototype._autoSaveCallback =
function(idle) {
    DBG.println('draft', 'DRAFT autosave check from ' + this._currentViewId);
    if (idle && !DwtBaseDialog.getActiveDialog() && !this._composeView.getHtmlEditor().isSpellCheckMode() && this._composeView.isDirty(true, true)) {
		this.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO);
	}
};

ZmComposeController.prototype.saveDraft =
function(draftType, attId, docIds, callback, contactId) {

	if (!this._canSaveDraft()) { return; }

	this._wasDirty = this._composeView._isDirty;
	this._composeView._isDirty = false;
	draftType = draftType || ZmComposeController.DRAFT_TYPE_MANUAL;
	var respCallback = this._handleResponseSaveDraftListener.bind(this, draftType, callback);
	this._resetDelayTime();
	if (!docIds) {
        DBG.println('draft', 'SAVE DRAFT for ' + this.getCurrentViewId() + ', type is ' + draftType);
		this.sendMsg(attId, draftType, respCallback, contactId);
	} else {
		this.sendDocs(docIds, draftType, respCallback, contactId);
	}
};

ZmComposeController.prototype._handleResponseSaveDraftListener =
function(draftType, callback, result) {
	if (draftType == ZmComposeController.DRAFT_TYPE_AUTO &&
		this._draftType == ZmComposeController.DRAFT_TYPE_NONE) {
		this._draftType = ZmComposeController.DRAFT_TYPE_AUTO;
	} else if (draftType == ZmComposeController.DRAFT_TYPE_MANUAL) {
		this._draftType = ZmComposeController.DRAFT_TYPE_MANUAL;
	}
//	this._action = ZmOperation.DRAFT;
    // Notify the htmlEditor that the draft has been saved and is not dirty any more.
    this._composeView._htmlEditor.clearDirty();
	if (draftType === ZmComposeController.DRAFT_TYPE_MANUAL) {
		this._setCancelText(ZmMsg.close)
	}

	if (callback) {
		callback.run(result);
	}
};

ZmComposeController.prototype._spellCheckListener = function(ev) {

	var spellCheckButton = this._toolbar.getButton(ZmOperation.SPELL_CHECK);
	var htmlEditor = this._composeView.getHtmlEditor();

    if (spellCheckButton) {
        if (spellCheckButton.isToggled()) {
            var callback = this.toggleSpellCheckButton.bind(this);
            if (!htmlEditor.spellCheck(callback)) {
                this.toggleSpellCheckButton(false);
            }
        } else {
            htmlEditor.discardMisspelledWords();
        }
    }
};

ZmComposeController.prototype.showDelayDialog =
function() {
	if (!this._delayDialog) {
		this._delayDialog = new ZmTimeDialog({parent:this._shell, buttons:[DwtDialog.OK_BUTTON, DwtDialog.CANCEL_BUTTON]});
		this._delayDialog.setButtonListener(DwtDialog.OK_BUTTON, this._handleDelayDialog.bind(this));
	}
	this._delayDialog.popup();
};

ZmComposeController.prototype._handleDelayDialog =
function() {
	this._delayDialog.popdown();
	var time = this._delayDialog.getValue(); //Returns {date: Date, timezone: String (see AjxTimezone)}

	var date = time.date;
	var dateOffset = AjxTimezone.getOffset(AjxTimezone.getClientId(time.timezone), date);
	var utcDate = new Date(date.getTime() - dateOffset*60*1000);

	var now = new Date();
	var nowOffset = AjxTimezone.getOffset(AjxTimezone.DEFAULT_RULE, now);
	var utcNow = new Date(now.getTime() - nowOffset*60*1000);

    if(!this._delayDialog.isValidDateStr()){
        this.showInvalidDateDialog();
    }
	else if (utcDate < utcNow) {
		this.showDelayPastDialog();
	} else {
		this._toolbar.enableAll(false); // thwart multiple clicks on Send button
		this._sendTime = time;
		this.sendMsg(null, ZmComposeController.DRAFT_TYPE_DELAYSEND, null);
	}
};

ZmComposeController.prototype.showDelayPastDialog =
function() {
	this._showMsgDialog(ZmComposeController.MSG_DIALOG_2, ZmMsg.sendLaterPastError, null, this._handleDelayPastDialog.bind(this));
};

ZmComposeController.prototype.showInvalidDateDialog =
function() {
	this._showMsgDialog(ZmComposeController.MSG_DIALOG_1, ZmMsg.invalidDateFormat, DwtMessageDialog.CRITICAL_STYLE, this._handleInvalidDateDialog.bind(this));
};

ZmComposeController.prototype._handleInvalidDateDialog =
function() {
	this._currentDlg.popdown();
    this._sendLaterListener();
}

ZmComposeController.prototype._handleDelayPastDialog =
function() {
	this._currentDlg.popdown();
	this._send();
};

ZmComposeController.prototype._resetDelayTime =
function() {
	this._sendTime = null;
};

// Callbacks

ZmComposeController.prototype._detachCallback =
function() {
	// get rid of any lingering attachments since they cannot be detached
	this._composeView.cleanupAttachments();
	this._currentDlg.popdown();
	this.detach();
};

ZmComposeController.prototype._formatOkCallback =
function(mode) {
	this._currentDlg.popdown();
	this._composeView.setComposeMode(mode);
	this._composeView._isDirty = true;
};

ZmComposeController.prototype._formatCancelCallback =
function(mode) {
	this._currentDlg.popdown();

	// reset the radio button for the format button menu
	var menu = this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS).getMenu();
	menu.checkItem(ZmHtmlEditor.VALUE, mode, true);

	this._composeView.reEnableDesignMode();
};

/**
 * Called as: Yes, save as draft
 * 			  Yes, go ahead and leave compose
 * 			  Yes, keep the auto-saved draft (view is dirty, new draft will be saved)
 *
 * @param mailtoParams		[Object]*	Used by offline client to pass on mailto handler params
 */
ZmComposeController.prototype._popShieldYesCallback = function(mailtoParams) {

	this._popShield.removePopdownListener(this._dialogPopdownListener);
	this._popShield.popdown();
	this._composeView.enableInputs(true);
	if (this._canSaveDraft()) {
		// save as draft
		var callback = mailtoParams ? this.doAction.bind(this, mailtoParams) : this._popShieldYesDraftSaved.bind(this);
		this._resetDelayTime();
		this.sendMsg(null, ZmComposeController.DRAFT_TYPE_MANUAL, callback);
	}
    else {
		// cancel
		if (appCtxt.isChildWindow && window.parentController) {
			window.onbeforeunload = null;
		}
		if (mailtoParams) {
			this.doAction(mailtoParams);
		}
        else {
            this._dontSavePreHide = true;
			appCtxt.getAppViewMgr().showPendingView(true);
		}
	}
};

ZmComposeController.prototype._popShieldYesDraftSaved =
function() {
	appCtxt.getAppViewMgr().showPendingView(true);
};

/**
 * Called as: No, don't save as draft
 * 			  No, don't leave compose
 * 			  Yes, keep the auto-saved draft (view is not dirty, no need to save again)
 *
 * @param mailtoParams		[Object]*	Used by offline client to pass on mailto handler params
 */
ZmComposeController.prototype._popShieldNoCallback = function(mailtoParams) {

	this._popShield.removePopdownListener(this._dialogPopdownListener);
	this._popShield.popdown();
	this._composeView.enableInputs(true);
    this._dontSavePreHide = true;

	if (this._canSaveDraft()) {
		if (appCtxt.isChildWindow && window.parentController) {
			window.onbeforeunload = null;
		}
		if (!mailtoParams) {
			appCtxt.getAppViewMgr().showPendingView(true);
		}
	}
    else {
		if (!mailtoParams) {
			appCtxt.getAppViewMgr().showPendingView(false);
		}
		this._composeView.reEnableDesignMode();
	}

	if (mailtoParams) {
		this.doAction(mailtoParams);
	}
};

// Called as: No, do not keep the auto-saved draft
ZmComposeController.prototype._popShieldDiscardCallback =
function() {
	this._deleteDraft(this._draftMsg);
	this._popShieldNoCallback();
};

// Called as: I changed my mind, just make the pop shield go away
ZmComposeController.prototype._popShieldDismissCallback =
function() {
	this._popShield.removePopdownListener(this._dialogPopdownListener);
	this._popShield.popdown();
	this._cancelViewPop();
	this._initAutoSave(); //re-init autosave since it was killed in preHide
	
};

ZmComposeController.prototype._switchIncludeOkCallback =
function(op) {
	this._currentDlg.popdown();
	this._switchInclude(op);
	this._setDependentOptions();
};

ZmComposeController.prototype._switchIncludeCancelCallback =
function(origIncOptions) {
	this._currentDlg.popdown();
	this._setOptionsMenu(null, origIncOptions);
};

/**
 * Handles re-enabling inputs if the pop shield is dismissed via
 * Esc. Otherwise, the handling is done explicitly by a callback.
 */
ZmComposeController.prototype._dialogPopdownActionListener =
function() {
	this._cancelViewPop();
};

ZmComposeController.prototype._cancelViewPop =
function() {
	this._composeView.enableInputs(true);
	appCtxt.getAppViewMgr().showPendingView(false);
	this._composeView.reEnableDesignMode();
};

ZmComposeController.prototype._getDefaultFocusItem =
function() {
	if (this._action == ZmOperation.NEW_MESSAGE ||
		this._action == ZmOperation.FORWARD_INLINE ||
		this._action == ZmOperation.FORWARD_ATT)
	{
		return this._composeView.getAddrInputField(AjxEmailAddress.TO);
	}

	return (this._composeView.getComposeMode() == Dwt.TEXT)
		? this._composeView._bodyField
		: this._composeView._htmlEditor;
};

ZmComposeController.prototype._createSignatureMenu =
function(button, account) {
	if (!this._composeView) { return null; }

	var button = this._getSignatureButton();
	if (!button) { return null; }

	var menu;
	var options = appCtxt.getSignatureCollection(account).getSignatureOptions();
	if (options.length > 0) {
		menu = new DwtMenu({parent:button});
		var listener = this._handleSelectSignature.bind(this);
		var radioId = this._composeView._htmlElId + "_sig";
		for (var i = 0; i < options.length; i++) {
			var option = options[i];
			var menuitem = new DwtMenuItem({parent:menu, style:DwtMenuItem.RADIO_STYLE, radioGroupId:radioId});
			menuitem.setText(AjxStringUtil.htmlEncode(option.displayValue));
			menuitem.setData(ZmComposeController.SIGNATURE_KEY, option.value);
			menuitem.addSelectionListener(listener);
			menu.checkItem(ZmComposeController.SIGNATURE_KEY, option.value, option.selected);
		}
	}
	return menu;
};

ZmComposeController.prototype._signatureChangeListener =
function(ev) {
	this.resetSignatureToolbar(this.getSelectedSignature());
};

/**
 * Resets the signature dropdown based on the given account and selects the
 * given signature if provided.
 *
 * @param selected	[String]*			ID of the signature to select
 * @param account	[ZmZimbraAccount]*	account for which to load signatures
 */
ZmComposeController.prototype.resetSignatureToolbar =
function(selected, account) {
	var button = this._getSignatureButton();
	if (!button) {
		return;
	}
	var previousMenu = button.getMenu();
	previousMenu &&	previousMenu.dispose();

	var menu = this._createSignatureMenu(null, account);
	if (menu) {
		button.setMenu(menu);
		this.setSelectedSignature(selected || "");
	}

	this._setAddSignatureVisibility(account);
};

ZmComposeController.prototype.resetToolbarOperations =
function() {
	if (this.isHidden) { return; }
	this._toolbar.enableAll(true);
	if (ZmComposeController.IS_INVITE_REPLY[this._action]) {
		var ops = [ ZmOperation.SAVE_DRAFT, ZmOperation.ATTACHMENT ];
		this._toolbar.enable(ops, false);
        this._composeView.enableAttachButton(false);
	} else {
        this._composeView.enableAttachButton(true);
    }

	this._setCancelText(this._action === ZmId.OP_DRAFT ? ZmMsg.close : ZmMsg.cancel);

	appCtxt.notifyZimlets("resetToolbarOperations", [this._toolbar, 1]);
};

ZmComposeController.prototype._setCancelText =
function(text) {
	var cancel = this._toolbar.getButton(ZmOperation.CANCEL);
	cancel.setText(text);
};

ZmComposeController.prototype._canSaveDraft =
function() {
	return !this.isHidden && appCtxt.get(ZmSetting.SAVE_DRAFT_ENABLED) && !ZmComposeController.IS_INVITE_REPLY[this._action];
};

/*
 * Return true/false if read receipt is being requested
 */
ZmComposeController.prototype.isRequestReadReceipt =
function(){

  	// check for read receipt
	var requestReadReceipt = false;
    var isEnabled = this.isReadReceiptEnabled();
	if (isEnabled) {
		var menu = this._toolbar.getButton(ZmOperation.COMPOSE_OPTIONS).getMenu();
		if (menu) {
			var mi = menu.getItemById(ZmOperation.KEY_ID, ZmOperation.REQUEST_READ_RECEIPT);
			requestReadReceipt = (!!(mi && mi.getChecked()));
		}
	}

    return requestReadReceipt;
};

/*
 * Return true/false if read receipt is enabled
 */
ZmComposeController.prototype.isReadReceiptEnabled =
function(){
    var acctName = appCtxt.multiAccounts
		? this._composeView.getFromAccount().name : this._accountName;
    var acct = acctName && appCtxt.accountList.getAccountByName(acctName);
    if (appCtxt.get(ZmSetting.MAIL_READ_RECEIPT_ENABLED, null, acct)){
        return true;
    }

    return false;
};

/**
 * Return ZmMailMsg object
 * @return {ZmMailMsg} message object
 */
ZmComposeController.prototype.getMsg =
function(){
    return this._msg;
};

ZmComposeController.prototype._processImages =
function(callback){

    var idoc = this._composeView._getIframeDoc();//editor iframe document
    if (!idoc) {
        return;
    }

    var imgArray = idoc.getElementsByTagName("img"),
        length = imgArray.length;
    if (length === 0) {//No image elements in the editor document
        return;
    }

    var isWebkitFakeURLImage = false;
    for (var i = 0; i < length; i++) {
        var img = imgArray[i],
            imgSrc = img.src;

        if (imgSrc && imgSrc.indexOf("webkit-fake-url://") === 0) {
            img.parentNode.removeChild(img);
            length--;
            i--;
            isWebkitFakeURLImage = true;
        }
    }

    if (isWebkitFakeURLImage) {
        appCtxt.setStatusMsg(ZmMsg.invalidPastedImages);
        if (length === 0) {//No image elements in the editor document
            return;
        }
    }

    return this._processDataURIImages(imgArray, length, callback);
};

ZmComposeController.prototype._processDataURIImages =
function (imgArray, length, callback) {

    if ( !(typeof window.atob === "function" && typeof window.Blob === "function") || appCtxt.isWebClientOffline()) {
        return;
    }

    for (var i = 0, blobArray = []; i < length; i++) {
        var img = imgArray[i];
        if (img) {
            var imgSrc = img.src;
            if (imgSrc && imgSrc.indexOf("data:") !== -1) {
                var blob = AjxUtil.dataURItoBlob(imgSrc);
                if (blob) {
                    //setting data-zim-uri attribute for image replacement in callback
                    var id = Dwt.getNextId();
                    img.setAttribute("id", id);
                    img.setAttribute("data-zim-uri", id);
                    blob.id = id;
                    blobArray.push(blob);
                }
            }
        }
    }

    length = blobArray.length;
    if (length === 0) {
        return;
    }

    this._uploadedImageArray = [];
    this._dataURIImagesLength = length;

    for (i = 0; i < length; i++) {
        var blob = blobArray[i];
        var uploadImageCallback = this._handleUploadImage.bind(this, callback, blob.id);
        this._uploadImage(blob, uploadImageCallback);
    }
    return true;
};

ZmComposeController.prototype._initUploadMyComputerFile =
function(files) {
    if (appCtxt.isWebClientOffline()) {
        return this._handleOfflineUpload(files);
    } else {
        var curView = this._composeView;
        if (curView) {
            var params = {
				attachment:            true,
                files:                 files,
                notes:                 "",
                allResponses:          null,
                start:                 0,
                curView:               this._composeView,
                preAllCallback:        this._preUploadAll.bind(this),
                initOneUploadCallback: curView._startUploadAttachment.bind(curView),
                errorCallback:         curView._resetUpload.bind(curView, true),
                completeOneCallback:   curView.updateAttachFileNode.bind(curView),
                completeAllCallback:   this._completeAllUpload.bind(this)
            }
			params.progressCallback =  curView._uploadFileProgress.bind(curView, params);


			// Do a SaveDraft at the start, since we will suppress autosave during the upload
            var uploadManager = appCtxt.getZmUploadManager();
            var uploadCallback = uploadManager.upload.bind(uploadManager, params);
            this.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO, null, null, uploadCallback);
        }
    }
};

ZmComposeController.prototype._preUploadAll =
function(fileName) {
    var curView = this._composeView;
    if (!curView) {
        return;
    }
    curView._initProgressSpan(fileName);
    // Disable autosave while uploading
    if (this._autoSaveTimer) {
        this._autoSaveTimer.kill();
    }
};

ZmComposeController.prototype._completeAllUpload =
function(allResponses) {
    var curView = this._composeView;
    if (!curView){
        return;
    }
    var callback = curView._resetUpload.bind(curView);
    // Init autosave, otherwise saveDraft thinks this is a suppressed autosave, and aborts w/o saving
    this._initAutoSave();
    this.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO, this._syncPrevData(allResponses), null, callback);
}

ZmComposeController.prototype._syncPrevData =
function(attaData){
    var result = []
    for (var i=0;i < attaData.length  ; i++){
        if (attaData[i] && (i === attaData.length -1 || document.getElementById(attaData[i].aid))){
            result.push(attaData[i]);
        }
    }

    return result;
};

ZmComposeController.prototype._uploadImage = function(blob, callback, errorCallback){
    var req = new XMLHttpRequest();
    req.open("POST", appCtxt.get(ZmSetting.CSFE_ATTACHMENT_UPLOAD_URI)+"?fmt=extended,raw", true);
    req.setRequestHeader("Cache-Control", "no-cache");
    req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    req.setRequestHeader("Content-Type", blob.type);
    req.setRequestHeader("Content-Disposition", 'attachment; filename="' + AjxUtil.convertToEntities(blob.name) + '"');
    if (window.csrfToken) {
        req.setRequestHeader("X-Zimbra-Csrf-Token", window.csrfToken);
    }
    req.onreadystatechange = function() {
        if (req.readyState === 4) {
            if (req.status === 200) {
                var resp = eval("["+req.responseText+"]");
                callback.run(resp[2]);
            }
            else {
                errorCallback && errorCallback();
            }
        }
    };
    req.send(blob);
};

ZmComposeController.prototype._handleUploadImage = function(callback, id, response){
    this._dataURIImagesLength--;
    var uploadedImageArray = this._uploadedImageArray;
    if( response && id ){
        response[0]["id"] = id;
        uploadedImageArray.push(response[0]);
    }
    if( this._dataURIImagesLength === 0 && callback ){
        if( uploadedImageArray.length > 0 && callback.args ){
            uploadedImageArray.clipboardPaste = true;
            if(callback.args[0]){  //attid argument of _sendMsg method
                callback.args[0] = callback.args[0].concat(uploadedImageArray);
            }
            else{
                callback.args[0] = uploadedImageArray;
            }
        }
        callback.run();
        delete this._uploadedImageArray;
        delete this._dataURIImagesLength;
    }
};

ZmComposeController.prototype._warnUserAboutChanges =
function(op, okCallback, cancelCallback) {

	var cv = this._composeView;
	var switchToText = (op === ZmOperation.FORMAT_TEXT &&
	                    !AjxUtil.isEmpty(this._getBodyContent()));
	var willLoseChanges = cv.componentContentChanged(ZmComposeView.BC_SIG_PRE) ||
						  cv.componentContentChanged(ZmComposeView.BC_DIVIDER) ||
						  cv.componentContentChanged(ZmComposeView.BC_HEADERS) ||
						  cv.componentContentChanged(ZmComposeView.BC_SIG_POST) ||
						  !cv.canPreserveQuotedText(op) ||
						  switchToText;
	if (willLoseChanges) {
		var callbacks = {};
		callbacks[DwtDialog.OK_BUTTON] = okCallback;
		callbacks[DwtDialog.CANCEL_BUTTON] = cancelCallback;
		var msg = (willLoseChanges && switchToText) ? ZmMsg.switchIncludeAndFormat : 
				willLoseChanges ? ZmMsg.switchIncludeWarning : ZmMsg.switchToText;
		this._showMsgDialog(ZmComposeController.MSG_DIALOG_2, msg, null, callbacks);
		return true;
	}

	return false;
};

ZmComposeController.prototype._showMsgDialog =
function(dlgType, msg, style, callbacks) {

	var ac = window.appCtxt;
	var dlg = this._currentDlg = (dlgType === ZmComposeController.MSG_DIALOG_1) ? ac.getMsgDialog() :
								 (dlgType === ZmComposeController.MSG_DIALOG_2) ? ac.getOkCancelMsgDialog() : ac.getYesNoCancelMsgDialog();
	dlg.reset();
	if (msg) {
		dlg.setMessage(msg, style || DwtMessageDialog.WARNING_STYLE);
	}
	if (callbacks) {
		if (typeof callbacks === "function") {
			var cb = {};
			cb[DwtDialog.OK_BUTTON] = callbacks;
			callbacks = cb;
		}
		for (var buttonId in callbacks) {
			dlg.registerCallback(buttonId, callbacks[buttonId]);
		}
	}
	dlg.popup();
};

ZmComposeController.prototype._handleOfflineUpload =
function(files) {
    var callback = this._readFilesAsDataURLCallback.bind(this);
    ZmComposeController.readFilesAsDataURL(files, callback);
};

/**
 * Read files in DataURL Format and execute the callback with param dataURLArray.
 *
 * dataURLArray is an array of objects, with each object containing name, type, size and data in data-url format for an file.
 *
 * @param {FileList} files                  Object containing one or more files
 * @param {AjxCallback/Bound} callback	    the success callback
 * @param {AjxCallback/Bound} errorCallback the error callback
 *
 * @public
 */
ZmComposeController.readFilesAsDataURL =
function(files, callback, errorCallback) {
    var i = 0,
        filesLength = files.length,
        dataURLArray = [],
        fileReadErrorCount = 0;

    if (!window.FileReader || filesLength === 0) {
        if (errorCallback) {
            errorCallback.run(dataURLArray, fileReadErrorCount);
        }
        return;
    }

    for (; i < filesLength; i++) {

        var file = files[i],
            reader = new FileReader();

        reader.onload = function(file, ev) {
            dataURLArray.push(
                {
                    filename : file.name,
                    ct : file.type,
                    s : file.size,
                    data : ev.target.result,
                    aid : new Date().getTime().toString(),
                    isOfflineUploaded : true
                }
            );
        }.bind(null, file);

        reader.onerror = function() {
            fileReadErrorCount++;
        };

        //Called when the read is completed, whether successful or not. This is called after either onload or onerror.
        reader.onloadend = function() {
            if ((dataURLArray.length + fileReadErrorCount) === filesLength) {
                if (fileReadErrorCount > 0 && errorCallback) {
                    errorCallback.run(dataURLArray, fileReadErrorCount);
                }
                if (callback) {
                    callback.run(dataURLArray, fileReadErrorCount);
                }
            }
        };

        reader.readAsDataURL(file);
    }
};

ZmComposeController.prototype._readFilesAsDataURLCallback =
function(filesArray) {
    for (var j = 0; j < filesArray.length; j++) {
        var file = filesArray[j];
        if (file) {
            appCtxt.cacheSet(file.aid, file);
        }
    }
    var curView = this._composeView,
        callback = curView._resetUpload.bind(curView);
    this.saveDraft(ZmComposeController.DRAFT_TYPE_AUTO, filesArray, null, callback);
};
}
if (AjxPackage.define("zimbraMail.mail.controller.ZmMailListController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a new, empty mail list controller.
 * @constructor
 * @class
 * This class encapsulates controller behavior that is common to lists of mail items.
 * Operations such as replying and marking read/unread are supported.
 *
 * @author Conrad Damon
 *
 * @param {DwtControl}					container					the containing shell
 * @param {ZmApp}						mailApp						the containing application
 * @param {constant}					type						type of controller
 * @param {string}						sessionId					the session id
 * @param {ZmSearchResultsController}	searchResultsController		containing controller
 * 
 * @extends		ZmListController
 */
ZmMailListController = function(container, mailApp, type, sessionId, searchResultsController) {

	if (arguments.length == 0) { return; }
	ZmListController.apply(this, arguments);

	this._setStatics();

	this._listeners[ZmOperation.SHOW_ORIG] = this._showOrigListener.bind(this);

	this._listeners[ZmOperation.MARK_READ] = this._markReadListener.bind(this);
	this._listeners[ZmOperation.MARK_UNREAD] = this._markUnreadListener.bind(this);
	this._listeners[ZmOperation.FLAG] = this._flagListener.bind(this, true);
	this._listeners[ZmOperation.UNFLAG] = this._flagListener.bind(this, false);
	//fixed bug:15460 removed reply and forward menu.
	if (appCtxt.get(ZmSetting.REPLY_MENU_ENABLED)) {
		this._listeners[ZmOperation.REPLY] = this._replyListener.bind(this);
		this._listeners[ZmOperation.REPLY_ALL] = this._replyListener.bind(this);
	}

	if (appCtxt.get(ZmSetting.FORWARD_MENU_ENABLED)) {
		this._listeners[ZmOperation.FORWARD] = this._forwardListener.bind(this);
		this._listeners[ZmOperation.FORWARD_CONV] = this._forwardConvListener.bind(this);
	}
	this._listeners[ZmOperation.REDIRECT] = new AjxListener(this, this._redirectListener);
	this._listeners[ZmOperation.EDIT] = this._editListener.bind(this, false);
	this._listeners[ZmOperation.EDIT_AS_NEW] = this._editListener.bind(this, true);
	this._listeners[ZmOperation.MUTE_CONV] = this._muteConvListener.bind(this);
	this._listeners[ZmOperation.UNMUTE_CONV] = this._unmuteConvListener.bind(this);

	if (appCtxt.get(ZmSetting.SPAM_ENABLED)) {
		this._listeners[ZmOperation.SPAM] = this._spamListener.bind(this);
	}

	this._listeners[ZmOperation.DETACH] = this._detachListener.bind(this);
	this._inviteReplyListener = this._inviteReplyHandler.bind(this);
	this._shareListener = this._shareHandler.bind(this);
	this._subscribeListener = this._subscribeHandler.bind(this);

	this._acceptShareListener = this._acceptShareHandler.bind(this);
	this._declineShareListener = this._declineShareHandler.bind(this);

	this._listeners[ZmOperation.ADD_FILTER_RULE]	= this._filterListener.bind(this, false, null);
	this._listeners[ZmOperation.CREATE_APPT]		= this._createApptListener.bind(this);
	this._listeners[ZmOperation.CREATE_TASK]		= this._createTaskListener.bind(this);

};

ZmMailListController.prototype = new ZmListController;
ZmMailListController.prototype.constructor = ZmMailListController;

ZmMailListController.prototype.isZmMailListController = true;
ZmMailListController.prototype.toString = function() { return "ZmMailListController"; };

ZmMailListController.GROUP_BY_ITEM		= {};	// item type to search for
ZmMailListController.GROUP_BY_SETTING	= {};	// associated setting on server

// Stuff for the View menu
ZmMailListController.GROUP_BY_ICON		= {};
ZmMailListController.GROUP_BY_MSG_KEY	= {};
ZmMailListController.GROUP_BY_SHORTCUT	= {};
ZmMailListController.GROUP_BY_VIEWS		= [];

// reading pane options
ZmMailListController.READING_PANE_TEXT = {};
ZmMailListController.READING_PANE_TEXT[ZmSetting.RP_OFF]	= ZmMsg.readingPaneOff;
ZmMailListController.READING_PANE_TEXT[ZmSetting.RP_BOTTOM]	= ZmMsg.readingPaneAtBottom;
ZmMailListController.READING_PANE_TEXT[ZmSetting.RP_RIGHT]	= ZmMsg.readingPaneOnRight;

ZmMailListController.READING_PANE_ICON = {};
ZmMailListController.READING_PANE_ICON[ZmSetting.RP_OFF]	= "SplitPaneOff";
ZmMailListController.READING_PANE_ICON[ZmSetting.RP_BOTTOM]	= "SplitPane";
ZmMailListController.READING_PANE_ICON[ZmSetting.RP_RIGHT]	= "SplitPaneVertical";

// conv order options
ZmMailListController.CONV_ORDER_DESC	= ZmSearch.DATE_DESC;
ZmMailListController.CONV_ORDER_ASC		= ZmSearch.DATE_ASC;

ZmMailListController.CONV_ORDER_TEXT = {};
ZmMailListController.CONV_ORDER_TEXT[ZmMailListController.CONV_ORDER_DESC]	= ZmMsg.convOrderDescending;
ZmMailListController.CONV_ORDER_TEXT[ZmMailListController.CONV_ORDER_ASC]	= ZmMsg.convOrderAscending;

// convert key mapping to folder to search
ZmMailListController.ACTION_CODE_TO_FOLDER = {};
ZmMailListController.ACTION_CODE_TO_FOLDER[ZmKeyMap.GOTO_INBOX]		= ZmFolder.ID_INBOX;
ZmMailListController.ACTION_CODE_TO_FOLDER[ZmKeyMap.GOTO_DRAFTS]	= ZmFolder.ID_DRAFTS;
ZmMailListController.ACTION_CODE_TO_FOLDER[ZmKeyMap.GOTO_JUNK]		= ZmFolder.ID_SPAM;
ZmMailListController.ACTION_CODE_TO_FOLDER[ZmKeyMap.GOTO_SENT]		= ZmFolder.ID_SENT;
ZmMailListController.ACTION_CODE_TO_FOLDER[ZmKeyMap.GOTO_TRASH]		= ZmFolder.ID_TRASH;

// convert key mapping to folder to move to
ZmMailListController.ACTION_CODE_TO_FOLDER_MOVE = {};
ZmMailListController.ACTION_CODE_TO_FOLDER_MOVE[ZmKeyMap.MOVE_TO_INBOX]	= ZmFolder.ID_INBOX;
ZmMailListController.ACTION_CODE_TO_FOLDER_MOVE[ZmKeyMap.MOVE_TO_TRASH]	= ZmFolder.ID_TRASH;
ZmMailListController.ACTION_CODE_TO_FOLDER_MOVE[ZmKeyMap.MOVE_TO_JUNK]	= ZmFolder.ID_SPAM;

// convert key mapping to view menu item
ZmMailListController.ACTION_CODE_TO_MENU_ID = {};
ZmMailListController.ACTION_CODE_TO_MENU_ID[ZmKeyMap.READING_PANE_OFF]		= ZmSetting.RP_OFF;
ZmMailListController.ACTION_CODE_TO_MENU_ID[ZmKeyMap.READING_PANE_BOTTOM]	= ZmSetting.RP_BOTTOM;
ZmMailListController.ACTION_CODE_TO_MENU_ID[ZmKeyMap.READING_PANE_RIGHT]	= ZmSetting.RP_RIGHT;

ZmMailListController.ACTION_CODE_WHICH = {};
ZmMailListController.ACTION_CODE_WHICH[ZmKeyMap.FIRST_UNREAD]	= DwtKeyMap.SELECT_FIRST;
ZmMailListController.ACTION_CODE_WHICH[ZmKeyMap.LAST_UNREAD]	= DwtKeyMap.SELECT_LAST;
ZmMailListController.ACTION_CODE_WHICH[ZmKeyMap.NEXT_UNREAD]	= DwtKeyMap.SELECT_NEXT;
ZmMailListController.ACTION_CODE_WHICH[ZmKeyMap.PREV_UNREAD]	= DwtKeyMap.SELECT_PREV;

ZmMailListController.viewToTab = {};


// Public methods

/**
 * Handles switching views based on action from view menu.
 *
 * @param {constant}	view		the id of the new view
 * @param {Boolean}	force		if <code>true</code>, always redraw view
 */
ZmMailListController.prototype.switchView = function(view, force) {

	if ((view == ZmId.VIEW_TRAD || view == ZmId.VIEW_CONVLIST) && view != this.getCurrentViewType()) {
		if (appCtxt.multiAccounts) {
			delete this._showingAccountColumn;
		}

		var groupBy = ZmMailListController.GROUP_BY_SETTING[view];
		if (this.isSearchResults) {
			appCtxt.getApp(ZmApp.SEARCH).setGroupMailBy(groupBy);
		}
		else {
			this._app.setGroupMailBy(groupBy);
		}

		var folderId = this._currentSearch && this._currentSearch.folderId;
		
		var sortBy = appCtxt.get(ZmSetting.SORTING_PREF, folderId || view);
		if (view == ZmId.VIEW_CONVLIST && (sortBy == ZmSearch.NAME_DESC || sortBy == ZmSearch.NAME_ASC)) {
			sortBy =  appCtxt.get(ZmSetting.SORTING_PREF, view); //go back to sortBy for view
			appCtxt.set(ZmSetting.SORTING_PREF, sortBy, folderId); //force folderId sorting
		}
		if (this._mailListView && !appCtxt.isExternalAccount()) {
			//clear the groups to address "from" grouping for conversation
			if (folderId) {
				var currentGroup = this._mailListView.getGroup(folderId);
				if (currentGroup && currentGroup.id == ZmId.GROUPBY_FROM) {
					this._mailListView.setGroup(ZmId.GROUPBY_NONE);
				}
			}		
		}
		
		this._currentSearch.clearCursor();
		var limit = this._listView[this._currentViewId].getLimit();
		var getHtml = appCtxt.get(ZmSetting.VIEW_AS_HTML);
		var groupByItem = (view == ZmId.VIEW_TRAD) ? ZmItem.MSG : ZmItem.CONV;
		var params = {
			types:			[groupByItem],
			offset:			0,
			limit:			limit,
			sortBy:			sortBy,
			getHtml:		getHtml,
			isViewSwitch:	true
		};
		appCtxt.getSearchController().redoSearch(this._currentSearch, null, params);
	}
};

// override if reading pane is supported
ZmMailListController.prototype._setupReadingPaneMenu = function() {};
ZmMailListController.prototype._setupConvOrderMenu = function() {};

/**
 * Checks if the reading pane is "on".
 * 
 * @return	{Boolean}	<code>true</code> if the reading pane is "on"
 */
ZmMailListController.prototype.isReadingPaneOn =
function() {
	return (this._getReadingPanePref() != ZmSetting.RP_OFF);
};

/**
 * Checks if the reading pane is "on" right.
 * 
 * @return	{Boolean}	<code>true</code> if the reading pane is "on" right.
 */
ZmMailListController.prototype.isReadingPaneOnRight =
function() {
	return (this._getReadingPanePref() == ZmSetting.RP_RIGHT);
};

ZmMailListController.prototype._getReadingPanePref =
function() {
	return (this._readingPaneLoc || appCtxt.get(ZmSetting.READING_PANE_LOCATION));
};

ZmMailListController.prototype._setReadingPanePref =
function(value) {
	if (this.isSearchResults || appCtxt.isExternalAccount()) {
		this._readingPaneLoc = value;
	}
	else {
		appCtxt.set(ZmSetting.READING_PANE_LOCATION, value);
	}
};

ZmMailListController.prototype.getKeyMapName =
function() {
	return ZmKeyMap.MAP_MAIL;
};

// We need to stay in sync with what's allowed by _resetOperations
// TODO: we should just find out if an operation was enabled via _resetOperations
ZmMailListController.prototype.handleKeyAction =
function(actionCode, ev) {
	DBG.println(AjxDebug.DBG3, "ZmMailListController.handleKeyAction");

    var lv = this._listView[this._currentViewId];
    var num = lv.getSelectionCount();

    var item;
    if (num == 1 && !this.isDraftsFolder()) {
        var sel = this._listView[this._currentViewId].getSelection();
        if (sel && sel.length) {
            item = sel[0];
        }
    }

    var folder = this._getSearchFolder();
	var isSyncFailures = this.isSyncFailuresFolder();
	var isDrafts = (item && item.isDraft && (item.type != ZmId.ITEM_CONV || item.numMsgs == 1)) || this.isDraftsFolder();
	var isFeed = (folder && folder.isFeed());
    var isExternalAccount = appCtxt.isExternalAccount();

	switch (actionCode) {

		case ZmKeyMap.FORWARD:
			if (!isDrafts && !isExternalAccount) {
				this._doAction({action:ZmOperation.FORWARD, foldersToOmit:ZmMailApp.getFoldersToOmit()});
			}
			break;

		case ZmKeyMap.GET_MAIL:
			this._checkMailListener();
			break;

		case ZmKeyMap.GOTO_INBOX:
		case ZmKeyMap.GOTO_DRAFTS:
		case ZmKeyMap.GOTO_JUNK:
		case ZmKeyMap.GOTO_SENT:
		case ZmKeyMap.GOTO_TRASH:
            if (isExternalAccount) { break; }
			if (actionCode == ZmKeyMap.GOTO_JUNK && !appCtxt.get(ZmSetting.SPAM_ENABLED)) { break; }
			this._folderSearch(ZmMailListController.ACTION_CODE_TO_FOLDER[actionCode]);
			break;

		case ZmKeyMap.MOVE_TO_INBOX:
		case ZmKeyMap.MOVE_TO_TRASH:
		case ZmKeyMap.MOVE_TO_JUNK:
			if (isSyncFailures || isExternalAccount) { break; }
			if (actionCode == ZmKeyMap.MOVE_TO_JUNK && !appCtxt.get(ZmSetting.SPAM_ENABLED)) { break; }
			if (num && !(isDrafts && actionCode != ZmKeyMap.MOVE_TO_TRASH)) {
			 	var folderId = ZmMailListController.ACTION_CODE_TO_FOLDER_MOVE[actionCode];
				folder = appCtxt.getById(folderId);
				var items = lv.getSelection();
				this._doMove(items, folder);
			}
			break;

		case ZmKeyMap.REPLY:
		case ZmKeyMap.REPLY_ALL:
			if (!isDrafts && !isExternalAccount && (num == 1) && !isSyncFailures && !isFeed) {
				this._doAction({action:ZmMailListController.ACTION_CODE_TO_OP[actionCode], foldersToOmit:ZmMailApp.getFoldersToOmit()});
			}
			break;

		case ZmKeyMap.SELECT_ALL:
			lv.selectAll(true);
			this._resetToolbarOperations();
			break;
	
		case ZmKeyMap.SPAM:
            if (isExternalAccount) { break; }
			if (num && !isDrafts && !isExternalAccount && !isSyncFailures && appCtxt.get(ZmSetting.SPAM_ENABLED) && (folder && !folder.isReadOnly())) {
				this._spamListener();
			}
			break;

		case ZmKeyMap.MUTE_UNMUTE_CONV:
            // Mute/Unmute Code removed for IM will be added for JP
			break;

        case ZmKeyMap.MARK_READ:
			if (this._isPermissionDenied(folder)) {
				break;
			}
			this._markReadListener();
			break;

		case ZmKeyMap.MARK_UNREAD:
			if (this._isPermissionDenied(folder)) {
				break;
			}
			this._markUnreadListener();
			break;

		case ZmKeyMap.FLAG:
			if (this._isPermissionDenied(folder)) {
				break;
			}
			this._doFlag(this.getItems());
			break;

		case ZmKeyMap.VIEW_BY_CONV:
			if (!isSyncFailures && appCtxt.get(ZmSetting.CONVERSATIONS_ENABLED)) {
				this.switchView(ZmId.VIEW_CONVLIST);
			}
			break;

		case ZmKeyMap.VIEW_BY_MSG:
			if (!isSyncFailures) {
				this.switchView(ZmId.VIEW_TRAD);
			}
			break;

		case ZmKeyMap.READING_PANE_BOTTOM:
		case ZmKeyMap.READING_PANE_RIGHT:
		case ZmKeyMap.READING_PANE_OFF:
			var menuId = ZmMailListController.ACTION_CODE_TO_MENU_ID[actionCode];
			this.switchView(menuId, true);
			this._updateViewMenu(menuId, this._readingPaneViewMenu);
			break;

		case ZmKeyMap.SHOW_FRAGMENT:
			if (num == 1) {
				var item = lv.getSelection()[0];
                if (!item) { break; }
                var id = lv._getFieldId(item, ZmItem.F_SUBJECT);
                var subjectField = document.getElementById(id);
                if (subjectField) {
                    var loc = Dwt.getLocation(subjectField);
					var frag;
					// TODO: refactor / clean up
					if ((item.type == ZmItem.MSG && item.isInvite() && item.needsRsvp()) ||
                        (item.type == ZmId.ITEM_CONV && this.getMsg() && this.getMsg().isInvite() && this.getMsg().needsRsvp()))
                    {
						frag = item.invite ? item.invite.getToolTip() : this.getMsg().invite.getToolTip();
					} else {
						frag = item.fragment ? item.fragment : ZmMsg.fragmentIsEmpty;
						if (frag != "") { lv.setToolTipContent(AjxStringUtil.htmlEncode(frag), true); }
					}
					var tooltip = this._shell.getToolTip();
					tooltip.popdown();
					if (frag != "") {
						tooltip.setContent(frag);
						tooltip.popup(loc.x, loc.y);
					}
				}
			}
			break;

		case ZmKeyMap.NEXT_UNREAD:
		case ZmKeyMap.PREV_UNREAD:
			this.lastListAction = actionCode;

		case ZmKeyMap.FIRST_UNREAD:
		case ZmKeyMap.LAST_UNREAD:
			var unreadItem = this._getUnreadItem(ZmMailListController.ACTION_CODE_WHICH[actionCode]);
			if (unreadItem) {
				this._selectItem(lv, unreadItem);
			}
			break;
	
		default:
			return ZmListController.prototype.handleKeyAction.apply(this, arguments);
	}
	return true;
};

ZmMailListController.prototype._isPermissionDenied =
function(folder) {
	var isExternalAccount = appCtxt.isExternalAccount();

	if (isExternalAccount || (folder && folder.isReadOnly())) {
		appCtxt.setStatusMsg(ZmMsg.errorPermission);
		return true;
	}
	return false;
};

ZmMailListController.prototype._selectItem =
function(listView, item) {
	listView._unmarkKbAnchorElement(true);
	listView.setSelection(item);
	var el = listView._getElFromItem(item);
	if (el) {
		listView._scrollList(el);
	}
};

ZmMailListController.prototype.mapSupported =
function(map) {
	return (map == "list");
};

/**
 * Sends the read receipt.
 * 
 * @param	{ZmMailMsg}		msg			the message
 */
ZmMailListController.prototype.sendReadReceipt =
function(msg) {

	if (!appCtxt.get(ZmSetting.MAIL_READ_RECEIPT_ENABLED) || msg.readReceiptSent || msg.isSent) {
		return;
	}

	var rrPref = appCtxt.get(ZmSetting.MAIL_SEND_READ_RECEIPTS);

	if (rrPref == ZmMailApp.SEND_RECEIPT_PROMPT) {
		var dlg = appCtxt.getYesNoMsgDialog();
		dlg.registerCallback(DwtDialog.YES_BUTTON, this._sendReadReceipt, this, [msg, dlg]);
		dlg.registerCallback(DwtDialog.NO_BUTTON, this._sendReadReceiptNotified, this, [msg, dlg]);
		dlg.setMessage(ZmMsg.readReceiptSend, DwtMessageDialog.WARNING_STYLE);
		dlg.popup();
	} else if (rrPref == ZmMailApp.SEND_RECEIPT_ALWAYS) {
		msg.readReceiptSent = true;
        this._sendReadReceipt(msg);
	}
};

ZmMailListController.prototype._sendReadReceipt =
function(msg, dlg) {
	if (dlg) {
		dlg.popdown();
	}
	msg.sendReadReceipt(this._handleSendReadReceipt.bind(this, msg));
};

ZmMailListController.prototype._handleSendReadReceipt =
function(msg) {
	appCtxt.setStatusMsg(ZmMsg.readReceiptSent);
    this._sendReadReceiptNotified(msg);
};

ZmMailListController.prototype._sendReadReceiptNotified =
function(msg, dlg) {
	var callback = dlg ? (new AjxCallback(dlg, dlg.popdown)) : null;
	var flags = msg.setFlag(ZmItem.FLAG_READ_RECEIPT_SENT, true);
	msg.list.flagItems({items:[msg], op:"update", value:flags, callback:callback});
};

ZmMailListController.prototype._updateViewMenu = function(id, menu) {

	var viewBtn = this.getCurrentToolbar().getButton(ZmOperation.VIEW_MENU);
	menu = menu || (viewBtn && viewBtn.getMenu());
	if (menu) {
		var mi = menu.getItemById(ZmOperation.MENUITEM_ID, id);
		if (mi) {
			mi.setChecked(true, true);
		}
	}

	// Create "Display" submenu here since it's only needed for multi-column
	if (!this._colHeaderViewMenu && this._mailListView.isMultiColumn()) {
		this._colHeaderViewMenu = this._setupColHeaderViewMenu(this._currentView, this._viewMenu);
	}

	if (this._colHeaderMenuItem && (id === ZmSetting.RP_OFF || id === ZmSetting.RP_BOTTOM || id === ZmSetting.RP_RIGHT)) {
		this._colHeaderMenuItem.setVisible(this._mailListView.isMultiColumn());
	}
};

// Private and protected methods

ZmMailListController.prototype._initialize =
function(view) {
	this._setActiveSearch(view);

	// call base class
	ZmListController.prototype._initialize.call(this, view);
};

ZmMailListController.prototype._initializeParticipantActionMenu =
function() {
	if (!this._participantActionMenu) {
		var menuItems = this._participantOps();
		menuItems.push(ZmOperation.SEP);
		var ops = this._getActionMenuOps();
		if (ops && ops.length) {
			menuItems = menuItems.concat(ops);
		}

		this._participantActionMenu = new ZmActionMenu({parent:this._shell, menuItems:menuItems, controller:this,
														context:this._currentViewId, menuType:ZmId.MENU_PARTICIPANT});
        if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
            this._setSearchMenu(this._participantActionMenu);
        }
		this._addMenuListeners(this._participantActionMenu);
		this._participantActionMenu.addPopdownListener(this._menuPopdownListener);
		this._setupTagMenu(this._participantActionMenu);

		//notify Zimlet before showing 
		appCtxt.notifyZimlets("onParticipantActionMenuInitialized", [this, this._participantActionMenu]);
	}
	return this._participantActionMenu;
};

ZmMailListController.prototype._initializeDraftsActionMenu =
function() {
    if (!this._draftsActionMenu) {
		var menuItems = [
			ZmOperation.EDIT,
			ZmOperation.SEP,
			ZmOperation.TAG_MENU, ZmOperation.DELETE, ZmOperation.PRINT,
			ZmOperation.SEP,
			ZmOperation.SHOW_ORIG
		];
		this._draftsActionMenu = new ZmActionMenu({parent:this._shell, menuItems:menuItems,
												   context:this._currentViewId, menuType:ZmId.MENU_DRAFTS});
        if (appCtxt.get(ZmSetting.SEARCH_ENABLED)) {
            this._setSearchMenu(this._draftsActionMenu);
        }
		this._addMenuListeners(this._draftsActionMenu);
		this._draftsActionMenu.addPopdownListener(this._menuPopdownListener);
		this._setupTagMenu(this._draftsActionMenu);
		appCtxt.notifyZimlets("onDraftsActionMenuInitialized", [this, this._draftsActionMenu]);
	}
};

ZmMailListController.prototype._setDraftSearchMenu =
function(address, item, ev){
   if (address && appCtxt.get(ZmSetting.SEARCH_ENABLED) && (ev.field == ZmItem.F_PARTICIPANT || ev.field == ZmItem.F_FROM)){
        if (!this._draftsActionMenu.getOp(ZmOperation.SEARCH_MENU)) {
            ZmOperation.addOperation(this._draftsActionMenu, ZmOperation.SEARCH_MENU, [ZmOperation.SEARCH_MENU, ZmOperation.SEP], 0);
            this._setSearchMenu(this._draftsActionMenu);
        }
        if (item && (item.getAddresses(AjxEmailAddress.TO).getArray().length + item.getAddresses(AjxEmailAddress.CC).getArray().length) > 1){
            ZmOperation.setOperation(this._draftsActionMenu.getSearchMenu(), ZmOperation.SEARCH_TO, ZmOperation.SEARCH_TO, ZmMsg.findEmailToRecipients);
            ZmOperation.setOperation(this._draftsActionMenu.getSearchMenu(), ZmOperation.SEARCH, ZmOperation.SEARCH, ZmMsg.findEmailFromRecipients);
        }
        else{
            ZmOperation.setOperation(this._draftsActionMenu.getSearchMenu(), ZmOperation.SEARCH_TO, ZmOperation.SEARCH_TO, ZmMsg.findEmailToRecipient);
            ZmOperation.setOperation(this._draftsActionMenu.getSearchMenu(), ZmOperation.SEARCH, ZmOperation.SEARCH, ZmMsg.findEmailFromRecipient);
        }
     }
     else if (this._draftsActionMenu.getOp(ZmOperation.SEARCH_MENU)) {
            this._draftsActionMenu = null;
            this._initializeDraftsActionMenu();
     }
};

ZmMailListController.prototype._getToolBarOps =
function() {
	var list = [];
	list.push(ZmOperation.SEP);
	list = list.concat(this._msgOps());
	list.push(ZmOperation.SEP);
	list = list.concat(this._deleteOps());
	list.push(ZmOperation.SEP);
	list.push(ZmOperation.MOVE_MENU);
	list.push(ZmOperation.TAG_MENU);
	return list;
};

ZmMailListController.prototype._getRightSideToolBarOps =
function() {
	if (appCtxt.isChildWindow) {
		return [];
	}
	return [ZmOperation.VIEW_MENU];
};


ZmMailListController.prototype._showDetachInSecondary =
function() {
	return true;
};

ZmMailListController.prototype._getSecondaryToolBarOps =
function() {

	var list = [],
		viewType = this.getCurrentViewType();

	list.push(ZmOperation.PRINT);
	list.push(ZmOperation.SEP);
	list = list.concat(this._flagOps());
	list.push(ZmOperation.SEP);
    list.push(ZmOperation.REDIRECT);
    list.push(ZmOperation.EDIT_AS_NEW);
    list.push(ZmOperation.SEP);
	list = list.concat(this._createOps());
	list.push(ZmOperation.SEP);
	list = list.concat(this._otherOps(true));
	if (viewType === ZmId.VIEW_TRAD) {
		list.push(ZmOperation.SHOW_CONV);
	}

	return list;
};


ZmMailListController.prototype._initializeToolBar =
function(view, className) {

	if (!this._toolbar[view]) {
		ZmListController.prototype._initializeToolBar.call(this, view, className);
		this._createViewMenu(view);
		this._setReplyText(this._toolbar[view]);
//		this._toolbar[view].addOp(ZmOperation.FILLER);
		if (!appCtxt.isChildWindow) {
			this._initializeNavToolBar(view);
		}
	}

	if (!appCtxt.isChildWindow) {
		this._setupViewMenu(view);
	}
	this._setupDeleteButton(this._toolbar[view]);
	if (appCtxt.get(ZmSetting.SPAM_ENABLED)) {
		this._setupSpamButton(this._toolbar[view]);
	}
    this._setupPrintButton(this._toolbar[view]);
};

ZmMailListController.prototype._getNumTotal =
function(){
	// Yuck, remove "of Total" from Nav toolbar at lower resolutions
	if (AjxEnv.is1024x768orLower) {
		 return null;
	}
	return ZmListController.prototype._getNumTotal.call(this);
};

ZmMailListController.prototype._initializeActionMenu =
function() {
	var isInitialized = (this._actionMenu != null);
	ZmListController.prototype._initializeActionMenu.call(this);

	if (this._actionMenu) {
		this._setupSpamButton(this._actionMenu);
	}
	//notify Zimlet before showing
	appCtxt.notifyZimlets("onActionMenuInitialized", [this, this._actionMenu]);
};

// Groups of mail-related operations

ZmMailListController.prototype._flagOps =
function() {
	return [ZmOperation.MARK_READ, ZmOperation.MARK_UNREAD, ZmOperation.FLAG, ZmOperation.UNFLAG];
};

ZmMailListController.prototype._msgOps =
function() {
	var list = [];

	list.push(ZmOperation.EDIT); // hidden except for Drafts

	if (appCtxt.get(ZmSetting.REPLY_MENU_ENABLED)) {
		list.push(ZmOperation.REPLY, ZmOperation.REPLY_ALL);
	}

	if (appCtxt.get(ZmSetting.FORWARD_MENU_ENABLED)) {
		list.push(ZmOperation.FORWARD);
	}
	return list;
};

ZmMailListController.prototype._deleteOps =
function() {
	return [this.getDeleteOperation(), ZmOperation.SPAM];
};

ZmMailListController.prototype._createOps =
function() {
	var list = [];
	if (appCtxt.get(ZmSetting.FILTERS_ENABLED)) {
		list.push(ZmOperation.ADD_FILTER_RULE);
	}
	if (appCtxt.get(ZmSetting.CALENDAR_ENABLED)) {
		list.push(ZmOperation.CREATE_APPT);
	}
	if (appCtxt.get(ZmSetting.TASKS_ENABLED)) {
		list.push(ZmOperation.CREATE_TASK);
	}
	//list.push(ZmOperation.QUICK_COMMANDS);
	return list;
};

ZmMailListController.prototype._otherOps =
function(isSecondary) {
	var list = [];
	if (!appCtxt.isChildWindow && (!isSecondary || this._showDetachInSecondary()) && appCtxt.get(ZmSetting.DETACH_MAILVIEW_ENABLED) && !appCtxt.isExternalAccount()) {
		list.push(ZmOperation.DETACH);
	}
	list.push(ZmOperation.SHOW_ORIG);
	return list;
};



ZmMailListController.prototype.getDeleteOperation =
function() {
	return ZmOperation.DELETE;
};

ZmMailListController.prototype._setActiveSearch =
function(view) {
	// save info. returned by search result
	if (this._activeSearch) {
		if (this._list) {
			this._list.setHasMore(this._activeSearch.getAttribute("more"));
		}
		if (this._listView[view]) {
			this._listView[view].offset = parseInt(this._activeSearch.getAttribute("offset"));
		}
	}
};


/**
 * checks whether some of the selected messages are read and unread. returns it as a 2 flag object with "hasRead" and "hasUnread" attributes.
 *
 * @private
 */
ZmMailListController.prototype._getReadStatus =
function() {

	var status = {hasRead : false, hasUnread : false}

	// dont bother checking for read/unread state for read-only folders
	var folder = this._getSearchFolder();
	if (folder && folder.isReadOnly()) {
		return status;
	}

	var items = this.getItems();

	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		// TODO: refactor / clean up
		if (item.type == ZmItem.MSG) {
			status[item.isUnread ? "hasUnread" : "hasRead"] = true;
			status[item.isFlagged ? "hasFlagged" : "hasUnflagged"] = true;
		}
		else if (item.type == ZmItem.CONV) {
			status.hasUnread = status.hasUnread || item.hasFlag(ZmItem.FLAG_UNREAD, true);
			status.hasRead = status.hasRead || item.hasFlag(ZmItem.FLAG_UNREAD, false);
			status.hasUnflagged = status.hasUnflagged || item.hasFlag(ZmItem.FLAG_FLAGGED, false);
			status.hasFlagged = status.hasFlagged || item.hasFlag(ZmItem.FLAG_FLAGGED, true);
		}
		if (status.hasUnread && status.hasRead) {
			break;
		}
	}

	return status;
};


ZmMailListController.prototype._getConvMuteStatus =
function() {
	var items = this.getItems();
    var status = {
                    hasMuteConv: false,
                    hasUnmuteConv: false
                },
        item,
        i;
    for (i=0; i<items.length; i++) {
        item = items[i];
        if (item.isMute) {
            status.hasMuteConv = true;
        }
        else {
            status.hasUnmuteConv = true;
        }
    }
    return status;
};

/**
 * Dynamically enable/disable the mark read/unread menu items.
 *
 * @private
 */
ZmMailListController.prototype._enableReadUnreadToolbarActions =
function() {
	var menu = this.getCurrentToolbar().getActionsMenu();
	this._enableFlags(menu);
};

ZmMailListController.prototype._enableMuteUnmuteToolbarActions =
function() {
	var menu = this.getCurrentToolbar().getActionsMenu();
	this._enableMuteUnmute(menu);
};

ZmMailListController.prototype._actionsButtonListener =
function(ev) {
	this._enableReadUnreadToolbarActions();
	this._enableMuteUnmuteToolbarActions();
	ZmBaseController.prototype._actionsButtonListener.call(this, ev);
};

// List listeners

ZmMailListController.prototype._listSelectionListener =
function(ev) {
	// offline: when opening a message in Outbox, move it to the appropriate
	// account's Drafts folder first
	var search = appCtxt.getCurrentSearch();
	if (appCtxt.isOffline &&
		ev.detail == DwtListView.ITEM_DBL_CLICKED &&
		ev.item && ev.item.isDraft &&
		search && search.folderId == ZmFolder.ID_OUTBOX)
	{
		var account = ev.item.account || ZmOrganizer.parseId(ev.item.id).account;
		var folder = appCtxt.getById(ZmOrganizer.getSystemId(ZmFolder.ID_DRAFTS, account));
		this._list.moveItems({items:[ev.item], folder:folder});
		return false;
	}
	var folderId = ev.item.folderId || (search && search.folderId);
	var folder = folderId && appCtxt.getById(folderId);

	if (ev.field === ZmItem.F_FLAG && this._isPermissionDenied(folder)) {
		return true;
	}
	if (ev.field === ZmItem.F_READ) {
		if (!this._isPermissionDenied(folder)) {
			this._doMarkRead([ev.item], ev.item.isUnread);
		}
		return true;
	}
	else {
		return ZmListController.prototype._listSelectionListener.apply(this, arguments);
	}
};

// Based on context, enable read/unread operation, add/edit contact.
ZmMailListController.prototype._listActionListener =
function(ev) {

	ZmListController.prototype._listActionListener.call(this, ev);

	var items = this._listView[this._currentViewId].getSelection();
	var folder = this._getSearchFolder();

	// bug fix #3602
	var address = (appCtxt.get(ZmSetting.CONTACTS_ENABLED) && ev.field == ZmItem.F_PARTICIPANT)
		? ev.detail
		: ((ev.item && ev.item.isZmMailMsg) ? ev.item.getAddress(AjxEmailAddress.FROM) : null);

	var email = address && address.getAddress();

	var item = (items && items.length == 1) ? items[0] : null;
	if (this.isDraftsFolder() || (item && item.isDraft && item.type != ZmId.ITEM_CONV)) { //note that we never treat a conversation as a draft for actions. See also bug 64494
		// show drafts menu
		this._initializeDraftsActionMenu();
        this._setDraftSearchMenu(address, item, ev);
        if (address)
            this._actionEv.address = address;
		this._setTagMenu(this._draftsActionMenu);
        this._resetOperations(this._draftsActionMenu, items.length);
		appCtxt.notifyZimlets("onMailActionMenuResetOperations", [this, this._draftsActionMenu]);
		this._draftsActionMenu.popup(0, ev.docX, ev.docY);
	}
	else if (!appCtxt.isExternalAccount() && email && items.length == 1 &&
			(appCtxt.get(ZmSetting.CONTACTS_ENABLED) && (ev.field == ZmItem.F_PARTICIPANT || ev.field == ZmItem.F_FROM)))
	{
		// show participant menu
		this._initializeParticipantActionMenu();
		this._setTagMenu(this._participantActionMenu);
		this._actionEv.address = address;
		this._setupSpamButton(this._participantActionMenu);
		this._resetOperations(this._participantActionMenu, items.length);
		appCtxt.notifyZimlets("onMailActionMenuResetOperations", [this, this._participantActionMenu]);
		this._enableFlags(this._participantActionMenu);
		this._enableMuteUnmute(this._participantActionMenu);
		var imItem = this._participantActionMenu.getOp(ZmOperation.IM);
		var contactsApp = appCtxt.getApp(ZmApp.CONTACTS);
		if (contactsApp) {
			this._loadContactForMenu(this._participantActionMenu, address, ev, imItem);
		}
		else if (imItem) {
			// since contacts app is disabled, we won't be making a server call
			ZmImApp.updateImMenuItemByAddress(imItem, address, true);
			this._participantActionMenu.popup(0, ev.docX, ev.docY);
		}
	}
    else if (this.isOutboxFolder()) {
        // show drafts menu
        //this._initializeOutboxsActionMenu();
    } else {
		var actionMenu = this.getActionMenu();
		this._setupSpamButton(actionMenu);
		this._enableFlags(actionMenu);
		this._enableMuteUnmute(actionMenu);
		appCtxt.notifyZimlets("onMailActionMenuResetOperations", [this, actionMenu]);
		actionMenu.popup(0, ev.docX, ev.docY);
		if (ev.ersatz) {
			// menu popped up via keyboard nav
			actionMenu.setSelectedItem(0);
		}
	}

    if (!folder) {
        //might have come from searching on sent items and want to stay in search sent view (i.e. recipient instead of sender)
        folder = this._getActiveSearchFolder();
    }

    if (folder && (folder.nId == ZmFolder.ID_SENT  &&
                  (this._participantActionMenu && this._participantActionMenu.getOp(ZmOperation.SEARCH_MENU)))) {
        if (item && (item.getAddresses(AjxEmailAddress.TO).getArray().length + item.getAddresses(AjxEmailAddress.CC).getArray().length) > 1){
            ZmOperation.setOperation(this._participantActionMenu.getSearchMenu(), ZmOperation.SEARCH_TO, ZmOperation.SEARCH_TO, ZmMsg.findEmailToRecipients);
            ZmOperation.setOperation(this._participantActionMenu.getSearchMenu(), ZmOperation.SEARCH, ZmOperation.SEARCH, ZmMsg.findEmailFromRecipients);
        }
        else{
            ZmOperation.setOperation(this._participantActionMenu.getSearchMenu(), ZmOperation.SEARCH_TO, ZmOperation.SEARCH_TO, ZmMsg.findEmailToRecipient);
            ZmOperation.setOperation(this._participantActionMenu.getSearchMenu(), ZmOperation.SEARCH, ZmOperation.SEARCH, ZmMsg.findEmailFromRecipient);
        }
    }
    else if (this._participantActionMenu && this._participantActionMenu.getOp(ZmOperation.SEARCH_MENU)) {
        ZmOperation.setOperation(this._participantActionMenu.getSearchMenu(), ZmOperation.SEARCH_TO, ZmOperation.SEARCH_TO, ZmMsg.findEmailToSender);
        ZmOperation.setOperation(this._participantActionMenu.getSearchMenu(), ZmOperation.SEARCH, ZmOperation.SEARCH, ZmMsg.findEmailFromSender);
    }
};

// Operation listeners

ZmMailListController.prototype._markReadListener =
function(ev) {
	var callback = this._getMarkReadCallback();
	this._doMarkRead(this._listView[this._currentViewId].getSelection(), true, callback);
};

ZmMailListController.prototype._showOrigListener =
function() {
	var msg = this.getMsg();
	if (!msg) { return; }

	setTimeout(this._showMsgSource.bind(this, msg), 100); // Other listeners are focusing the main window, so delay the window opening for just a bit
};

ZmMailListController.prototype._showMsgSource =
function(msg) {
	var msgFetchUrl = appCtxt.get(ZmSetting.CSFE_MSG_FETCHER_URI) + "&view=text&id=" + msg.id + (msg.partId ? "&part=" + msg.partId : "");

	// create a new window w/ generated msg based on msg id
	window.open(msgFetchUrl, "_blank", "menubar=yes,resizable=yes,scrollbars=yes");
};


/**
 * Per bug #7257, read receipt must be sent if user explicitly marks a message
 * read under the following conditions:
 *
 * 0. read receipt is requested, user agrees to send it
 * 1. reading pane is on
 * 2. mark as read preference is set to "never"
 * 3. the message currently being read in the reading pane is in the list of
 *    convs/msgs selected for mark as read
 *
 * If all these conditions are met, a callback to run sendReadReceipt() is returned.
 * 
 * @private
 */
ZmMailListController.prototype._getMarkReadCallback =
function() {
	var view = this._listView[this._currentViewId];
	var items = view.getSelection();

	if (this.isReadingPaneOn() && appCtxt.get(ZmSetting.MARK_MSG_READ) == -1) {
		// check if current message being read is the message in the selection list
		var msg = view.parent.getItemView && view.parent.getItemView().getItem();
		if (msg && msg.readReceiptRequested) {
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				var itemId = (item.id < 0) ? (item.id * (-1)) : item.id;
				if (itemId == msg.id) {
					return this.sendReadReceipt.bind(this, msg);
				}
			}
		}
	}
	return null;
};

ZmMailListController.prototype._markUnreadListener =
function(ev) {

	appCtxt.killMarkReadTimer();

	this._doMarkRead(this._listView[this._currentViewId].getSelection(), false);
};

/**
 * flags or unflags (based on the status of the first item. See doFlag)
 * @param ev
 * @private
 */
ZmMailListController.prototype._flagListener =
function(on) {
	this._doFlag(this._listView[this._currentViewId].getSelection(), on);
};


ZmMailListController.prototype._replyListener =
function(ev) {
	var action = ev.item.getData(ZmOperation.KEY_ID);
	if (!action || action == ZmOperation.REPLY_MENU) {
		action = ZmOperation.REPLY;
	}

	this._doAction({ev: ev, action: action, foldersToOmit: ZmMailApp.getReplyFoldersToOmit()});
};

ZmMailListController.prototype._forwardListener =
function(ev) {
	var action = ev.item.getData(ZmOperation.KEY_ID);
	this._doAction({ev: ev, action: action, foldersToOmit: ZmMailApp.getReplyFoldersToOmit()});
};

ZmMailListController.prototype._forwardConvListener = function(ev) {
	this._doAction({ev: ev, action: ZmOperation.FORWARD_CONV, foldersToOmit: ZmMailApp.getReplyFoldersToOmit()});
};

// This method may be called with a null ev parameter
ZmMailListController.prototype._doAction =
function(params) {

	// get msg w/ addrs to select identity from - don't load it yet (no callback)
	// for special handling of multiple forwarded messages, see _handleResponseDoAction
	var msg = params.msg || this.getMsg(params);
	if (!msg) {
		return;
	}

	// use resolved msg to figure out identity/persona to use for compose
	var collection = appCtxt.getIdentityCollection();
	var identity = collection.selectIdentity(msg);

	var action = params.action;
	if (!action || action == ZmOperation.FORWARD_MENU || action == ZmOperation.FORWARD)	{
		params.origAction = action;
		action = params.action = (appCtxt.get(ZmSetting.FORWARD_INCLUDE_ORIG) == ZmSetting.INC_ATTACH)
			? ZmOperation.FORWARD_ATT : ZmOperation.FORWARD_INLINE;

		if (msg.isInvite()) {
			action = params.action = ZmOperation.FORWARD_ATT;
		}
	}
	if (action === ZmOperation.FORWARD_CONV) {
		params.origAction = action;
		// need to remember conv since a single right-clicked item has its selection cleared when
		// the action menu is popped down during the request to load the conv
		var selection = this.getSelection();
		params.conv = selection && selection.length === 1 ? selection[0] : null;
		action = params.action = ZmOperation.FORWARD_ATT;
	}

	// if html compose is allowed and if opening draft always request html
	//   otherwise check if user prefers html or
	//   msg hasn't been loaded yet and user prefers format of orig msg
	var htmlEnabled = appCtxt.get(ZmSetting.HTML_COMPOSE_ENABLED);
	var prefersHtml = (appCtxt.get(ZmSetting.COMPOSE_AS_FORMAT) == ZmSetting.COMPOSE_HTML);
	var sameFormat = appCtxt.get(ZmSetting.COMPOSE_SAME_FORMAT);
	params.getHtml = (htmlEnabled && (action == ZmOperation.DRAFT || (prefersHtml || (!msg._loaded && sameFormat))));
	if (action == ZmOperation.DRAFT) {
		params.listController = this;
		//always reload the draft msg except offline created msg
        if (!msg.isOfflineCreated) {
            params.forceLoad = true;
        }
	}

	// bug: 38928 - if user viewed entire truncated message, fetch the whole
	// thing when replying/forwarding
	if (action != ZmOperation.NEW_MESSAGE && action != ZmOperation.DRAFT && msg.viewEntireMessage) {
		params.noTruncate = true;
		params.forceLoad = true;
	}

	if (action == ZmOperation.DRAFT || action == ZmOperation.FORWARD_INLINE ||
            action == ZmOperation.REPLY || action == ZmOperation.REPLY_ALL) {
		var bp = msg.getBodyPart();
		if ((bp && bp.isTruncated) || !msg._loaded) {
			params.noTruncate = true;
			params.forceLoad = true;
		}
	}

	if (params.msg) {
		this._handleResponseDoAction(params, params.msg);
	}
	else {
		var respCallback = this._handleResponseDoAction.bind(this, params);
		// TODO: pointless to load msg when forwarding as att
		this._getLoadedMsg(params, respCallback);
	}
};

ZmMailListController.prototype._handleResponseDoAction =
function(params, msg, finalChoice) {

	if (!msg) { return; }

	msg._instanceDate = params.instanceDate;

	params.inNewWindow = (!appCtxt.isChildWindow && this._app._inNewWindow(params.ev));

    if (msg.list && msg.isUnread && !appCtxt.getById(msg.folderId).isReadOnly()) {
        msg.list.markRead({items:[msg], value:true});
    }

	// check to see if we're forwarding multiple msgs, in which case we do them as attachments;
	// also check to see if we're forwarding an invite; if so, go to appt compose
	var action = params.action;
	if (action == ZmOperation.FORWARD_ATT || action == ZmOperation.FORWARD_INLINE) {
		var selection, selCount;
		if (params.msg) {
			selCount = 1
		}
		else {
			var cview = this._listView[this._currentViewId];
			if (cview) {
				selection = params.conv ? [ params.conv ] : cview.getSelection();
				selCount = params.conv ? 1 : selection.length;
			}
		}
		// bug 43428 - invitation should be forwarded using appt forward view
		if (selCount == 1 && msg.forwardAsInvite()) {
			var ac = window.parentAppCtxt || window.appCtxt;
			if (ac.get(ZmSetting.CALENDAR_ENABLED)) {
				var controller = ac.getApp(ZmApp.CALENDAR).getCalController();
				controller.forwardInvite(msg);
				if (appCtxt.isChildWindow) {
					window.close();
				}
				return;
			}
		}

		// forward multiple msgs as attachments
		if (selCount > 1 || params.origAction === ZmOperation.FORWARD_CONV) {
			action = params.action = ZmOperation.FORWARD_ATT;
			this._handleLoadMsgs(params, selection);
			return;
		}
	}
	else if (appCtxt.isOffline && action == ZmOperation.DRAFT) {
		var folder = appCtxt.getById(msg.folderId);
		params.accountName = folder && folder.getAccount().name;
	}
	else if (action == ZmOperation.DECLINE_PROPOSAL) {
		params.subjOverride = this._getInviteReplySubject(action) + msg.subject;
	}

	params.msg = msg;
	AjxDispatcher.run("Compose", params);
};


ZmMailListController.prototype._redirectListener =
function(ev) {

    var action = ev.item.getData(ZmOperation.KEY_ID);
    var msg = this.getMsg({ev:ev, action:action});
    if (!msg) return;

    var redirectDialog = appCtxt.getMailRedirectDialog();
    var redirectDialogCB = this._redirectCallback.bind(this, msg);
    ZmController.showDialog(redirectDialog, redirectDialogCB);
};


ZmMailListController.prototype._redirectCallback =
function(msg) {
	if (!msg) return;

	var redirectDialog = appCtxt.getMailRedirectDialog();
	var addrs = redirectDialog.getAddrs();
	// Code copied from ZmComposeView.  Should consolidate along with the
	// ZmRecipient code, i.e. the corresponding recipient controller code.
	if (addrs.gotAddress) {
        if (addrs[ZmRecipients.BAD].size()) {
            // Any bad addresses?  If there are bad ones, ask the user if they want to send anyway.
            var bad = AjxStringUtil.htmlEncode(addrs[ZmRecipients.BAD].toString(AjxEmailAddress.SEPARATOR));
            var badMsg = AjxMessageFormat.format(ZmMsg.compBadAddresses, bad);
            var cd = appCtxt.getOkCancelMsgDialog();
            cd.reset();
            cd.setMessage(badMsg, DwtMessageDialog.WARNING_STYLE);
            cd.registerCallback(DwtDialog.OK_BUTTON, this._badRedirectAddrsOkCallback, this, [addrs, cd, msg]);
            cd.registerCallback(DwtDialog.CANCEL_BUTTON, this._badRedirectAddrsCancelCallback, this, cd);
            cd.setVisible(true); // per fix for bug 3209
            cd.popup();
        } else {
            redirectDialog.popdown();
            msg.redirect(addrs, this._handleSendRedirect.bind(this));
         }
    } else {
        redirectDialog.popdown();
    }
};

// User has agreed to send message with bad addresses
ZmMailListController.prototype._badRedirectAddrsOkCallback =
function(addrs, dialog, msg) {
    dialog.popdown();
    appCtxt.getMailRedirectDialog().popdown();
    msg.redirect(addrs, this._handleSendRedirect.bind(this));
};


// User has declined to send message with bad addresses - popdown the bad addr dialog,
// returning to the redirect dialog
ZmMailListController.prototype._badRedirectAddrsCancelCallback =
function(dialog) {
    dialog.popdown();
};

ZmMailListController.prototype._handleLoadMsgs =
function(params, selection) {

	var msgIds = new AjxVector(),
		foldersToOmit = params.foldersToOmit || {};

	for (var i = 0; i < selection.length; i++) {
		var item = selection[i];
		if (item.type == ZmItem.CONV) {
			for (var j = 0; j < item.msgIds.length; j++) {
				var msgId = item.msgIds[j];
				if (!foldersToOmit[item.msgFolder[msgId]]) {
					msgIds.add(msgId);
				}
			}
		}
		else {
			if (!msgIds.contains(item.id)) {
				msgIds.add(item.id);
			}
		}
	}
	params.msgIds = msgIds.getArray();
    params.selectedMessages = selection;

	AjxDispatcher.run("Compose", params);
};

ZmMailListController.prototype._handleSendRedirect =
function() {
    appCtxt.setStatusMsg(ZmMsg.redirectSent, ZmStatusView.LEVEL_INFO, null);
};

/**
 * Marks a mail item read if appropriate, possibly after a delay. An arg can be passed so that this function
 * just returns whether the item can be marked read now, which typically results in the setting of the "read"
 * flag in a retrieval request to the server. After that, it can be called without that arg in order to mark
 * the item read after a delay if necessary.
 * 
 * @param {ZmMailItem}	item		msg or conv
 * @param {boolean}		check		if true, return true if msg can be marked read now, without marking it read
 */
ZmMailListController.prototype._handleMarkRead =
function(item, check) {

	var convView = this._convView;
	var waitOnMarkRead = convView && convView.isWaitOnMarkRead();
	if (item && item.isUnread && !waitOnMarkRead) {
		if (!item.isReadOnly() && !appCtxt.isExternalAccount()) {
			var markRead = appCtxt.get(ZmSetting.MARK_MSG_READ);
			if (markRead == ZmSetting.MARK_READ_NOW) {
				if (check) {
					return true;
				}
				else {
					// msg was cached as unread, mark it read now
					this._doMarkRead([item], true);
				}
			} else if (markRead > 0) {
				if (!appCtxt.markReadAction) {
					appCtxt.markReadAction = new AjxTimedAction(this, this._markReadAction);
				}
				appCtxt.markReadAction.args = [item];
				appCtxt.markReadActionId = AjxTimedAction.scheduleAction(appCtxt.markReadAction, markRead * 1000);
			}
		}
	}
	return false;
};

ZmMailListController.prototype._markReadAction =
function(msg) {
	this._doMarkRead([msg], true);
};

ZmMailListController.prototype._doMarkRead =
function(items, on, callback, forceCallback) {

	var params = {items:items, value:on, callback:callback, noBusyOverlay: true};
	var list = params.list = this._getList(params.items);
    params.forceCallback = forceCallback;
	this._setupContinuation(this._doMarkRead, [on, callback], params);
	list.markRead(params);
};

ZmMailListController.prototype._doMarkMute =
function(items, on, callback, forceCallback) {

	var params = {items:items, value:on, callback:callback};
	var list = params.list = this._getList(params.items);
    params.forceCallback = forceCallback;
	this._setupContinuation(this._doMarkMute, [on, callback], params);
	list.markMute(params);
};

/**
* Marks the given items as "spam" or "not spam". Items marked as spam are moved to
* the Junk folder. If items are being moved out of the Junk folder, they will be
* marked "not spam", and the destination folder may be provided. It defaults to Inbox
* if not present.
*
* @param items			[Array]			a list of items to move
* @param markAsSpam		[boolean]		spam or not spam
* @param folder			[ZmFolder]		destination folder
*/
ZmMailListController.prototype._doSpam =
function(items, markAsSpam, folder) {

	this._listView[this._currentViewId]._itemToSelect = this._getNextItemToSelect();
	items = AjxUtil.toArray(items);

	var params = {items:items,
					markAsSpam:markAsSpam,
					folder:folder,
					childWin:appCtxt.isChildWindow && window,
					closeChildWin: appCtxt.isChildWindow};

	var allDoneCallback = this._getAllDoneCallback();
	var list = params.list = this._getList(params.items);
	this._setupContinuation(this._doSpam, [markAsSpam, folder], params, allDoneCallback);
	list.spamItems(params);
};

ZmMailListController.prototype._inviteReplyHandler =
function(ev) {
	var ac = window.parentAppCtxt || window.appCtxt;

	this._listView[this._currentViewId]._itemToSelect = this._getNextItemToSelect();
	ac.getAppController().focusContentPane();

	var type = ev._inviteReplyType;
	if (type == ZmOperation.PROPOSE_NEW_TIME ) {
		ac.getApp(ZmApp.CALENDAR).getCalController().proposeNewTime(ev._msg);
		if (appCtxt.isChildWindow) {
			window.close();
		}
	}
	else if (type == ZmOperation.ACCEPT_PROPOSAL) {
		this._acceptProposedTime(ev._inviteComponentId, ev._msg);
	}
	else if (type == ZmOperation.DECLINE_PROPOSAL) {
		this._declineProposedTime(ev._inviteComponentId, ev._msg);
	}
	else if (type == ZmOperation.INVITE_REPLY_ACCEPT ||
			type == ZmOperation.EDIT_REPLY_CANCEL ||
			type == ZmOperation.INVITE_REPLY_DECLINE ||
			type == ZmOperation.INVITE_REPLY_TENTATIVE)
	{
		this._editInviteReply(ZmMailListController.INVITE_REPLY_MAP[type], ev._inviteComponentId, null, null, ev._inviteReplyFolderId);
	}
	else {
		var callback = new AjxCallback(this, this._handleInviteReplySent);
		var accountName = ac.multiAccounts && ac.accountList.mainAccount.name;
		this._sendInviteReply(type, ev._inviteComponentId, null, accountName, null, ev._msg, ev._inviteReplyFolderId, callback);
	}
	return false;
};

ZmMailListController.prototype._handleInviteReplySent =
function(result, newPtst) {
	var inviteMsgView = this.getCurrentView().getInviteMsgView();
	if (!inviteMsgView || !newPtst) {
		return;
	}
	inviteMsgView.enableToolbarButtons(newPtst);
	inviteMsgView.updatePtstMsg(newPtst);
};

ZmMailListController.prototype._shareHandler =
function(ev) {
	var msg = this.getMsg();
	var fromAddr = msg ? msg.getAddress(AjxEmailAddress.FROM).address : null;

	if (ev._buttonId == ZmOperation.SHARE_ACCEPT) {
		var acceptDialog = appCtxt.getAcceptShareDialog();
		acceptDialog.setAcceptListener(this._acceptShareListener);
		acceptDialog.popup(ev._share, fromAddr);
	} else if (ev._buttonId == ZmOperation.SHARE_DECLINE) {
		var declineDialog = appCtxt.getDeclineShareDialog();
		declineDialog.setDeclineListener(this._declineShareListener);
		declineDialog.popup(ev._share, fromAddr);
	}
};

ZmMailListController.prototype._subscribeHandler =
function(ev) {
	var req = ev._subscribeReq;
	var statusMsg;
	var approve = false;
	if (ev._buttonId == ZmOperation.SUBSCRIBE_APPROVE) {
		statusMsg = req.subscribe ? ZmMsg.dlSubscribeRequestApproved : ZmMsg.dlUnsubscribeRequestApproved;
		approve = true;
	}
	else if (ev._buttonId == ZmOperation.SUBSCRIBE_REJECT) {
		statusMsg = req.subscribe ? ZmMsg.dlSubscribeRequestRejected : ZmMsg.dlUnsubscribeRequestRejected;
	}

	var jsonObj = {
		DistributionListActionRequest: {
			_jsns: "urn:zimbraAccount",
			dl: {by: "name",
				 _content: req.dl.email
			},
			action: {op: approve ? "acceptSubsReq" : "rejectSubsReq",
					 subsReq: {op: req.subscribe ? "subscribe" : "unsubscribe",
							   _content: req.user.email
					 		  }
					}
		}
	};
	var respCallback = this._subscribeResponseHandler.bind(this, statusMsg);
	appCtxt.getAppController().sendRequest({jsonObj: jsonObj, asyncMode: true, callback: respCallback});

	

};

ZmMailListController.prototype._subscribeResponseHandler =
function(statusMsg, ev) {
	var msg = this.getMsg();
	this._removeActionMsg(msg);
	appCtxt.setStatusMsg(statusMsg);
};


ZmMailListController.prototype._acceptShareHandler =
function(ev) {
	var msg = appCtxt.getById(ev._share._msgId);
	this._removeActionMsg(msg);
};

ZmMailListController.prototype._removeActionMsg =
function(msg) {
	var folder = appCtxt.getById(ZmFolder.ID_TRASH);

	this._listView[this._currentViewId]._itemToSelect = this._getNextItemToSelect();
	var list = msg.list || this.getList();
	var callback = (appCtxt.isChildWindow)
		? (new AjxCallback(this, this._handleAcceptShareInNewWindow)) : null;
	list.moveItems({items: [msg], folder: folder, callback: callback, closeChildWin: appCtxt.isChildWindow});
};

ZmMailListController.prototype._declineShareHandler = ZmMailListController.prototype._acceptShareHandler;

ZmMailListController.prototype._handleAcceptShareInNewWindow =
function() {
	window.close();
};

ZmMailListController.prototype._createViewMenu =
function(view) {
	var btn = this._toolbar[view].getButton(ZmOperation.VIEW_MENU);
	if (!btn) { return; }

	btn.setMenu(new AjxCallback(this, this._setupViewMenuItems, [view, btn]));
	btn.noMenuBar = true;
};


ZmMailListController.prototype._setupViewMenu =
function(view) {

	// always reset the view menu button icon to reflect the current view
	var btn = this._toolbar[view].getButton(ZmOperation.VIEW_MENU);
	if (btn) {
		var viewType = appCtxt.getViewTypeFromId(view);
		btn.setImage(ZmMailListController.GROUP_BY_ICON[viewType]);
	}
};

ZmMailListController.prototype._setupViewMenuItems =
function(view, btn) {

	var menu = this._viewMenu = new ZmPopupMenu(btn, null, null, this);
	btn.setMenu(menu);
    var isExternalAccount = appCtxt.isExternalAccount(),
	    convsEnabled = appCtxt.get(ZmSetting.CONVERSATIONS_ENABLED);

	if (convsEnabled && this.supportsGrouping()) {
		this._setupGroupByMenuItems(view, menu);
	}
	if (menu.getItemCount() > 0) {
		new DwtMenuItem({
			parent: menu,
			style:  DwtMenuItem.SEPARATOR_STYLE
		});
	}
	this._readingPaneViewMenu = this._setupReadingPaneMenu(view, menu);
	if (!isExternalAccount && convsEnabled) {
		this._convOrderViewMenu = this._setupConvOrderMenu(view, menu);
	}

    // add sort and group by menus only if we have headers (not in standalone conv view)
    if (this.supportsSorting()) {
	    this._sortViewMenu = this._setupSortViewMenu(view, menu);
	    this._groupByViewMenu = this._mailListView._getGroupByActionMenu(menu, true, true);
    }

	return menu;
};

ZmMailListController.prototype._setupSortViewMenu = function(view, menu) {

	var	sortMenuItem = menu.createMenuItem(Dwt.getNextId("SORT_"), {
			text:           ZmMsg.sortBy,
			style:          DwtMenuItem.NO_STYLE
		}),
		sortMenu = this._mailListView._setupSortMenu(sortMenuItem, false);

	sortMenuItem.setMenu(sortMenu);

	return sortMenu;
};

ZmMailListController.prototype._setupColHeaderViewMenu = function(view, menu) {

	var	colHeaderMenuItem = this._colHeaderMenuItem = menu.createMenuItem(Dwt.getNextId("COL_HEADER_"), {
			text:           ZmMsg.display,
			style:          DwtMenuItem.NO_STYLE
		}),
		colHeaderMenu = ZmListView.prototype._getActionMenuForColHeader.call(this._mailListView, true, colHeaderMenuItem, "view");

	colHeaderMenuItem.setMenu(colHeaderMenu);

	return colHeaderMenu;
};

// If we're in the Trash or Junk folder, change the "Delete" button tooltip
ZmMailListController.prototype._setupDeleteButton =
function(parent) {
	var folder = this._getSearchFolder();
	var inTrashFolder = (folder && folder.nId == ZmFolder.ID_TRASH);
    var inJunkFolder =  (folder && folder.nId == ZmFolder.ID_SPAM);
    var deleteButton = parent.getButton(ZmOperation.DELETE);
	var deleteMenuButton = parent.getButton(ZmOperation.DELETE_MENU);
	var tooltip = (inTrashFolder || inJunkFolder) ? ZmMsg.deletePermanentTooltip : ZmMsg.deleteTooltip;
	if (deleteButton) {
		deleteButton.setToolTipContent(ZmOperation.getToolTip(ZmOperation.DELETE, this.getKeyMapName(), tooltip), true);
	}
	if (deleteMenuButton) {
		deleteMenuButton.setToolTipContent(ZmOperation.getToolTip(ZmOperation.DELETE_MENU, this.getKeyMapName(), tooltip), true);
	}
};

// If we're in the Spam folder, the "Spam" button becomes the "Not Spam" button
ZmMailListController.prototype._setupSpamButton =
function(parent) {
	if (!parent) { return; }

	var item = parent.getOp(ZmOperation.SPAM);
	if (item) {
		var folderId = this._getSearchFolderId();
		var folder = appCtxt.getById(folderId);
		var inSpamFolder = ((folder && folder.nId == ZmFolder.ID_SPAM) ||
							(!folder && folderId == ZmFolder.ID_SPAM)  ||
                            (this._currentSearch && this._currentSearch.folderId == ZmFolder.ID_SPAM)); // fall back
		var inPopupMenu = (parent.isZmActionMenu);
		if (parent.isZmButtonToolBar) {
			//might still be in a popup if it's in the Actions menu. That's the case now but I do this generically so it works if one day we move it as a main button (might want to do that in the spam folder at least)
			inPopupMenu = parent.getActionsMenu() && parent.getActionsMenu().getOp(ZmOperation.SPAM);
		}

		if (inPopupMenu) {
			item.setText(inSpamFolder ? ZmMsg.notJunkMarkLabel : ZmMsg.junkMarkLabel);
		} else {
			item.setText(inSpamFolder ? ZmMsg.notJunkLabel : ZmMsg.junkLabel);
		}
		item.setImage(inSpamFolder ? 'NotJunk' : 'JunkMail');
		if (item.setToolTipContent) {
			var tooltip = inSpamFolder ? ZmMsg.notJunkTooltip : ZmMsg.junkTooltip;
			item.setToolTipContent(ZmOperation.getToolTip(ZmOperation.SPAM, this.getKeyMapName(), tooltip), true);
		}
		item.isMarkAsSpam = !inSpamFolder;
	}
};

// set tooltip for print button
ZmMailListController.prototype._setupPrintButton =
function(parent) {
    if (!parent) { return; }

    var item = parent.getOp(ZmOperation.PRINT);
    if (item) {
        item.setToolTipContent(ZmMsg.printMultiTooltip, true);
    }
};



/**
 * Gets the selected message.
 * 
 * @param	{Hash}	params		a hash of parameters
 * @return	{ZmMailMsg|ZmConv}		the selected message
 */
ZmMailListController.prototype.getMsg =
function(params) {
	var sel = this._listView[this._currentViewId].getSelection();
	return (sel && sel.length) ? sel[0] : null;
};

ZmMailListController.prototype._filterListener =
function(isAddress, rule) {

	if (isAddress) {
		this._handleResponseFilterListener(rule, this._actionEv.address);
	}
	else {
		this._getLoadedMsg(null, this._handleResponseFilterListener.bind(this, rule));
	}
};


ZmMailListController.prototype._setAddToFilterMenu =
function(parent) {
	if (this._filterMenu) {
		return;
	}

	var menuItem = parent.getOp(ZmOperation.ADD_TO_FILTER_RULE);
	this._filterMenu = new ZmPopupMenu(menuItem);
	menuItem.setMenu(this._filterMenu);

	this._rules = AjxDispatcher.run("GetFilterRules");
	this._rules.addChangeListener(this._rulesChangeListener.bind(this));
	this._resetFilterMenu();
};

ZmMailListController.prototype._resetFilterMenu =
function() {
	var filterItems = this._filterMenu.getItems();
	while (filterItems.length > 0) {
		this._filterMenu.removeChild(filterItems[0]);
	}
	this._rules.loadRules(false, this._populateFiltersMenu.bind(this));
};

ZmMailListController.prototype._populateFiltersMenu =
function(results){
	var filters = results.getResponse();
	var menu = this._filterMenu;

	var newItem = new DwtMenuItem({parent: menu});
	newItem.setText(ZmMsg.newFilter);
	newItem.setImage("Plus");
	newItem.addSelectionListener(this._filterListener.bind(this, true, null));

	if (!filters.size()) {
		return;
	}
	menu.createSeparator();

	for (var i = 0; i < filters.size(); i++) {
		var rule = filters.get(i);
		var mi = new DwtMenuItem({parent: menu});
		mi.setText(AjxStringUtil.clipByLength(rule.name, 20));
		mi.addSelectionListener(this._filterListener.bind(this, true, rule));
	}
};

ZmMailListController.prototype._rulesChangeListener =
function(ev){
	if (ev.handled || ev.type !== ZmEvent.S_FILTER) {
		return;
	}

	this._resetFilterMenu();
	ev.handled = true;
};

ZmMailListController.prototype._createApptListener =
function() {
	this._getLoadedMsg(null, this._handleResponseNewApptListener.bind(this));
};

ZmMailListController.prototype._createTaskListener =
function() {
	this._getLoadedMsg(null, this._handleResponseNewTaskListener.bind(this));
};

ZmMailListController.prototype._handleResponseNewApptListener =
function(msg) {
	if (!msg) { return; }
	if (msg.cloneOf) {
		msg = msg.cloneOf;
	}
	var w = appCtxt.isChildWindow ? window.opener : window;
    var calController = w.AjxDispatcher.run("GetCalController");
    calController.newApptFromMailItem(msg, new Date());
	if (appCtxt.isChildWindow) {
		window.close();
	}
};

ZmMailListController.prototype._handleResponseNewTaskListener =
function(msg) {
	if (!msg) { return; }
	if (msg.cloneOf) {
		msg = msg.cloneOf;
	}
	var w = appCtxt.isChildWindow ? window.opener : window;
    var aCtxt = appCtxt.isChildWindow ? parentAppCtxt : appCtxt;
	w.AjxDispatcher.require(["TasksCore", "Tasks"]);
    aCtxt.getApp(ZmApp.TASKS).newTaskFromMailItem(msg, new Date());
	if (appCtxt.isChildWindow) {
		window.close();
	}
};

ZmMailListController.prototype._handleResponseFilterListener =
function(rule, msgOrAddr) {

	if (!msgOrAddr) {
		return;
	}

	// arg can be ZmMailMsg or String (address)
	var msg = msgOrAddr.isZmMailMsg ? msgOrAddr : null;

	if (msg && msg.cloneOf) {
		msg = msg.cloneOf;
	}
	if (appCtxt.isChildWindow) {
		var mailListController = window.opener.AjxDispatcher.run("GetMailListController");
		mailListController._handleResponseFilterListener(rule, msgOrAddr);
		window.close();
		return;
	}
	
	AjxDispatcher.require(["PreferencesCore", "Preferences"]);
	var editMode = !!rule;
	if (rule) {
		//this is important, without this, in case the user goes to the Filters page, things get messed up and trying to save an
		// edited filter complains about the existence of a filter with the same name.
		rule = this._rules.getRuleByName(rule.name) || rule;
	}
	else {
		rule = new ZmFilterRule();
	}

	if (msg) {
		var listId = msg.getListIdHeader();
		if (listId) {
			rule.addCondition(ZmFilterRule.TEST_HEADER, ZmFilterRule.OP_CONTAINS, listId, ZmMailMsg.HDR_LISTID);
		}
		else {
			var from = msg.getAddress(AjxEmailAddress.FROM);
			if (from) {
				var subjMod = ZmFilterRule.C_ADDRESS_VALUE[ZmFilterRule.C_FROM];
				rule.addCondition(ZmFilterRule.TEST_ADDRESS, ZmFilterRule.OP_CONTAINS, from.address, subjMod);
			}
			var cc = msg.getAddress(AjxEmailAddress.CC);
			if (cc)	{
				var subjMod = ZmFilterRule.C_ADDRESS_VALUE[ZmFilterRule.C_CC];
				rule.addCondition(ZmFilterRule.TEST_ADDRESS, ZmFilterRule.OP_CONTAINS, cc.address, subjMod);
			}
			var xZimbraDL = msg.getXZimbraDLHeader();
			if (xZimbraDL && xZimbraDL.good) {
				var arr = xZimbraDL.good.getArray();
				var max = arr.length < 5 ? arr.length : 5; //limit number of X-Zimbra-DL ids
				for (var i=0; i < max; i++) {
					rule.addCondition(ZmFilterRule.TEST_HEADER, ZmFilterRule.OP_CONTAINS, arr[i].address, ZmMailMsg.HDR_XZIMBRADL);
				}
			}
			var subj = msg.subject;
			if (subj) {
				var subjMod = ZmFilterRule.C_HEADER_VALUE[ZmFilterRule.C_SUBJECT];
				rule.addCondition(ZmFilterRule.TEST_HEADER, ZmFilterRule.OP_IS, subj, subjMod);
			}
			rule.setGroupOp(ZmFilterRule.GROUP_ALL);
		}
	}
	else {
		var subjMod = ZmFilterRule.C_ADDRESS_VALUE[ZmFilterRule.C_FROM];
		rule.addCondition(ZmFilterRule.TEST_ADDRESS, ZmFilterRule.OP_CONTAINS, msgOrAddr.isAjxEmailAddress ? msgOrAddr.address : msgOrAddr, subjMod);
	}

	if (!editMode) {
		rule.addAction(ZmFilterRule.A_KEEP);
	}

	var accountName = appCtxt.multiAccounts && msg && msg.getAccount().name,
		folder = msg && appCtxt.getById(msg.getFolderId()),
		outgoing = !!(folder && folder.isOutbound());

	appCtxt.getFilterRuleDialog().popup(rule, editMode, null, accountName, outgoing);
};

/**
 * Returns the selected msg, ensuring that it's loaded.
 * 
 * @private
 */
ZmMailListController.prototype._getLoadedMsg =
function(params, callback) {
	params = params || {};
	var msg = this.getMsg(params);
	if (!msg) {
		callback.run();
	}
	if (msg._loaded && !params.forceLoad) {
		callback.run(msg);
	} else {
		if (msg.id == this._pendingMsg) { return; }
		msg._loadPending = true;
		this._pendingMsg = msg.id;
		params.markRead = (params.markRead != null) ? params.markRead : this._handleMarkRead(msg, true);
		// use prototype in callback because these functions are overridden by ZmConvListController
		var respCallback = new AjxCallback(this, ZmMailListController.prototype._handleResponseGetLoadedMsg, [callback, msg]);
		msg.load({getHtml:params.getHtml, markRead:params.markRead, callback:respCallback, noBusyOverlay:false, forceLoad: params.forceLoad, noTruncate: params.noTruncate});
	}
};

ZmMailListController.prototype._handleResponseGetLoadedMsg =
function(callback, msg) {
	if (this._pendingMsg && (msg.id != this._pendingMsg)) { return; }
	msg._loadPending = false;
	this._pendingMsg = null;
	callback.run(msg);
};

ZmMailListController.prototype._getInviteReplyBody =
function(type, instanceDate, isResourceInvite) {
	var replyBody;

	if (instanceDate) {
		switch (type) {
			case ZmOperation.REPLY_ACCEPT:		replyBody = ZmMsg.defaultInviteReplyAcceptInstanceMessage; break;
			case ZmOperation.REPLY_CANCEL:		replyBody = ZmMsg.apptInstanceCanceled; break;
			case ZmOperation.REPLY_DECLINE:		replyBody = ZmMsg.defaultInviteReplyDeclineInstanceMessage; break;
			case ZmOperation.REPLY_TENTATIVE: 	replyBody = ZmMsg.defaultInviteReplyTentativeInstanceMessage; break;
		}

		if (isResourceInvite) {
			switch (type) {
				case ZmOperation.REPLY_ACCEPT:		replyBody = ZmMsg.defaultInviteReplyResourceAcceptInstanceMessage; break;
				case ZmOperation.REPLY_CANCEL:		replyBody = ZmMsg.apptInstanceCanceled; break;
				case ZmOperation.REPLY_DECLINE:		replyBody = ZmMsg.defaultInviteReplyResourceDeclineInstanceMessage; break;
				case ZmOperation.REPLY_TENTATIVE: 	replyBody = ZmMsg.defaultInviteReplyResourceTentativeInstanceMessage; break;
			}
		}

		if (replyBody) {
			return AjxMessageFormat.format(replyBody, instanceDate);
		}
	}
	switch (type) {
		case ZmOperation.REPLY_ACCEPT:		replyBody = ZmMsg.defaultInviteReplyAcceptMessage; break;
		case ZmOperation.REPLY_CANCEL:		replyBody = ZmMsg.apptCanceled; break;
		case ZmOperation.DECLINE_PROPOSAL:  replyBody = ""; break;
		case ZmOperation.REPLY_DECLINE:		replyBody = ZmMsg.defaultInviteReplyDeclineMessage; break;
		case ZmOperation.REPLY_TENTATIVE: 	replyBody = ZmMsg.defaultInviteReplyTentativeMessage; break;
		case ZmOperation.REPLY_NEW_TIME: 	replyBody = ZmMsg.defaultInviteReplyNewTimeMessage;	break;
	}

	if (isResourceInvite) {
		switch (type) {
			case ZmOperation.REPLY_ACCEPT:		replyBody = ZmMsg.defaultInviteReplyResourceAcceptMessage; break;
			case ZmOperation.REPLY_CANCEL:		replyBody = ZmMsg.apptCanceled; break;
			case ZmOperation.REPLY_DECLINE:		replyBody = ZmMsg.defaultInviteReplyResourceDeclineMessage; break;
			case ZmOperation.REPLY_TENTATIVE: 	replyBody = ZmMsg.defaultInviteReplyResourceTentativeMessage; break;
			case ZmOperation.REPLY_NEW_TIME: 	replyBody = ZmMsg.defaultInviteReplyNewTimeMessage;	break;
		}
	}

	//format the escaped apostrophe in ZmMsg entry
	if (replyBody) {
		replyBody =  AjxMessageFormat.format(replyBody, []);
	}
	return replyBody;
};

ZmMailListController.prototype._getInviteReplySubject =
function(type) {
	var replySubject = null;
	switch (type) {
		case ZmOperation.REPLY_ACCEPT:		replySubject = ZmMsg.subjectAccept + ": "; break;
		case ZmOperation.DECLINE_PROPOSAL:	replySubject = ZmMsg.subjectDecline + " - "; break;
		case ZmOperation.REPLY_DECLINE:		replySubject = ZmMsg.subjectDecline + ": "; break;
		case ZmOperation.REPLY_TENTATIVE:	replySubject = ZmMsg.subjectTentative + ": "; break;
		case ZmOperation.REPLY_NEW_TIME:	replySubject = ZmMsg.subjectNewTime + ": "; break;
	}
	return replySubject;
};

ZmMailListController.prototype._editInviteReply =
function(action, componentId, instanceDate, accountName, acceptFolderId) {
	var replyBody = this._getInviteReplyBody(action, instanceDate);
	this._doAction({action:action, extraBodyText:replyBody, instanceDate:instanceDate, accountName:accountName, acceptFolderId: acceptFolderId});
};

ZmMailListController.prototype._acceptProposedTime =
function(componentId, origMsg) {
	var invite = origMsg.invite;
	var apptId = invite.getAppointmentId();
	var ac = window.parentAppCtxt || window.appCtxt;
	var controller = ac.getApp(ZmApp.CALENDAR).getCalController();
	var callback = new AjxCallback(this, this._handleAcceptDeclineProposedTime, [origMsg]);
	controller.acceptProposedTime(apptId, invite, appCtxt.isChildWindow ? null : callback);
	if (appCtxt.isChildWindow) {
		window.close();
	}
};

ZmMailListController.prototype._declineProposedTime =
function(componentId, origMsg) {
	var replyBody = this._getInviteReplyBody(ZmOperation.DECLINE_PROPOSAL);
	var callback = new AjxCallback(this, this._handleAcceptDeclineProposedTime, [origMsg]);
	this._doAction({action:ZmOperation.DECLINE_PROPOSAL, extraBodyText:replyBody, instanceDate:null, sendMsgCallback: callback});
};

ZmMailListController.prototype._handleAcceptDeclineProposedTime =
function(origMsg) {
	this._doDelete([origMsg]);
};

ZmMailListController.prototype._sendInviteReply =
function(type, componentId, instanceDate, accountName, ignoreNotify, origMsg, acceptFolderId, callback) {
	var msg = new ZmMailMsg();
	AjxDispatcher.require(["MailCore", "CalendarCore"]);

	msg._origMsg = origMsg || this.getMsg();
	msg.inviteMode = type;
	msg.isReplied = true;
	msg.isForwarded = false;
	msg.isInviteReply = true;
	msg.acceptFolderId = acceptFolderId;
	msg.folderId = msg._origMsg.folderId;

	var replyActionMode = ZmMailListController.REPLY_ACTION_MAP[type] ? ZmMailListController.REPLY_ACTION_MAP[type] : type;
	var replyBody = this._getInviteReplyBody(replyActionMode, instanceDate, msg._origMsg.isResourceInvite());
	if (replyBody != null) {
		var dummyAppt = new ZmAppt();
		dummyAppt.setFromMessage(msg._origMsg);

		var tcontent = dummyAppt.getTextSummary() + "\n" + replyBody;
		var textPart = new ZmMimePart();
		textPart.setContentType(ZmMimeTable.TEXT_PLAIN);
		textPart.setContent(tcontent);

		var hcontent = dummyAppt.getHtmlSummary() + "<p>" + replyBody + "</p>";
		var htmlPart = new ZmMimePart();
		htmlPart.setContentType(ZmMimeTable.TEXT_HTML);
		htmlPart.setContent(hcontent);

		var topPart = new ZmMimePart();
		topPart.setContentType(ZmMimeTable.MULTI_ALT);
		topPart.children.add(textPart);
		topPart.children.add(htmlPart);

		msg.setTopPart(topPart);
	}
	var subject = this._getInviteReplySubject(replyActionMode) + msg._origMsg.invite.getEventName();
	if (subject != null) {
		msg.setSubject(subject);
	}
	var errorCallback = new AjxCallback(this, this._handleErrorInviteReply);
	msg.sendInviteReply(true, componentId, callback, errorCallback, instanceDate, accountName, ignoreNotify);
};

ZmMailListController.prototype._handleErrorInviteReply =
function(result) {
	if (result.code == ZmCsfeException.MAIL_NO_SUCH_ITEM) {
		var dialog = appCtxt.getErrorDialog();
		dialog.setMessage(ZmMsg.inviteOutOfDate);
		dialog.popup(null, true);
		return true;
	}
};

ZmMailListController.prototype._spamListener =
function(ev) {
	var items = this._listView[this._currentViewId].getSelection();
	var button = this.getCurrentToolbar().getButton(ZmOperation.SPAM);

	this._doSpam(items, button.isMarkAsSpam);
};

ZmMailListController.prototype._detachListener =
function(ev, callback) {
	var msg = this.getMsg();
	if (msg) {
		if (msg._loaded) {
			ZmMailMsgView.detachMsgInNewWindow(msg, false, this);
			// always mark a msg read if it is displayed in its own window
			if (msg.isUnread && !appCtxt.getById(msg.folderId).isReadOnly()) {
				msg.list.markRead({items:[msg], value:true});
			}
		} else {
			ZmMailMsgView.rfc822Callback(msg.id, null, this);
		}
	}
	if (callback) { callback.run(); }
};

ZmMailListController.prototype._printListener =
function(ev) {
	var listView = this._listView[this._currentViewId];
	var items = listView.getSelection();
	items = AjxUtil.toArray(items);
	var ids = [];
	var showImages = false;
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		// always extract out the msg ids from the conv
		if (item.toString() == "ZmConv") {
			// get msg ID in case of virtual conv.
			// item.msgIds.length is inconsistent, so checking if conv id is negative.
			if (appCtxt.isOffline && item.id.split(":")[1]<0) {
				ids.push(item.msgIds[0]);
			} else {
				ids.push("C:"+item.id);
			}
			if (item.isZmConv) {
				var msgList = item.getMsgList();
				for(var j=0; j<msgList.length; j++) {
					if(msgList[j].showImages) {
						showImages = true;
						break;
					}
				}
			}
		} else {
			ids.push(item.id);
			if (item.showImages) {
				showImages = true;
			}
		}
	}
	var url = ("/h/printmessage?id=" + ids.join(",")) + "&tz=" + AjxTimezone.getServerId(AjxTimezone.DEFAULT);
	if (appCtxt.get(ZmSetting.DISPLAY_EXTERNAL_IMAGES) || showImages) {
		url = url+"&xim=1";
	}
    if (appCtxt.isOffline) {
        var acctName = items[0].getAccount().name;
        url+="&acct=" + acctName ;
    }
    window.open(appContextPath+url, "_blank");
};

ZmMailListController.prototype._editListener =
function(isEditAsNew, ev) {
    this._doAction({ev:ev, action:ZmOperation.DRAFT, isEditAsNew:isEditAsNew});
};

ZmMailListController.prototype._muteUnmuteConvListener =
function(ev) {
    var status = this._getConvMuteStatus();
    if (status.hasUnmuteConv) {
        this._muteConvListener();
    }
    else {
        this._unmuteConvListener();
    }
};

ZmMailListController.prototype._muteConvListener =
function(ev) {
    var listView = this._listView[this._currentView];
	var items = listView.getSelection();
	items = AjxUtil.toArray(items);
    var markReadcallback = this._getMarkReadCallback();
    var callback = new AjxCallback(this, this._handleMuteUnmuteConvResponse, [markReadcallback, ZmId.OP_MUTE_CONV]);
    this._doMarkMute(items, true, callback, true);
};

ZmMailListController.prototype._unmuteConvListener =
function(ev) {
    var listView = this._listView[this._currentView];
	var items = listView.getSelection();
	items = AjxUtil.toArray(items);
    var convListView = this._mailListView || this._parentController._mailListView;
    //When a conv is unmuted it needs to be rearranged in the list as per its sorting order. convListCallback will handle it.
    var convListCallback = null;
    if(convListView && convListView.toString() == "ZmConvListView") {
        convListCallback = new AjxCallback(convListView, convListView.handleUnmuteConv, items);
    }
    var callback = new AjxCallback(this, this._handleMuteUnmuteConvResponse, [convListCallback, ZmId.OP_UNMUTE_CONV]);
    this._doMarkMute(items, false, callback, true);
};

ZmMailListController.prototype._handleMuteUnmuteConvResponse =
function(callback, actionId, result) {
    if(callback != null) {
        callback.run();
    }
};

ZmMailListController.prototype._checkMailListener =
function() {
	if (appCtxt.isOffline) {
		var callback = new AjxCallback(this, this._handleSyncAll);
		appCtxt.accountList.syncAll(callback);
	}

	var folder = this._getSearchFolder();
	var isFeed = (folder && folder.isFeed());
	if (isFeed) {
		folder.sync();
	} else {
		var hasExternalAccounts = false;
		if (!appCtxt.isOffline) {
			var isEnabled = appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED) || appCtxt.get(ZmSetting.IMAP_ACCOUNTS_ENABLED);
			if (folder && !isFeed && isEnabled) {
				var dataSources = folder.getDataSources(null, true);
				if (dataSources) {
					hasExternalAccounts = true;
					var dsCollection = AjxDispatcher.run("GetDataSourceCollection");
					dsCollection.importMail(dataSources);
				}
			}
		}

		if ((folder && folder.nId == ZmFolder.ID_INBOX) || !hasExternalAccounts) {
			appCtxt.getAppController().sendNoOp();
		}
	}
};

ZmMailListController.prototype._handleSyncAll =
function() {
	//doesn't do anything now after I removed the appCtxt.get(ZmSetting.GET_MAIL_ACTION) == ZmSetting.GETMAIL_ACTION_DEFAULT preference stuff
};

ZmMailListController.prototype.runRefresh =
function() {
	this._checkMailListener();
};

ZmMailListController.prototype._sendReceiveListener =
function(ev) {
	var account = appCtxt.accountList.getAccount(ev.item.getData(ZmOperation.MENUITEM_ID));
	if (account) {
		account.sync();
	}
};

ZmMailListController.prototype._folderSearch =
function(folderId) {
	appCtxt.getSearchController().search({query:"in:" + ZmFolder.QUERY_NAME[folderId]});
};

// Miscellaneous

// Adds "By Conversation" and "By Message" to a view menu
ZmMailListController.prototype._setupGroupByMenuItems =
function(view, menu) {

	for (var i = 0; i < ZmMailListController.GROUP_BY_VIEWS.length; i++) {
		var id = ZmMailListController.GROUP_BY_VIEWS[i];
		var mi = menu.createMenuItem(id, {image:	ZmMailListController.GROUP_BY_ICON[id],
										  text:		ZmMsg[ZmMailListController.GROUP_BY_MSG_KEY[id]],
										  shortcut:	ZmMailListController.GROUP_BY_SHORTCUT[id],
										  style:	DwtMenuItem.RADIO_STYLE});
		mi.setData(ZmOperation.MENUITEM_ID, id);
		mi.addSelectionListener(this._listeners[ZmOperation.VIEW]);
		if (id == this.getDefaultViewType()) {
			mi.setChecked(true, true);
		}
	}
};

ZmMailListController.prototype._setReplyText =
function(parent) {
	if (parent && appCtxt.get(ZmSetting.REPLY_MENU_ENABLED)) {
		var op = parent.getOp(ZmOperation.REPLY_MENU);
		if (op) {
			var menu = op.getMenu();
			var replyOp = menu.getOp(ZmOperation.REPLY);
			replyOp.setText(ZmMsg.replySender);
		}
	}
};

ZmMailListController.prototype._resetOperations =
function(parent, num) {

	ZmListController.prototype._resetOperations.call(this, parent, num);

	var isWebClientOffline = appCtxt.isWebClientOffline();
	parent.enable(ZmOperation.PRINT, (num > 0) && !isWebClientOffline );
	parent.enable(ZmOperation.SHOW_ORIG, !isWebClientOffline);

	if (this.isSyncFailuresFolder()) {
		parent.enableAll(false);
		parent.enable([ZmOperation.NEW_MENU], true);
		parent.enable([ZmOperation.DELETE, ZmOperation.FORWARD], num > 0);
		return;
	}

	var item;
	if (num == 1 && !this.isDraftsFolder()) {
		var sel = this._listView[this._currentViewId].getSelection();
		if (sel && sel.length) {
			item = sel[0];
		}
	}
	
	// If one item is selected, use its folder; otherwise check if search was constrained to a folder
	var itemFolder = item && item.folderId && appCtxt.getById(item.folderId);
	var folder = itemFolder;
	if (!folder) {
		var folderId = this._getSearchFolderId(true);
		folder = folderId && appCtxt.getById(folderId);
	}

	var isDrafts = (item && item.isDraft && (item.type != ZmId.ITEM_CONV || item.numMsgs == 1)) || this.isDraftsFolder();
	var isFeed = (folder && folder.isFeed());
	var isReadOnly = (folder && folder.isReadOnly());
    var isOutboxFolder = this.isOutboxFolder();
	parent.setItemVisible(ZmOperation.EDIT, (isDrafts || isOutboxFolder) && (!folder || !folder.isReadOnly()));
	parent.setItemVisible(ZmOperation.EDIT_AS_NEW, !(isDrafts || isOutboxFolder));

	parent.setItemVisible(ZmOperation.REDIRECT, !(isDrafts || isOutboxFolder));
	parent.enable(ZmOperation.REDIRECT, !(isDrafts || isOutboxFolder || isWebClientOffline));

	parent.setItemVisible(ZmOperation.MARK_READ, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.MARK_UNREAD, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.FLAG, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.UNFLAG, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.SPAM, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.DETACH, !(isDrafts || isOutboxFolder));

	parent.enable(ZmOperation.MOVE_MENU, !(isDrafts || isOutboxFolder) && num > 0);

	parent.enable(ZmOperation.DETACH, (appCtxt.get(ZmSetting.DETACH_MAILVIEW_ENABLED) && !(isDrafts || isOutboxFolder || isWebClientOffline) && num == 1));

	/*if (parent.isZmActionMenu) {
		parent.setItemVisible(ZmOperation.QUICK_COMMANDS, !isDrafts && parent._hasQuickCommands);
	} else {
		parent.setItemVisible(ZmOperation.QUICK_COMMANDS, !isDrafts);
	} */

	parent.setItemVisible(ZmOperation.ADD_FILTER_RULE, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.CREATE_APPT, !(isDrafts || isOutboxFolder));
	parent.setItemVisible(ZmOperation.CREATE_TASK, !(isDrafts || isOutboxFolder));
    parent.setItemVisible(ZmOperation.ACTIONS_MENU, !isOutboxFolder);

	// bug fix #37154 - disable non-applicable buttons if rfc/822 message
	var isRfc822 = appCtxt.isChildWindow && window.newWindowParams && window.newWindowParams.isRfc822;
	if (isRfc822 || (isReadOnly && num > 0)) {
		parent.enable([ZmOperation.DELETE, ZmOperation.MOVE, ZmOperation.MOVE_MENU, ZmOperation.SPAM, ZmOperation.TAG_MENU], false);
	} else {
		parent.enable([ZmOperation.REPLY, ZmOperation.REPLY_ALL], (!(isDrafts || isOutboxFolder) && !isFeed && num == 1));
		parent.enable([ZmOperation.VIEW_MENU], true);
		parent.enable([ZmOperation.FORWARD, ZmOperation.SPAM], (!(isDrafts || isOutboxFolder) && num > 0));
	}

	if (this._draftsActionMenu) {
		var editMenu = this._draftsActionMenu.getOp(ZmOperation.EDIT);
		if (editMenu) {
			// Enable|disable 'edit' context menu item based on selection count
			editMenu.setEnabled(num == 1 && (this.isDraftsFolder() || !isReadOnly));
		}
	}

	var search = appCtxt.getCurrentSearch();
	if (appCtxt.multiAccounts && num > 1 && search && search.isMultiAccount()) {
		parent.enable(ZmOperation.TAG_MENU, false);
	}

    if (appCtxt.isExternalAccount()) {
        parent.enable(
                        [
                            ZmOperation.REPLY,
                            ZmOperation.REPLY_ALL,
                            ZmOperation.FORWARD,
                            ZmOperation.EDIT_AS_NEW,
                            ZmOperation.REDIRECT,
                            ZmOperation.MARK_READ,
                            ZmOperation.MARK_UNREAD,
                            ZmOperation.SPAM,
                            ZmOperation.MOVE,
                            ZmOperation.MOVE_MENU,
                            ZmOperation.DELETE,
                            ZmOperation.DETACH,
                            ZmOperation.ADD_FILTER_RULE,
                            ZmOperation.CREATE_APPT,
                            ZmOperation.SEARCH_TO,
                            ZmOperation.SEARCH,
                            ZmOperation.CREATE_TASK
                        ],
                        false
                    );
        parent.setItemVisible(ZmOperation.TAG_MENU, false);
    }

	this._cleanupToolbar(parent);
};

ZmMailListController.prototype._showMailItem =
function() {
	var avm = appCtxt.getAppViewMgr();
	this._setup(this._currentViewId);
	var elements = this.getViewElements(this._currentViewId, this._view[this._currentViewId]);

	var curView = avm.getCurrentViewId();
	var tabId = ZmMailListController.viewToTab[curView] || Dwt.getNextId();
	ZmMailListController.viewToTab[this._currentViewId] = tabId;
	var viewParams = {
		view:		this._currentViewId,
		viewType:	this._currentViewType,
		elements:	elements,
		hide:		this._elementsToHide,
		clear:		appCtxt.isChildWindow,
		tabParams:	this._getTabParams(tabId, this._tabCallback.bind(this))
	};
	var buttonText = (this._conv && this._conv.subject) ? this._conv.subject.substr(0, ZmAppViewMgr.TAB_BUTTON_MAX_TEXT) : (this._msg && this._msg.subject && this._msg.subject.substr(0, ZmAppViewMgr.TAB_BUTTON_MAX_TEXT)) ||   ZmMsgController.DEFAULT_TAB_TEXT;

	this._setView(viewParams);
	avm.setTabTitle(this._currentViewId, buttonText);
	this._resetOperations(this._toolbar[this._currentViewId], 1); // enable all buttons
	this._resetNavToolBarButtons();
};


/**
 * if parent is a toolbar, it might have an actionsMenu. If it does, we can clean up the separators in that menu.
 * (to prevent multiple consecutive separators, etc)
 * @param parent
 */
ZmMailListController.prototype._cleanupToolbar =
function(parent) {
	//cleanup the separators of the toolbar Actions menu
	if (!parent.getActionsMenu) {
		return;
	}
	var actionsMenu = parent.getActionsMenu();
	if (!actionsMenu) {
		return;
	}
	actionsMenu.cleanupSeparators();
};



// Enable mark read/unread as appropriate.
ZmMailListController.prototype._enableFlags =
function(menu) {
    if(appCtxt.isExternalAccount()) {
        menu.enable([ZmOperation.MARK_READ, ZmOperation.MARK_UNREAD, ZmOperation.FLAG, ZmOperation.UNFLAG], false);
        return;
    }
	var status = this._getReadStatus();
	menu.enable(ZmOperation.MARK_READ, status.hasUnread);
	menu.enable(ZmOperation.MARK_UNREAD, status.hasRead);
	menu.enable(ZmOperation.FLAG, status.hasUnflagged);
	menu.enable(ZmOperation.UNFLAG, status.hasFlagged);

    if (appCtxt.isWebClientOffline()) {
        menu.enable([ZmOperation.ADD_FILTER_RULE,ZmOperation.CREATE_APPT, ZmOperation.CREATE_TASK], false);
    }
};

// Enable mark read/unread as appropriate.
ZmMailListController.prototype._enableMuteUnmute =
function(menu) {
    menu.enable([ZmOperation.UNMUTE_CONV, ZmOperation.MUTE_CONV], false);
    if (appCtxt.isExternalAccount() || appCtxt.isChildWindow || this._app.getGroupMailBy() === ZmItem.MSG) {
        return;
    }
    var status = this._getConvMuteStatus();
    if (status.hasMuteConv && status.hasUnmuteConv) {
        menu.enable(ZmOperation.UNMUTE_CONV, true);
        menu.enable(ZmOperation.MUTE_CONV, true);
    }
	else if (status.hasMuteConv) {
         menu.enable(ZmOperation.UNMUTE_CONV, true);
    }
    else {
         menu.enable(ZmOperation.MUTE_CONV, true);
    }
};

/**
* This method is actually called by a pushed view's controller when a user
* attempts to page conversations (from CV) or messages (from MV ala TV).
* We want the underlying view (CLV or MLV) to update itself silently as it
* feeds the next/prev conv/msg to its respective controller.
*
* @param {ZmItem}	currentItem	the current item
* @param {Boolean}	forward		if <code>true</code>, get next item rather than previous
* 
* @private
*/
ZmMailListController.prototype.pageItemSilently =
function(currentItem, forward, msgController) {

	var newItem = this._getNextItem(currentItem, forward);
	if (newItem) {
		if (msgController) {
			msgController.inactive = true; //make it inactive so it can be reused instead of creating a new one for each item paged.
		}
		var lv = this._listView[this._currentViewId];
		lv.emulateDblClick(newItem);
	}
};

ZmMailListController.prototype._getNextItem =
function(currentItem, forward) {

	var list = this._list.getArray();
	var len = list.length;
	for (var i = 0; i < len; i++) {
		if (currentItem == list[i]) {
			break;
		}
	}
	if (i == len) { return; }

	var itemIdx = forward ? i + 1 : i - 1;

	if (itemIdx >= len) {
		//we are looking for the next item after the current list, not yet loaded
		if (!this._list.hasMore()) {
			return;
		}
		this._paginate(this._currentViewId, true, itemIdx);
		return;
	}
	return list[itemIdx];
};

/**
 * Selects and displays an item that has been loaded into a page that's
 * not visible (eg getting the next conv from within the last conv on a page).
 *
 * @param view			[constant]		current view
 * @param saveSelection	[boolean]		if true, maintain current selection
 * @param loadIndex		[int]			index of item to show
 * @param result			[ZmCsfeResult]	result of SOAP request
 * 
 * @private
 */
ZmMailListController.prototype._handleResponsePaginate =
function(view, saveSelection, loadIndex, offset, result) {
	ZmListController.prototype._handleResponsePaginate.apply(this, arguments);

	var newItem = loadIndex ? this._list.getVector().get(loadIndex) : null;
	if (newItem) {
		this._listView[this._currentViewId].emulateDblClick(newItem);
	}
};

ZmMailListController.prototype._getMenuContext =
function() {
	return this.getCurrentViewId();
};

// Flag mail items(override ZmListController to add hook to zimletMgr
ZmMailListController.prototype._doFlag =
function(items, on) {
	ZmListController.prototype._doFlag.call(this, items, on);
	appCtxt.notifyZimlets("onMailFlagClick", [items, on]);
};

// Tag/untag items(override ZmListController to add hook to zimletMgr
ZmMailListController.prototype._doTag =
function(items, tag, doTag) {
	ZmListController.prototype._doTag.call(this, items, tag, doTag);
	appCtxt.notifyZimlets("onTagAction", [items, tag, doTag]);
};


/**
 * Returns the next/previous/first/last unread item in the list, based on what's
 * currently selected.
 *
 * @param which		[constant]		DwtKeyMap constant for selecting next/previous/first/last
 * @param type		[constant]*		if present, only return this type of item
 * @param noBump	[boolean]*		if true, start with currently selected item
 * 
 * @private
 */
ZmMailListController.prototype._getUnreadItem =
function(which, type, noBump) {

	var lv = this._listView[this._currentViewId];
	var vec = lv.getList(true);
	var list = vec && vec.getArray();
	var size = list && list.length;
	if (!size) { return; }

	var start, index;
	if (which == DwtKeyMap.SELECT_FIRST) {
		index = 0;
	} else if (which == DwtKeyMap.SELECT_LAST) {
		index = list.length - 1;
	} else {
		var sel = lv.getSelection();
		var start, index;
		if (sel && sel.length) {
			start = (which == DwtKeyMap.SELECT_NEXT) ? sel[sel.length - 1] : sel[0];
		} else {
			start = (which == DwtKeyMap.SELECT_NEXT) ? list[0] : list[list.length - 1];
		}
		if (start) {
			var startIndex = lv.getItemIndex(start, true);
			if (sel && sel.length && !noBump) {
				index = (which == DwtKeyMap.SELECT_NEXT) ? startIndex + 1 : startIndex - 1;
			} else {
				index = startIndex;
			}
		}
	}

	var unreadItem = null;
	while ((index >= 0 && index < size) && !unreadItem) {
		var item = list[index];
		if (item.isUnread && (!type || item.type == type)) {
			unreadItem = item;
		} else {
			index = (which == DwtKeyMap.SELECT_NEXT || which == DwtKeyMap.SELECT_FIRST) ? index + 1 : index - 1;
		}
	}

	return unreadItem;
};

ZmMailListController.prototype._getNextItemToSelect = function() {};

ZmMailListController.prototype.addTrustedAddr =
function(value, callback, errorCallback) {
    var soapDoc = AjxSoapDoc.create("ModifyPrefsRequest", "urn:zimbraAccount"),
        node,
        i;

    for(i=0; i<value.length;i++) {
        node = soapDoc.set("pref", AjxStringUtil.trim(value[i]));
        node.setAttribute("name", "zimbraPrefMailTrustedSenderList");
    }

    return appCtxt.getAppController().sendRequest({
       soapDoc: soapDoc,
       asyncMode: true,
       callback: callback,
       errorCallback: errorCallback
    });
};

/**
 * @private
 */
ZmMailListController.prototype._getActiveSearchFolderId =
function() {
	var s = this._activeSearch && this._activeSearch.search;
	return s && s.folderId;
};

/**
 * @private
 */
ZmMailListController.prototype._getActiveSearchFolder =
function() {
	var id = this._getActiveSearchFolderId();
	return id && appCtxt.getById(id);
};

/* ZmMailListController.prototype._quickCommandMenuHandler = function(evt, batchCmd) {
    var selectedItems = this.getItems();

    ZmListController.prototype._quickCommandMenuHandler.call(this, evt);

    if (!selectedItems || !selectedItems.length) {return;}

    var menuItem = evt.dwtObj;
    var quickCommand = menuItem.getData(Dwt.KEY_OBJECT);
    if (!quickCommand) {return;}
            
    var actions = quickCommand.actions;
    var len = actions.length;
    for (var i = 0; i < len; i++) {
        var action = actions[i];
        if (!action.isActive) {continue;}
        var actionValue = action.value;
        if (action.type == ZmQuickCommandAction[ZmFilterRule.A_NAME_FLAG]) {
            if (actionValue == "read" || actionValue == "unread") {
                this._doMarkRead(selectedItems, (actionValue == "read"));
            }
        }
    }
};
*/

/**
* Deletes one or more items from the list.
*
* @param items			[Array]			list of items to delete
* @param hardDelete		[boolean]*		if true, physically delete items
* @param attrs			[Object]*		additional attrs for SOAP command
* @param confirmDelete  [Boolean]       user already confirmed hard delete (see ZmBriefcaseController.prototype._doDelete and ZmBriefcaseController.prototype._doDelete2)
*
* @private
*/
ZmMailListController.prototype._doDelete =
function(items, hardDelete, attrs, confirmDelete) {

    var messages = AjxUtil.toArray(items);
    if (!messages.length) { return; }

    // Check if need to warn the user about violating the keep retention policy.  If a warning
    // dialog is displayed, the callback from that dialog allows the user to delete messages
    var warningIssued = this._doRetentionPolicyWarning(messages,
        ZmListController.prototype._doDelete, [hardDelete, attrs, false]);
    if (!warningIssued) {
        // No retention policy, or all the chosen messages fall outside the retention period.
        ZmListController.prototype._doDelete.call(this, messages, hardDelete, attrs, confirmDelete);
    }
};

ZmMailListController.prototype._doMove =
function(items, destinationFolder, attrs, isShiftKey) {
    var messages = AjxUtil.toArray(items);
    if (!messages.length) { return; }

    var warningIssued = false;

    if (destinationFolder && (destinationFolder.nId == ZmFolder.ID_TRASH)) {
        // Check if need to warn the user about violating the keep retention policy.  If a warning
        // dialog is displayed, the callback from that dialog allows the user to trash messages
        warningIssued = this._doRetentionPolicyWarning(messages,
            ZmListController.prototype._doMove, [destinationFolder, attrs, isShiftKey]);
    }
    if (!warningIssued) {
        // No retention policy, or all the chosen messages fall outside the retention period.
        ZmListController.prototype._doMove.call(this, items, destinationFolder, attrs, isShiftKey);
    }
}

ZmMailListController.prototype._doRetentionPolicyWarning =
function(messages, callbackFunc, args) {
    var numWithinRetention = 0;
    var folder;
    var keepPolicy;
    var now = new Date();
    var validMessages = [];
    var policyStartMsec = {};
    for (var i = 0; i < messages.length; i++) {
        var folderId = messages[i].folderId;
        if (!policyStartMsec[folderId]) {
            policyStartMsec[folderId] = -1;
            folder = appCtxt.getById(folderId);
            keepPolicy = (folder ? folder.getRetentionPolicy(ZmOrganizer.RETENTION_KEEP) : null);
            if (keepPolicy) {
                // Calculate the current start of this folder's keep (retention) period
                var keepLifetimeMsec = folder.getRetentionPolicyLifetimeMsec(keepPolicy);
                policyStartMsec[folderId] = now.getTime() - keepLifetimeMsec;
            }
        }
        if (policyStartMsec[folderId] > 0) {
            // Determine which messages are not affected by the retention policy (i.e.
            // their age exceeds that mandated by the policy)
            if (messages[i].date < policyStartMsec[folderId]) {
                validMessages.push(messages[i]);
            }
        } else {
            // The message's folder does not have a retention policy
            validMessages.push(messages[i]);
        }
    }

    numWithinRetention = messages.length - validMessages.length;
    if (numWithinRetention > 0) {
        // Create the base warning text
        var warningMsg = ((numWithinRetention == 1) ?
                            ZmMsg.retentionKeepWarning :
                            AjxMessageFormat.format(ZmMsg.retentionKeepWarnings,[numWithinRetention.toString()])) +
                         "<BR><BR>";

        if (validMessages.length == 0) {
            // All the chosen messages fall within the retention period
            this._showSimpleRetentionWarning(warningMsg, messages, callbackFunc, args);
        } else {
            // A mix of messages - some outside the retention period, some within.
            warningMsg += ZmMsg.retentionDeleteAllExplanation + "<BR><BR>" +
                          ((validMessages.length == 1) ?
                              ZmMsg.retentionDeleteValidExplanation :
                              AjxMessageFormat.format(ZmMsg.retentionDeleteValidExplanations,[validMessages.length.toString()]));
            this._showRetentionWarningDialog(warningMsg, messages, validMessages, callbackFunc, args);
        }
    }

    return numWithinRetention != 0;
}

ZmMailListController.prototype._showSimpleRetentionWarning =
function(warningMsg, messages, callbackFunc, args) {
    warningMsg += (messages.length == 1) ? ZmMsg.retentionDeleteOne :
                                           ZmMsg.retentionDeleteMultiple;
    // This assumes that the first parameter of the OK function is the messages
    // to be processed, followed by other arbitrary parameters
    var okArgs = [messages].concat(args);
    var callback = new AjxCallback(this, callbackFunc,okArgs);

    var okCancelDialog = appCtxt.getOkCancelMsgDialog();
    okCancelDialog.registerCallback(DwtDialog.OK_BUTTON,
        this._handleRetentionWarningOK, this, [okCancelDialog, callback]);
    okCancelDialog.setMessage(warningMsg, DwtMessageDialog.WARNING_STYLE);
    okCancelDialog.setVisible(true);
    okCancelDialog.popup();
}


ZmMailListController.prototype._showRetentionWarningDialog =
function(warningMsg, messages, validMessages, callbackFunc, args) {
    var retentionDialog = appCtxt.getRetentionWarningDialog();
	retentionDialog.reset();

    var callback;
    // This assumes that the first parameter of the OK function is the messages
    // to be processed, followed by other arbitrary parameters
    var allArgs = [messages].concat(args);
    callback = new AjxCallback(this, callbackFunc, allArgs);
    retentionDialog.registerCallback(ZmRetentionWarningDialog.DELETE_ALL_BUTTON,
        this._handleRetentionWarningOK, this, [retentionDialog, callback]);

    var oldArgs = [validMessages].concat(args);
    callback = new AjxCallback(this, callbackFunc, oldArgs);
    retentionDialog.registerCallback(ZmRetentionWarningDialog.DELETE_VALID_BUTTON,
        this._handleRetentionWarningOK, this, [retentionDialog, callback]);

    retentionDialog.setMessage(warningMsg, DwtMessageDialog.WARNING_STYLE);
    retentionDialog.setVisible(true);
    retentionDialog.popup();
};

ZmMailListController.prototype._handleRetentionWarningOK =
function(dialog, callback) {
    dialog.popdown();
    callback.run();
};

// done here since operations may not be defined at parse time
ZmMailListController.prototype._setStatics = function() {

	if (!ZmMailListController.INVITE_REPLY_MAP) {

		ZmMailListController.INVITE_REPLY_MAP = {};
		ZmMailListController.INVITE_REPLY_MAP[ZmOperation.INVITE_REPLY_ACCEPT]		= ZmOperation.REPLY_ACCEPT;
		ZmMailListController.INVITE_REPLY_MAP[ZmOperation.INVITE_REPLY_DECLINE]		= ZmOperation.REPLY_DECLINE;
		ZmMailListController.INVITE_REPLY_MAP[ZmOperation.INVITE_REPLY_TENTATIVE]	= ZmOperation.REPLY_TENTATIVE;

		ZmMailListController.REPLY_ACTION_MAP = {};
		ZmMailListController.REPLY_ACTION_MAP[ZmOperation.REPLY_ACCEPT_NOTIFY]		= ZmOperation.REPLY_ACCEPT;
		ZmMailListController.REPLY_ACTION_MAP[ZmOperation.REPLY_ACCEPT_IGNORE]		= ZmOperation.REPLY_ACCEPT;
		ZmMailListController.REPLY_ACTION_MAP[ZmOperation.REPLY_DECLINE_NOTIFY]		= ZmOperation.REPLY_DECLINE;
		ZmMailListController.REPLY_ACTION_MAP[ZmOperation.REPLY_DECLINE_IGNORE]		= ZmOperation.REPLY_DECLINE;
		ZmMailListController.REPLY_ACTION_MAP[ZmOperation.REPLY_TENTATIVE_NOTIFY]	= ZmOperation.REPLY_TENTATIVE;
		ZmMailListController.REPLY_ACTION_MAP[ZmOperation.REPLY_TENTATIVE_IGNORE]	= ZmOperation.REPLY_TENTATIVE;

		// convert key mapping to operation
		ZmMailListController.ACTION_CODE_TO_OP = {};
		ZmMailListController.ACTION_CODE_TO_OP[ZmKeyMap.REPLY]			= ZmOperation.REPLY;
		ZmMailListController.ACTION_CODE_TO_OP[ZmKeyMap.REPLY_ALL]		= ZmOperation.REPLY_ALL;
		ZmMailListController.ACTION_CODE_TO_OP[ZmKeyMap.FORWARD_INLINE]	= ZmOperation.FORWARD_INLINE;
		ZmMailListController.ACTION_CODE_TO_OP[ZmKeyMap.FORWARD_ATT]	= ZmOperation.FORWARD_ATT;
	}
};

// Mail can be grouped by msg or conv
ZmMailListController.prototype.supportsGrouping = function() {
    return true;
};
}
if (AjxPackage.define("zimbraMail.mail.controller.ZmMsgController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates an empty message controller.
 * @constructor
 * @class
 * This class controls the display and management of a single message in the content area. Since it
 * needs to handle pretty much the same operations as a list, it extends ZmMailListController.
 *
 * @author Parag Shah
 * @author Conrad Damon
 * 
 * @param {DwtControl}	container		the containing shell
 * @param {constant}	type			type of controller
 * @param {ZmApp}		mailApp			the containing application
 * @param {string}		sessionId		the session id
 * 
 * @extends		ZmMailListController
 */
ZmMsgController = function(container, mailApp, type, sessionId) {

    if (arguments.length == 0) { return; }
	ZmMailListController.apply(this, arguments);
	this._elementsToHide = ZmAppViewMgr.LEFT_NAV;
};

ZmMsgController.prototype = new ZmMailListController;
ZmMsgController.prototype.constructor = ZmMsgController;

ZmMsgController.MODE_TO_CONTROLLER = {};
ZmMsgController.MODE_TO_CONTROLLER[ZmId.VIEW_TRAD]		= "GetTradController";
ZmMsgController.MODE_TO_CONTROLLER[ZmId.VIEW_CONV]		= "GetConvController";
ZmMsgController.MODE_TO_CONTROLLER[ZmId.VIEW_CONVLIST]	= "GetConvListController";

ZmMsgController.DEFAULT_TAB_TEXT = ZmMsg.message;

ZmMsgController.viewToTab = {};

ZmMsgController.prototype.isZmMsgController = true;
ZmMsgController.prototype.toString = function() { return "ZmMsgController"; };

// Public methods

ZmMsgController.getDefaultViewType =
function() {
	return ZmId.VIEW_MSG;
};
ZmMsgController.prototype.getDefaultViewType = ZmMsgController.getDefaultViewType;

/**
 * Displays a message in the single-pane view.
 *
 * @param {ZmMailMsg}			msg					the message to display
 * @param {ZmListController}	parentController	the controller that called this method
 * @param {AjxCallback}			callback			the client callback
 * @param {Boolean}				markRead			if <code>true</code>, mark msg read
 * @param {Boolean}				hidePagination		if <code>true</code>, hide the pagination buttons
 */
ZmMsgController.prototype.show = 
function(msg, parentController, callback, markRead, hidePagination, forceLoad, noTruncate) {
	this.setMsg(msg);
	this._parentController = parentController;
	//if(msg.list) {
        this.setList(msg.list);
    //}
	if (!msg._loaded || forceLoad) {
		var respCallback = new AjxCallback(this, this._handleResponseShow, [callback, hidePagination]);
		if (msg._loadPending) {
			// override any local callback if we're being launched by double-pane view,
			// so that multiple GetMsgRequest's aren't made
			msg._loadCallback = respCallback;
		} else {
			markRead = markRead || (appCtxt.get(ZmSetting.MARK_MSG_READ) == ZmSetting.MARK_READ_NOW);
			msg.load({callback:respCallback, markRead:markRead, forceLoad:forceLoad, noTruncate:noTruncate});
		}
	} else {
		// May have been explicitly marked as unread
		var marked = false;
		if (!msg.isReadOnly() && msg.isUnread && (appCtxt.get(ZmSetting.MARK_MSG_READ) != ZmSetting.MARK_READ_NONE)) {
			if (msg.list) {
				// Need to mark it on the server
				marked = true;
				var markCallback =  this._handleResponseShow.bind(this, callback, hidePagination);
				msg.list.markRead({items: msg, value: true, callback: markCallback, noBusyOverlay: true});
			}  else {
				msg.markRead();
			}
		}
		if (!marked) {
			this._handleResponseShow(callback, hidePagination);
		}
	}
};

ZmMsgController.prototype._handleResponseShow = 
function(callback, hidePagination, result) {
	this._showMsg();
	this._showNavToolBarButtons(this._currentViewId, !hidePagination);
	if (callback && callback.run) {
		callback.run(this, this._view[this._currentViewId]);
	}
};


/**
 * can't repro bug 77538 - but since the exception happens in ZmListController.prototype._setupContinuation if lastItem is not set, let's set it here to be on the safe side.
 */
ZmMsgController.prototype._setupContinuation =
function() {
	this._continuation.lastItem = true; //just a dummy value.  I could use this._msg but afraid that in the case of the bug (77538) - that I can't repro - this._msg might be empty.
	this._continuation.totalItems = 1;
	ZmListController.prototype._setupContinuation.apply(this, arguments);
};


/**
 * Called by ZmNewWindow.unload to remove tag list listener (which resides in 
 * the parent window). Otherwise, after the child window is closed, the parent 
 * window is still referencing the child window's msg controller, which has
 * been unloaded!!
 * 
 * @private
 */
ZmMsgController.prototype.dispose = 
function() {
	this._tagList.removeChangeListener(this._tagChangeListener);
};

ZmMsgController.prototype._showMsg = 
function() {
	this._showMailItem();
};

ZmMsgController.prototype._getTabParams =
function(tabId, tabCallback) {
	return {
		id:				tabId,
		textPrecedence:	85,
        image:          "CloseGray",
        hoverImage:     "Close",
        style:          DwtLabel.IMAGE_RIGHT,
		tooltip:		ZmMsgController.DEFAULT_TAB_TEXT,
		tabCallback:	tabCallback
	};
};

ZmMsgController.prototype.getKeyMapName =
function() {
	return ZmKeyMap.MAP_MESSAGE;
};

ZmMsgController.prototype.handleKeyAction =
function(actionCode) {
	DBG.println(AjxDebug.DBG3, "ZmMsgController.handleKeyAction");
	
	switch (actionCode) {
		case ZmKeyMap.CANCEL:
			this._backListener();
			break;

		case ZmKeyMap.NEXT_PAGE:
			this._goToMsg(this._currentViewId, true);
			break;

		case ZmKeyMap.PREV_PAGE:
			this._goToMsg(this._currentViewId, false);
			break;

		// switching view not supported here
		case ZmKeyMap.VIEW_BY_CONV:
		case ZmKeyMap.VIEW_BY_MSG:
			break;
		
		default:
			if (ZmMsgController.ALLOWED_SHORTCUT[actionCode]) {
				return ZmMailListController.prototype.handleKeyAction.call(this, actionCode);
			}
	}
	return true;
};

ZmMsgController.prototype.mapSupported =
function(map) {
	return false;
};

// Private methods (mostly overrides of ZmListController protected methods)

ZmMsgController.prototype._getToolBarOps = 
function() {
	var list = [ZmOperation.CLOSE, ZmOperation.SEP];
	list = list.concat(ZmMailListController.prototype._getToolBarOps.call(this));
	return list;
};

ZmMsgController.prototype._getRightSideToolBarOps =
function() {
	if (appCtxt.isChildWindow || !appCtxt.get(ZmSetting.DETACH_MAILVIEW_ENABLED) || appCtxt.isExternalAccount()) {
		return [];
	}
	return [ZmOperation.DETACH];
};


ZmMsgController.prototype._showDetachInSecondary =
function() {
	return false;
};

ZmMsgController.prototype._initializeToolBar =
function(view) {
	var className = appCtxt.isChildWindow ? "ZmMsgViewToolBar_cw" : null;

	ZmMailListController.prototype._initializeToolBar.call(this, view, className);
};

ZmMsgController.prototype._navBarListener =
function(ev) {
	var op = ev.item.getData(ZmOperation.KEY_ID);
	if (op == ZmOperation.PAGE_BACK || op == ZmOperation.PAGE_FORWARD) {
		this._goToMsg(this._currentViewId, (op == ZmOperation.PAGE_FORWARD));
	}
};

// message view has no view menu button
ZmMsgController.prototype._setupViewMenu = function(view, firstTime) {};

ZmMsgController.prototype._getActionMenuOps =
function() {
	return null;
};

ZmMsgController.prototype._initializeView =
function(view) {
	if (!this._view[view]) {
		var params = {
			parent:		this._container,
			id:			ZmId.getViewId(ZmId.VIEW_MSG, null, view),
			posStyle:	Dwt.ABSOLUTE_STYLE,
			mode:		ZmId.VIEW_MSG,
			controller:	this
		};
		this._view[view] = new ZmMailMsgView(params);
		this._view[view].addInviteReplyListener(this._inviteReplyListener);
		this._view[view].addShareListener(this._shareListener);
		this._view[view].addSubscribeListener(this._subscribeListener);
	}
};

ZmMsgController.prototype._initializeTabGroup =
function(view) {
	if (this._tabGroups[view]) { return; }

	ZmMailListController.prototype._initializeTabGroup.apply(this, arguments);

	this._tabGroups[view].removeMember(this._view[view]);
};

ZmMsgController.prototype._getSearchFolderId =
function() {
	return this._msg.folderId ? this._msg.folderId : (this._msg.list && this._msg.list.search) ?
		this._msg.list.search.folderId : null;
};

ZmMsgController.prototype._getTagMenuMsg =
function() {
	return ZmMsg.tagMessage;
};

ZmMsgController.prototype._getMoveDialogTitle =
function() {
	return ZmMsg.moveMessage;
};

ZmMsgController.prototype._setViewContents =
function(view) {
	this._view[view].set(this._msg);
};

ZmMsgController.prototype._resetNavToolBarButtons =
function(view) {
	view = view || this.getCurrentViewId();
	if (!this._navToolBar[view]) { return; }
	// NOTE: we purposely do not call base class here!
	if (!appCtxt.isChildWindow) {
		var list = this._msg.list && this._msg.list.getVector();

		this._navToolBar[view].enable(ZmOperation.PAGE_BACK, (list && (list.get(0) != this._msg)));

		var bEnableForw = list && (this._msg.list.hasMore() || (list.getLast() != this._msg));
		this._navToolBar[view].enable(ZmOperation.PAGE_FORWARD, bEnableForw);

		this._navToolBar[view].setToolTip(ZmOperation.PAGE_BACK, ZmMsg.previousMessage);
		this._navToolBar[view].setToolTip(ZmOperation.PAGE_FORWARD, ZmMsg.nextMessage);
	}
};

ZmMsgController.prototype._showNavToolBarButtons =
function(view, show) {
	var toolbar = this._navToolBar[view];
	if (!toolbar) { return; }
	if (!appCtxt.isChildWindow) {
		toolbar.getButton(ZmOperation.PAGE_BACK).setVisible(show);
		toolbar.getButton(ZmOperation.PAGE_FORWARD).setVisible(show);
	}
};

ZmMsgController.prototype._goToMsg =
function(view, next) {
	var controller = this._parentController;
	if (controller && controller.pageItemSilently) {
		controller.pageItemSilently(this._msg, next, this);
	}
};

ZmMsgController.prototype._selectNextItemInParentListView =
function() {
	var controller = this._parentController;
	if (controller && controller._getNextItemToSelect) {
		controller._view[controller._currentViewId]._itemToSelect = controller._getNextItemToSelect();
	}
};

ZmMsgController.prototype._doDelete =
function() {
	this._selectNextItemInParentListView();
	ZmMailListController.prototype._doDelete.apply(this, arguments);
};

ZmMsgController.prototype._doMove =
function() {
	this._selectNextItemInParentListView();
	ZmMailListController.prototype._doMove.apply(this, arguments);
};

ZmMsgController.prototype._doSpam =
function() {
	this._selectNextItemInParentListView();
	ZmMailListController.prototype._doSpam.apply(this, arguments);
};

ZmMsgController.prototype._menuPopdownActionListener =
function(ev) {
	// dont do anything since msg view has no action menus
};

// Miscellaneous

ZmMsgController.prototype.getMsg =
function(params) {
	return this._msg;
};

ZmMsgController.prototype.getItems =
function() {
	return [this._msg];
};

ZmMsgController.prototype._getLoadedMsg =
function(params, callback) {
	callback.run(this._msg);
};

ZmMsgController.prototype._getSelectedMsg =
function() {
	return this._msg;
};

ZmMsgController.prototype.setMsg = function (msg) {
	this._msg = msg;
    msg.refCount++
};

ZmMsgController.prototype.getItemView = function() {
	return this._view[this._currentViewId];
};

// No-op replenishment
ZmMsgController.prototype._checkReplenish =
function(params) {
	// XXX: remove this when replenishment is fixed for msg controller!
	DBG.println(AjxDebug.DBG1, "SORRY. NO REPLENISHMENT FOR YOU.");
};

ZmMsgController.prototype._checkItemCount =
function() {
	if (!appCtxt.isChildWindow) {
		this._backListener();
	}
};

ZmMsgController.prototype._getDefaultFocusItem = 
function() {
	return this._toolbar[this._currentViewId];
};

ZmMsgController.prototype._backListener =
function(ev) {
	// bug fix #30835 - prism triggers this listener twice for some reason :/
	if (appCtxt.isOffline && (this._currentViewId != appCtxt.getCurrentViewId())) {
		return;
	}
	var isChildWindow = appCtxt.isChildWindow;
	if (!this._app.popView() && !isChildWindow) {
		this._app.mailSearch();
	}
};

ZmMsgController.prototype.isTransient =
function(oldView, newView) {
	return (appCtxt.getViewTypeFromId(newView) != ZmId.VIEW_COMPOSE);
};

ZmMsgController.prototype._tabCallback =
function(oldView, newView) {
	return (appCtxt.getViewTypeFromId(oldView) == ZmId.VIEW_MSG);
};

ZmMsgController.prototype._printListener =
function(ev) {
    var ids = [];
    var item = this._msg;
    var id;
    var showImages;
    // always extract out the msg ids from the conv
    if (item.toString() == "ZmConv") {
        // get msg ID in case of virtual conv.
        // item.msgIds.length is inconsistent, so checking if conv id is negative.
        if (appCtxt.isOffline && item.id.split(":")[1]<0) {
            id = item.msgIds[0];
        } else {
            id = "C:" + item.id;
        }
        var msgList = item.getMsgList();
        for(var j=0; j<msgList.length; j++) {
            if(msgList[j].showImages) {
                showImages = true;
                break;
            }
        }
    } else {
        id = item.id;
        // Fix for bug: 84261, bug: 85363. partId is present if original message is present as an attachment.
        var part = item.partId;
        if (part) {
            id += "&part=" + part;
        }

        if (item.showImages) {
            showImages = true;
        }
    }
    var url = "/h/printmessage?id=" + id + "&tz=" + AjxTimezone.getServerId(AjxTimezone.DEFAULT);
    if (appCtxt.get(ZmSetting.DISPLAY_EXTERNAL_IMAGES) || showImages) {
        url += "&xim=1";
    }
    if (appCtxt.isOffline) {
        var acctName = item.getAccount().name;
        url+="&acct=" + acctName ;
    }
    window.open(appContextPath+url, "_blank");
};

ZmMsgController.prototype._subscribeResponseHandler =
function(statusMsg, ev) {
    ZmMailListController.prototype._subscribeResponseHandler.call(this, statusMsg, ev);
    //Close View
    appCtxt.getAppViewMgr().popView();
};

ZmMsgController.prototype._acceptShareHandler =
function(ev) {
    ZmMailListController.prototype._acceptShareHandler.call(this, ev);
    //Close View
    appCtxt.getAppViewMgr().popView();
};

ZmMsgController.prototype._setStatics = function() {

	if (!ZmMsgController.ALLOWED_SHORTCUT) {
		ZmMsgController.ALLOWED_SHORTCUT = AjxUtil.arrayAsHash([
			ZmKeyMap.FORWARD,
			ZmKeyMap.MOVE,
			ZmKeyMap.PRINT,
			ZmKeyMap.TAG,
			ZmKeyMap.UNTAG,
			ZmKeyMap.REPLY,
			ZmKeyMap.REPLY_ALL,
			ZmKeyMap.SPAM,
			ZmKeyMap.MARK_READ,
			ZmKeyMap.MARK_UNREAD,
			ZmKeyMap.FLAG
		]);
	}

	ZmMailListController.prototype._setStatics();
};

ZmMsgController.prototype._postRemoveCallback = function() {
    this._msg.refCount--;
};
}
if (AjxPackage.define("zimbraMail.mail.controller.ZmMailConfirmController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * Creates a new controller to show mail send confirmation.
 * @constructor
 * @class
 * This class represents the mail confirmation controller.
 * 
 * @param {DwtShell}	container	the containing shell
 * @param {ZmApp}		mailApp		the containing app
 * @param {constant}	type		controller type
 * @param {string}		sessionId	the session id
 * 
 * @extends		ZmController
 */
ZmMailConfirmController = function(container, mailApp, type, sessionId) {

	ZmController.apply(this, arguments);
	this._elementsToHide = ZmAppViewMgr.LEFT_NAV;
};

ZmMailConfirmController.prototype = new ZmController();
ZmMailConfirmController.prototype.constructor = ZmMailConfirmController;

ZmMailConfirmController.prototype.isZmMailConfirmController = true;
ZmMailConfirmController.prototype.toString = function() { return "ZmMailConfirmController"; };

ZmMailConfirmController.getDefaultViewType =
function() {
	return ZmId.VIEW_MAIL_CONFIRM;
};
ZmMailConfirmController.prototype.getDefaultViewType = ZmMailConfirmController.getDefaultViewType;

/**
 * Shows the confirmation that the message was sent.
 *
 * @param	{ZmMailMsg}				msg					the message that was sent
 * @param	{constant}				composeViewId		the compose view id
 * @param	{constant}				composeTabId		the compose tab id
 * @param	{ZmComposeController}	controller			compose controller
 */
ZmMailConfirmController.prototype.showConfirmation =
function(msg, composeViewId, composeTabId, controller) {

	this._composeViewId = composeViewId;
	this._composeTabId = composeTabId;
	this._composeController = controller;

	if (!this._view) {
		this._initView();
	}

    this._initializeToolBar();
	this.resetToolbarOperations(this._toolbar);
	this._view.showConfirmation(msg);

	if (appCtxt.isChildWindow) {
		appCtxt.getAppViewMgr()._setViewVisible(ZmId.VIEW_LOADING, false);
	}

	var avm = appCtxt.getAppViewMgr();
	avm.pushView(this._currentViewId);
};

ZmMailConfirmController.prototype.resetToolbarOperations =
function() {
	this._toolbar.enableAll(true);
};

ZmMailConfirmController.prototype.getKeyMapName =
function() {
	return ZmKeyMap.MAP_GLOBAL;
};

ZmMailConfirmController.prototype.handleKeyAction =
function(actionCode) {
	switch (actionCode) {
		case ZmKeyMap.CANCEL:
			this._closeListener();
			break;

		default:
			return ZmController.prototype.handleKeyAction.call(this, actionCode);
			break;
	}
	return true;
};

ZmMailConfirmController.prototype._initView =
function() {
	this._view = new ZmMailConfirmView(this._container, this);
	this._view.addNewContactsListener(new AjxListener(this, this._addNewContactsListener));

	var tg = this._createTabGroup();
	var rootTg = appCtxt.getRootTabGroup();
	tg.newParent(rootTg);
	tg.addMember(this._view.getTabGroupMember());

	this._initializeToolBar();
	var elements = this.getViewElements(null, this._view, this._toolbar);

	var callbacks = {};
	callbacks[ZmAppViewMgr.CB_PRE_HIDE] = this._preHideCallback.bind(this);
	callbacks[ZmAppViewMgr.CB_POST_SHOW] = this._postShowCallback.bind(this);
    this._app.createView({	viewId:		this._currentViewId,
							viewType:	this._currentViewType,
							elements:	elements,
							hide:		this._elementsToHide,
							controller:	this,
							callbacks:	callbacks,
							tabParams:	{ id:this._composeTabId }});
};

ZmMailConfirmController.prototype._initializeToolBar =
function() {
	if (this._toolbar) return;

	var buttons = [ZmOperation.CLOSE];

	var className = appCtxt.isChildWindow ? "ZmAppToolBar_cw" : "ZmAppToolBar";
	this._toolbar = new ZmButtonToolBar({parent:this._container, buttons:buttons, className:className+" ImgSkin_Toolbar",
										 context:ZmId.VIEW_MAIL_CONFIRM});
	this._toolbar.addSelectionListener(ZmOperation.CLOSE, new AjxListener(this, this._closeListener));
};

ZmMailConfirmController.prototype._getDefaultFocusItem =
function() {
	return this._view.getDefaultFocusItem();
};

ZmMailConfirmController.prototype._closeListener =
function() {
	this._doClose();
};

ZmMailConfirmController.prototype._addNewContactsListener =
function(attrs) {
	if (!attrs.length) {
		this._doClose();
		return;
	}
	
	var batchCommand = new ZmBatchCommand(false, null, true);
	for (var i = 0, count = attrs.length; i < count; i++) {
		var contact = new ZmContact();
		batchCommand.add(new AjxCallback(contact, contact.create, [attrs[i]]));
	}
	batchCommand.run(new AjxCallback(this, this._handleResponseCreateContacts));
};

ZmMailConfirmController.prototype._handleResponseCreateContacts =
function() {
	this._doClose();
};

ZmMailConfirmController.prototype._doClose =
function() {
	appCtxt.getAppViewMgr().popView(true);
};
}
if (AjxPackage.define("zimbraMail.mail.controller.ZmMailFolderTreeController")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2008, 2009, 2010, 2011, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmMailFolderTreeController = function(type, dropTgt) {
    if (arguments.length == 0) return;
	ZmFolderTreeController.apply(this, arguments);
};
ZmMailFolderTreeController.prototype = new ZmFolderTreeController;
ZmMailFolderTreeController.prototype.constructor = ZmMailFolderTreeController;

ZmMailFolderTreeController.prototype.toString =
function() {
	return "ZmMailFolderTreeController";
};

//
// ZmFolderTreeController methods
//

ZmMailFolderTreeController.prototype._updateOverview = function(params) {

	ZmTreeController.prototype._updateOverview.call(this, params);

	// for multi-account allow account header to update based on Inbox's unread count
	var org = params.organizer, fields = params.fields;
	if (appCtxt.multiAccounts && (fields[ZmOrganizer.F_UNREAD] && org.isSystem()) ||
		(fields[ZmOrganizer.F_TOTAL] && (org.nId == ZmFolder.ID_DRAFTS || org.nId == ZmOrganizer.ID_OUTBOX))) {

		var ovc = appCtxt.getApp(ZmApp.MAIL).getOverviewContainer(true);
		if (ovc) {
			ovc.updateLabel(org);
		}
	}
};

ZmMailFolderTreeController.prototype._deleteListener =
function(ev) {
	// check for associated data source
	if (appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED)) {
		var organizer = this._getActionedOrganizer(ev);
		if (organizer.isDataSource()) {
			var accounts = appCtxt.getDataSourceCollection().getPopAccountsFor(organizer.id);
			var args = [ organizer.getName(), AjxStringUtil.htmlEncode(accounts[0].getName(), true)];
			var message = AjxMessageFormat.format(ZmMsg.errorDeletePopFolder, args);

			var dialog = appCtxt.getMsgDialog();
			dialog.setMessage(message);
			dialog.popup();
			return;
		}
	}

	// perform default action
	ZmFolderTreeController.prototype._deleteListener.apply(this, arguments);
};

ZmMailFolderTreeController.prototype._dropListener =
function(ev) {
	// check for associated data source
	if ((appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED) || appCtxt.get(ZmSetting.IMAP_ACCOUNTS_ENABLED)) && ev.action == DwtDropEvent.DRAG_DROP) {
		var item = ev.srcData.data;
		var organizer = item instanceof ZmOrganizer ? item : null;
		if (organizer && organizer.isDataSource()) {
			var datasources = appCtxt.getDataSourceCollection();
			var popAccounts = appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED) ? datasources.getPopAccountsFor(organizer.id) : [];
			var imapAccounts = appCtxt.get(ZmSetting.IMAP_ACCOUNTS_ENABLED) ? datasources.getImapAccountsFor(organizer.id) : [];
		
			if (popAccounts.length || imapAccounts.length) {
				var args = [ organizer.getName(), popAccounts.length ? popAccounts[0].getName() : imapAccounts[0].getName() ];
				var message = AjxMessageFormat.format(popAccounts.length ? ZmMsg.errorMovePopFolder : ZmMsg.errorMoveImapFolder, args);

				var dialog = appCtxt.getMsgDialog();
				dialog.setMessage(message);
				dialog.popup();
				return;
			}
		}
	}

	// perform default action
	ZmFolderTreeController.prototype._dropListener.apply(this, arguments);
};

ZmMailFolderTreeController.prototype.resetOperations =
function(parent, type, id) {
	// perform default action
	ZmFolderTreeController.prototype.resetOperations.apply(this, arguments);

	// disable move for folders with POP accounts
	if (appCtxt.get(ZmSetting.POP_ACCOUNTS_ENABLED)) {
		var organizer = appCtxt.getById(id);
		if (organizer.isDataSource()) {
			parent.enable(ZmOperation.MOVE, false);
			parent.enable(ZmOperation.MOVE_MENU, false)
		}
	}
};

ZmMailFolderTreeController.prototype._doMarkAllRead =
function(organizer) {
	// we're not guaranteed mark-all will succeed, so this is a tiny bit risky
	if (appCtxt.isOffline) {
		appCtxt.getApp(ZmApp.MAIL).clearNewMailBadge();
	}

	ZmTreeController.prototype._doMarkAllRead.apply(this, arguments);
};
}
if (AjxPackage.define("zimbraMail.mail.view.ZmMailRedirectDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2011, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2011, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 */

/**
 * Creates a Mail Redirect dialog.
 * @class
 * This class represents a Mail Redirect dialog.
 *
 * @param	{DwtControl}	parent		the parent
 * @param	{String}	className		the class name
 *
 * @extends		DwtDialog
 */
ZmMailRedirectDialog = function(parent, className) {
	className = className || "ZmFolderPropsDialog";

    DwtDialog.call(this, {parent:parent, className:className, title:ZmMsg.mailRedirect, id:"RedirectDialog"});

	this.setButtonListener(DwtDialog.CANCEL_BUTTON, this._handleCancelButton.bind(this));

	var recipParams = {};
	recipParams.enableContainerInputs		= this.enableInputs.bind(this);
	recipParams.contactPopdownListener		= this.contactPopdownListener.bind(this);
	recipParams.contextId					= this.toString();
    this._recipients = new ZmRecipients(recipParams);

    this._fieldNames = [AjxEmailAddress.TO];
    var data = { id : this._htmlElId };

    for (var i = 0; i < this._fieldNames.length; i++) {
        var typeStr = AjxEmailAddress.TYPE_STRING[this._fieldNames[i]];
        var ids =  this._recipients.createRecipientIds(this._htmlElId, typeStr)
        data[typeStr + "RowId"]    = ids.row;
        data[typeStr + "PickerId"] = ids.picker;
        data[typeStr + "InputId"]  = ids.control;
        data[typeStr + "CellId"]   = ids.cell;
    }

    var html = AjxTemplate.expand("mail.Message#RedirectDialog", data);
    this.setContent(html);


    this._recipients.createRecipientHtml(this, this._htmlElId, this._htmlElId, this._fieldNames);
    this._tabGroup.addMember(this._recipients.getField(AjxEmailAddress.TO), 0);
};

ZmMailRedirectDialog.prototype = new DwtDialog;
ZmMailRedirectDialog.prototype.constructor = ZmMailRedirectDialog;

ZmMailRedirectDialog.prototype.isZmMailRedirectDialog = true;
ZmMailRedirectDialog.prototype.toString = function() { return "ZmMailRedirectDialog"; };



ZmMailRedirectDialog.prototype.getAddrs =
function() {
	return this._recipients.collectAddrs();
};


/**
 * Pops-up the properties dialog.
 *
 * @param	{ZmOrganizer}	organizer		the organizer
 */
ZmMailRedirectDialog.prototype.popup =
function(mail) {
    this._recipients.setup();

	DwtDialog.prototype.popup.call(this);
};

ZmMailRedirectDialog.prototype._resetTabFocus =
function(){
	this._tabGroup.setFocusMember(this._recipients.getField(AjxEmailAddress.TO), true);
};


ZmMailRedirectDialog.prototype.popdown =
function() {
    this._recipients.reset();
	DwtDialog.prototype.popdown.call(this);
};


// Miscellaneous methods

ZmMailRedirectDialog.prototype.enableInputs =
function(bEnable) {
    this._recipients.enableInputs(bEnable);
};

/**
 * Handles re-enabling inputs if the pop shield is dismissed via
 * Esc. Otherwise, the handling is done explicitly by a callback.
 */
// *** NEEDED??? **** //
ZmMailRedirectDialog.prototype.contactPopdownListener =
function() {
	this.enableInputs(true);
	appCtxt.getAppViewMgr().showPendingView(false);
};

ZmMailRedirectDialog.prototype._handleCancelButton =
function(event) {
	this.popdown();
};
}


if (AjxPackage.define("zimbraMail.mail.view.object.ZmImageAttachmentObjectHandler")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

ZmImageAttachmentObjectHandler = function() {
	ZmObjectHandler.call(this, ZmImageAttachmentObjectHandler.TYPE);
	this._imageHash = {};
}

ZmImageAttachmentObjectHandler.prototype = new ZmObjectHandler;
ZmImageAttachmentObjectHandler.prototype.constructor = ZmImageAttachmentObjectHandler;

ZmImageAttachmentObjectHandler.TYPE = "imageAttachemnt";

ZmImageAttachmentObjectHandler.THUMB_SIZE = 'width="320" height="240"';
ZmImageAttachmentObjectHandler.THUMB_SIZE_MAX = 320;
	
// already htmlencoded!!
ZmImageAttachmentObjectHandler.prototype._getHtmlContent =
function(html, idx, obj, context) {
	html[idx++] = obj; //AjxStringUtil.htmlEncode(obj, true);
	return idx;
}

ZmImageAttachmentObjectHandler.prototype.getToolTipText =
function(url, context) {
	var image = this._imageHash[context.url];
	if (!image) {
		image = {id:Dwt.getNextId()};
	}
	if (!image.el || (image.el.src !== context.url)) {
		this._imageHash[context.url] = image;
		this._preload(context.url, image.id);	
	}
	
	var el = document.getElementById(image.id);
	if (el && !image.el) {
		image.el = el;
	}
	if (image.el) {
		return image.el.xml || image.el.outerHTML;
	}
	return '<img id="'+ image.id +'" style="visibility:hidden;"/>';
};

ZmImageAttachmentObjectHandler.prototype.getActionMenu =
function(obj) {
	return null;
};

ZmImageAttachmentObjectHandler.prototype._preload =
function(url, id) {
	var tmpImage = new Image();
	tmpImage.onload = AjxCallback.simpleClosure(this._setSize, this, id, tmpImage);
	tmpImage.src = url;
};

ZmImageAttachmentObjectHandler.prototype._setSize =
function(id, tmpImage) {
	var elm = document.getElementById(id);
	if(elm) {
		var width = tmpImage.width;
		var height = tmpImage.height;
		if(width > ZmImageAttachmentObjectHandler.THUMB_SIZE_MAX && width >= height) {
			elm.width = ZmImageAttachmentObjectHandler.THUMB_SIZE_MAX;
		} else if (height > ZmImageAttachmentObjectHandler.THUMB_SIZE_MAX && height > width) {
			elm.height = ZmImageAttachmentObjectHandler.THUMB_SIZE_MAX;
		} else {
			elm.width = width;
			elm.width = height;
		}
		elm.src = tmpImage.src;
		elm.style.visibility = "visible";
	}
	tmpImage.onload = null;
	tmpImage = null;
};
}
if (AjxPackage.define("zimbraMail.share.zimlet.handler.ZmEmailObjectHandler")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @class
 * Internal handler for email addresses.
 *
 * @author Conrad Damon
 * @extends	ZmObjectHandler
 */
ZmEmailObjectHandler = function() {
	ZmObjectHandler.call(this, 'email');
};

ZmEmailObjectHandler.prototype = new ZmObjectHandler;
ZmEmailObjectHandler.prototype.constructor = ZmEmailObjectHandler;

ZmEmailObjectHandler.prototype.isZmEmailObjectHandler = true;
ZmEmailObjectHandler.prototype.toString = function() {
	return 'ZmEmailObjectHandler';
};

// email regex that recognizes mailto: links as well
//ZmEmailObjectHandler.RE = /\b(mailto:[ ]*)?([0-9a-zA-Z]+[.&#!$%'*+-\/=?^_`{}|~])*[0-9a-zA-Z_-]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}([\w\/_\.]*(\?\S+)?)/gi;
ZmEmailObjectHandler.RE = /\b(mailto:[ ]*)?([0-9a-zA-Z\u00C0-\u00ff]+[.&#!$%'*+-\/=?^_`{}|~])*[0-9a-zA-Z_-\u00C0-\u00ff]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}([\w\/_\.]*(\?\S+)?)/gi;


ZmEmailObjectHandler.prototype.match = function(content, startIndex, objectMgr) {

	ZmEmailObjectHandler.RE.lastIndex = startIndex;
	var ret = ZmEmailObjectHandler.RE.exec(content);
	if (ret) {
		ret.context = ret;
		ret.objectMgr = objectMgr;  // obj mgr can get us back to containing view
	}
	return ret;
};

// See if a zimlet wants to handle email hover; if not, do the default thing
ZmEmailObjectHandler.prototype.hoverOver = function(object, context, x, y, span) {
	object = AjxStringUtil.parseMailtoLink(object).to;
	if (!appCtxt.notifyZimlets('onEmailHover', [ object, context, x, y, span ])) {
		ZmObjectHandler.prototype.hoverOver.apply(this, arguments);
	}
};

ZmEmailObjectHandler.prototype.getToolTipText = function(obj, context) {

	// Return a callback since we may need to make an async request to get data for the tooltip content.
	return new AjxCallback(this,
		function(callback) {
			appCtxt.getToolTipMgr().getToolTip(ZmToolTipMgr.PERSON, { address: AjxStringUtil.parseMailtoLink(obj).to }, callback);
		});
};

// Left-click starts a compose session
ZmEmailObjectHandler.prototype.clicked = function(spanElement, contentObjText, matchContext, ev) {

	var	ctlr = this._getController(matchContext),
		parts = AjxStringUtil.parseMailtoLink(contentObjText);

	var params = {
		action:         ZmOperation.NEW_MESSAGE,
		inNewWindow:    ctlr && ctlr._app && ctlr._app._inNewWindow(ev),
		toOverride:     parts.to,
		subjOverride:   parts.subject,
		extraBodyText:  parts.body
	};

	AjxDispatcher.run("Compose", params);
};

// Borrow the bubble action menu from the owning controller. Object framework doesn't explicitly call an
// action listener, so we do it here.
ZmEmailObjectHandler.prototype.getActionMenu = function(obj, span, context, ev) {

	var ctlr = this._getController(context);
	if (!ctlr) {
		return null;
	}

	ctlr._actionEv = ev;
	ctlr._actionEv.address = AjxStringUtil.parseMailtoLink(obj).to;
	ctlr._actionEv.handler = this;

	if (!this._actionMenu && ctlr._getBubbleActionMenu) {
		this._actionMenu = ctlr._getBubbleActionMenu();
	}

	ctlr._bubbleActionListener(ev, obj);

	return this._actionMenu;
};

ZmEmailObjectHandler.prototype._getController = function(context) {

	var om = context && context.objectMgr,
		view = om && om.getView();

	return view && view._controller;
};

// Tell the object framework we're here. The 'email' type arg is probably not needed.
ZmObjectManager.registerHandler("ZmEmailObjectHandler", 'email', 4);
}

if (AjxPackage.define("zimbra.common.ZmErrorDialog")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */

/**
 * @overview
 * This file defines the Zimbra error dialog.
 *
 */

/**
 * Creates an error dialog.
 * @class
 * Creates an error dialog which will have a "Send Error Report" button.
 * A normal {@link DwtMessageDialog} with a "Send Error Report" button that will post user info to the 
 * server when clicked.
 * 
 * @param	{Object}	parent		the parent
 * @param	{Hash}		msgs		a hash of messages
 * @param	{String}	msgs.showDetails		the show details message
 * @param	{String}	msgs.hideDetails		the hide details message
 * 
 * @extends DwtMessageDialog
 */
ZmErrorDialog = function(parent, msgs) {

	// go ahead and cache the navigator and subject info now (since it should never change)		
	this._strNav = this._getNavigatorInfo();
	this._subjPfx = this._getSubjectPrefix();

	var reportButton = new DwtDialog_ButtonDescriptor(ZmErrorDialog.REPORT_BUTTON, msgs.report, DwtDialog.ALIGN_LEFT);
	var detailButton = new DwtDialog_ButtonDescriptor(ZmErrorDialog.DETAIL_BUTTON, msgs.showDetails, DwtDialog.ALIGN_LEFT);
	DwtMessageDialog.call(this, {parent:parent, extraButtons:[reportButton, detailButton], id:"ErrorDialog"});

	this.registerCallback(ZmErrorDialog.REPORT_BUTTON, this._reportCallback, this);
	this.registerCallback(ZmErrorDialog.DETAIL_BUTTON, this.showDetail, this);
	
	this._showDetailsMsg = msgs.showDetails;
	this._hideDetailsMsg = msgs.hideDetails;

	this._setAllowSelection();
};

ZmErrorDialog.prototype = new DwtMessageDialog;
ZmErrorDialog.prototype.constructor = ZmErrorDialog;

/**
 * Returns a string representation of the object.
 * 
 * @return		{String}		a string representation of the object
 */
ZmErrorDialog.prototype.toString =
function() {
	return "ZmErrorDialog";
};

//
// Consts
//

ZmErrorDialog.REPORT_BUTTON = "Report";
ZmErrorDialog.DETAIL_BUTTON = "Detail";
ZmErrorDialog.DEFAULT_REPORT_URL = "//www.zimbra.com/e/";

//
// Data
//

ZmErrorDialog.prototype._detailsVisible = false;
ZmErrorDialog.prototype.CONTROLS_TEMPLATE = "zimbra.Widgets#ZmErrorDialogControls";

//
// Public methods
//

/**
 * Resets the dialog.
 * 
 */
ZmErrorDialog.prototype.reset =
function() {
	this.setDetailString();
	DwtMessageDialog.prototype.reset.call(this);
};

/**
* Sets the text to display when the "Show Details" button is pressed.
*
* @param {String}	text	the detail text
*/
ZmErrorDialog.prototype.setDetailString = 
function(text) {
	if (!(this._button[ZmErrorDialog.DETAIL_BUTTON])) { return; }

	this._button[ZmErrorDialog.DETAIL_BUTTON].setVisible(text != null);
	this._detailStr = text;
};

/**
 * Sets the message style (info/warning/critical) and content.
 *
 * @param {String}	msgStr		the message text
 * @param {String}	detailStr	the detail text
 * @param {constant}	style		the style (see {@link DwtMessageDialog} <code>_STYLE</code> constants)
 * @param {String}	title		the dialog box title
 */
ZmErrorDialog.prototype.setMessage =
function(msgStr, detailStr, style, title) {
	this._msgStr = msgStr;
	this.setDetailString(detailStr);
	this._msgStyle = style;
	this._msgTitle = title;

	// clear the 'detailsVisible' flag and reset the title of the 'showDetails' button
	this._detailsVisible = false;
	this._button[ZmErrorDialog.DETAIL_BUTTON].setText(this._showDetailsMsg);
	
	// Set the content, enveloped
	this._updateContent();
};

/**
 * Sets/updates the content
 */
ZmErrorDialog.prototype._updateContent = 
function() {
	var data = {
		message: this._msgStr,
		detail: this._detailStr,
		showDetails: this._detailsVisible
	};
	var html = AjxTemplate.expand("zimbra.Widgets#ZmErrorDialogContent", data);
	this.setSize(Dwt.CLEAR, this._detailsVisible ? "300" : Dwt.CLEAR);
	DwtMessageDialog.prototype.setMessage.call(this, html, this._msgStyle, this._msgTitle);
};

/**
 * Pops-up the error dialog.
 * 
 * @param {Object}	loc				the desired location
 * @param {Boolean}	hideReportButton	if <code>true</code>, do not show "Send Error Report" button
 * 
 */
ZmErrorDialog.prototype.popup =
function(loc, hideReportButton) {
	if (hideReportButton) {
		this.setButtonVisible(ZmErrorDialog.REPORT_BUTTON, false);
	}
	DwtMessageDialog.prototype.popup.call(this, loc);
};

/**
 * Pops-down the dialog.
 * 
 */
ZmErrorDialog.prototype.popdown =
function() {
	DwtMessageDialog.prototype.popdown.call(this);

	// reset dialog
	this.setSize(Dwt.CLEAR, Dwt.CLEAR);
	this.setButtonVisible(ZmErrorDialog.REPORT_BUTTON, true);
};

//
// Protected methods
//
/**
 * @private
 */
ZmErrorDialog.prototype._getNavigatorInfo =
function() {
	var strNav = [];
	var idx = 0;

	// Add the url
	strNav[idx++] = "\n\n";
	strNav[idx++] = "href: ";
	strNav[idx++] = location.href;
	strNav[idx++] = "\n";

	for (var i in navigator) {
		// Skip functions
		if(typeof navigator[i] == "function") {continue;}
		if(typeof navigator[i] == "unknown") {continue;}	// IE7
		if(AjxEnv.isIE && i === "mimeTypes") {continue;}
		strNav[idx++] = i + ": " + navigator[i] + "\n";
	}
	return strNav.join("");
};

/**
 * @private
 */
ZmErrorDialog.prototype._getSubjectPrefix = 
function() {
	var strSubj = [];
	var idx = 0;

	strSubj[idx++] = "ER: ";

	if (AjxEnv.isIE) 				strSubj[idx++] = "IE ";
	else if (AjxEnv.isFirefox)		strSubj[idx++] = "FF ";
	else if (AjxEnv.isMozilla)		strSubj[idx++] = "MOZ ";
	else if (AjxEnv.isSafari)		strSubj[idx++] = "SAF ";
	else if (AjxEnv.isOpera)		strSubj[idx++] = "OPE ";
	else							strSubj[idx++] = "UKN ";

	if (AjxEnv.isWindows)			strSubj[idx++] = "WIN ";
	else if (AjxEnv.isLinux)		strSubj[idx++] = "LNX ";
	else if (AjxEnv.isMac)			strSubj[idx++] = "MAC ";
	else							strSubj[idx++] = "UNK ";

	strSubj[idx++] = appCtxt.get(ZmSetting.CLIENT_VERSION) + " ";
	return strSubj.join("");
};

/**
 * @private
 */
ZmErrorDialog.prototype._getUserPrefs = 
function() {
	var currSearch = appCtxt.getCurrentSearch();
	var strPrefs = [];
	var idx = 0;

	// Add username and current search
	strPrefs[idx++] = "\n\n";
	strPrefs[idx++] = "username: ";
	strPrefs[idx++] = appCtxt.get(ZmSetting.USERNAME);
	strPrefs[idx++] = "\n";
	if (currSearch) {
		strPrefs[idx++] = "currentSearch: ";
		strPrefs[idx++] = currSearch.query;
		strPrefs[idx++] = "\n";
	}
	for (var i in ZmSetting.INIT) {
		if (ZmSetting.INIT[i][0]) {
			strPrefs[idx++] = ZmSetting.INIT[i][0];
			strPrefs[idx++] = ": ";
			strPrefs[idx++] = ("" + ZmSetting.INIT[i][3]);
			strPrefs[idx++] = "\n";
		}
	}
	return strPrefs.join("");
};

// Callbacks

/**
 * @private
 */
ZmErrorDialog.prototype._reportCallback =
function() {
	this._iframe = document.createElement("iframe");
	this._iframe.style.width = this._iframe.style.height = 0;
	this._iframe.style.visibility = "hidden";

	var contentDiv = this._getContentDiv();
	contentDiv.appendChild(this._iframe);

	var strPrefs = this._getUserPrefs();
	var formId = Dwt.getNextId();

	// generate html form for submission via POST
	var html = [];
	var idx = 0;
	var subject = this._subjPfx + this._detailStr.substring(0,40);
	var scheme = (location.protocol == 'https:') ? "https:" : "http:";
	html[idx++] = "<html><head></head><body><form id='";
	html[idx++] = formId;
	html[idx++] = "' method='POST' action='";
	html[idx++] = scheme;
	html[idx++] = appCtxt.get(ZmSetting.ERROR_REPORT_URL) || ZmErrorDialog.DEFAULT_REPORT_URL;
	html[idx++] = "'>";
	html[idx++] = "<textarea name='details'>";
	html[idx++] = this._detailStr;
	html[idx++] = "version - ";
	html[idx++] = appCtxt.get(ZmSetting.CLIENT_VERSION);
	html[idx++] = "\n";
	html[idx++] = "release - ";
	html[idx++] = appCtxt.get(ZmSetting.CLIENT_RELEASE);
	html[idx++] = "\n";
	html[idx++] = "date - ";
	html[idx++] = appCtxt.get(ZmSetting.CLIENT_DATETIME);
	html[idx++] = "</textarea><textarea name='navigator'>";
	html[idx++] = this._strNav;
	html[idx++] = "</textarea><textarea name='prefs'>";
	html[idx++] = strPrefs;
	html[idx++] = "</textarea><textarea name='subject'>";
	html[idx++] = subject;
	html[idx++] = "</textarea></form></body></html>";

	var idoc = Dwt.getIframeDoc(this._iframe);
	idoc.open();
	idoc.write(html.join(""));
	idoc.close();

	// submit the form!
	var form = idoc.getElementById(formId);
	if (form) {
		form.submit();
		appCtxt.setStatusMsg(ZmMsg.errorReportSent);
	}

	this.popdown();
};

/**
 * Displays the detail text
 */
ZmErrorDialog.prototype.showDetail = 
function() {
	this._detailsVisible = !this._detailsVisible;
	this._updateContent();
	this._button[ZmErrorDialog.DETAIL_BUTTON].setText(this._detailsVisible ? this._hideDetailsMsg : this._showDetailsMsg);
};
}
if (AjxPackage.define("zimbraMail.offline.ZmOffline")) {
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Web Client
 * Copyright (C) 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * The contents of this file are subject to the Common Public Attribution License Version 1.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at: https://www.zimbra.com/license
 * The License is based on the Mozilla Public License Version 1.1 but Sections 14 and 15
 * have been added to cover use of software over a computer network and provide for limited attribution
 * for the Original Developer. In addition, Exhibit A has been modified to be consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the License for the specific language governing rights and limitations under the License.
 * The Original Code is Zimbra Open Source Web Client.
 * The Initial Developer of the Original Code is Zimbra, Inc.  All rights to the Original Code were
 * transferred by Zimbra, Inc. to Synacor, Inc. on September 14, 2015.
 *
 * All portions of the code are Copyright (C) 2012, 2013, 2014, 2015, 2016 Synacor, Inc. All Rights Reserved.
 * ***** END LICENSE BLOCK *****
 */
ZmOffline = function() {
	ZmOffline.SUPPORTED_APPS = [ZmApp.MAIL, ZmApp.CONTACTS, ZmApp.CALENDAR];
	ZmOffline.SUPPORTED_MAIL_TREE_VIEWS = [ZmOrganizer.FOLDER, ZmOrganizer.SEARCH, ZmOrganizer.TAG];
    ZmOfflineDB.init();
    this._addListeners();
};

ZmOffline.appCacheDone = false;
ZmOffline.messageNotShowed = true;
ZmOffline.cacheProgress = [];
ZmOffline.syncStarted = false;
ZmOffline.isServerReachable = true;

ZmOffline.folders = {};
ZmOffline.calendars = {};

// The number of days we read into the future to get calendar entries
ZmOffline.CALENDAR_LOOK_BEHIND_DAYS = 7;
ZmOffline.CALENDAR_READ_AHEAD_DAYS  = 21;

ZmOffline.ATTACHMENT = "Attachment";
ZmOffline.REQUESTQUEUE = "RequestQueue";
ZmOffline.META_DATA = "MetaData";

ZmOffline.MAIL_PROGRESS = "Mail";
ZmOffline.CONTACTS_PROGRESS = "Contacts";
ZmOffline.CALENDAR_PROGRESS = "Calendar Appointments";

ZmOffline.MAX_REQUEST_IN_BATCH_REQUEST = 50;
ZmOffline.SYNC_REQUEST_DELAY = 10000;

ZmOffline._checkCacheDone =
function (){
    if (appCtxt.isWebClientOfflineSupported && ZmOffline.appCacheDone && ZmOffline.cacheProgress.length === 0 && ZmOffline.syncStarted && ZmOffline.messageNotShowed){
        appCtxt.setStatusMsg(ZmMsg.offlineCachingDone, ZmStatusView.LEVEL_INFO);
        ZmOffline.messageNotShowed = false;
    }
};

ZmOffline.prototype._addListeners =
function() {
    $(window).on("online offline", ZmOffline.checkServerStatus);
    $(document).on("ZWCOffline", this._onZWCOffline.bind(this));
    $(document).on("ZWCOnline", this._onZWCOnline.bind(this));
	ZmZimbraMail.addListener(ZmAppEvent.POST_STARTUP, this._onPostStartup.bind(this));
    setInterval(ZmOffline.checkServerStatus, 10000);
};

ZmOffline.prototype._onZWCOffline =
function() {
	ZmOffline.refreshStatusIcon();
    this._disableApps();
	var zimbraMail = appCtxt.getZimbraMail();
	if (zimbraMail) {
		zimbraMail.setupHelpMenu();
	}
	this._setSearchOfflineState(true);
};

ZmOffline.prototype._onZWCOnline =
function() {
	ZmOffline.refreshStatusIcon();
    this._enableApps();
    this._replayOfflineRequest();
	var zimbraMail = appCtxt.getZimbraMail();
	if (zimbraMail) {
		zimbraMail.setupHelpMenu();
	}
	this._setSearchOfflineState(false);
};

ZmOffline.prototype._setSearchOfflineState = function(offline) {
	var searchController = appCtxt.getSearchController();
	if (searchController) {
		var searchToolbar = searchController.getSearchToolbar();
		if (searchToolbar) {
			searchToolbar.setOfflineState(offline);
		}
	}
}

ZmOffline.prototype._onPostStartup =
function() {
	this._initOfflineFolders();
	if (appCtxt.isWebClientOffline()) {
		this._onZWCOffline();
	}
	else {
		// Always replay offline request on post startup event so that the offline related changes are applied.
		this._replayOfflineRequest();
		this._initStaticResources();
	}
	ZmOffline.updateFolderCount();
};

ZmOffline.prototype._enableApps =
function() {
    // Configure the tabs
    var appChooser = appCtxt.getAppChooser();
    for (var i in ZmApp.ENABLED_APPS) {
        var appButton = appChooser.getButton(i);
        if (appButton) {
            appButton.setEnabled(true);
        }
    }

    // Enable features for the current app
    var app = appCtxt.getCurrentApp();
	app.resetWebClientOfflineOperations();
 };

ZmOffline.prototype._disableApps =
function() {
    // Configure the tabs
    var appChooser = appCtxt.getAppChooser();
    var enabledApps = AjxUtil.keys(ZmApp.ENABLED_APPS);
    var disabledApps = AjxUtil.arraySubstract(enabledApps, ZmOffline.SUPPORTED_APPS);
    for (var j = 0; j < disabledApps.length; j++) {
        var appButton = appChooser.getButton(disabledApps[j]);
        if (appButton) {
            appButton.setEnabled();
        }
    }

    // Disable features for the current app
    var app = appCtxt.getCurrentApp();
	app.resetWebClientOfflineOperations();
};

ZmOffline.prototype._initOfflineFolders =
function() {
	var folderTree = appCtxt.getFolderTree();
	if (folderTree) {
		var folders = folderTree.getByType("FOLDER");
		folders.forEach(function(folder) {
			if (folder.webOfflineSyncDays !== 0) {
				ZmOffline.folders[folder.id] = folder;
			}
		});

		var addrBooks = folderTree.getByType("ADDRBOOK");
		addrBooks.forEach(function(folder) {
			if (folder.id != ZmFolder.ID_DLS) {//Do not add distribution lists
				ZmOffline.folders[folder.id] = folder;
			}
		});

		//Check for deferredFolders for contacts
		var contactApp = appCtxt.getApp("Contacts");
		if (contactApp) {
			contactApp._deferredFolders.forEach(function(folder) {
				if (folder.obj.id != ZmFolder.ID_DLS) {
					ZmOffline.folders[folder.obj.id] = folder.obj;
				}
			});
		}
	}

	// Get the possible set of calendars.  Used to insure getFolder allows access to the invite messages
	var calMgr = appCtxt.getCalManager();
	var calViewController = calMgr && calMgr.getCalViewController();
	var calendarIds = calViewController.getOfflineSearchCalendarIds();
	for (var i = 0; i < calendarIds.length; i++) {
		// Store for use in processing mail messages - allow invites
		ZmOffline.calendars[calendarIds[i]] = calendarIds[i];
	}
};

ZmOffline.prototype._initStaticResources =
function() {
	ZmOffline.refreshStatusIcon(true);
	var staticURLs = [];
	var cssUrl = ["/css/msgview.css?v=", cacheKillerVersion, "&locale=", window.appRequestLocaleId, "&skin=", window.appCurrentSkin].join("");
	staticURLs.push({url : cssUrl, storeInLocalStorage : true, appendCacheKillerVersion : false});
	staticURLs.push({url : "/img/large.png"});
	staticURLs.push({url : "/img/large/ImgPerson_48.png"});
	staticURLs.push({url : "/img/arrows/ImgSashArrowsUp.png"});
	staticURLs.push({url : "/img/arrows.png"});
	staticURLs.push({url : "/img/calendar/ImgCalendarDayGrid.repeat.gif"});
	staticURLs.push({url : "/css/tinymce-content.css"});
	staticURLs.push({url : "/js/ajax/3rdparty/tinymce/skins/lightgray/fonts/tinymce-small.woff", appendCacheKillerVersion : false});
	staticURLs.push({url : "/js/ajax/3rdparty/tinymce/skins/lightgray/content.min.css", appendCacheKillerVersion : false});
	staticURLs.push({url : "/js/ajax/3rdparty/tinymce/skins/lightgray/skin.min.css", appendCacheKillerVersion : false});
	this._cacheStaticResources(staticURLs);
};

ZmOffline.prototype._cacheStaticResources =
function(staticURLs, cachedURL, response) {
	if (response && response.success && cachedURL && cachedURL.storeInLocalStorage) {
		localStorage.setItem(cachedURL.url, response.text);
	}
	if (staticURLs && staticURLs.length > 0) {
		var staticURL = staticURLs.shift();
		var url = appContextPath + staticURL.url;
		if (staticURL.appendCacheKillerVersion !== false) {
			staticURL.url = url = url + "?v=" + cacheKillerVersion;
		}
		var callback = this._cacheStaticResources.bind(this, staticURLs, staticURL);
		AjxRpc.invoke(null, url, null, callback, true);
	}
	else {
		var callback = this._cacheStaticResourcesContinue.bind(this);
		AjxDispatcher.require(["Contacts", "TinyMCE", "Extras"], true, callback);
	}
};

ZmOffline.prototype._cacheStaticResourcesContinue =
function() {
	var callback = this.sendSyncRequest.bind(this, appCtxt.reloadAppCache.bind(appCtxt));
	var cacheSignatureImages = this._cacheSignatureImages.bind(this, callback);
	var tinyMCELocale = tinyMCE.getlanguage(appCtxt.get(ZmSetting.LOCALE_NAME));
	if (tinyMCELocale === "en") {
		cacheSignatureImages();
	}
	else {
		var url = appContextPath + "/js/ajax/3rdparty/tinymce/langs/" + tinyMCELocale + ".js";
		AjxRpc.invoke(null, url, null, cacheSignatureImages, true);
	}
};

ZmOffline.prototype._cacheSignatureImages =
function(callback) {
	var signatures = appCtxt.getSignatureCollection().getSignatures();
	if (!signatures || signatures.length === 0) {
		return callback && callback();
	}
	var template = document.createElement("template");
	var imgSrcArray = [];
	signatures.forEach(function(signature) {
		template.innerHTML = signature.getValue(ZmMimeTable.TEXT_HTML);
		var imgNodeList = template.content.querySelectorAll("img[src]");
		for (var i = 0; i < imgNodeList.length; i++) {
			imgSrcArray.push(imgNodeList[i].getAttribute("src"));
		}
	});
	this._storeSignatureImages(imgSrcArray, callback);
};

ZmOffline.prototype._storeSignatureImages =
function(imgSrcArray, callback) {
	if (!imgSrcArray || imgSrcArray.length === 0) {
		return callback && callback();
	}
	var imgSrc = imgSrcArray.shift();
	var request = $.ajax({
		url: imgSrc,
		dataType: "text",
		headers: {'X-Zimbra-Encoding':'x-base64'}
	});
	request.done(function(imgSrc, response) {
		var imgType = imgSrc.substr(imgSrc.lastIndexOf(".") + 1);
		localStorage.setItem(imgSrc, "data:image/" + imgType + ";base64," + response);
	}.bind(window, imgSrc));
	request.always(this._storeSignatureImages.bind(this, imgSrcArray, callback));
};

ZmOffline.modifySignature =
function(value) {
	var template = document.createElement("template");
	template.innerHTML = value;
	var imgNodeList = template.content.querySelectorAll("img[src]");
	for (var i = 0; i < imgNodeList.length; i++) {
		var img = imgNodeList[i];
		var dataURI = localStorage.getItem(img.getAttribute("src"));
		if (dataURI) {
			img.setAttribute("src", dataURI);
			img.removeAttribute("dfsrc");
			img.removeAttribute("data-mce-src");
		}
	}
	return template.innerHTML;
};

ZmOffline.prototype._downloadCalendar =
function(startTime, endTime, calendarIds, callback, getMessages, previousMessageIds) {
    // Bundle it together in a batch request
    var jsonObj = {BatchRequest:{_jsns:"urn:zimbra", onerror:"continue"}};
    var request = jsonObj.BatchRequest;

    // Get the Cal Manager and CalViewController
    var calMgr = appCtxt.getCalManager();
    var calViewController = calMgr && calMgr.getCalViewController();
    var apptCache = calViewController.getApptCache();

    if (!startTime) {
        var endDate = new Date();
        endDate.setHours(23,59,59,999);
        //grab a week's appt backwards for reminders
        var startDate = new Date(endDate.getTime());
        startDate.setDate(startDate.getDate()-ZmOffline.CALENDAR_LOOK_BEHIND_DAYS);
        startDate.setHours(0,0,0, 0);
        endDate.setDate(endDate.getDate()+ ZmOffline.CALENDAR_READ_AHEAD_DAYS);
        startTime = startDate.getTime();
        endTime   = endDate.getTime();
    }

    if (!calendarIds) {
        // Get the calendars ids stored checked calendars for the first (main) account
        calendarIds = [];
        for (var calendarId in  ZmOffline.calendars) {
            calendarIds.push(calendarId);
        }
    }
    // Store the marker containing the end of the current display time window.
    localStorage.setItem("calendarSyncTime", endTime);

    // Appt Search Request.  This request will provide data for the calendar view displays, the reminders, and
    // the minical display.  Entries will be stored as ZmAppt data,
    var searchParams = {
        start:            startTime,
        end:              endTime,
        accountFolderIds: calendarIds,
        folderIds:        calendarIds,
        offset:           0
    }
    apptCache.setFolderSearchParams(searchParams.folderIds, searchParams);
    request.SearchRequest = {_jsns:"urn:zimbraMail"};
    apptCache._setSoapParams(request.SearchRequest, searchParams);

    var respCallback = this._handleCalendarResponse.bind(this, startTime, endTime, callback, getMessages, previousMessageIds, null);
    appCtxt.getRequestMgr().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
};

ZmOffline.prototype._downloadByApptId =
function(apptIds, itemQueryClause, startTime, endTime, callback) {
    // Place the search in a batchRequest, so handleCalendarResponse can unpack it in the same way
    var jsonObj = {BatchRequest:{_jsns:"urn:zimbra", onerror:"continue"}};
    jsonObj.BatchRequest.SearchRequest = {_jsns:"urn:zimbraMail"};
    var request = jsonObj.BatchRequest.SearchRequest;
    request.sortBy = "none";
    request.limit  = "500";
    request.offset = 0;
    request.locale = { _content: AjxEnv.DEFAULT_LOCALE };
    request.types  = ZmSearch.TYPE[ZmItem.APPT];
    var query      = itemQueryClause.join(" OR ");
    request.query  = {_content:query};
    request.calExpandInstStart = startTime;
    request.calExpandInstEnd   = endTime;

    // Call with getMessages == false, so callback will continue the downloading, and do the combined getMsgRequest call
    var respCallback = this._handleCalendarResponse.bind(this, startTime, endTime, callback, callback == null, null, apptIds);
    appCtxt.getRequestMgr().sendRequest({jsonObj:jsonObj, asyncMode:true, callback:respCallback});
}

ZmOffline.prototype._handleCalendarResponse =
function(startTime, endTime, callback, getMessages, previousMessageIds, apptIds, response) {

    var batchResp   = response && response._data && response._data.BatchResponse;
    var searchResp  = batchResp && batchResp.SearchResponse && batchResp.SearchResponse[0];

    try{
        var rawAppt;
        var appt;
        var apptList = new ZmApptList();
        // Convert the raw appts into ZmAppt objects.  Each rawAppt may represent several actual appointments (if the
        // appt is a recurring one), with differing start and end dates.  So break a raw appt into its component appts
        // and store them individually, with start and end time index info.
        apptList.loadFromSummaryJs(searchResp.appt, true);
        var numAppt = apptList.size();
        var apptContainers = [];
        var apptContainer;
        var apptStartTime;
        var apptEndTime;
        var msgIds = previousMessageIds ? previousMessageIds : [];
        var uniqueMsgIds = {};
        for (var i = 0; i < numAppt; i++) {
            appt       = apptList.get(i);
            apptStartTime  = appt.startDate.getTime();
            apptEndTime    = appt.endDate.getTime();
            // If this was called via _downloadByApptId (Sync items), prune if a synced item is outside
            // of the display window.  This may not be needed, since it looks like we can use calExpandInstStart and
            // End in the Search, but leave it for the moment.
            if (((apptStartTime >= startTime) && (apptStartTime <= endTime)) ||
                ((apptEndTime   >= startTime) && (apptEndTime   <= endTime)) ) {
                // The appts do not contain a unique id for each instance.  Generate one (used as the primary key),
                // for each appt/instance and store the appt with a container that has the index fields

                this._cleanApptForStorage(appt);
                apptContainer = {appt: appt,
                                 instanceId: this._createApptPrimaryKey(appt),
                                 id:         appt.id,
                                 invId:      appt.invId,
                                 startDate:  apptStartTime,
                                 endDate:    apptEndTime
                                };
                apptContainers.push(apptContainer);

                // Accumulate the msgIds for reading the appt invites.  Do that here to pick up any series exceptions
                // Note:  ZmCalItem.getDetails does:
                //   var id = seriesMode ? (this.seriesInvId || this.invId || this.id) : this.invId;
                // seriesInvId is the invId or null, constructed on dom load.  We want the actual invIds
                var msgId = appt.invId || appt.id;
                uniqueMsgIds[msgId] = true;
            }
        }
        for (var uniqueId in uniqueMsgIds) {
            msgIds.push(uniqueId);
        }

        // Unfortunately, periodic appts have a cancel mode ('Delete this instance and any future
        // ones') that removes a portion of the appts associated with an apptId.  In order to
        // assure that we have the correct appts and instances, delete all appts mentioned in
        // the apptIds (provided when syncing) and then write the newly acquired appts (i.e. an
        // update will be a delete then rewrite).
        if (apptIds) {
            var search;
            var offlineUpdateAppts = this._offlineUpdateAppts.bind(this, apptContainers);
            for (var apptId in apptIds) {
                search = [apptId];
                // If its a recurring appt, several ZmAppts may share the same id.  Find them and delete them all
                ZmOfflineDB.doIndexSearch(search, ZmApp.CALENDAR, null, offlineUpdateAppts,
                    this.calendarDeleteErrorCallback.bind(this), "id");
            }
        }  else {
			// Store the new/modified entries.
			ZmOfflineDB.setItem(apptContainers, ZmApp.CALENDAR, null, this.calendarDownloadErrorCallback.bind(this));
		}

        // Now make a server read to get the detailed appt invites, for edit view and tooltips
        if (getMessages) {
            if (msgIds.length > 0) {
                var updateProgress = this._updateCacheProgress.bind(this, ZmOffline.CALENDAR_PROGRESS);
                this._loadMessages(msgIds, updateProgress);
            } else {
                this._updateCacheProgress(ZmOffline.CALENDAR_PROGRESS);
            }
        }

        var calMgr = appCtxt.getCalManager();
        var calViewController = calMgr && calMgr.getCalViewController();
        var apptCache = calViewController.getApptCache();
        apptCache.clearCache();
    }catch(ex){
        DBG.println(AjxDebug.DBG1, ex);
        if (!callback) {
            this._updateCacheProgress(ZmOffline.CALENDAR_PROGRESS);
        }
    }

    if (callback) {
        callback.run(msgIds);
    }

};
ZmOffline.prototype.calendarDownloadErrorCallback =
function(e) {
    DBG.println(AjxDebug.DBG1, "Error while adding appts to indexedDB.  Error = " + e);
}
ZmOffline.prototype.calendarDeleteErrorCallback =
function(e) {
    DBG.println(AjxDebug.DBG1, "Error while deleting appts from indexedDB.  Error = " + e);
}

ZmOffline.prototype._createApptPrimaryKey =
function(appt) {
    return appt.id + ":" + appt.startDate.getTime();
}

ZmOffline.prototype._cleanApptForStorage =
function(appt) {
    delete appt.list;
    delete appt._list;
    delete appt._evt;
    delete appt._evtMgr;
}

ZmOffline.prototype._updateCacheProgress =
function(folderName){

    var index = $.inArray(folderName, ZmOffline.cacheProgress);
    if(index != -1){
        ZmOffline.cacheProgress.splice(index, 1);
    }
    if (ZmOffline.cacheProgress.length === 0){
        //this.sendSyncRequest();
        ZmOffline._checkCacheDone();
    }
    DBG.println(AjxDebug.DBG1, "_updateCacheProgress folder: " + folderName + " ZmOffline.cacheProgress " + ZmOffline.cacheProgress.join());


};

ZmOffline.prototype.scheduleSyncRequest =
function(notify, methodName) {
	if (methodName === "SyncRequest") {
		return;
	}
	var keys = Object.keys(notify.created || {});
	keys = keys.concat(Object.keys(notify.modified || {}));
	keys = keys.concat(Object.keys(notify.deleted || {}));
	if (keys.length === 0) {
		return;
	}
	if (this._syncRequestActionId) {
		AjxTimedAction.cancelAction(this._syncRequestActionId);
	}
	this._syncRequestActionId = AjxTimedAction.scheduleAction(new AjxTimedAction(this, this.sendSyncRequest), ZmOffline.SYNC_REQUEST_DELAY);
};

ZmOffline.prototype.sendSyncRequest =
function(callback) {
	ZmOffline.refreshStatusIcon(true);
	var syncToken = localStorage.getItem("SyncToken");
	if (syncToken) {
		AjxDebug.println(AjxDebug.OFFLINE, "syncToken :: "+syncToken);
		this._sendDeltaSyncRequest(callback, syncToken);
	}
	else {
		this._sendInitialSyncRequest(callback);
	}
};

ZmOffline.prototype._sendInitialSyncRequest =
function(callback) {
	var syncRequestArray = [];
	var keys = AjxUtil.keys(ZmOffline.folders);
	for (var i = 0, length = keys.length; i < length; i++) {
		var folder = ZmOffline.folders[keys[i]];
		if (folder && folder.id != ZmFolder.ID_OUTBOX) {
			var params = {l:folder.id, _jsns:"urn:zimbraMail"};
			if (folder.type === "FOLDER") {
				//specify the start date for the mail to be synched
				var startDate = AjxDateUtil.roll(new Date(), AjxDateUtil.DAY, -parseInt(folder.webOfflineSyncDays));
				params.msgCutoff = Math.round(startDate.getTime() / 1000);
			}
			syncRequestArray.push(params);
		}
	}
	if (syncRequestArray.length > 0) {
		var params = {
			jsonObj : {BatchRequest:{_jsns:"urn:zimbra", onerror:"continue", SyncRequest:syncRequestArray}},
			asyncMode : true,
			callback : this._handleInitialSyncResponse.bind(this, true, callback),
			errorCallback : this._handleInitialSyncError.bind(this)
		};
		appCtxt.getRequestMgr().sendRequest(params);
	}
};

ZmOffline.prototype._handleInitialSyncResponse =
function(downloadCalendar, callback, result) {
	var response = result && result.getResponse();
	var batchResponse = response && response.BatchResponse;
	var syncResponse = batchResponse && batchResponse.SyncResponse;
	if (!syncResponse) {
		return;
	}
	var msgParamsArray = [];
	var contactIdsArray = [];
	var syncToken;
	var more;
	syncResponse.forEach(function(response) {
		var folderInfo = response.folder && response.folder[0];
		if (folderInfo) {
			if (folderInfo.m) {
				var msgIds = folderInfo.m[0].ids;
				if (msgIds) {
					// Check for a shared-mailbox folder.  If so, the msgIds must be specified as mountpoint:msgId
					var idParts = folderInfo.id.split(":");
					var prefix = (idParts.length > 1) ? idParts[0] + ":" : "";
					msgIds.split(",").forEach(function(id) {
						var params = {
							m : {id: prefix + id, html:1, needExp:1},
							_jsns : "urn:zimbraMail"
						};
						msgParamsArray.push(params);
					});
				}
			}
			else if (folderInfo.cn) {
				var contactIds = folderInfo.cn[0].ids;
				if (contactIds) {
					contactIdsArray = contactIdsArray.concat(contactIds.split(","));
				}
			}
		}
		syncToken = response.token;
		more = response.more;
	});
	var params = {
		msgs : msgParamsArray,
		contactIds : contactIdsArray
	};
	// if more="1" is specified on the sync response, the response does *not* bring the client completely up to date. more changes are still queued, and another SyncRequest (using the new returned token) is necessary.
	if (more == 1) {
		params.callback = this.sendSyncRequest.bind(this, callback);
	}
	else {
		params.callback = callback;
	}
	this._sendGetRequest(params);
	if (downloadCalendar) {
		this._downloadCalendar(null, null, null, null, true, null);
	}
	this._storeSyncToken(syncToken);
};

ZmOffline.prototype._handleInitialSyncError =
function() {
	ZmOffline.refreshStatusIcon();
};

ZmOffline.prototype._sendGetRequest =
function(params) {
	var msgs = params.msgs || [];
	var contactIds = params.contactIds || [];
	var msgsLength = msgs.length;
	var contactIdsLength = contactIds.length;
	if (msgsLength === 0 && contactIdsLength === 0) {
		if (params.callback && !params.isCallbackExecuted) {
			params.isCallbackExecuted = true;
			params.callback();
		}
		ZmOffline.refreshStatusIcon();
	}
	else {
		var getCallback = this._sendGetRequest.bind(this, params);
		var newParams = {
			jsonObj : {BatchRequest:{_jsns:"urn:zimbra", onerror:"continue"}},
			asyncMode : true,
			callback : this._handleGetResponse.bind(this, getCallback),
			errorCallback : this._handleGetError.bind(this, getCallback)
		};
		var batchRequest = newParams.jsonObj.BatchRequest;
		//Limit maximum number of request in batch request to ZmOffline.MAX_REQUEST_IN_BATCH_REQUEST property
		var getMsgRequest = msgs.splice(0, ZmOffline.MAX_REQUEST_IN_BATCH_REQUEST);
		if (getMsgRequest.length > 0) {
			batchRequest.GetMsgRequest = getMsgRequest;
		}
		if (contactIdsLength > 0 && getMsgRequest.length < ZmOffline.MAX_REQUEST_IN_BATCH_REQUEST) {
			batchRequest.GetContactsRequest = {_jsns:"urn:zimbraMail", derefGroupMember:1, cn:{id:contactIds.join()}};
			contactIds.splice(0, contactIdsLength);
		}
		appCtxt.getRequestMgr().sendRequest(newParams);
	}
};

ZmOffline.prototype._sendDeltaSyncRequest =
function(callback, syncToken) {
	var params = {
		jsonObj : {SyncRequest:{_jsns:"urn:zimbraMail", token:syncToken, typed:1}},
		asyncMode : true,
		callback : this._handleDeltaSyncResponse.bind(this, callback, syncToken),
		errorCallback : this._handleDeltaSyncError.bind(this)
	};
	appCtxt.getRequestMgr().sendRequest(params);
};

ZmOffline.prototype._handleDeltaSyncResponse =
function(callback, syncToken, result) {
	ZmOffline.refreshStatusIcon();
	var syncResponse = result && result.getResponse().SyncResponse;
	if (!syncResponse || syncResponse.token === syncToken) {
		if (callback) {
			callback();
		}
		return;
	}
	this._storeSyncToken(syncResponse.token);
	if (syncResponse.deleted) {
		this._handleSyncDeletes(syncResponse.deleted);
	}
	if (syncResponse.m || syncResponse.cn) {
		this._handleSyncUpdate(syncResponse);
	}
	if (syncResponse.appt) {
		this._handleUpdateAppts(syncResponse.appt);
	}
	if (syncResponse.folder) {
		this._handleUpdateFolders(syncResponse.folder);
	}
    if (syncResponse.folder || syncResponse.search) {
        appCtxt.reloadAppCache();
    }
	if (callback) {
		callback();
	}
};

ZmOffline.prototype._handleDeltaSyncError =
function(ex) {
	ZmOffline.refreshStatusIcon();
	if (ex && ex.code === ZmCsfeException.MAIL_MUST_RESYNC) {
		//if the response is a mail.MUST_RESYNC fault, client has fallen too far out of date and must re-initial sync
		localStorage.removeItem("SyncToken");
		this.sendSyncRequest();
		return true;
	}
};

ZmOffline.prototype._handleSyncDeletes =
function(deletes) {
	var deletedInfo = deletes[0];
	if (!deletedInfo) {
		return;
	}
	if (deletedInfo.m) {
		var deletedMsgIds = deletedInfo.m[0] && deletedInfo.m[0].ids;
		if (deletedMsgIds) {
			var deletedMsgIdArray = [].concat(deletedMsgIds.split(","));
		}
	}
	if (deletedInfo.cn) {
		var deletedContactIds = deletedInfo.cn[0] && deletedInfo.cn[0].ids;
		if (deletedContactIds) {
			var deletedContactsIdArray = [].concat(deletedContactIds.split(","));
		}
	}
	if (deletedMsgIdArray && deletedMsgIdArray.length > 0) {
		ZmOfflineDB.deleteItem(deletedMsgIdArray, ZmApp.MAIL);
	}
	if (deletedContactsIdArray && deletedContactsIdArray.length > 0) {
		ZmOfflineDB.deleteItem(deletedContactsIdArray, ZmApp.CONTACTS);
	}
};

ZmOffline.prototype._handleSyncUpdate =
function(syncResponse) {
	var msgs = syncResponse.m;
	var contacts = syncResponse.cn;
	var msgParamsArray = [];
	var contactIdsArray = [];
	if (msgs) {
		var offlineFolderIds = Object.keys(ZmOffline.folders);
		var nonOfflineMsgIds = [];
		msgs.forEach(function(msg) {
			//Get messages only if it belongs to offline folder
			if (msg.l && offlineFolderIds.indexOf(msg.l) !== -1) {
				var params = {m:{id:msg.id, html:1, needExp:1}, _jsns:"urn:zimbraMail"};
				msgParamsArray.push(params);
			} else {
				nonOfflineMsgIds.push(msg.id);
			}
		});
		if (nonOfflineMsgIds.length > 0) {
			// Fix for Bug 95758.  Try and delete the messages from the mail store, in case some were stored offline.
			// This happens when a message is moved from a folder that stores offline messages to one that does not.
			ZmOfflineDB.deleteItem(nonOfflineMsgIds, ZmApp.MAIL);
		}
	}
	if (contacts) {
		contacts.forEach(function(contact) {
			contactIdsArray.push(contact.id);
		});
	}
	ZmOffline.refreshStatusIcon(true);
	this._sendGetRequest({msgs : msgParamsArray, contactIds : contactIdsArray});
};

ZmOffline.prototype._handleUpdateFolders =
function(folders) {
	var syncRequestArray = [];
	folders.forEach(function(folder) {
		var folderId = folder.id;
		var params = {l:folderId, _jsns:"urn:zimbraMail"};
		if (folder.view === "message") {
			var isExistingOfflineFolder = ZmOffline.folders.hasOwnProperty(folderId);
			if (isExistingOfflineFolder && folder.webOfflineSyncDays == 0) {
				var callback = function(result) {
					ZmOfflineDB.deleteItem(result, ZmApp.MAIL);
				};
				ZmOfflineDB.doIndexSearch([folderId.toString()], ZmApp.MAIL, null, callback, null, "folder", true);
				delete ZmOffline.folders[folderId];
			}
			else if ( (isExistingOfflineFolder && folder.webOfflineSyncDays != ZmOffline.folders[folderId].webOfflineSyncDays)
					  || (!isExistingOfflineFolder && folder.webOfflineSyncDays != 0) ) {
				//If existing offline folders webOfflineSyncDays property is modified or new folders webOfflineSyncDays property is set
				//specify the start date for the mail to be synched
				var startDate = AjxDateUtil.roll(new Date(), AjxDateUtil.DAY, -parseInt(folder.webOfflineSyncDays));
				params.msgCutoff = Math.round(startDate.getTime() / 1000);
				syncRequestArray.push(params);
				ZmOffline.folders[folderId] = folder;
			}
		}
		else if (folder.view === "contact") {
			syncRequestArray.push(params);
			ZmOffline.folders[folderId] = folder;
		}
	});
	if (syncRequestArray.length > 0) {
		var params = {
			jsonObj : {BatchRequest:{_jsns:"urn:zimbra", onerror:"continue", SyncRequest:syncRequestArray}},
			asyncMode : true,
			callback : this._handleInitialSyncResponse.bind(this, false, false)
		};
		ZmOffline.refreshStatusIcon(true);
		appCtxt.getRequestMgr().sendRequest(params);
	}
};

ZmOffline.prototype._storeSyncToken =
function(syncToken) {
	AjxDebug.println(AjxDebug.OFFLINE, "New syncToken :: " + syncToken);
	localStorage.setItem("SyncToken", syncToken);
};

ZmOffline.prototype._handleGetResponse =
function(callback, result) {
	var response = result && result.getResponse();
	var batchResponse = response && response.BatchResponse;
	if (!batchResponse) {
		return;
	}
	var getMsgResponse = batchResponse.GetMsgResponse;
	if (getMsgResponse) {
		var msgs = [];
		for (var i = 0; i < getMsgResponse.length; i++) {
			msgs.push(getMsgResponse[i].m[0]);
		}
		var setItemCallback = this._handleSetItemCallback.bind(this, msgs, ZmApp.MAIL, callback);
		ZmOfflineDB.setItem(msgs, ZmApp.MAIL, setItemCallback);
	}
	var getContactsResponse = batchResponse.GetContactsResponse;
	if (getContactsResponse) {
		var contacts = [];
		for (var i = 0; i < getContactsResponse.length; i++) {
			contacts = contacts.concat(getContactsResponse[i].cn);
		}
		var setItemCallback = this._handleSetItemCallback.bind(this, contacts, ZmApp.CONTACTS, callback);
		ZmOfflineDB.setItem(contacts, ZmApp.CONTACTS, setItemCallback);
	}
};

ZmOffline.prototype._handleSetItemCallback =
function(item, type, callback) {
	if (callback) {
		callback();
	}
	if (type === ZmApp.MAIL) {
		this._fetchMsgAttachments(item);
	}
};

ZmOffline.prototype._handleGetError =
function(folder, index, result) {
	localStorage.removeItem("SyncToken");
};

// Different enough from mail to warrent its own function
ZmOffline.prototype._handleUpdateAppts =
function(items, type){

    if (!items) items = [];

    var item = null;
    var folders = {};
    var startOfDayDate = new Date();
    var currentTime    = startOfDayDate.getTime();
    var endOfDayDate   = new Date(currentTime);

    // We only care about changes within our display window.
    startOfDayDate.setHours(0,0,0,0);
    var newStartTime = startOfDayDate.getTime() - (AjxDateUtil.MSEC_PER_DAY * ZmOffline.CALENDAR_LOOK_BEHIND_DAYS);
    endOfDayDate.setHours(23,59,59,999)
    var newEndTime   = endOfDayDate.getTime()   + (AjxDateUtil.MSEC_PER_DAY * ZmOffline.CALENDAR_READ_AHEAD_DAYS);

    var previousEndTime = newEndTime;
    var lastSyncTime = localStorage.getItem("calendarSyncTime");
    if (lastSyncTime) {
        previousEndTime = parseInt(lastSyncTime) + (AjxDateUtil.MSEC_PER_DAY * ZmOffline.CALENDAR_READ_AHEAD_DAYS);
    }
    localStorage.setItem("calendarSyncTime", endOfDayDate.getTime());

    // Accumulate the ids of the altered appts
    var itemQueryClause = [];
    var apptIds  = {};
    var sId;
    for (var i = 0, length = items.length; i < length; i++){
        item = items[i];
        sId = item.id.toString();
        apptIds[sId] = true;
        itemQueryClause.push("item:\"" + sId + "\"");
    }

    // If this is not the first download, we need to extend the visible range beyond the last update which read
    // calendar items from current-1week to current+3weeks.  So if 2 days has passed since the previous
    // read, read from the previousEnd to previousEnd+2days;  We also update previousEnd (by setting
    // calendarSyncTime in localstore).
    var doEndRangeDownloadCallback = (newEndTime > previousEndTime) ?
        this._downloadCalendar.bind(this, previousEndTime, newEndTime, null, null, true) : null;

    if (itemQueryClause.length > 0) {
        this._downloadByApptId(apptIds, itemQueryClause, newStartTime, newEndTime, doEndRangeDownloadCallback);
    } else if (doEndRangeDownloadCallback) {
        doEndRangeDownloadCallback.run();
    }

    // Delete items < newStartTime, in order to prune old entries and prevent monotonic accumulation
    // Search for items whose endTime is from 0 to newStartTime
    var search = [0, newStartTime];
    var errorCallback = this._expiredErrorCallback.bind(this);
    var offlineSearchExpiredAppts = this._offlineUpdateAppts.bind(this, null);
    ZmOfflineDB.doIndexSearch(search, ZmApp.CALENDAR, null, offlineSearchExpiredAppts, errorCallback, "endDate");
};

ZmOffline.prototype._offlineUpdateAppts =
function(apptContainersToAdd, apptContainersToDelete) {
    var appt;
	if (apptContainersToDelete) {
		for (var i = 0; i < apptContainersToDelete.length; i++) {
			appt = apptContainersToDelete[i].appt;
			ZmOfflineDB.deleteItem(this._createApptPrimaryKey(appt), ZmApp.CALENDAR, this.calendarDeleteErrorCallback.bind(this));
		}
	}

	// Store the new/modified entries.
	if (apptContainersToAdd) {
		ZmOfflineDB.setItem(apptContainersToAdd, ZmApp.CALENDAR, null, this.calendarDownloadErrorCallback.bind(this));
	}
}

ZmOffline.prototype._expiredErrorCallback =
function(e) {
    DBG.println(AjxDebug.DBG1, "Error while trying to search for expired appts in indexedDB.  Error = " + e);
}

ZmOffline.prototype._loadMessages =
function(msgIds, callback){
    if (!msgIds || msgIds.length === 0){
        return;
    }
    var soapDoc = AjxSoapDoc.create("BatchRequest", "urn:zimbra");
    soapDoc.setMethodAttribute("onerror", "continue");
    for (var i=0, length = msgIds.length;i<length;i++){
        var requestNode = soapDoc.set("GetMsgRequest",null,null,"urn:zimbraMail");
        var msg = soapDoc.set("m", null, requestNode);
        msg.setAttribute("id", msgIds[i]);
        msg.setAttribute("read", 0);
        msg.setAttribute("html", 1);
        msg.setAttribute("needExp", 1);
     }
    var respCallback = this._handleGetResponse.bind(this, callback);
    appCtxt.getRequestMgr().sendRequest({
        soapDoc: soapDoc,
        asyncMode: true,
        callback: respCallback
    });

};


ZmOffline.prototype._replayOfflineRequest =
function() {
    var callback = this._sendOfflineRequest.bind(this);
    ZmOfflineDB.getItemInRequestQueue(false, callback);
};

ZmOffline.prototype._sendOfflineRequest =
function(result, skipOfflineAttachmentUpload) {

    if (!result || result.length === 0) {
        return;
    }

	if (skipOfflineAttachmentUpload) {
		var idArray = [];
		var oidArray = [];
		// Bundle it together in a batch request
		var params = {
			jsonObj : {BatchRequest:{_jsns:"urn:zimbra", onerror:"continue"}},
			asyncMode : true
		};
		params.errorCallback = params.callback = this._handleResponseSendOfflineRequest.bind(this, idArray, oidArray);
		var batchRequest = params.jsonObj.BatchRequest;
		result.forEach(function(obj) {
			var methodName = obj.methodName;
			if (methodName === "BatchRequest") {
				$.extend(true, batchRequest, obj[methodName]);
			}
			else {
				if (!batchRequest[methodName]) {
					batchRequest[methodName] = [];
				}
				batchRequest[methodName].push(obj[methodName]);
			}
			idArray.push(obj.id);
			oidArray.push(obj.oid);
		});
		appCtxt.getRequestMgr().sendRequest(params);
	}
	else {
		var offlineAttachments = [];
		result.forEach(function(obj) {
			var methodName = obj.methodName;
			if (methodName === "SendMsgRequest" || methodName === "SaveDraftRequest") {
				var msg = obj[methodName].m;
				var attach = msg && msg.attach;
				if (attach) {
					for (var j in attach) {
						var attachmentObj = attach[j];
						if (attachmentObj && attachmentObj.isOfflineUploaded) {
							offlineAttachments.push(attachmentObj);
						}
					}
				}
				var flags = msg && msg.f;
				if (flags && flags.indexOf(ZmItem.FLAG_OFFLINE_CREATED) !== -1) {
					msg.f = flags.replace(ZmItem.FLAG_OFFLINE_CREATED, "");//Removing the offline created flag
					if (!msg.f) {
						delete msg.f;
					}
					delete msg.id;//Removing the temporary id
					delete msg.did;//Removing the temporary draft id
				}
			}
		});
		this._uploadOfflineAttachments(offlineAttachments, result);
	}
};

ZmOffline.prototype._handleResponseSendOfflineRequest =
function(idArray, oidArray) {
	if (idArray.length > 0) {
		var callback = ZmOffline.updateFolderCountCallback.bind(window, ZmFolder.ID_OUTBOX, 0);
		ZmOfflineDB.deleteItem(idArray, ZmApp.MAIL, callback);
	}
	if (oidArray.length > 0) {
		ZmOfflineDB.deleteItemInRequestQueue(oidArray);
	}
};

ZmOffline.prototype._getFolder =
function(index){
    for (var i=0, length = ZmOffline.folders.length; i< length; i++){
        if (ZmOffline.folders[i].id == index){
            return ZmOffline.folders[i].name;
        }
    }
    if (ZmOffline.calendars[index]) {
        return ZmOffline.calendars[index];
    } else {
        return null;
    }
};

/**
 * Deletes conversations or messages from the offline database.
 * @param {deletedIds}	array of message/convesation id's to be deleted from offline database.
 * @param {type}    type of the mail item ("message" or "conversation").
 */

ZmOffline.prototype.deleteItem =
function(deletedIds, type, folder){
    if (!deletedIds || deletedIds.length === 0){
        return;
    }
    var store = folder + type;
    for (var i=0, length = deletedIds.length;i < length; i++){
        ZmOfflineDB.deleteItem(deletedIds[i], store);
    }

};

ZmOffline.deleteOfflineData =
function() {
    DBG.println(AjxDebug.DBG1, "ZmOffline.deleteOfflineData");
    ZmOfflineDB.deleteDB();
    localStorage.clear();
};

ZmOffline.generateMsgResponse =
function(result) {
    var resp = [],
        obj,
        msgNode,
        generatedMsg,
        messagePart,
        i,
        length;

    result = [].concat(result);
    for (i = 0, length = result.length; i < length; i++) {
        obj = result[i];
        if (obj) {
            msgNode = obj[obj.methodName] && obj[obj.methodName]["m"];
            if (msgNode) {
                generatedMsg = {
                    id : msgNode.id,
                    f : msgNode.f || "",
                    mid : msgNode.mid,
                    cid : msgNode.cid,
                    idnt : msgNode.idnt,
                    e : msgNode.e,
                    l : "",
                    fr : "",
                    su : msgNode.su._content,
                    mp : [],
                    d : msgNode.d
                };
                //Flags
                if (obj.methodName === "SendMsgRequest") {
                    generatedMsg.f = generatedMsg.f.replace(ZmItem.FLAG_ISSENT, "").concat(ZmItem.FLAG_ISSENT);
                }
                else if (obj.methodName === "SaveDraftRequest") {
                    generatedMsg.f = generatedMsg.f.replace(ZmItem.FLAG_ISDRAFT, "").concat(ZmItem.FLAG_ISDRAFT);
                }
                if (msgNode.attach) {//attachment is there
                    generatedMsg.f = generatedMsg.f.replace(ZmItem.FLAG_ATTACH, "").concat(ZmItem.FLAG_ATTACH);
                }
                //Folder id
                if (obj.methodName === "SendMsgRequest") {
                    generatedMsg.l = ZmFolder.ID_OUTBOX.toString();
                }
                else if (obj.methodName === "SaveDraftRequest") {
                    generatedMsg.l = ZmFolder.ID_DRAFTS.toString();
                }
                //Message part
                messagePart = msgNode.mp[0];
                if (messagePart) {
                    var attach = msgNode.attach;
                    if (attach && attach.aid) { //attachment is there

                        generatedMsg.mp.push({
                            ct : ZmMimeTable.MULTI_MIXED,
                            part: ZmMimeTable.TEXT,
                            mp : []
                        });

                        if (messagePart.ct === ZmMimeTable.TEXT_PLAIN) {

                            generatedMsg.mp[0].mp.push({
                                body : true,
                                part : "1",
                                ct : ZmMimeTable.TEXT_PLAIN,
                                content : messagePart.content._content
                            });
                            generatedMsg.fr = generatedMsg.mp[0].mp[0].content;

                        } else if (messagePart.ct === ZmMimeTable.MULTI_ALT) {

                            generatedMsg.mp[0].mp.push({
                                ct : ZmMimeTable.MULTI_ALT,
                                part : "1",
                                mp : [{
                                        ct : ZmMimeTable.TEXT_PLAIN,
                                        part : "1.1",
                                        content : (messagePart.mp[0].content) ? messagePart.mp[0].content._content : ""
                                       },
                                       {
                                        ct : ZmMimeTable.TEXT_HTML,
                                        part : "1.2",
                                        body : true,
                                        content : (messagePart.mp[1].content) ? messagePart.mp[1].content._content : ""
                                       }
                                ]
                            });
                            generatedMsg.fr = generatedMsg.mp[0].mp[0].mp[0].content;

                        }

                        var attachIds = attach.aid.split(",");
                        for (var j = 0; j < attachIds.length; j++) {
                            var attachment = attach[attachIds[j]];
                            if (attachment) {
                                generatedMsg.mp[0].mp.push({
                                    cd : "attachment",
                                    ct : attachment.ct,
                                    filename : attachment.filename,
                                    aid : attachment.aid,
                                    s : attachment.s,
                                    data : attachment.data,
                                    isOfflineUploaded : attachment.isOfflineUploaded,
                                    part : (j + 2).toString()
                                });
                            }
                        }

                    } else {

                        if (messagePart.ct === ZmMimeTable.TEXT_PLAIN) {

                            generatedMsg.mp.push({
                                ct : ZmMimeTable.TEXT_PLAIN,
                                body : true,
                                part : "1",
                                content : messagePart.content._content
                            });
                            generatedMsg.fr = generatedMsg.mp[0].content;

                        } else if (messagePart.ct === ZmMimeTable.MULTI_ALT) {

                            generatedMsg.mp.push({
                                ct : ZmMimeTable.MULTI_ALT,
                                part: ZmMimeTable.TEXT,
                                mp : [{
                                        ct : ZmMimeTable.TEXT_PLAIN,
                                        part : "1",
                                        content : (messagePart.mp[0].content) ? messagePart.mp[0].content._content : ""
                                    },
                                    {
                                        ct : ZmMimeTable.TEXT_HTML,
                                        part : "2",
                                        body : true,
                                        content : (messagePart.mp[1].content) ? messagePart.mp[1].content._content : ""
                                    }
                                ]
                            });
                            generatedMsg.fr = generatedMsg.mp[0].mp[0].content;

                        }
                    }
                }
            }
            resp.push(generatedMsg);
        }
    }
    return resp;
};

/**
 * For ZWC offline, adds outbox folder
 */
ZmOffline.addOutboxFolder =
function() {
    if (!appCtxt.isWebClientOfflineSupported) {
        return;
    }
    var folderTree = appCtxt.getFolderTree(),
        root = folderTree.root,
        folderObj = {
            id: ZmFolder.ID_OUTBOX,
            absFolderPath: "/Outbox",
            activesyncdisabled: false,
            name: "Outbox"
        };
    var folder = ZmFolderTree.createFolder(ZmOrganizer.FOLDER, root, folderObj, folderTree, null, "folder");
    root.children.add(folder);
};

ZmOffline.updateFolderCount =
function() {
	var folders = [ZmFolder.ID_DRAFTS, ZmFolder.ID_OUTBOX];
	for (var i = 0, length = folders.length; i < length; i++) {
		var callback = ZmOffline.updateFolderCountCallback.bind(window, folders[i]);
		ZmOfflineDB.doIndexSearch([folders[i].toString()], ZmApp.MAIL, null, callback, null, "folder", true);
	}
};

ZmOffline.updateFolderCountCallback =
function(folderId, count) {
	if (AjxUtil.isArray(count)) {
		count = count.length;
	}
	var folder = appCtxt.getById(folderId);
	if (folder) {
		folder.notifyModify({n : count});
	}
};

ZmOffline.prototype._uploadOfflineAttachments =
function (attachments, result) {
	var attachment = attachments.shift();
	if (attachment) {
		var blob = AjxUtil.dataURItoBlob(attachment.data);
		if (blob) {
			blob.name = attachment.filename;
			var callback = this._uploadOfflineAttachmentsCallback.bind(this, attachments, result, attachment.aid);
			var errorCallback = this._uploadOfflineAttachmentsErrorCallback.bind(this, attachments, result, attachment.aid);
			ZmComposeController.prototype._uploadImage(blob, callback, errorCallback);
		}
	}
	else {
		this._sendOfflineRequest(result, true);
	}
};

ZmOffline.prototype._uploadOfflineAttachmentsCallback =
function(attachments, result, attachmentAid, uploadResponse) {
	for (var i = 0; i < result.length; i++) {
		var obj = result[i];
		if (!obj) {
			continue;
		}
		var methodName = obj.methodName;
		if (methodName === "SendMsgRequest" || methodName === "SaveDraftRequest") {
			var msg = obj[methodName].m;
			var attach = msg && msg.attach;
			var aid = attach && attach.aid;
			if (aid && aid.indexOf(attachmentAid) !== -1) {
				attach.aid = aid.replace(attachmentAid, uploadResponse[0].aid);
				delete attach[attachmentAid];
				break;
			}
		}
	}
	this._uploadOfflineAttachments(attachments, result);
};

ZmOffline.prototype._uploadOfflineAttachmentsErrorCallback =
function(attachments, result, attachmentAid) {
	for (var i = 0; i < result.length; i++) {
		var obj = result[i];
		if (!obj) {
			continue;
		}
		var methodName = obj.methodName;
		if (methodName === "SendMsgRequest" || methodName === "SaveDraftRequest") {
			var msg = obj[methodName].m;
			var attach = msg && msg.attach;
			var aid = attach && attach.aid;
			if (aid && aid.indexOf(attachmentAid) !== -1) {
				var aidArray = aid.split(",");
				AjxUtil.arrayRemove(aidArray, attachmentAid);
				if (aidArray.length > 0) {
					delete attach.aid;
				}
				else {
					attach.aid = aidArray.join();
				}
				delete attach[attachmentAid];//deleting the offline created attachment in the message node
				break;
			}
		}
	}
	this._uploadOfflineAttachments(attachments, result);
};

ZmOffline.prototype._uploadOfflineInlineAttachments =
function (obj, msg) {
    var template = document.createElement("template");
    template.innerHTML = msg.mp[0].mp[1].content._content;
    var dataURIImageNodeList = template.content.querySelectorAll("img[src^='data:']");
    for (var i = 0; i < dataURIImageNodeList.length; i++) {
        var blob = AjxUtil.dataURItoBlob(dataURIImageNodeList[i].src);
        if (blob) {
            var callback = this._uploadOfflineInlineAttachmentsCallback.bind(this, dataURIImageNodeList[i], obj, msg, template);
            ZmComposeController.prototype._uploadImage(blob, callback);
        }
    }

};

ZmOffline.prototype._uploadOfflineInlineAttachmentsCallback =
function(img, obj, msg, template, uploadResponse) {
    //img.src =
    var dataURIImageNodeList = template.content.querySelectorAll("img[src^='data:']");
    if (dataURIImageNodeList.length === 0) {
        delete msg.isInlineAttachment;
        this._sendOfflineRequest([].concat(obj));
    }
};

/**
 * Fires a head request to find whether server is reachable or not
 * @param {Boolean} [doStop] will not fire a second head request to confirm the server reachability
 * @param {Boolean} [doNotTrigger] Do not trigger online/offline events
 * @param {Function} [callback] Callback function to be called when the request finishes
 */
ZmOffline.checkServerStatus =
function(doStop, doNotTrigger, callback) {
    $.ajax({
        type: "HEAD",
        url: "/public/blank.html",
		cache: false,
        statusCode: {
            0: function() {
                if (ZmOffline.isServerReachable === true) {
                    if (doStop) {
                        // Reset here - state must be correct for functions triggered by ZWCOffline
                        ZmOffline.isServerReachable = false;
						if (!doNotTrigger) {
							$.event.trigger({
								type: "ZWCOffline"
							});
						}
					}
                    else {
                        return ZmOffline.checkServerStatus(true);
                    }
                }
                ZmOffline.isServerReachable = false;
            },
            200: function() {
                if (ZmOffline.isServerReachable === false) {
                    if (doStop) {
                        // Reset here - state must be correct for functions triggered by ZWCOnline
                        ZmOffline.isServerReachable = true;
						if (!doNotTrigger) {
							$.event.trigger({
								type: "ZWCOnline"
							});
						}
					}
                    else {
                        return ZmOffline.checkServerStatus(true);
                    }
                }
                ZmOffline.isServerReachable = true;
			}
		},
		complete: callback
    });
};
ZmOffline.checkServerStatus(true, true);

ZmOffline.isOnlineMode =
function() {
    return appCtxt.isWebClientOfflineSupported && !appCtxt.isWebClientOffline();
};

ZmOffline.prototype._fetchMsgAttachments =
function(messages) {
    var attachments = [];
    messages = ZmOffline.recreateMsg(messages);
    messages.forEach(function(msg) {
        var mailMsg = ZmMailMsg.createFromDom(msg, {}, true);
        var attachInfo = mailMsg.getAttachmentInfo();
        attachInfo.forEach(function(attachment) {
            attachments.push(attachment);
        });
    });
    this._saveAttachments(attachments);
};

ZmOffline.prototype._saveAttachments =
function(attachments) {
    if (!attachments || attachments.length === 0) {
	    ZmOffline.refreshStatusIcon();
        return;
    }
	ZmOffline.refreshStatusIcon(true);
    var attachment = attachments.shift();
    var callback = this._isAttachmentSavedinIndexedDBCallback.bind(this, attachment, attachments);
    ZmOffline.isAttachmentSavedinIndexedDB(attachment, callback);
};

ZmOffline.isAttachmentSavedinIndexedDB =
function(attachment, callback, errorCallback) {
    var key = ZmOffline.createAttachmentKey(attachment);
    ZmOfflineDB.getItemCount(key, ZmOffline.ATTACHMENT, callback, errorCallback);
};

ZmOffline.createAttachmentKey = function(attachment) {
	return "id=" + attachment.mid + "&part=" + attachment.part;
}

ZmOffline.prototype._isAttachmentSavedinIndexedDBCallback =
function(attachment, attachments, count) {
    var callback = this._saveAttachments.bind(this, attachments);
    if (count === 0) {
        var request = $.ajax({
            url: attachment.url,
	        dataType: "text",
            headers: {'X-Zimbra-Encoding':'x-base64'}
        });

        request.done(function(response) {
            var key = ZmOffline.createAttachmentKey(attachment);
            var item = {
                id   : key,
                mid  : attachment.mid,
                url  : attachment.url,
                type : attachment.ct,
                name : attachment.label,
                size : attachment.sizeInBytes,
				part : attachment.part,
                content : response
            };
            ZmOfflineDB.setItem(item, ZmOffline.ATTACHMENT, callback, callback);
        }.bind(this));

        request.fail(callback);
    }
    else {
        callback();
    }
};

ZmOffline.prototype._handleAttachmentsForOfflineMode = function(attachments, getLinkIdCallback, linkIds) {
	if (appCtxt.isWebClientOffline()) {
		var keyArray = [];
		if (attachments) {
			attachments.forEach(function(attachment) {
				var key = ZmOffline.createAttachmentKey(attachment);
				keyArray.push(key);
			});
			if (keyArray.length > 0) {
				var callback = this._handleAttachmentsForOfflineModeCallback.bind(this, attachments, getLinkIdCallback, linkIds);
				ZmOfflineDB.getItem(keyArray, ZmOffline.ATTACHMENT, callback);
			}
		}
	}
};

ZmOffline.prototype._handleAttachmentsForOfflineModeCallback = function(attachments, getLinkIdCallback, linkIds, resultArray) {
	if (!resultArray || !linkIds) {
		return;
	}
	var self = this;
	resultArray.forEach(function(result) {
		if (result.type && result.content) {
			var url = "data:" + result.type + ";base64," + result.content;
			for (var i = 0; i < linkIds.length; i++) {
				//Attachment main link
				var id = getLinkIdCallback(result.part, linkIds[i]);
				var link = document.getElementById(id);
				if (link) {
					link.href     = url;
					link.onclick  = null;
					link.download = result.name;
				}
			}
		}
	});
};


ZmOffline.modifyMsg =
function(msg) {

    var result = [].concat(msg).map(function(item) {
        if (item.f) {
            item.f = item.f.split("");
        }
        if (item.su) {
            item.su = item.su.split(" ");
        }
        if (item.fr) {
            item.fr = item.fr.split(" ");
        }
        if (item.tn) {
            item.tn = item.tn.split(",");
        }
        if (item.l) {
            item.l = item.l.toString();
        }
        if (item.e) {
            var from = [];
            var to = [];
            var cc = [];
            item.e.forEach(function(element){
                if (element.t === "f") {
                    if (element.a) {
                        from.push(element.a.toLowerCase());
                    }
                    if (element.p) {
                        from = from.concat(element.p.toLowerCase().split(" "));
                    }
                }
                else if (element.t === "t") {
                    if (element.a) {
                        to.push(element.a.toLowerCase());
                    }
                    if (element.p) {
                        to = to.concat(element.p.toLowerCase().split(" "));
                    }
                }
                else if (element.t === "c") {
                    if (element.a) {
                        cc.push(element.a.toLowerCase());
                    }
                    if (element.p) {
                        cc = cc.concat(element.p.toLowerCase().split(" "));
                    }
                }
            });
            if (from.length) {
                item.e.from = from;
            }
            if (to.length) {
                item.e.to = to;
            }
            if (cc.length) {
                item.e.cc = cc;
            }
        }
        return item;
    });

    return result;
};

ZmOffline.recreateMsg =
function(msg) {

    var result = [].concat(msg).map(function(item) {
        if (Array.isArray(item.f)) {
            item.f = item.f.join();
        }
        if (Array.isArray(item.su)) {
            item.su = item.su.join(" ");
        }
        if (Array.isArray(item.fr)) {
            item.fr = item.fr.join(" ");
        }
        if (Array.isArray(item.tn)) {
            item.tn = item.tn.join();
        }
        if (item.e) {
            delete item.e.from;
            delete item.e.to;
            delete item.e.cc;
        }
        return item;
    });

    return result;
};

ZmOffline.modifyContact =
function(contact) {

    var result = [].concat(contact).map(function(item) {
        if (item.tn) {
            item.tn = item.tn.split(",");
        }
        if (item._attrs) {
            if (item._attrs.jobTitle) {
                item._attrs.jobTitle = item._attrs.jobTitle.split(" ");
            }
        }
        return item;
    });

    return result;
};

ZmOffline.recreateContact =
function(contact) {

    var result = [].concat(contact).map(function(item) {
        if (Array.isArray(item.tn)) {
            item.tn = item.tn.join();
        }
        if (item._attrs) {
            if (Array.isArray(item._attrs.jobTitle)) {
                item._attrs.jobTitle = item._attrs.jobTitle.join(" ");
            }
        }
		ZmOffline._cacheContactMember(item);
        return item;
    });

    return result;
};

/*
** cache contact group members
*/
ZmOffline._cacheContactMember =
function(contact) {
	var contactMember = contact.m;
	if (!contactMember || !Array.isArray(contactMember) || appCtxt.cacheGet(contact.id)) {
		return;
	}
	var contactObj = ZmContact.createFromDom(contact, {});
	var result = new ZmCsfeResult({GetContactsResponse : {cn : [contact]}});
	//This method will do the caching of contact group member and update the cache
	ZmContact.prototype._handleLoadResponse.call(contactObj, null, result);
};

ZmOffline.refreshStatusIcon =
function(isSyncing) {
	if (appCtxt.isWebClientOffline()) {
		$("#" + ZmId.SKIN_OFFLINE_STATUS).addClass("ImgDisconnect")
			.removeClass("ImgOfflineSync")
			.attr("title", ZmMsg.OfflineServerNotReachable);
	}
	else {
		if (isSyncing) {
			$("#" + ZmId.SKIN_OFFLINE_STATUS).addClass("ImgOfflineSync")
				.removeClass("ImgDisconnect")
				.attr("title", ZmMsg.offlineCachingSync);
		}
		else {
			$("#" + ZmId.SKIN_OFFLINE_STATUS).removeClass("ImgOfflineSync ImgDisconnect")
				.attr("title", ZmMsg.offlineCachingDone);
		}
	}
};

ZmOffline.handleLogOff =
function(ev, relogin) {
	if (ev) {
		ZmOfflineSettingsDialog.showConfirmSignOutDialog();
	}
	else if (relogin) {
		appCtxt.reloadAppCache();
		setTimeout(ZmZimbraMail.logOff, 1000);
	}
};
}
}
